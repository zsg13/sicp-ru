@comment @chapter Computing with Register Machines
@chapter Вычисления на регистровых машинах
@node    Chapter 5, References, Chapter 4, Top

@c @sp 0.2

@quotation
Моя цель --- показать, что небесная машина не некое божественное живое
существо, а скорее часовой механизм (а тот, кто верит, что у часов есть
душа, приписывает славу творца творению), поскольку почти все из ее
многочисленных движений вызываются простейшей материальной силой, так
же, как все движения часов вызываются весом гири.

Иоганн Кеплер
(письмо к Герварту фон Гогенбургу, 1605)
@end quotation

@c @sp 1.0

\lettrine[findent=1pt]{Э}{та книга начинается} с изучения процессов и с описания
процессов в терминах процедур, написанных на Лиспе. Чтобы объяснить значение этих
процедур, мы последовательно использовали несколько моделей вычисления:
подстановочную модель из главы @ref{Глава 1}, модель с окружениями из
главы @ref{Глава 3} и метациклический интерпретатор из главы @ref{Глава 4}.
Изучая последний, мы по большей части сняли покров тайны с деталей
интерпретации лиспоподобных языков. Однако даже метациклический
интерпретатор оставляет многие вопросы без ответа, поскольку он не
проясняет механизмы управления Лисп-системы. Например, интерпретатор не
показывает, как при вычислении подвыражения удается вернуть значение
выражению, это значение использующему, или почему одни рекурсивные
процедуры порождают итеративные процессы (то есть занимают неизменный
объем памяти), в то время как другие процедуры порождают рекурсивные
процессы. Эти вопросы остаются без ответа потому, что метациклический
интерпретатор сам по себе является программой на Лиспе, а
следовательно, наследует управляющую структуру нижележащей Лисп-системы.
Чтобы предоставить более полное описание управляющей структуры
вычислителя Лиспа, нам нужно работать на более элементарном уровне, чем
сам Лисп.

В этой главе мы будем описывать процессы в терминах пошаговых операций
традиционного компьютера. Такой компьютер, или (register machine),
последовательно выполняет (instructions), которые работают с
ограниченным числом элементов памяти, называемых (registers). Типичная
команда регистровой машины применяет элементарную операцию к содержимому
нескольких регистров и записывает результат еще в один регистр. Наши
описания процессов, выполняемых регистровыми машинами, будут очень
похожи на <<машинный язык>> обыкновенных компьютеров. Однако вместо
того, чтобы сосредоточиться на машинном языке какого-то конкретного
компьютера, мы рассмотрим несколько процедур на Лиспе и спроектируем
специальную регистровую машину для выполнения каждой из этих процедур.
Таким образом, мы будем решать задачу с точки зрения архитектора
аппаратуры, а не с точки зрения программиста на машинном языке
компьютера. При проектировании регистровых машин мы разработаем
механизмы для реализации важных программистских конструкций, таких, как
рекурсия. Кроме того, мы представим язык для описания регистровых машин.
В разделе @ref{5.2} мы реализуем
программу на Лиспе, которая с помощью этих описаний имитирует
проектируемые нами машины.

Большинство элементарных операций наших регистровых машин очень просты.
Например, такая операция может складывать числа, взятые из двух
регистров, и сохранять результат в третьем. Несложно описать
устройство, способное выполнять такие операции. Однако для работы со
списковыми структурами мы будем использовать также операции @code{car},
@code{cdr} и @code{cons}, а они требуют сложного механизма выделения
памяти. В разделе @ref{5.3}
мы изучаем их реализацию на основе более простых операций.

В разделе @ref{5.4}, накопив опыт
выражения простых процессов в виде регистровых машин, мы спроектируем
машину, которая реализует алгоритм, описываемый метациклическим
интерпретатором из раздела @ref{4.1}.
Таким образом, окажется заполненным пробел в нашем понимании того, как
интерпретируются выражения языка Scheme, поскольку будет представлена
явная модель механизмов управления вычислителя. В
разделе @ref{5.5} мы рассмотрим простой компилятор,
переводящий программы на Scheme в последовательности команд, которые
можно впрямую выполнить с помощью регистров и операций регистровой
машины-вычислителя.

@menu
* 5-1::              Проектирование регистровых машин
* 5-2::              Программа моделирования регистровых машин
* 5-3::              Выделение памяти и сборка мусора
* 5-4::              Вычислитель с явным управлением
* 5-5::              Компиляция
@end menu

@comment @section Designing Register Machines
@section Проектирование регистровых машин
@node	5.1, 5.2, Chapter 5, Chapter 5

Чтобы спроектировать регистровую машину, требуется описать ее (@newterm{data paths}),
то есть регистры и операции, а также @emph{контроллер}
(@newterm{controller}), который управляет последовательностью этих операций. Чтобы
продемонстрировать строение простой регистровой машины, рассмотрим
алгоритм Евклида для вычисления наибольшего общего делителя (@acronym{НОД}) двух
натуральных чисел. Как мы видели в разделе @ref{1.2.5},
алгоритм Евклида можно реализовать в виде итеративного процесса,
который описывается следующей процедурой:

@lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
@end lisp

@noindent
Машина, реализующая алгоритм, должна отслеживать два числовых значения,
@math{a} и @math{b}. Поэтому предположим, что эти числа хранятся в двух
регистрах с такими же именами. Основные требуемые операции --- это
проверка, не является ли содержимое регистра @code{b} нулем, и
вычисление остатка от деления содержимого регистра @code{a} на
содержимое регистра @code{b}. Операция вычисления остатка --- сложный
процесс, однако пока что предположим, что у нас есть элементарное
устройство, вычисляющее остатки. В каждом цикле алгоритма вычисления НОД
содержимое регистра @code{a} требуется заменить содержимым регистра
@code{b}, а содержимое регистра @code{b} следует заменить на остаток от
деления старого содержимого @code{a} на старое содержимое @code{b}. Было
бы удобно, если бы можно было производить эти замены одновременно,
однако для нашей модели регистровых машин мы предположим, что на каждом
шаге можно присвоить новое значение только одному регистру. Чтобы
произвести замены, наша машина использует третий <<временный>> регистр,
который мы назовем @code{t}. (Сначала мы помещаем остаток в @code{t},
затем помещаем содержимое @code{b} в @code{a}, и наконец переносим
остаток, хранимый в @code{t}, в @code{b}.)

Можно изобразить регистры и операции, требуемые нашей машине, при помощи
диаграммы путей данных, показанной на рисунке @ref{Рисунок 5.1}.
Регистры (@code{a}, @code{b} и @code{t}) на этой диаграмме
изображаются в виде прямоугольников. Каждый способ присвоить регистру
значение обозначается стрелкой, указывающей из источника данных на
регистр, со значком Х позади головки. Можно считать этот Х кнопкой,
которая при нажатии позволяет значению из источника <<перетечь>> в
указанный регистр. Метка рядом --- это имя для кнопки. Имена эти
произвольны, и их можно подбирать с мнемоническим значением (например,
@code{a<-b} обозначает нажатие кнопки, которая присваивает содержимое
регистра @code{b} регистру @code{a}). Источником данных для регистра
может служить другой регистр (как в случае присваивания @code{a<-b}),
результат операции (как в случае присваивания @code{t<-r}) или
константа (встроенное значение, которое нельзя изменять и которое
представляется на диаграмме путей данных в виде треугольника со
значением внутри).

@float
@quotation
@anchor{Рисунок 5.1}
@ifinfo
@strong{Рисунок 5.1:} Data paths for a @acronym{GCD} machine.

@example
                              ___
+-----+          +-----+     /   \
|  a  |<--(X)----|  b  +--->|  =  |
+--+--+   a<-b   +-+---+     \___/
   |               |  ^        ^
   +------+   +----+  |        |
          |   |      (X) b<-t  |
       .--+---+--.    |       / \
        \  rem  /     |      / O \
         \_____/      |     +-----+
            |         |
           (X) t<-r   |
            |         |
            V         |
         +-----+      |
         |  t  +------+
         +-----+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.1a,58mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 5.1:} Data paths for a @acronym{GCD} machine.}
@sp 0.8
@end iftex
@end quotation
@end float

Операция, которая вычисляет значение на основе констант и содержимого
регистров, представляется на диаграмме путей данных в виде трапеции,
содержащей имя операции. Например, фигура, обозначенная на
рисунке @ref{Рисунок 5.1} как @code{rem}, представляет операцию,
вычисляющую остаток от деления содержимых регистров @code{a} и @code{b},
к которым она подсоединена. Стрелки (без кнопок) указывают из входных
регистров и констант на фигуру, а другие стрелки связывают результат
операции с регистрами. Сравнение изображается в виде круга, содержащего
имя теста. К примеру, в нашей машине НОД имеется операция, которая
проверяет, не равно ли содержимое регистра @code{b} нулю. У теста тоже
есть входные стрелки, ведущие из входных регистров и констант, но у него
нет исходящих стрелок; его значение используется контроллером, а не
путями данных. В целом, диаграмма путей данных показывает регистры и
операции, которые нужны машине, и как они должны быть связаны. Если мы
рассматриваем стрелки как провода, а кнопки Х как переключатели, то
диаграмма путей данных оказывается очень похожа на схему машины, которую
можно было бы построить из электронных деталей.

@float
@quotation
@anchor{Рисунок 5.2}
@ifinfo
@strong{Рисунок 5.2:} Controller for a @acronym{GCD} machine.

@example
     start
       |
       V
      / \ yes
+--->< = >-----> done
|     \ /
|      | no
|      V
|  +------+
|  | t<-r |
|  +---+--+
|      |
|      V
|  +------+
|  | a<-b |
|  +---+--+
|      |
|      V
|  +------+
+--+ b<-t |
   +------+
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap5/Fig5.2,41mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 5.2:} Controller for a @acronym{GCD} machine.}
@sp 0.7
@end iftex
@end quotation
@end float

Для того, чтобы пути данных вычисляли НОД, нужно нажимать кнопки в
правильной последовательности. Мы будем описывать эту последовательность
с помощью диаграммы контроллера, показанной на
рисунке @ref{Рисунок 5.2}. Элементы диаграммы контроллера показывают,
как следует работать с компонентами путей данных. Прямоугольные блоки в
такой диаграмме указывают, на какие кнопки следует нажимать, а стрелки
описывают последовательный переход от одного шага к другому. Ромб на
диаграмме обозначает выбор. Произойдет переход по одной из двух
исходящих стрелок, в зависимости от значения того теста в потоке
данных, имя которого указано в ромбе. Можно интерпретировать контроллер
с помощью физической аналогии: представьте себе, что диаграмма --- это
лабиринт, в котором катается шарик. Когда шарик закатывается в
прямоугольник, он нажимает на кнопку, имя которой в прямоугольнике
написано. Когда шарик закатывается в узел выбора (например, тест
@code{b} = 0), он покидает этот узел по стрелке, которую
определяет результат указанного теста. Взятые вместе, пути данных и
контроллер полностью определяют машину для вычисления НОД. Мы запускаем
контроллер (катящийся шарик) в месте, обозначенном @code{start},
поместив предварительно числа в регистры @code{a} и @code{b}. Когда
контроллер достигает точки, помеченной @code{done}, в регистре @code{a}
оказывается значение НОД.

@quotation
@strong{@anchor{Упражнение 5.1}Упражнение 5.1:} Спроектируйте
регистровую машину для вычисления факториалов с
помощью итеративного алгоритма, задаваемого следующей процедурой.
Нарисуйте для этой машины диаграммы путей данных и контроллера.

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp
@end quotation

@menu
* 5-1-1::            Язык для описания регистровых машин
* 5-1-2::            Абстракция в проектировании машин
* 5-1-3::            Подпрограммы
* 5-1-4::            Реализация рекурсии с помощью стека
* 5-1-5::            Обзор системы команд
@end menu

@comment @subsection A Language for Describing Register Machines
@subsection Язык для описания регистровых машин
@node	5.1.1, 5.1.2, 5.1, 5.1

Диаграммы путей данных и контроллера адекватно представляют простые
машины вроде машины НОД, но для описания сложных машин вроде
интерпретатора Лиспа они непригодны. Чтобы можно было работать со
сложными машинами, мы создадим язык, который представляет в текстовом
виде всю информацию, содержащуюся в диаграммах путей данных и
контроллера. Начнем с нотации, которая впрямую отражает диаграммы.

Мы определяем пути данных (@code{data-paths}) машины, описывая регистры
(@code{registers}) и операции (@code{operations}). Чтобы описать
регистр, мы даем ему имя (@code{name}) и указываем кнопки
(@code{buttons}), которые присваивают ему значение. Каждой из этих
кнопок мы даем имя (@code{name}) и указываем источник (@code{source})
для данных, которые попадают в регистр, управляемый кнопкой. Источником
может служить регистр (@code{register}), константа (@code{constant}) или
операция (@code{operation}). Для описания операции нам нужно дать ей имя
и указать входы (@code{inputs}) --- регистры или константы.

Контроллер машины мы определяем как последовательность @emph{команд}
(instructions) с @emph{метками} (labels), которые определяют @emph{точки
входа} (entry points). Есть следующие виды команд:

@itemize @bullet

@item
Имя кнопки на пути данных, которую следует нажать и присвоить регистру
значение. (Это соответствует прямоугольнику на диаграмме контроллера.)

@item
Команда @code{test}, которая выполняет указанный тест.

@item
Условный переход (команда @code{branch}) в место, определяемое меткой
контроллера, на основании предыдущего теста. (@code{Test} и
@code{branch} вместе соответствуют ромбу на диаграмме контроллера.) Если
тест дает результат <<ложь>>, контроллер должен выполнять следующую
команду в последовательности. В противном случае он должен выполнять
команду, которая следует за меткой.

@item
Безусловный переход (команда ), указывающий метку, с которой следует
продолжить выполнение.

@end itemize

@noindent
Машина начинает работу с начала последовательности команд контроллера и
заканчивает, когда выполнение достигает конца последовательности. Кроме
тех случаев, когда переход изменяет поток управления, команды
выполняются по порядку, так, как они перечислены.

@quotation
@strong{@anchor{Рисунок 5.3}Figure 5.3:} @math{\downarrow} A specification of the @acronym{GCD}
machine.

@direntry
@lisp
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem) (inputs (register a) (register b)))
  ((name =) (inputs (register b) (constant 0)))))
(controller
 test-b                           @r{; label}
   (test =)                       @r{; test}
   (branch (label gcd-done))      @r{; conditional branch}
   (t<-r)                         @r{; button push}
   (a<-b)                         @r{; button push}
   (b<-t)                         @r{; button push}
   (goto (label test-b))          @r{; unconditional branch}
 gcd-done)                        @r{; label}
@end lisp
@end direntry

@lisp
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0))))
 (controller
  test-b                        @r{; метка}
    (test =)                    @r{; тест}
    (branch (label gcd-done))   @r{; условный переход}
    (t<-r)                      @r{; нажатие кнопки}
    (a<-b)                      @r{; нажатие кнопки}
    (b<-t)                      @r{; нажатие кнопки}
    (goto (label test-b))       @r{; безусловный переход}
  gcd-done))                    @r{; метка}
@end lisp

@end quotation
На рисунке @ref{Рисунок 5.3} изображена описанная на нашем языке
машина НОД. Этот пример служит не более чем намеком на степень общности
таких описаний, поскольку машина НОД --- очень простой случай: у
каждого регистра всего по одной кнопке, и каждая кнопка используется в
контроллере только один раз.

К сожалению, такое описание неудобно читать. Чтобы понимать команды
контроллера, нам все время приходится смотреть на определения имен
кнопок и операций, а чтобы понять, что делают операции, приходится
обращаться к определениям имен операций. Поэтому мы изменим свой способ
записи и сольем информацию из описания контроллера и описания путей
данных, так, чтобы видеть их одновременно.

В этой новой форме записи мы заменим произвольные имена кнопок и
операций на описание их поведения. То есть, вместо того, чтобы говорить
(в контроллере) <<нажать кнопку @code{t<-r}>> и отдельно (в путях
данных) <<кнопка @code{t<-r} присваивает регистру @code{t} значение
операции @code{rem}>>, а также <<входы операции @code{rem} --- это
содержимое регистров @code{a} и @code{b}>>, мы будем говорить (в
контроллере) <<нажать кнопку, которая присваивает регистру @code{t}
результат операции @code{rem} от содержимого регистров @code{a} и
@code{b}>>. Подобным образом, вместо <<выполнить тест @code{=}>> (в
контроллере) и отдельно (в путях данных) <<тест @code{=} применяется к
содержимому регистра @code{b} и константе 0>>, будем говорить
<<выполнить тест @code{=} над содержимым регистра @code{b} и константой
0>>. Описание путей данных мы будем опускать, оставляя только
последовательность команд контроллера. Таким образом, машину НОД можно
описать так:

@lisp
(controller 
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
@end lisp

@noindent
Запись в такой форме проще читать, чем описания на разновидности языка,
показанной на рисунке @ref{Рисунок 5.3}, но есть у нее и недостатки:

@itemize @bullet

@item
Для больших машин такие описания длиннее, поскольку полные определения
элементов путей данных повторяются каждый раз, как эти элементы
упоминаются в последовательности команд контроллера. (В примере с НОД
этой проблемы не возникает, поскольку каждая операция и каждая кнопка
используются только по разу.) Более того, повторение описаний путей
данных скрывает структуру этих путей в машине; для больших машин
становится сложно определить, сколько в них регистров, операций и
кнопок, и как они связаны.

@item
Поскольку команды контроллера в определении машины похожи на выражения
Лиспа, легко забыть, что это не произвольные Лисп-выражения. Можно
описывать только разрешенные операции машины. Например, операции впрямую
могут работать только с константами и содержимым регистров, а не с
результатами других операций.

@end itemize

@noindent
Несмотря на указанные недостатки, мы будем использовать такой язык
описания регистровых машин на всем протяжении этой главы, поскольку нас
в большей мере будет занимать понимание работы контроллеров, чем
понимание элементов и связей в путях данных. Следует, однако, помнить,
что проектирование путей данных --- ключевой элемент в разработке
настоящих машин.

@quotation
@strong{@anchor{Упражнение 5.2}Упражнение 5.2:} С помощью языка регистровых
машин опишите итеративную факториал-машину из упражнения @ref{Упражнение 5.1}.
@end quotation

@comment @subsubheading Actions
@subsubheading Действия

Давайте теперь изменим машину НОД так, чтобы можно было вводить числа,
НОД которых мы хотим получить, и видеть результаты, напечатанные на
терминале. Мы не будем обсуждать, как построить машину для считывания и
печати, а предположим (как и с процедурами @code{read} и
@code{display} в Scheme), что эти действия доступны как элементарные
операции.@footnote{Такое предположение покрывает большую и сложную
область. Обычно значительная часть реализации Лисп-систем посвящена
работе ввода и вывода.}

@float
@c @quotation
@anchor{Рисунок 5.4}
@ifinfo
@strong{Рисунок 5.4:} A @acronym{GCD} machine that reads inputs and prints results.

@example
                   .--------.
                    \ read /
                     \____/
                       |
               +-------*------+
               |              |
        a<-rd (X)            (X) b<-rd
               |              |
               V              V           ___
            +-----+        +-----+       /   \
            |  a  |<--(X)--+  b  +----->|  =  |
            +-+-+-+  a<-b  +-+---+       \___/
              | |            |  ^          ^
           +--+ +----+    +--+  |          |
           |         |    |    (X) b<-t   / \
           V         V    V     |        / O \
      .---------.  .---------.  |       /_____\
--(X)->\ print /    \  rem  /   |
   P    \_____/      \_____/    |
                        |       |
                       (X) t<-r |
                        |       |
                        V       |
                     +-----+    |
                     |  t  +----+
                     +-----+
@end example

@lisp
 (controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
@end lisp

@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.4b,107mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 5.4:} A @acronym{GCD} machine that reads inputs and prints results. }@short
@sp 0.7
@end iftex
@c @end quotation
@end float

@code{Read} подобна операциям, которые мы использовали ранее, поскольку
она порождает значение, и его можно сохранить в регистре. Однако
@code{read} не принимает входа ни из каких регистров; ее значение
зависит от событий, происходящих за пределами тех компонентов машины,
проектированием которых мы заняты. Мы позволим операциям нашей машины
вести себя таким образом, и, следовательно, будем рисовать @code{read} и
изображать ее в языке описания так же, как любую другую операцию,
вычисляющую значение.

@code{Print}, с другой стороны, фундаментальным образом отличается от
тех операций, которыми мы до сих пор пользовались: она не порождает
результата, который можно было бы поместить в регистр. Хотя она и
производит эффект, этот эффект не касается тех частей машины, которые мы
проектируем. Этот тип операций мы будем называть (actions). На диаграмме
путей данных мы будем представлять действие так же, как и операции,
вычисляющие значение --- как трапецию с именем действия. В этот элемент
входят стрелки из входов (регистров или констант). Кроме того, мы
связываем с действием кнопку. Нажатие кнопки заставляет действие
совершиться. Чтобы скомандовать контроллеру нажать кнопку действия, мы
вводим новый тип команды @code{perform}. Таким образом, действие по
распечатке содержимого регистра @code{a} представляется в
последовательности контроллера командой

@lisp
(perform (op print) (reg a))
@end lisp

На рисунке @ref{Рисунок 5.4} показаны пути данных и контроллер для
новой машины НОД. Вместо того, чтобы останавливать машину после печати
ответа, мы приказываем ей начать сначала, так что она в цикле считывает
пару чисел, вычисляет их НОД и печатает результат. Такая структура
подобна управляющим циклам, которые мы использовали в интерпретаторах
из главы @ref{Глава 4}.


@comment @subsection Abstraction in Machine Design
@subsection Абстракция в проектировании машин
@node	5.1.2, 5.1.3, 5.1.1, 5.1

Часто в определении машины мы будем использовать <<элементарные>>
операции, которые на самом деле весьма сложны. Например, в
разделах @ref{5.4} и @ref{5.5} мы будем рассматривать операции с окружениями
Scheme как элементарные. Такая абстракция полезна, поскольку она
позволяет нам игнорировать детали частей машины, так что мы можем
сосредоточиться на других сторонах общего плана. Однако, хотя мы и
скрываем существенную часть сложности, это не означает, что проект
машины нереалистичен. Сложные <<примитивы>> всегда можно заменить более
простыми операциями.

Рассмотрим машину НОД. В ней содержится команда, которая вычисляет
остаток от деления содержимого регистров @code{a} и @code{b} и сохраняет
результат в регистре @code{t}. Если мы хотим построить машину НОД без
использования элементарной операции взятия остатка, нам нужно указать,
как вычислять остатки с помощью более простых операций, например,
вычитания. Действительно, можно написать на Scheme процедуру нахождения
остатка таким образом:

@lisp
(define (remainder n d)
  (if (< n d)
      n
      (remainder (- n d) d)))
@end lisp

@float[tp]
@quotation
@anchor{Рисунок 5.5}
@ifinfo
@strong{Рисунок 5.5:} Data paths and controller for the elaborated @acronym{GCD} machine.

@example
                                    ___
+-----+         +-----+            /   \
|  a  |<--(X)---+  b  +-------*-->|  =  |
+--+--+   a<-b  +-+---+       |    \___/
   |              |  ^        |
  (X) t<-a        |  |        |
   |              | (X) b<-t  |
   V              |  |       _V_
+-----+           |  |      /   \
|  t  +-------*---|--*-----|  <  |
+-----+       |   |         \___/
   ^          V   V
   |        ---------
  (X) t<-d   \  -  /
   |          --+--
   |            |
   +------------+


   start
     |
     V
    / \ yes            +-------+
+->< = >----> done     | t<-d  |<--+
|   \ /                +---+---+   |
|    | no                  |       |
|    |                     V       |
|    |   +------+         / \ no   |
|    +-->| t<-a +------->< < >-----+
|        +------+         \ /
|                          | yes
|      +-------------------+
|      V
|  +-------+
|  | a<-b  |
|  +---+---+
|      |
|      V
|  +-------+
+--+ b<-t  |
   +-------+
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap5/Fig5.5a,67mm,,,.pdf}
@sp 1.0
@caption{@strong{Рисунок 5.5:} Data paths and controller for the elaborated @acronym{GCD} machine.}
@sp 1.0
@end iftex
@end quotation
@end float

Значит, мы можем заменить операцию взятия остатка в машине НОД
операцией вычитания и тестом-сравнением. На рисунке @ref{Рисунок 5.5}
показаны пути данных и контроллер уточненной машины. Команда

@lisp
(assign t (op rem) (reg a) (reg b))
@end lisp

@noindent
в определении контроллера НОД заменяется на последовательность команд,
содержащую цикл, как показано на рисунке @ref{Рисунок 5.6}.

@quotation
@strong{@anchor{Рисунок 5.6}@w{Рисунок 5.6:}} @math{\downarrow} Controller instruction sequence for the @acronym{GCD} machine in @ref{Figure 5.5}.

@lisp
(controller test-b
              (test (op =) (reg b) (const 0))
              (branch (label gcd-done))
              (assign t (reg a))
            rem-loop
              (test (op <) (reg t) (reg b))
              (branch (label rem-done))
              (assign t (op -) (reg t) (reg b))
              (goto (label rem-loop))
            rem-done
              (assign a (reg b))
              (assign b (reg t))
              (goto (label test-b))
            gcd-done)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.3}Упражнение 5.3:} Спроектируйте машину
для вычисления квадратных корней методом Ньютона, как описано в разделе @ref{1.1.7}:

@lisp
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
@end lisp

Для начала предположите, что операции @code{good-enough?} и
@code{improve} имеются как примитивы. Затем покажите, как развернуть их
с помощью арифметических операций. Опишите каждую из версий машины
@code{sqrt}, нарисовав диаграмму путей данных, и написав определение
контроллера на языке регистровых машин.
@end quotation

@comment @subsection Subroutines
@subsection Подпрограммы
@node	5.1.3, 5.1.4, 5.1.2, 5.1

При проектировании машины для некоторого вычисления мы часто предпочтем
устроить так, чтобы компоненты ее разделялись различными частями
вычисления, а не дублировались. Рассмотрим машину, которая включает в
себя два вычисления НОД --- одно находит НОД содержимого регистров
@code{a} и @code{b}, а другое НОД содержимого регистров @code{c} и
@code{d}. Для начала можно предположить, что имеется элементарная
операция @code{gcd}, а затем развернуть два экземпляра @code{gcd} в
терминах более простых операций. На рисунке @ref{Рисунок 5.7} показаны
только части получившихся путей данных, относящиеся к НОД. Связи с
остальными частями машины опущены. Кроме того, на рисунке показаны
соответствующие сегменты последовательности команд контроллера машины.

@float
@c @quotation
@anchor{Рисунок 5.7}
@ifinfo
@strong{Рисунок 5.7:} Portions of the data paths and controller sequence for a machine with two @acronym{GCD} computations.

@example
                            ___                                 ___
+-----+        +-----+     /   \    +-----+        +-----+     /   \
|  a  |<-(X)---+  b  |--->|  =  |   |  c  |<-(X)---+  d  |--->|  =  |
+--+--+  a<-b  ++----+     \___/    +--+--+  c<-d  ++----+     \___/
   |            |  ^         ^         |            |  ^         ^
   `----.   .---'  |         |         `----.   .---'  |         |
        V   V     (X) b<-t   |              V   V     (X) d<-t   |
       -------     |        / \            -------     |        / \
       \ rem /     |       /_0_\           \ rem /     |       /_0_\
        --+--      |                        --+--      |
          |        |                          |        |
         (X) t<-r  |                         (X) s<-r  |
          |        |                          |        |
          V        |                          V        |
       +-----+     |                       +-----+     |
       |  t  +-----'                       |  s  +-----'
       +-----+                             +-----+
@end example

@lisp
gcd-1
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-1))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-1))
after gcd-1
   @dots{}
gcd-2
(test (op =) (reg d) (const 0))
(branch (label after-gcd-2))
(assign s (op rem) (reg c) (reg d))
(assign c (reg d))
(assign d (reg s))
(goto (label gcd-2))
after-gcd-2
@end lisp

@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap5/Fig5.7b,105mm,,,.pdf}
@sp 0.7
@noindent
@caption{@strong{Рисунок 5.7:} Portions of the data paths and controller sequence for a @w{machine} with two @acronym{GCD} computations.}
@sp 0.3
@end iftex
@c @end quotation
@end float

В этой машине два блока вычисления остатка и два блока проверки на
равенство. Если повторяющиеся компоненты сложны, как, например, блок
вычисления остатка, такое построение машины окажется неэкономным. Можно
избежать дублирования компонент путей данных, если использовать для
обоих вычислений НОД одни и те же компоненты, при условии, что такое
решение не повлияет на остальные вычисления большой машины. Если к тому
времени, как контроллер добирается до @code{gcd-2}, значения в
регистрах @code{a} и @code{b} не нужны (или если их можно временно
сохранить в каких-то еще регистрах), то мы можем изменить машину так,
чтобы она использовала регистры @code{a} и @code{b}, а не @code{c} и
@code{d}, при вычислении второго НОД, так же как и при вычислении
первого. Так у нас получится последовательность команд контроллера,
показанная на рисунке @ref{Рисунок 5.8}.

@quotation
@strong{@anchor{Рисунок 5.8}Figure 5.8:} @math{\downarrow} Portions of the
controller sequence for a machine that uses the same data-path components
for two different @acronym{GCD} computations.
@lisp
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  @dots{}
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
@end lisp
@end quotation

Мы удалили одинаковые компоненты путей данных (так что они снова стали
такими, как на рисунке @ref{Рисунок 5.1}), но теперь в контроллере
содержатся две последовательности команд вычисления НОД, которые
различаются только метками. Было бы лучше заменить эти две
последовательности переходами к единой последовательности ---
(subroutine), --- в конце которой мы возвращаемся обратно к нужному
месту в основной последовательности команд. Этого можно добиться так:
прежде, чем перейти к @code{gcd}, мы помещаем определенное значение (0
или 1) в особый регистр, @code{continue}. В конце подпрограммы
@code{gcd} мы переходим либо к @code{after-gcd-1}, либо к
@code{after-gcd-2}, в зависимости от значения из регистра
@code{continue}. На рисунке @ref{Рисунок 5.9} показан соответствующий
сегмент получающейся последовательности команд контроллера, который
содержит только одну копию команд @code{gcd}.

@quotation
@strong{@anchor{Рисунок 5.9}Figure 5.9:} @math{\downarrow} Using a @code{continue}
register to avoid the duplicate controller sequence in @ref{Рисунок 5.8}.
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  @dots{}
 @r{;; Прежде, чем перейти к @code{gcd} из первого места, где}
 @r{;; он нужен, заносим 0 в регистр @code{continue}}
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  @dots{}
 @r{;;  Перед вторым использованием @code{gcd} помещаем 1}
 @r{;;  в регистр @code{continue}}
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
@end lisp
@end quotation

@direntry
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
   .
   .
   .
 @r{;; Прежде, чем перейти к @code{gcd} из первого места, где}
 @r{;; он нужен, заносим 0~в регистр @code{continue}}
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 @r{;;  Перед вторым использованием @code{gcd} помещаем 1~в регистр @code{continue}.}
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
@end lisp

@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   .
   .
   .
 @r{;; Перед вызовом @code{gcd} заносим~в @code{continue}}
 @r{;; метку, на которую @code{gcd} должен вернуться.}
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 @r{;;  Второй вызов@code{gcd}, с другим продолжением.}
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
@end lisp
@end direntry

Для маленьких задач это разумный подход, однако если бы в
последовательности команд контроллера имелось много вызовов вычисления
НОД, он стал бы неудобен. Чтобы решить, где продолжать вычисление после
подпрограммы @code{gcd}, нам пришлось бы иметь в контроллере тесты и
переходы для всех мест, где используется @code{gcd}. Более мощный метод
реализации подпрограмм состоит в том, чтобы запоминать в регистре
@code{continue} метку точки входа в последовательности контроллера, с
которой выполнение должно продолжиться, когда подпрограмма закончится.
Реализация этой стратегии требует нового вида связи между путями данных
и контроллером регистровой машины: должно быть возможно присвоить
регистру метку в последовательности команд контроллера таким образом,
чтобы это значение можно было из регистра извлечь и с его помощью
продолжить выполнение с указанной точки входа.

Чтобы отразить эту возможность, мы расширим команду @code{assign} языка
регистровых машин и позволим присваивать регистру в качестве значения
метку из последовательности команд контроллера (как особого рода
константу). Кроме того, мы расширим команду @code{goto} и позволим
вычислению продолжаться с точки входа, которая описывается содержимым
регистра, а не только с точки входа, описываемой меткой-константой. С
помощью этих двух команд мы можем завершить подпрограмму @code{gcd}
переходом в место, хранимое в регистре @code{continue}. Это ведет к
последовательности команд, показанной на рисунке @ref{Рисунок 5.10}.

@quotation
@strong{@anchor{Рисунок 5.10}Figure 5.10:} @math{\downarrow} Assigning labels to the
@code{continue} register simplifies and generalizes the strategy shown in
@ref{Рисунок 5.9}.
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   @dots{}
 @r{;; Перед вызовом @code{gcd} заносим в @code{continue}}
 @r{;; метку, на которую @code{gcd} должен вернуться}
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   @dots{}
 @r{;;  Второй вызов @code{gcd}, с другим продолжением}
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
@end lisp
@end quotation

@noindent
Машина, в которой имеется более одной подпрограммы, могла бы
использовать различные регистры продолжения (например,
@code{gcd-continue}, @code{factorial-continue}), или же мы могли бы для
всех подпрограмм использовать один регистр @code{continue}. Разделение
регистра экономичнее, однако тогда требуется отслеживать случаи, когда
из одной подпрограммы (@code{sub1}) зовется другая (@code{sub2}). Если
@code{sub1} не сохранит значение @code{continue} в каком-то другом
регистре, прежде чем использовать @code{continue} при вызове
@code{sub2}, то @code{sub1} не будет знать, откуда продолжать выполнение
после ее конца. Механизм, который разрабатывается в следующем разделе
для работы с рекурсией, дает хорошее решение и для проблемы с вложенными
вызовами подпрограмм.

@comment @subsection Using a Stack to Implement Recursion
@subsection Реализация рекурсии с помощью стека
@node	5.1.4, 5.1.5, 5.1.3, 5.1

При помощи описанных до сих пор механизмов мы можем реализовать любой
итеративный процесс, задав регистровую машину, в которой имеется по
регистру на каждую переменную состояния процесса. Машина выполняет цикл
контроллера, изменяя при этом состояние регистров, до тех пор, пока не
окажется выполнено некоторое условие окончания процесса. В каждой точке
последовательности команд контроллера состояние машины (представляющее
состояние итеративного процесса) полностью определяется состоянием
регистров (значением переменных состояния).

Однако реализация рекурсивных процессов требует дополнительного
механизма. Рассмотрим следующий рекурсивный метод вычисления факториала,
описанный нами в разделе @ref{1.2.1}:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Как мы видим из этой процедуры, вычисление @math{n!} требует вычисления
@math{(n-1)!}. Машина НОД, которая моделирует процедуру

@lisp
(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))
@end lisp

@noindent
также должна была вычислять НОД других чисел, помимо начальных значений.
Однако между машиной НОД, которая сводит исходное вычисление к
вычислению другого НОД, и @code{factorial}, в котором нужно вычислить
другой факториал как подзадачу, есть существенная разница. В машине НОД
ответ, выдаваемый новым вычислением НОД --- это и есть ответ на
исходную задачу. Чтобы вычислить следующий НОД, мы просто помещаем новые
аргументы во входные регистры машины и заново используем ее пути данных,
прогоняя ту же самую последовательность команд контроллера. Когда машина
заканчивает решение последней задачи НОД, исходное вычисление также
заканчивается.

В случае с факториалом (и в любом другом рекурсивном процессе) ответ на
подзадачу-факториал не является решением общей задачи. Значение,
полученное для @math{(n-1)!}, требуется еще домножить на @math{n}, чтобы
получить окончательный ответ. Если мы попытаемся сымитировать решение
задачи НОД и решить подзадачу-факториал, уменьшив регистр @code{n} и
запустив машину заново, у нас больше не будет старого значения @code{n},
на которое можно было бы домножить результат. Для решения подзадачи нам
бы потребовалась еще одна факториальная машина. Во втором вычислении
факториала также есть подзадача-факториал, для нее требуется третья
факториальная машина, и так далее. Поскольку внутри каждой факториальной
машины содержится другая факториальная машина, в общей машине должно
содержаться бесконечное гнездо вложенных друг в друга машин, а
следовательно, ее нельзя построить из заранее заданного конечного числа
деталей.

Тем не менее реализовать факториальный процесс в виде регистровой машины
можно, если использовать одни и те же компоненты для всех встроенных ее
экземпляров.  а именно, машина, которая вычисляет @math{n!}, должна
использовать одни и те же детали для работы над подзадачей вычисления
@math{(n-1)!}, @math{(n-2)!} и так далее. Такое построение возможно,
поскольку, несмотря на то, что факториальный процесс требует для своего
вычисления неограниченное число одинаковых машин, в каждый момент
времени только одна из этих машин активна. Когда машина встречает
рекурсивную подзадачу, она может остановить работу над основной задачей,
использовать свои физические детали для решения подзадачи, а затем
продолжить остановленное вычисление.

Содержимое регистров внутри подзадачи будет отличаться от их значения в
главной задаче. (В нашем случае регистр @code{n} уменьшается на
единицу.) Чтобы суметь продолжить остановленное вычисление, машина
должна сохранить содержимое всех регистров, которые ей понадобятся после
того, как подзадача будет решена, а затем восстановить их, прежде чем
возобновить работу. В случае с факториалом мы сохраним старое значение
@code{n} и восстановим его, когда закончим вычисление факториала от
уменьшенного значения регистра @code{n}.@footnote{Казалось бы, незачем
сохранять старое @code{n}; после того, как мы его уменьшим на единицу и
решим подзадачу, можно эту единицу добавить и восстановить старое
значение. Такая стратегия работает для факториала, но в общем случае
она работать не может, поскольку старое значение регистра не всегда
можно вычислить на основании нового.}

Поскольку нет никакого априорного ограничения на число вложенных
рекурсивных вызовов, нам может понадобиться хранить произвольное число
значений регистров. Значения эти требуется восстанавливать в порядке,
обратном порядку их сохранения, поскольку в гнезде рекурсий последняя
начатая подзадача должна завершаться первой. Поэтому требуется
использовать для сохранения значений регистров (stack), или структуру
данных вида <<последним вошел, первым вышел>>. Можно расширить язык
регистровых машин и добавить в него стек, если ввести два новых вида
команд: значения заносятся на стек командой и снимаются со стека при
помощи команды @code{restore}. После того, как последовательность
значений сохранена на стеке, последовательность команд @code{restore}
восстановит их в обратном порядке.@footnote{В разделе @ref{5.3} мы увидим,
как стек можно реализовать на основе более элементарных операций.}

С помощью стека можно использовать для всех подзадач-факториалов единую
копию путей данных факториальной машины. Имеется подобная проблема и при
использовании последовательности команд контроллера, который управляет
путями данных. Чтобы запустить новое вычисление факториала, контроллер
не может просто перейти в начало последовательности, как в итеративном
процессе, поскольку после решения подзадачи поиска @math{(n-1)!} машине
требуется еще домножить результат на @math{n}. Контроллер должен
остановить вычисление @math{n!}, решить подзадачу поиска @math{(n-1)!} и
затем продолжить вычисление @math{n!}. Такой взгляд на вычисление
факториала приводит к использованию механизма подпрограмм из
раздела @ref{5.1.3}, при котором контроллер с помощью
регистра @code{continue} переходит к той части последовательности
команд, которая решает подзадачу, а затем продолжает с того места, где
он остановился в главной задаче. Мы можем таким образом написать
факториальную подпрограмму, которая возвращается к точке входа,
сохраненной в регистре @code{continue}. При каждом вызове подпрограммы
мы сохраняем и восстанавливаем регистр @code{continue} подобно регистру
@code{n}, поскольку все <<уровни>> вычисления факториала используют один
и тот же регистр @code{continue}. Так что факториальная подпрограмма
должна записать в @code{continue} новое значение, когда она вызывает
сама себя для решения подзадачи, но для возврата в место, откуда она
была вызвана для решения подзадачи, ей потребуется старое значение
@code{continue}.

На рисунке @ref{Рисунок 5.11} показаны пути данных и контроллер
машины, реализующей рекурсивную процедуру @code{factorial}. В этой
машине имеются стек и три регистра с именами @code{n}, @code{val} и
@code{continue}. Чтобы упростить диаграмму путей данных, мы не стали
давать имена кнопкам присваивания регистров, и поименовали только кнопки
работы со стеком --- @code{sc} и @code{sn} для сохранения регистров,
@code{rc} и @code{rn} для их восстановления. В начале работы мы
кладем в регистр @code{n} число, факториал которого желаем вычислить, и
запускаем машину. Когда машина достигает состояния @code{fact-done},
вычисление закончено и результат находится в регистре @code{val}. В
последовательности команд контроллера @code{n} и @code{continue}
сохраняются перед каждым рекурсивным вызовом и восстанавливаются при
возврате из этого вызова. Возврат из вызова происходит путем перехода к
месту, хранящемуся в @code{continue}. В начале работы машины
@code{continue} получает такое значение, что последний возврат переходит
в @code{fact-done}. Регистр @code{val}, где хранится результат
вычисления факториала, не сохраняется перед рекурсивным вызовом,
поскольку после возврата из подпрограммы его старое содержимое не нужно.
Используется только новое значение @code{val}, то есть результат
подвычисления.

@float[tp]
@c @quotation
@anchor{Рисунок 5.11}
@ifinfo
@strong{Рисунок 5.11:} A recursive factorial machine.

@example
                             ___
                            /   \
    +----------*-----------|  =  |
    |          |            \___/
   (X)         |              ^
    |          |              |
    V          |          +---+---+   sn    +-------+
+-------+      |          |       +---(X)-->|       |
|  val  |<-(X)-|----------+   n   |         | stack |
+-----+-+      |          |       |<--(X)---+       |
  ^   |        |          +-------+   rn    +-+-----+
  |   |        |            ^                 |   ^
 (X)  |        |            |                 |   |
  |   |   +----|--------*  (X)                |  (X) sc
  |   |   |    |        |   |             rc (X)  |
  |   |   |    *----.   |   |                 |   |
  |   V   V    |    V   V   |                 V   |
  |  -------   |   -------  |              +------+-+
  |  \  *  /   |   \  -  /  |              |continue+--> controller
  |   --+--    |    --+--   |              +--------+
  |     |      |      |     |               ^      ^
  +-----+      |      +-----+               |      |
               |                           (X)    (X)
               |                            |      |
              / \                   after- / \    / \  fact-
             /_1_\                  fact  /___\  /___\ done
@end example

@smalllisp
(controller
   (assign continue (label fact-done))     @r{; установить адрес} 
   @r{; окончательного возврата}
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   @r{;; Подготовиться к рекурсивному вызову, сохраняя @code{n} и @code{continue}.}
   @r{;; Установить  @code{continue} так, что вычисление продолжится }
   @r{;; с @code{after-fact} после возврата из подпрограммы.}
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)

   (assign val (op *) (reg n) (reg val))  @r{; теперь @code{val} содержит} @math{n(n-1)!}
   (goto (reg continue))                  @r{; возврат в вызывающую программу}
 base-case
 (assign val (const 1))                   @r{; базовый случай: $1! = 1$}
   (goto (reg continue))                  @r{; возврат в вызывающую программу}
 fact-done)
@end smalllisp

@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.11a,106mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 5.11:} A recursive factorial machine.}
@sp 0.0
@end iftex
@c @end quotation
@end float

Несмотря на то, что в принципе вычисление факториала требует
бесконечной машины, машина на рисунке @ref{Рисунок 5.11} конечна, за
исключением стека, который потенциально неограничен. Однако любая
конкретная физическая реализация стека будет иметь конечный размер и
таким образом будет ограничивать возможную глубину рекурсивных вызовов,
которые машина сможет делать. Такая реализация факториала иллюстрирует
общую стратегию реализации рекурсивных алгоритмов в виде обыкновенных
регистровых машин, дополненных стеком. Когда нам требуется решить
рекурсивную подзадачу, мы сохраняем на стеке регистры, текущее значение
которых потребуется после решения этой подзадачи, решаем ее, затем
восстанавливаем сохраненные регистры и продолжаем выполнение главной
задачи. Регистр @code{continue} следует сохранять всегда. Нужно ли
сохранять другие регистры, зависит от конкретной машины, поскольку не
все рекурсивные вычисления нуждаются в исходных значениях регистров во
время решения подзадачи (см. упражнение @ref{Упражнение 5.4}).

@comment @subsubheading A double recursion
@subsubheading Двойная рекурсия
Рассмотрим более сложный рекурсивный процесс --- древовидную рекурсию
при вычислении чисел Фибоначчи, описанную в
разделе @ref{1.2.2}:

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
@end lisp

@noindent
Как и в случае с факториалом, рекурсивное вычисление чисел Фибоначчи
можно реализовать в виде регистровой машины с регистрами @code{n},
@code{val} и @code{continue}. Машина более сложна, чем факториальная,
поскольку в последовательности команд контроллера здесь два места, где
нам нужно произвести рекурсивный вызов --- один раз для вычисления
@math{{\rm Fib}(n-1)}, а другой для вычисления
@math{{\rm Fib}(n-2)}. При подготовке к этим вызовам мы сохраняем
регистры, чье значение нам потребуется позже, устанавливаем в регистр
@code{n} число, Fib от которого нам требуется
вычислить (@math{n-1} или @math{n-2}), и присваиваем регистру
@code{continue} точку входа в главной последовательности, куда нужно
вернуться (соответственно, @code{afterfib-n-1} или @code{afterfib-n-2}).
Затем мы переходим к метке @code{fib-loop}. При возврате из рекурсивного
вызова ответ содержится в @code{val}. На рисунке @ref{Рисунок 5.12}
показана последовательность команд контроллера для этой машины.

@strong{@anchor{Рисунок 5.12}Figure 5.12:} @math{\downarrow} Controller for a machine to compute Fibonacci numbers.

@lisp
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   @r{;; готовимся вычислить Fib@math{(n-1)}}
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                          @r{; сохранить старое значение @code{n}}
   (assign n (op -) (reg n) (const 1))@r{; записать в @code{n} @code{n-1}}
   (goto (label fib-loop))        @r{; произвести рекурсивный вызов}
 afterfib-n-1                     @r{; при возврате @code{val} содержит Fib@math{(n-1)}}
   (restore n)
   (restore continue)
   @r{;; готовимся вычислить Fib@math{(n-2)}}
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                    @r{; сохранить Fib@math{(n-1)}}
   (goto (label fib-loop))
 afterfib-n-2                    @r{; при возврате @code{val} содержит Fib@math{(n-2)}}
   (assign n (reg val))          @r{; теперь @code{n} содержит Fib@math{(n-2)}}
   (restore val)                 @r{; теперь @code{val} содержит Fib@math{(n-1)}}
   (restore continue)
   (assign val                   @r{;Fib@math{(n-1)} + Fib@math{(n-2)}}
           (op +) (reg val) (reg n)) 
   (goto (reg continue))         @r{; возврат, ответ в @code{val}}
 immediate-answer
   (assign val (reg n))          @r{; базовый случай: Fib@math{(n) = n}}
   (goto (reg continue))
 fib-done)
@end lisp

@direntry
@lisp
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   @r{;; set up to compute Fib@math{(n-1)}}
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                 @r{; save old value of @code{n}}
   (assign n (op -) (reg n) (const 1)) @r{; clobber @code{n} to @code{n-1}}
   (goto (label fib-loop))  @r{; perform recursive call}
 afterfib-n-1     @r{; upon return, @code{val} contains Fib@math{(n-1)}}
   (restore n)
   (restore continue)
   @r{;; set up to compute Fib@math{(n - 2)}}
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)               @r{; save Fib@math{(n-1)}}
   (goto (label fib-loop))
 afterfib-n-2     @r{; upon return, @code{val} contains Fib@math{(n-2)}}
   (assign n (reg val))     @r{; @code{n} now contains Fib@math{(n-2)}}
   (restore val)            @r{; @code{val} now contains Fib@math{(n-1)}}
   (restore continue)
   (assign val              @r{; Fib@math{(n-1)} + Fib@math{(n-2)}}
           (op +) (reg val) (reg n))
   (goto (reg continue))    @r{; return to caller, answer is in @code{val}}
 immediate-answer
   (assign val (reg n))     @r{; base case: Fib@math{(n) = n}}
   (goto (reg continue))
 fib-done)
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.4}Упражнение 5.4:} Опишите регистровые машины для реализации каждой из следующих
процедур. Для каждой из этих машин напишите последовательность команд
контроллера и нарисуйте диаграмму, показывающую пути данных.

@enumerate a.

@item
Рекурсивное возведение в степень:

@lisp
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
@end lisp

@item
Итеративное возведение в степень:

@lisp
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))
@end lisp

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.5}Упражнение 5.5:} Смоделируйте вручную работу факториальной машины и машины
Фибоначчи с каким-нибудь нетривиальным значением на входе (чтобы
потребовался хотя бы один рекурсивный вызов). Покажите содержимое
стека в каждый момент выполнения.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.6}Упражнение 5.6:} Бен Битобор утверждает, что последовательность команд машины
Фибоначчи содержит одну лишнюю команду @code{save} и одну лишнюю
@code{restore}, которые можно убрать и получить более быструю машину.
Что это за команды?
@end quotation

@comment @subsection Instruction Summary
@subsection Обзор системы команд
@node	5.1.5,  , 5.1.4, 5.1

Команда контроллера в нашей регистровой машине имеет одну из следующих
форм, причем каждый
@math{\langle}@var{input}@math{_i\rangle} --- это @code{(reg
@math{\langle}@var{register-name}@math{\rangle})} либо, @code{(const @math{\langle}@var{constant-value}@math{\rangle})}.  Команды, введенные в разделе @ref{5.1.1}:

@lisp
(assign @math{\langle}@var{register-name}@math{\rangle} (reg @math{\langle}@var{register-name}@math{\rangle}))
(assign @math{\langle}@var{register-name}@math{\rangle} (const @math{\langle}@var{constant-value}@math{\rangle}))
(assign @math{\langle}@var{register-name}@math{\rangle}
        (op @math{\langle}@var{operation-name}@math{\rangle})
        @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(perform (op @math{\langle}@var{operation-name}@math{\rangle}) @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(test (op @math{\langle}@var{operation-name}@math{\rangle}) @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(branch (label @math{\langle}@var{label-name}@math{\rangle}))
(goto (label @math{\langle}@var{label-name}@math{\rangle}))
@end lisp

@noindent
Использование регистров для хранения меток, введенное в разделе @ref{5.1.3}:

@lisp
(assign @math{\langle}@var{register-name}@math{\rangle} (label @math{\langle}@var{label-name}@math{\rangle}))
(goto (reg @math{\langle}@var{register-name}@math{\rangle}))
@end lisp

@noindent
Команды для работы со стеком, введенные в разделе @ref{5.1.4}:

@lisp
(save @math{\langle}@var{register-name}@math{\rangle})
(restore @math{\langle}@var{register-name}@math{\rangle})
@end lisp

@noindent
До сих пор единственный вид
@math{\langle}@var{constant-value}@math{\rangle}, который нам
встречался, --- числа, но в дальнейшем мы будем использовать строки,
символы и списки. Например, 

@lisp
(const "abc") @r{представляет строку} "abc",
(const abc) @r{представляет символ} abc,
(const (a b c)) @r{список} (a b c),
@r{and} (const ()) @r{пустой список.}
@end lisp

@comment @section A Register-Machine Simulator
@section Программа моделирования регистровых машин
@node	5.2, 5.3, 5.1, Chapter 5

Чтобы как следует разобраться в работе регистровых машин, нам нужно
уметь тестировать проектируемые нами машины и проверять, работают ли
они в соответствии с ожиданиями. Один из способов проверки проекта
состоит в ручном моделировании работы контроллера, как в
упражнении @ref{Упражнение 5.5}. Однако этот способ подходит только для
совсем простых машин. В этом разделе мы строим программу имитационного
моделирования, (simulator), для машин, задаваемых на языке описания
регистровых машин. Имитатор представляет собой программу на Scheme с
четырьмя интерфейсными процедурами. Первая из них на основе описания
регистровой машины строит ее модель (структуру данных, части которой
соответствуют частям имитируемой машины), а остальные три позволяют
имитировать машину, работая с этой моделью:

@quotation

@lisp
(make-machine @math{\langle}@var{register-names}@math{\rangle} @math{\langle}@var{operations}@math{\rangle} @math{\langle}@var{controller}@math{\rangle})
@end lisp

@noindent
строит и возвращает модель машины с указанными регистрами, операциями и
контроллером.

@lisp
(set-register-contents! @math{\langle\kern0.08em}@var{machine-model}@math{\rangle}
                        @math{\langle}@var{register-name}@math{\rangle}
                        @math{\langle}@var{value}@math{\rangle})
@end lisp

@noindent
записывает значение в имитируемый регистр указанной машины.

@lisp
(get-register-contents @math{\langle\kern0.08em}@var{machine-model}@math{\rangle} @math{\langle}@var{register-name}@math{\rangle})
@end lisp

@noindent
возвращает содержимое имитируемого регистра указанной машины.

@lisp
(start @math{\langle\kern0.08em}@var{machine-model}@math{\rangle})
@end lisp

имитирует работу данной машины. Машина запускается с начала последовательности команд
контроллера и останавливается, когда достигнут конец этой последовательности.
@end quotation

@noindent
В качестве примера того, как используются эти процедуры, можно
определить переменную @code{gcd-machine} как модель машины НОД из
раздела @ref{5.1.1} следующим образом:

@lisp
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
       gcd-done)))
@end lisp

Первым аргументом @code{make-machine} является список имен регистров.
Второй аргумент --- таблица (список двухэлементных списков),
связывающая каждое имя операции с процедурой Scheme, которая эту
операцию реализует (то есть порождает тот же результат на тех же входных
значениях). Последний аргумент описывает контроллер в виде списка из
меток и машинных команд, как в разделе @ref{5.1}.

Чтобы вычислить НОД двух чисел с помощью этой машины, мы заносим
значения во входные регистры, запускаем машину, а когда имитация ее
работы завершается, считываем результат:

@lisp
(set-register-contents! gcd-machine 'a 206)
@i{done}
(set-register-contents! gcd-machine 'b 40)
@i{done}
(start gcd-machine)
@i{done}
(get-register-contents gcd-machine 'a)
@i{2}
@end lisp

@noindent
Эта модель будет работать значительно медленнее, чем процедура
@code{gcd}, написанная на Scheme, поскольку она имитирует низкоуровневые
команды машины, например, @code{assign}, с помощью значительно более
сложных операций.

@quotation
@strong{@anchor{Упражнение 5.7}Упражнение 5.7:} Проверьте на имитаторе машины, построенные Вами в
упражнении @ref{Упражнение 5.4}.
@end quotation

@menu
* 5-2-1::            Модель машины
* 5-2-2::            Ассемблер
* 5-2-3::            Порождение исполнительных процедур для команд
* 5-2-4::            Отслеживание производительности машины
@end menu

@comment @subsection The Machine Model
@subsection Модель машины
@node	5.2.1, 5.2.2, 5.2, 5.2

Модель машины, которую порождает @code{make-machine}, представляется в
виде процедуры с внутренним состоянием при помощи методов передачи
сообщений, разработанных в главе @ref{Глава 3}.
При построении модели @code{make-machine} прежде всего вызывает
процедуру @code{make-new-machine}, порождающую те части модели, которые
у всех регистровых машин одинаковые. Эта базовая модель машины,
создаваемая @code{make-new-machine}, является, в сущности, контейнером
для нескольких регистров и стека, а кроме того, содержит механизм
выполнения, который обрабатывает команды контроллера одну за другой.

Затем @code{make-machine} расширяет эту базовую модель (посылая ей
сообщения) и добавляет в нее регистры, операции и контроллер для
конкретной определяемой машины. Сначала она выделяет в новой машине по
регистру на каждое из данных имен регистров и встраивает в нее
указанные операции. Затем она с помощью (assembler) (описанного в
разделе @ref{5.2.2}) преобразует список контроллера в
команды новой машины и устанавливает их ей в качестве
последовательности команд. В качестве результата @code{make-machine}
возвращает модифицированную модель машины.

@lisp
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each
     (lambda (register-name)
       ((machine 'allocate-register) register-name))
     register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
@end lisp

@comment @subsubheading Registers
@subsubheading Регистры

Мы будем представлять регистры в виде процедур с внутренним состоянием,
как в главе @ref{Глава 3}. Процедура @code{make-register} создает регистр.
Регистр содержит значение, которое можно считать или изменить.

@lisp
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request: REGISTER" message))))
    dispatch))
@end lisp

@noindent
Для доступа к регистрам используются следующие процедуры:

@lisp
(define (get-contents register) (register 'get))
(define (set-contents! register value)
  ((register 'set) value))
@end lisp

@comment @subsubheading The stack
@subsubheading Стек

Стек также можно представить в виде процедуры с внутренним состоянием.
Процедура @code{make-stack} создает стек, внутреннее состояние которого
состоит из списка элементов на стеке. Стек принимает сообщение
@code{push}, кладущее элемент на стек, сообщение @code{pop}, снимающее
со стека верхний элемент и возвращающее его, и сообщение
@code{initialize}, которое дает стеку начальное пустое значение.

@lisp
(define (make-stack)
  (let ((s '()))
    (define (push x) (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request: STACK" message))))
    dispatch))
@end lisp

@noindent
Для доступа к стеку используются следующие процедуры:

@lisp
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))
@end lisp

@comment @subsubheading The basic machine
@subsubheading Базовая машина

Процедура @code{make-new-machine}, приведенная на
рисунке @ref{Рисунок 5.13}, порождает объект, внутреннее состояние
которого состоит из стека, изначально пустой последовательности команд,
списка операций, где с самого начала присутствует операция инициализации
стека, а также (register table), в которой изначально содержатся два
регистра, @code{flag} и @code{pc} (от @emph{program counter}, <<счетчик
программы>>). Внутренняя процедура @code{allocate-register} добавляет в
таблицу новый элемент, а внутренняя процедура @code{lookup-register}
ищет регистр в таблице.

Регистр @code{flag} используется для управления переходами в
имитируемой машине. Команды @code{test} присваивают ему результат теста
(истину или ложь). Команды @code{branch} определяют, нужно ли делать
переход, в зависимости от значения регистра @code{flag}.

Регистр @code{pc} определяет порядок выполнения команд при работе
машины. Этот порядок реализуется внутренней процедурой @code{execute}. В
нашей имитационной модели каждая команда является структурой данных, в
которой есть процедура без аргументов, называемая (instruction execution
procedure). Вызов этой процедуры имитирует выполнение команды. Во время
работы модели @code{pc} указывает на часть последовательности команд,
начинающуюся со следующей подлежащей исполнению команды. Процедура
@code{execute} считывает эту команду, выполняет ее при помощи вызова
исполнительной процедуры, и повторяет этот процесс, пока имеется команды
для выполнения (то есть пока @code{pc} не станет указывать на конец
последовательности команд).

@quotation
@strong{@anchor{Рисунок 5.13}Figure 5.13:} @math{\downarrow} The @code{make-new-machine}
procedure, which implements the basic machine model.

@direntry
@lisp
(define (make-new-machine)\index{ru}{make-new-machine||||pd|}
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Многократно определенный регистр: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Неизвестный регистр:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Неизвестная операция -- MACHINE" message))))
      dispatch)))
@end lisp
@end direntry

@lisp
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register)
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request: MACHINE"
                           message))))
      dispatch)))
@end lisp
@end quotation

@noindent
В процессе работы каждая исполнительная процедура изменяет @code{pc} и
указывает, какую следующую команду надо выполнить. Команды @code{branch}
и @code{goto} присваивают регистру @code{pc} значение, указывающее на
новый адрес. Все остальные команды просто продвигают @code{pc} так,
чтобы он указывал на следующую команду в последовательности. Заметим,
что каждый вызов @code{execute} снова зовет @code{execute}, но это не
приводит к бесконечному циклу, поскольку запуск исполнительной процедуры
команды изменяет содержимое @code{pc}.

@code{make-new-machine} возвращает процедуру @code{dispatch}, которая
дает доступ к внутреннему состоянию на основе передачи сообщений. Запуск
машины осуществляется путем установки @code{pc} в начало
последовательности команд и вызова @code{execute}.

Ради удобства мы предоставляем альтернативный процедурный интерфейс для
операции @code{start} регистровой машины, а также процедуры для доступа
к содержимому регистров и их изменения, как указано в начале
раздела @ref{5.2}:

@lisp
(define (start machine) (machine 'start))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name)
                 value)
  'done)
@end lisp

@noindent
Все эти процедуры (а также многие процедуры из разделов @ref{5.2.2} и @ref{5.2.3})
следующим образом ищут регистр с данным именем в данной машине:

@lisp
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
@end lisp

@comment @subsection The Assembler
@subsection Ассемблер
@node	5.2.2, 5.2.3, 5.2.1, 5.2

Ассемблер переводит последовательность выражений контроллера машины в
соответствующий ей список машинных команд, каждая со своей
исполнительной процедурой. По общему строению ассемблер подобен
интерпретаторам, которые мы изучали в главе @ref{Глава 4} ---
имеется входной язык (в этом случае язык регистровых машин), и нам нужно
выполнить некоторое действие для каждого типа выражений этого языка.

Методика порождения исполнительной процедуры для каждой команды в
точности та же, которой мы пользовались в разделе @ref{4.1.7},
чтобы ускорить интерпретацию путем отделения синтаксического анализа от
выполнения. Как мы видели в главе @ref{Глава 4},
существенную часть полезного анализа выражений Scheme можно провести, не
зная конкретных значений переменных. Подобным образом и здесь
существенную часть анализа выражений машинного языка можно провести, не
зная конкретного содержимого регистров машины. Например, можно заменить
имена регистров указателями на объекты-регистры, а имена меток ---
указателями на те места в последовательности команд, которые метками
обозначаются.

Прежде чем порождать исполнительные процедуры команд, ассемблер должен
знать, куда указывают все метки, так что вначале он просматривает текст
контроллера и отделяет метки от команд. При просмотре текста он строит
список команд и таблицу, которая связывает каждую метку с указателем
внутрь этого списка. Затем ассемблер дополняет список команд,
вставляя в каждую команду исполнительную процедуру.

Процедура @code{assemble} --- основной вход в ассемблер. Она
принимает в качестве аргументов текст контроллера и модель машины, а
возвращает последовательность команд, которую нужно сохранить в модели.
@code{assemble} вызывает @code{extract-labels}, чтобы построить из
данного ей списка контроллера исходный список команд и таблицу меток.
Вторым аргументом @code{extract-labels} служит процедура, которую
следует позвать для обработки этих результатов: эта процедура зовет
@code{update-insts!}, чтобы породить исполнительные процедуры для команд
и вставить их в командный список, а затем возвращает модифицированный
список команд.

@lisp
(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
@end lisp

@noindent
@code{extract-labels} принимает на входе список @code{text}
(последовательность выражений, обозначающих команды контроллера) и
процедуру @code{receive}. @code{receive} будет вызвана с двумя
аргументами: (1) списком @code{insts} структур данных, каждая из которых
содержит команду из @code{text}; и (2) таблицей под названием
@code{labels}, связывающей каждую метку из @code{text} с позицией в
списке @code{insts}, которую эта метка обозначает.

@lisp
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
@end lisp

@noindent
Работа @code{extract-labels} заключается в последовательном просмотре
элементов @code{text} и сборке @code{insts} и @code{labels}. Если
очередной элемент является символом (то есть меткой), соответствующий
вход добавляется в таблицу @code{labels}. В противном случае элемент
добавляется к списку @code{insts}.@footnote{Процедура @code{receive}
используется здесь, в сущности, для того, чтобы заставить
@code{extract-labels} вернуть два значения --- @code{labels} и
@code{insts}, --- не создавая специально структуры данных для их
хранения. Альтернативная реализация, которая явным образам возвращает
пару значений, выглядит так:

@lisp
(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
@end lisp

@noindent
Вызывать ее из @code{assemble} следовало бы таким образом:

@lisp
(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
@end lisp

Можно считать, что использование @code{receive} показывает изящный
способ вернуть несколько значений, а можно считать, что это просто
оправдание для демонстрации программистского трюка. Аргумент, который,
как @code{receive}, является процедурой, вызываемой в конце, называется
<<продолжением>>. Напомним, что мы уже использовали продолжения для
того, чтобы реализовать управляющую структуру перебора с возвратом в
разделе @ref{4.3.3}.}

@code{update-insts!} модифицирует командный список, который сначала
содержит только текст команд, так, чтобы в нем имелись соответствующие
исполнительные процедуры:

@lisp
(define (update-insts! insts labels machine) 
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
@end lisp

@noindent
Структура данных для машинной команды просто сочетает текст команды с
соответствующей исполнительной процедурой. Когда @code{extract-labels}
создает команду, исполнительной процедуры еще нет, и она вставляется
позже из процедуры @code{update-insts!}:

@lisp
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
@end lisp

@noindent
Текст команды не используется в имитаторе, но сохраняется в целях
отладки (см. упражнение @ref{Упражнение 5.16}).

Элементы таблицы меток --- это пары:

@lisp
(define (make-label-entry label-name insts)
  (cons label-name insts))
@end lisp

@noindent
Записи в таблице можно искать через

@lisp
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label: ASSEMBLE"
               label-name))))
@end lisp

@direntry
@lisp
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Неопределенная метка -- ASSEMBLE"
               label-name))))
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.8}Упражнение 5.8:} Следующий код для регистровой
машины неоднозначен, поскольку метка @code{here} определена более одного раза:

@lisp
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
@end lisp

Каково будет содержимое регистра @code{a} в нашем имитаторе, когда
управление достигнет @code{there}? Измените процедуру
@code{extract-labels} так, чтобы ассемблер сообщал об ошибке в случае,
когда одно и то же имя метки обозначает две различных точки в коде.
@end quotation

@comment @subsection Generating Execution Procedures@* for Instructions
@subsection Порождение исполнительных процедур для команд
@node	5.2.3, 5.2.4, 5.2.2, 5.2

Чтобы породить для команды исполнительную процедуру, ассемблер зовет
@code{make-execution-procedure}. Как и процедура @code{analyze} в
интерпретаторе из раздела @ref{4.1.7},
она делает выбор на основе типа команды и порождает соответствующую
исполнительную процедуру.

@lisp
(define (make-execution-procedure
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else
         (error "Unknown instruction type: ASSEMBLE"
                inst))))
@end lisp

@direntry
@lisp
(define (make-execution-procedure
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Неизвестный тип команды -- ASSEMBLE"
                     inst))))
@end lisp
@end direntry

@noindent
Для каждого типа команд языка регистровых машин имеется
процедура-генератор, которая порождает исполнительные процедуры. Детали
порождаемых процедур определяют как синтаксис, так и семантику отдельных
команд машинного языка. Мы изолируем с помощью абстракции данных
конкретный синтаксис выражений языка регистровых машин от общего
механизма вычисления, подобно тому, как мы это делали для интерпретатора
из раздела @ref{},
и для считывания и классификации частей команды используем
синтаксические процедуры.
Команды @code{assign}
Процедура @code{make-assign} обрабатывает команды @code{assign}:

@lisp
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()     @r{; исполнительная процедура для @code{assign}}
        (set-contents! target (value-proc))
        (advance-pc pc)))))
@end lisp

@code{make-assign} извлекает имя целевого регистра (второй элемент
команды) и выражение-значение (остаток списка, представляющего команду)
из команды @code{assign} с помощью селекторов

@lisp
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
@end lisp

@noindent
По имени регистра с помощью @code{get-register} находится объект-целевой
регистр. Выражение-значение передается в @code{make-operation-exp}, если
значение является результатом операции, и в
@code{make-primitive-exp} в противном случае. Эти процедуры
(приведенные ниже) рассматривают выражение-значение и порождают
исполнительную процедуру для вычисления этого выражения. Это процедура
без аргументов, называемая , которая будет вызвана во время работы
имитатора и породит значение, которое требуется присвоить регистру.
Заметим, что поиск регистра по имени и разбор выражения-значения
происходят только один раз во время ассемблирования, а не каждый раз
при выполнении команды. Именно ради такой экономии работы мы используем
исполнительные процедуры, и этот выигрыш прямо соответствует экономии,
полученной путем отделения синтаксического анализа от выполнения в
интерпретаторе из раздела @ref{4.1.7}.

Результат, возвращаемый @code{make-assign} --- это исполнительная
процедура для команды @code{assign}. Когда эта процедура вызывается (из
процедуры @code{execute} модели), она записывает в целевой регистр
результат, полученный при выполнении @code{value-proc}. Затем она
передвигает @code{pc} на следующую команду с помощью процедуры

@lisp
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
@end lisp

@noindent
@code{advance-pc} вызывается в конце исполнения всех команд, кроме
@code{branch} и @code{goto}.

@comment @subsubheading @code{test}, @code{branch}, and @code{goto} instructions
@subsubheading Команды @code{test}, @code{branch} и @code{goto}

@code{make-test} обрабатывает команду @code{test} похожим образом. Эта
процедура извлекает выражение, которое определяет подлежащее проверке
условие, и порождает для него исполнительную процедуру. Во время работы
модели эта процедура для условия вызывается, результат ее сохраняется в
регистре @code{flag}, и @code{pc} передвигается на шаг:

@lisp
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction: ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
@end lisp

@direntry
@lisp
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Плохая команда TEST -- ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
@end lisp
@end direntry

@noindent
Исполнительная процедура для команды @code{branch} проверяет содержимое
регистра @code{flag} и либо записывает в содержимое @code{pc} целевой
адрес (если переход происходит), либо просто продвигает @code{pc} (если
переход не происходит). Заметим, что указанная точка назначения для
команды @code{branch} обязана быть меткой, и процедура
@code{make-branch} это проверяет. Заметим также, что поиск метки
происходит во время ассемблирования, а не при каждом исполнении команды
@code{branch}.

@lisp
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label
                labels
                (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction: ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
@end lisp

@direntry
@lisp
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Плохая команда BRANCH -- ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
@end lisp
@end direntry

Команда @code{goto} подобна @code{branch}, но только здесь в качестве
целевого адреса может быть указана либо метка, либо регистр, и не надо
проверять никакого условия --- в @code{pc} всегда записывается новый
адрес.

@lisp
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts (lookup-label
                         labels
                         (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg (get-register
                       machine
                       (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
@end lisp

@direntry
@lisp
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Плохая команда GOTO -- ASSEMBLE"
                       inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
@end lisp
@end direntry

@comment @subsubheading Other instructions
@subsubheading Остальные команды

Команды работы со стеком @code{save} и @code{restore} просто используют
стек и указанный регистр, а затем продвигают @code{pc}:

@lisp
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
@end lisp

Последний тип команды, обрабатываемый процедурой @code{make-perform},
порождает исполнительную процедуру для требуемого действия. Во время
работы имитатора действие выполняется и продвигается @code{pc}.

@lisp
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda () (action-proc) (advance-pc pc)))
        (error "Bad PERFORM instruction: ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
@end lisp

@direntry
@lisp
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Плохая команда PERFORM -- ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
@end lisp
@end direntry

@comment @subsubheading Execution procedures for subexpressions
@subsubheading Исполнительные процедуры для подвыражений

Значение выражения @code{reg}, @code{label} или @code{const} может
потребоваться для присваивания регистру (@code{make-assign}) или как
аргумент операции (@code{make-operation-exp}, далее). Следующая
процедура порождает исполнительные процедуры, которые вычисляют во время
выполнения значения этих выражений:

@lisp
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts (lookup-label
                       labels
                       (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else (error "Unknown expression type: ASSEMBLE" exp))))
@end lisp

@direntry
@lisp
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Неизвестный тип выражения -- ASSEMBLE" exp))))
@end lisp
@end direntry

@noindent
Синтаксис выражений @code{reg}, @code{label} и @code{const} определяется
так:

@lisp
(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))
@end lisp

Команды @code{assign}, @code{test} и @code{perform} могут включать в
себя применение машинной операции (определяемой выражением @code{op}) к
нескольким операндам (определяемым выражениями @code{reg} или
@code{const}). Следующая процедура порождает исполнительную процедуру
для <<выражения-операции>> --- списка, состоящего из выражений внутри
команды, обозначающих операцию и операнды.

@lisp
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp)
                         operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
@end lisp

@noindent
Синтаксис выражений-операций определяется через

@lisp
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
@end lisp

Заметим, что обработка выражений-операций очень напоминает обработку
вызовов процедур процедурой @code{analyze-application} интерпретатора из раздела
@ref{4.1.7}, поскольку там и тут мы порождаем исполнительные процедуры для каждого
операнда. Во время работы мы вызываем эти процедуры для операндов и
применяем процедуру Scheme, которая имитирует операцию, к полученным
значениям. Имитирующая процедура получается путем поиска имени
операции в таблице операций регистровой машины:

@lisp
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE"
               symbol))))
@end lisp

@direntry
@lisp
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Неизвестная операция -- ASSEMBLE" symbol))))
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.9}Упражнение 5.9:} Приведенная в тексте обработка позволяет машинным операциям
принимать в качестве аргументов не только константы и содержимое
регистров, но и метки. Измените процедуры, обрабатывающие выражения, и
обеспечьте выполнение условия, что операции можно применять
исключительно к регистрам и константам.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.10}Упражнение 5.10:} Придумайте новый синтаксис для команд регистровой машины и
измените имитатор так, чтобы он использовал Ваш новый синтаксис. Можете
ли Вы реализовать свой синтаксис, ничего не трогая, кроме синтаксических
процедур из этого раздела?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.11}Упражнение 5.11:} Когда мы в
разделе @ref{5.1.4} определяли
@code{save} и @code{restore}, мы не указали, что произойдет, если
попытаться восстановить значение не в том регистре, который был
сохранен последним, как в последовательности команд

@lisp
(save y) (save x) (restore y)
@end lisp

Есть несколько разумных вариантов значения @code{restore}:

@enumerate a.

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
на стеке, независимо от того, откуда это значение взялось. Так работает
наш имитатор. Покажите, как с помощью такого поведения убрать одну
команду из машины Фибоначчи (раздел @ref{5.1.4}, рисунок @ref{Рисунок 5.12}).

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
на стеке, но только в том случае, когда это значение происходит из
регистра @code{y}; иначе возникает сообщение об ошибке. Модифицируйте
имитатор и заставьте его вести себя таким образом. Придется изменить
@code{save} так, чтобы он сохранял имя регистра вместе со значением.

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
из @code{y}, независимо от того, какие другие регистры были сохранены и
не восстановлены после @code{y}. Модифицируйте имитатор так, чтобы он
вел себя таким образом. С каждым регистром придется связать свой
собственный стек. Операция @code{initialize-stack} должна
инициализировать стеки всех регистров.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.12}Упражнение 5.12:} При помощи имитатора можно определять пути данных, которые
требуются для реализации машины с данным контроллером. Расширьте
ассемблер и заставьте его хранить следующую информацию о модели машины:

@itemize

@item
список всех команд, с удаленными дубликатами, отсортированный по типу
команды (@code{assign}, @code{goto} и так далее).

@item
список (без дубликатов) регистров, в которых хранятся точки входа (это
те регистры, которые упоминаются в командах @code{goto}).

@item
Список (без дубликатов) регистров, к которым применяются команды
@code{save} или @code{restore}.

@item
Для каждого регистра, список (без дубликатов) источников, из которых ему
присваивается значение (например, для регистра @code{val} в
факториальной машине на рисунке @ref{Рисунок 5.11} источниками
являются @code{(const 1)} и @code{((op *) (reg n) (reg val))}).

@end itemize

Расширьте интерфейс сообщений машины и включите в него доступ к новой
информации. Чтобы проверить свой анализатор, примените его к машине
Фибоначчи с рисунка @ref{Рисунок 5.12} и рассмотрите получившиеся
списки.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.13}Упражнение 5.13:} Модифицируйте имитатор так, чтобы он определял, какие
регистры присутствуют в машине, из последовательности команд
контроллера, а не принимал список регистров в качестве аргумента
@code{make-machine}. Вместо того, чтобы выделять регистры в
@code{make-machine} заранее, их можно создавать по одному, когда они
встречаются в первый раз при ассемблировании команд.
@end quotation

@comment @subsection Monitoring Machine Performance
@subsection Отслеживание производительности машины
@node	5.2.4,  , 5.2.3, 5.2

Имитационное моделирование может служить не только для проверки
правильности проекта машины, но и для измерения ее производительности. К
примеру, можно установить в нашу машину <<счетчик>>, измеряющий
количество операций со стеком, задействованных при вычислении. Для этого
мы изменяем моделируемый стек и следим, сколько раз регистры сохраняются
на стеке, регистрируем максимальную глубину, которой он достигает, а
также добавляем к интерфейсу стека сообщение, которое распечатывает
статистику, как показано ниже. Кроме того, мы добавляем к базовой машине
операцию для распечатки статистики, устанавливая значение @code{the-ops}
в @code{make-new-machine} в

@lisp
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
@end lisp

@noindent
Вот новая версия @code{make-stack}:

@lisp
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else (error "Unknown request: STACK" message))))
    dispatch))
@end lisp

@direntry
@lisp
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Пустой стек -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Неизвестная операция -- STACK" message))))
    dispatch))
@end lisp
@end direntry

В упражнениях от @ref{Упражнение 5.15} до @ref{Упражнение 5.19}
описываются другие полезные возможности для сбора информации и отладки,
которые можно добавить к имитатору регистровых машин.

@quotation
@strong{@anchor{Упражнение 5.14}Упражнение 5.14:} Измерьте количество сохранений и максимальную глубину
стека, требуемую для вычисления @math{n!} при различных малых значениях
@math{n} с помощью факториальной машины, показанной на
рисунке @ref{Рисунок 5.11}. По этим данным определите формулы в
зависимости от @math{n} для числа сохранений и максимальной глубины
стека, требуемых для вычисления @math{n!} при любом @math{n > 1}.
Обратите внимание, что это линейные функции от @math{n}, и они
определяются двумя константами. Чтобы увидеть статистику, Вам придется
добавить к факториальной машине команды для инициализации стека и
распечатки статистики. Можно также заставить машину в цикле считывать
@code{n}, вычислять факториал и печатать результат (как для машины НОД с
рисунка @ref{Рисунок 5.4}), так, чтобы не нужно было все время
вызывать @code{get-register-contents}, @code{set-register-contents!} и
@code{start}.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.15}Упражнение 5.15:} Добавьте к модели регистровой машины (instruction
counting). Это значит, что машина должна подсчитывать число выполненных
ею команд. Расширьте интерфейс модели и добавьте новое сообщение,
которое печатает счетчик команд и переустанавливает его в ноль.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.16}Упражнение 5.16:} Добавьте к имитатору (instruction tracing).  А именно,
перед тем, как выполнить каждую команду, имитатор должен распечатывать
ее текст. Заставьте модель принимать сообщения @code{trace-on} и
@code{trace-off}, которые включают и выключают трассировку.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.17}Упражнение 5.17:} Расширьте трассировку команд из
упражнения @ref{Упражнение 5.16} так, чтобы перед тем, как печатать
команду, имитатор распечатывал метки, которые стоят в
последовательности контроллера непосредственно перед этой командой.
Постарайтесь при этом не помешать подсчету команд
(упражнение @ref{Упражнение 5.15}). Придется заставить имитатор
хранить необходимую информацию о метках.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.18}Упражнение 5.18:} Измените процедуру @code{make-register} из раздела
@ref{5.2.1}, так, чтобы можно было трассировать
регистры. Регистры должны принимать сообщения, которые включают и
выключают трассировку. Когда регистр подвергается трассировке,
присваивание ему значения должно вызывать распечатку имени регистра,
старого его содержимого и нового, которое ему присваивается. Расширьте
интерфейс модели и дайте пользователю возможность включать и выключать
трассировку для указанных регистров машины.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.19}Упражнение 5.19:} Лиза П. Хакер хочет добавить в имитатор (breakpoints)
для облегчения отладки проектов машин. Вас наняли для реализации такой
возможности. Лиза хочет, чтобы в последовательности команд контроллера
можно было указать место, где имитатор остановится и позволит ей
исследовать состояние машины. Вам нужно реализовать процедуру

@lisp
(set-breakpoint @math{\langle\kern0.08em}@var{machine}@math{\rangle} @math{\langle}@var{label}@math{\rangle} @math{\langle}@var{n}@math{\rangle})
@end lisp

@noindent
которая устанавливает контрольную точку перед @math{n}-й командой,
следующей за указанной меткой. Например,

@lisp
(set-breakpoint gcd-machine 'test-b 4)
@end lisp

@noindent
установит контрольную точку в @code{gcd-machine} непосредственно перед
присваиванием регистру @code{a}. Когда моделирование достигает
контрольной точки, имитатор должен распечатать метку и смещение
точки, а затем прекратить выполнение команд. Тогда Лиза может с помощью
@code{get-register-contents} и @code{set-register-contents!} исследовать
и изменять состояние имитируемой машины. Затем она должна быть способна
продолжить выполнение, сказав

@lisp
(proceed-machine @math{\langle\kern0.08em}@var{machine}@math{\rangle})
@end lisp

Кроме того, необходимо иметь возможность удалить контрольную точку с
помощью

@lisp
(cancel-breakpoint @math{\langle\kern0.08em}@var{machine}@math{\rangle} @math{\langle}@var{label}@math{\rangle} @math{\langle}@var{n}@math{\rangle})
@end lisp

@noindent
и удалить все контрольные точки с помощью

@lisp
(cancel-all-breakpoints @math{\langle\kern0.08em}@var{machine}@math{\rangle})
@end lisp
@end quotation

@comment @section Storage Allocation and Garbage Collection
@section Выделение памяти и сборка мусора
@node	5.3, 5.4, 5.2, Chapter 5

В разделе @ref{5.4} мы покажем, как
реализовать вычислитель для Scheme в виде регистровой машины. Для того,
чтобы упростить обсуждение, мы будем предполагать, что наши машины
обладают (@newterm{list-structured memory}), в которой основные операции по
работе с данными списковой структуры элементарны. Постулирование такой
памяти --- удобная абстракция, если мы хотим сконцентрировать внимание
на механизмах управления в интерпретаторе Scheme, однако она не дает
реалистической картины того, как на самом деле устроены элементарные
операции с данными в современных компьютерах. Для того, чтобы получить
более полное понимание работы Лисп-системы, требуется исследовать, как
списковую структуру можно представить способом, совместимым с
устройством памяти обыкновенных компьютеров.

При реализации списковой структуры возникает два вопроса. Первый
относится только к способу представления: как изобразить структуру
<<ячеек и указателей>>, присущую лисповским парам, используя только
механизмы хранения и адресации, которыми обладает обыкновенная
компьютерная память. Второй вопрос связан с управлением памятью по мере
того, как вычисление развивается. Работа Лисп-системы существенным
образом зависит от ее способности постоянно создавать новые объекты
данных. Сюда включаются как объекты, которые явным образом выделяются в
интерпретируемых Лисп-процедурах, так и структуры, создаваемые самим
интерпретатором, например окружения и списки аргументов. Несмотря на то,
что постоянное создание новых объектов данных не вызвало бы проблемы на
компьютере с бесконечным количеством быстродействующей памяти, в
настоящих компьютерах объем доступной памяти ограничен (к сожалению).
Поэтому Лисп-системы реализуют @emph{автоматическое распределение
памяти} (@newterm{automatic storage allocation}), которое поддерживает иллюзию
бесконечной памяти. Когда объект данных перестает быть нужным, занятая
под него память автоматически освобождается и используется для
построения новых объектов данных. Имеются различные методы реализации
такого автоматического распределителя памяти. Метод, обсуждаемый нами в
этом разделе, называется (@newterm{garbage collection}).

@menu
* 5-3-1::            Память как векторы::
* 5-3-2::            Иллюзия бесконечной памяти::
@end menu

@comment @subsection Memory as Vectors
@subsection Память как векторы
@node	5.3.1, 5.3.2, 5.3, 5.3

Обыкновенную память компьютера можно рассматривать как массив клеток,
каждая из которых может содержать кусочек информации. У каждой клетки
имеется собственное имя, которое называется ее (@newterm{address}). Типичная
система памяти предоставляет две элементарные операции: одна считывает
данные, хранящиеся по указанному адресу, а вторая записывает по
указанному адресу новые данные. Адреса памяти можно складывать с целыми
числами и получать таким образом последовательный доступ к некоторому
множеству клеток. Если говорить более общо, многие важные операции с
данными требуют, чтобы адреса памяти рассматривались как данные, которые
можно записывать в ячейки памяти, и которыми можно манипулировать в
регистрах машины. Представление списковой структуры --- одно из
применений такой (@newterm{address arithmetic}).

@endpage
Для моделирования памяти компьютера мы используем новый вид структуры
данных, называемый @emph{вектором} (@newterm{vector}). С абстрактной точки зрения,
вектор представляет собой составной объект, к отдельным элементам
которого можно обращаться при помощи целочисленного индекса за время,
независимое от величины индекса.@footnote{Можно было бы представить
память в виде списка ячеек. Однако тогда время доступа не было бы
независимым от индекса, поскольку доступ к @math{n}-му элементу списка
требует @math{n-1} операций @code{cdr}.} Чтобы описать операции с
памятью, мы пользуемся двумя элементарными процедурами Scheme для работы
с векторами:

@itemize @bullet

@item
@code{(vector-ref @math{\langle}@var{vector}@math{\rangle} @math{\langle}@var{n}@math{\rangle})} возвращает @math{n}-ый элемент вектора.

@item
@code{(vector-set! @math{\langle}@var{vector}@math{\rangle} @math{\langle}@var{n}@math{\rangle} @math{\langle}@var{value}@math{\rangle})}
устанавливает @math{n}-ый элемент вектора в указанное значение.

@end itemize

@noindent
Например, если @code{v} --- вектор, то @code{(vector-ref v 5)} получает
его пятый элемент, а @code{(vector-set! v 5 7)} устанавливает значение
его пятого элемента равным 7.@footnote{Полноты ради, надо было бы указать
еще операцию @code{make-vector}, которая создает вектора. Однако в
текущем приложении мы используем вектора исключительно для моделирования
заранее заданных участков компьютерной памяти.} В памяти компьютера
такой доступ можно было бы организовать через адресную арифметику,
сочетая (@newterm{base address}), который указывает на начальное положение вектора
в памяти, с (@newterm{index}), который указывает смещение определенного элемента
вектора.

@comment @subsubheading Representing Lisp data
@subsubheading Представление лисповских данных

С помощью списков можно реализовать пары --- основные объекты данных,
нужные для памяти со списковой структурой. Представим, что память
разделена на два вектора: и @code{the-cdrs}. Списковую структуру мы
будем представлять следующим образом: указатель на пару есть индекс,
указывающий внутрь этих двух векторов. Содержимое элемента
@code{the-cars} с указанным индексом является @code{car} пары, а
содержимое элемента @code{the-cdrs} с тем же индексом является
@code{cdr} пары. Кроме того, нам нужно представление для объектов помимо
пар (например, чисел и символов) и способ отличать один тип данных от
другого. Есть много способов этого добиться, но все они сводятся к
использованию (@newterm{typed pointers}) --- то есть понятие <<указатель>>
расширяется и включает в себя тип данных.@footnote{Это в точности
понятие <<помеченных данных>>, которое мы ввели в главе @ref{Глава 2}
для работы с обобщенными операциями. Однако здесь типы данных вводятся
на элементарном машинном уровне, а не конструируются через списки.}
Тип данных позволяет системе отличить указатель на пару (который состоит
из метки типа данных <<пара>> и индекса в вектора памяти) от указателей
на другие типы данных (которые состоят из метки какого-то другого типа и
того, что используется для представления значений этого типа). Два
объекта данных считаются равными (@code{eq?}), если равны указатели на
них.@footnote{Информация о типе может быть представлена различными
способами, в зависимости от деталей машины, на которой реализована
Лисп-система. Эффективность выполнения Лисп-программ будет сильно
зависеть от того, насколько разумно сделан этот выбор, однако правила
проектирования, определяющие, какой выбор хорош, сформулировать трудно.
Самый простой способ реализации типизированных указателей состоит в
том, чтобы в каждом указателе выделить несколько бит как (@newterm{type field})
(или (type tag)) которое кодирует тип. При этом требуется решить
следующие важные вопросы: сколько требуется битов для поля типа? Как
велики должны быть индексы векторов? Насколько эффективно можно
использовать элементарные команды машины для работы с полями типа в
указателях? Про машины, в которых имеется специальная аппаратура для
эффективной обработки полей типа, говорят, что они обладают (tagged
architecture).} На рисунке @ref{Рисунок 5.14} показано, как с
помощью этого метода представляется список @code{((1 2) 3 4)}, а также
дана его стрелочная диаграмма. Информацию о типах мы обозначаем через
буквенные префиксы. Например, указатель на пару с индексом 5
обозначается @code{p5}, пустой список обозначается @code{e0}, а
указатель на число 4 обозначается @code{n4}. На стрелочной диаграмме
мы в левом нижнем углу каждой пары ставим индекс вектора, который
показывает, где хранятся @code{car} и @code{cdr} пары. Пустые клетки в
@code{the-cars} и @code{the-cdrs} могут содержать части других структур
(которые нам сейчас неинтересны).

Указатель на число, например @code{n4}, может состоять из метки,
указывающей, что это число, и собственно представления числа
4.@footnote{Решение о представлении чисел определяет, можно ли сравнивать
числа через @code{eq?}, который проверяет одинаковость указателей. Если
указатель содержит само число, то равные числа будут иметь одинаковые
указатели. Однако если в указателе содержится индекс ячейки, в которой
хранится само число, то у равных чисел будут одинаковые указатели
только в том случае, если нам удастся никогда не хранить одно и то же
число в двух местах.} Для того, чтобы работать с числами, не
умещающимися в ограниченном объеме, отводимом под указатель, может
иметься особый тип данных (@newterm{bignum}), для которого указатель обозначает
список, где хранятся части числа.@footnote{Это представление очень похоже
на запись числа в виде последовательности цифр, только каждая <<цифра>>
является числом между 0 и максимальным значением, которое можно
уместить в указателе.}

@float
@quotation
@anchor{Рисунок 5.14}
@ifinfo
@strong{Рисунок 5.14:} Box-and-pointer and memory-vector representations of the list @code{((1 2) 3 4)}.

@example
               +---+---+               +---+---+    +---+---+
((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
               +-|-+---+               +-|-+---+    +-|-+---+
              1  |                    2  |         4  |
                 V                       V            V
               +---+---+    +---+---+  +---+        +---+
               | * | *-+--->| * | / |  | 3 |        | 4 |
               +-|-+---+    +-|-+---+  +---+        +---+
              5  |         7  |
                 V            V
               +---+        +---+
               | 1 |        | 2 |
               +---+        +---+

   Index   0    1    2    3    4    5    6    7    8    ...
         +----+----+----+----+----+----+----+----+----+----
the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
         +----+----+----+----+----+----+----+----+----+----
the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
         +----+----+----+----+----+----+----+----+----+----
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap5/Fig5.14a,91mm,,,.pdf}
@sp 0.6
@caption{@strong{Рисунок 5.14:} Box-and-pointer and memory-vector representations of the list @code{((1 2) 3 4)}.}
@sp 0.9
@end iftex
@end quotation
@end float

Символ можно представить как типизированный указатель, обозначающий
последовательность знаков, из которых состоит печатное представление
символа. Эта последовательность создается процедурой чтения Лиспа, когда
строка-представление в первый раз встречается при вводе. Поскольку мы
хотим, чтобы два экземпляра символа всегда были <<одинаковы>> в смысле
@code{eq?}, а @code{eq?} должно быть простым сравнением указателей, нам
нужно обеспечить, чтобы процедура чтения, когда она видит ту же строку
второй раз, использовала тот же самый указатель (к той же
последовательности знаков) для представления обоих вхождений символа.
Ради этого процедура чтения содержит таблицу, которая по традиции
называется (obarray), и в ней хранит все когда-либо встреченные
символы. Когда процедура видит строку и готова создать символ, она
проверяет в обмассиве, не было ли уже ранее такой же строки. Если нет,
она строит новый символ со встретившейся строкой в качестве имени
(типизированный указатель на последовательность знаков) и включает
его в обмассив. Если же процедура уже встречала указанную строку, она
возвращает указатель на символ, хранимый в обмассиве. Процесс замены
строк печатных знаков указателями без повторения называется (@newterm{interning})
символов.

@comment @subsubheading Implementing the primitive list operations
@subsubheading Реализация элементарных списковых операций

Имея вышеописанную схему представления, можно заменить каждую
<<элементарную>> списковую операцию регистровой машины одной или более
элементарной векторной операцией. Мы будем обозначать векторы памяти
двумя регистрами и @code{the-cdrs}, и предположим, что операции
@code{vector-ref} и @code{vector-set!} даны как элементарные. Кроме
того, предположим, что численные операции с указателями (добавление
единицы, индексирование вектора с помощью указателя на пару и сложение
чисел) используют только индексную часть типизированного указателя.

Например, можно заставить регистровую машину поддерживать команды

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op car) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op cdr) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
если мы реализуем их, соответственно, как

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op vector-ref) (reg the-cars) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op vector-ref) (reg the-cdrs) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
Команды

@lisp
(perform (op set-car!) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform (op set-cdr!) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
реализуются как

@lisp
(perform
 (op vector-set!) (reg the-cars) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform
 (op vector-set!) (reg the-cdrs) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
При выполнении @code{cons} выделяется неиспользуемый индекс, и аргументы
@code{cons} записываются в @code{the-cars} и @code{the-cdrs} в ячейках
с выделенным индексом. Мы предполагаем, что имеется особый регистр
@code{free}, в котором всегда содержится указатель на следующую
свободную пару, и что мы можем его увеличить и получить следующую
свободную ячейку.@footnote{Имеются и другие способы поиска свободной
памяти. Например, можно было бы связать все неиспользуемые пары в (free
list). Наши свободные ячейки идут подряд, поскольку мы пользуемся
сжимающим сборщиком мусора, как будет описано в разделе @ref{5.3.2}.}
Например, команда

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op cons) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{3}}\rangle}))
@end lisp

@noindent
реализуется как следующая последовательность векторных
операций:@footnote{В сущности, это реализация @code{cons} через
@code{set-car!} и @code{set-cdr!}, как описано в разделе @ref{3.3.1}.
Операция @code{get-new-pair}, которая там используется, здесь
реализуется через указатель @code{free}.}

@lisp
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg @math{\langle}@var{reg}@math{_{\mono{3}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (reg free))
(assign free (op +) (reg free) (const 1))
@end lisp

@noindent
Операция @code{eq?}

@lisp
(op eq?) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
попросту проверяет равенство всех полей регистров, а предикаты вроде
@code{pair?}, @code{null?}, @code{symbol?} и @code{number?} смотрят
только на поле типа.

@comment @subsubheading Implementing stacks
@subsubheading Реализация стеков

Хотя наши регистровые машины используют стеки, нам ничего специально
здесь делать не надо, поскольку стеки можно смоделировать на основе
списков. Стек может быть списком сохраненных значений, на которые
указывает особый регистр @code{the-stack}. Таким образом,
@code{(save @math{\langle}@var{reg}@math{\rangle})} может реализовываться как

@lisp
(assign the-stack (op cons) (reg @math{\langle}@var{reg}@math{\rangle}) (reg the-stack))
@end lisp

@noindent
Подобным образом,  @code{(restore @math{\langle}@var{reg}@math{\rangle})}
можно реализовать как

@lisp
(assign @math{\langle}@var{reg}@math{\rangle} (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
@end lisp

@noindent
а @code{(perform (op initialize-stack))} реализуется как

@lisp
(assign the-stack (const ()))
@end lisp

@noindent
Все эти операции можно далее расшифровать в терминах векторных
операций, как показано выше. Однако в традиционных компьютерных
архитектурах обычно удобно выделять стек в виде отдельного вектора. В
таком случае сохранение на стеке и снятие с него реализуются через
увеличение и уменьшение индекса, указывающего в этот вектор.

@quotation
@strong{@anchor{Упражнение 5.20}Упражнение 5.20:} Нарисуйте стрелочную диаграмму и представление в виде
вектора (как на рисунке @ref{Рисунок 5.14}) списка, который порождается кодом

@lisp
(define x (cons 1 2))
(define y (list x x))
@end lisp

если вначале указатель @code{free} равен @code{p1}. Чему равно значение
@code{free} после исполнения кода? Какие указатели представляют значения
@code{x} и @code{y}?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.21}Упражнение 5.21:} Реализуйте регистровые машины для следующих процедур.
Считайте, что операции с памятью, реализующие списковую структуру,
имеются в машине как примитивы.

@enumerate a.

@item
Рекурсивная @code{count-leaves}:

@lisp
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
@end lisp

@item
Рекурсивная @code{count-leaves} с явным счетчиком:

@lisp
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
@end lisp
@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.22}Упражнение 5.22:} В упражнении @ref{Упражнение 3.12} из
раздела @ref{3.3.1} были
представлены процедура @code{append}, которая добавляет два списка друг
к другу и получает третий, и процедура @code{append!}, которая склеивает
два списка вместе. Спроектируйте регистровые машины, которые реализуют
каждую из этих процедур. Предполагайте, что операции с памятью,
реализующие списковую структуру, являются примитивами.
@end quotation

@comment @subsection Maintaining the Illusion of Infinite Memory
@subsection Иллюзия бесконечной памяти
@node	5.3.2,  , 5.3.1, 5.3

Метод представления, намеченный в разделе @ref{5.3.1}, решает задачу реализации
списковой структуры при условии, что у нас бесконечное количество
памяти. В настоящем компьютере у нас в конце концов кончится свободное
место, где можно строить новые пары.@footnote{На самом деле и это может
быть неправдой, поскольку размеры памяти могут стать настолько большими,
что свободная память просто не успеет исчерпаться за время жизни
компьютера. Например, в году примерно @math{3\cdot10^{13}} секунд,
так что если мы будем вызывать @code{cons} один раз в микросекунду, и у
нас будет примерно @math{10^{15}} ячеек памяти, то мы построим машину,
которая сможет работать 30 лет, пока память не кончится. По теперешним
понятиям такое количество памяти кажется абсурдно большим, однако
физически оно вполне возможно. С другой стороны, процессоры становятся
быстрее, и может быть, что в компьютерах будущего будет по многу
процессоров, работающих параллельно в единой памяти, так что память
можно будет расходовать намного быстрее, чем мы сейчас предполагаем.}
Однако большинство пар, порождаемых во время типичного вычисления,
используются только для хранения промежуточных результатов. После того,
как эти результаты обработаны, пары больше не нужны --- они становятся
(@newterm{garbage}). Например, при выполнении


@lisp
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
@end lisp

создается два списка: перечисление и результат его фильтрации. После
того, как проводится накопление, эти списки больше не нужны, и
выделенную под них память можно освободить. Если нам удастся
периодически собирать весь мусор, и память будет таким образом
освобождаться приблизительно с той же скоростью, с которой мы строим
новые пары, мы сможем поддерживать иллюзию, что у нас бесконечное
количество памяти.

Для того, чтобы освобождать пары, нужен способ определять, какие из
выделенных пар больше не нужны (в том смысле, что их содержимое не может
уже повлиять на будущее вычисления). Метод, с помощью которого мы этого
добиваемся, называется (@newterm{garbage collection}). Сборка мусора основана на
наблюдении, что в каждый момент при интерпретации Лисп-программы на
будущую судьбу вычисления могут повлиять только те объекты, до которых
можно добраться с помощью какой-нибудь последовательности операций
@code{car} и @code{cdr}, начиная с указателей, хранимых в этот момент в
регистрах машины.@footnote{Здесь мы предполагаем, что стек
представляется в виде списка, как описано в
разделе @ref{5.3.1}, так что элементы стека доступны
через указатель, хранящейся в стековом регистре.} Любую ячейку памяти,
до которой так добраться нельзя, можно освободить.

Есть множество способов сборки мусора. Метод, который мы опишем здесь,
называется @emph{остановка с копированием} (@newterm{stop-and-copy}). Основная
идея состоит в том, чтобы разделить память на две половины: <<рабочую
память>> и <<свободную память>>. Когда @code{cons} строит пары, он это
делает в рабочей памяти. Когда рабочая память заполняется, проводится
сборка мусора: мы отыскиваем все используемые пары в рабочей памяти и
копируем их в последовательные ячейки свободной памяти. (Используемые
пары ищутся просмотром всех указателей @code{car} и @code{cdr}, начиная
с машинных регистров.) Поскольку мусор мы не копируем, предполагается,
что при этом появится дополнительная свободная память, где можно
выделять новые пары. Кроме того, в рабочей памяти не осталось ничего
нужного, поскольку все полезные пары из нее скопированы в свободную
память. Таким образом, если мы поменяем роли рабочей и свободной памяти,
мы можем продолжить работу; новые пары будут выделяться в новой рабочей
памяти (бывшей свободной). Когда она заполнится, мы можем скопировать
используемые пары из нее в новую свободную память (старую
рабочую).@footnote{Эта идея была придумана и впервые реализована Минским,
как часть реализации Лиспа для машины PDP-1 в Исследовательской
лаборатории Электроники в MIT. Ее дополнили Феничель и Йохельсон
(Fenichel and Yochelson 1969) для реализации Лиспа в системе разделения
времени Multics. Позднее Бейкер (Baker 1978) разработал версию для
<<реального времени>>, в которой не требуется останавливать вычисления
на время сборки. Идею Бейкера расширили Хьюитт, Либерман и Мун
(Lieberman and Hewitt 1983), использовав то, что часть структуры более
подвижна, а часть более постоянна.

Второй часто используемый метод сборки мусора --- это (mark-sweep). Он
состоит в том, что все структуры, доступные из машинных регистров,
просматриваются и помечаются. Затем вся память просматривается, и всякий
непомеченный участок <<вычищается>> как мусор и объявляется свободным.
Полное обсуждение метода пометки с очисткой можно найти в Allen 1978.

В системах с большой памятью, как правило, используется алгоритм
Минского-Феничеля-Йохельсона, поскольку он просматривает только
используемую часть памяти. Напротив, при методе пометки с очисткой фаза
очистки должна проверять всю память. Второе преимущество остановки с
копированием состоит в том, что это (compacting) сборщик мусора. Это
означает, что в конце фазы сборки мусора все используемые данные
оказываются в последовательной области памяти, а весь мусор <<выжат>>.
На машинах с виртуальной памятью это может давать весьма большой выигрыш
в производительности, поскольку доступ к сильно различающимся адресам в
памяти может приводить к дополнительной подкачке страниц.}

@comment @subsubheading Implementation of a stop-and-copy garbage collector
@subsubheading Реализация сборщика мусора методом остановки с копированием

Теперь мы можем с помощью языка регистровых машин описать алгоритм
остановки с копированием более подробно. Предположим, что имеется
регистр @code{root}, и в нем хранится указатель на корневой объект ---
структуру, которая (через перенаправления) указывает на все доступные
данные. Такой конфигурации можно добиться, если переместить содержимое
всех регистров машины в заранее выделенный список, на который и будет
указывать @code{root}, непосредственно перед запуском сборщика
мусора@footnote{Этот список регистров не включает в себя регистры,
которые используются подсистемой выделения памяти --- @code{root},
@code{the-cars}, @code{the-cdrs} и еще несколько регистров, которые
будут введены в этом разделе.}. Кроме того, мы предполагаем, что помимо
текущей рабочей памяти имеется свободная память, в которую мы можем
копировать используемые данные. Текущая рабочая память состоит из
векторов, базовые адреса которых хранятся в регистрах @code{the-cars} и
@code{the-cdrs}, а свободная память доступна через регистры
@code{new-cars} и @code{new-cdrs}.

Сборка мусора запускается, когда кончаются свободные ячейки в текущей
рабочей памяти, то есть когда операция @code{cons} пытается сдвинуть
указатель @code{free} за пределы вектора памяти. По завершении сборки
мусора указатель @code{root} будет указывать на новую память, все
объекты, доступные через @code{root}, будут перемещены в новую
память, а указатель @code{free} будет указывать на место в новой
памяти, начиная с которого можно выделять новые пары. Кроме того,
поменяются местами роли рабочей памяти и свободной памяти --- новые
пары будут выделяться в новой памяти, начиная с места, на которое
показывает @code{free}, а (предыдущая) рабочая память будет доступна в
качестве новой памяти для следующей сборки мусора. На
рисунке @ref{Рисунок 5.15} показано устройство памяти непосредственно
перед сборкой мусора и сразу после нее.

@float[tp]
@anchor{Рисунок 5.15}
@ifinfo
@quotation
@strong{Рисунок 5.15:} Reconfiguration of memory by the garbage-collection process.

@example
             Just before garbage collection

         +------------------------------------+
the-cars |                                    | working
         | mixture of useful data and garbage | memory
the-cdrs |                                    |
         +------------------------------------+
                                            ^
                                            | free

         +------------------------------------+
new-cars |                                    | free
         |            free memory             | memory
new-cdrs |                                    |
         +------------------------------------+

             Just after garbage collection

         +------------------------------------+
new-cars |                                    | new
         |          discarded memory          | free
new-cdrs |                                    | memory
         +------------------------------------+

         +------------------+-----------------+
the-cars |                  |                 | new
         |   useful data    |    free area    | working
the-cdrs |                  |                 | memory
         +------------------+-----------------+
                              ^
                              | free
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap5/Fig5.15a,91mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 5.15:} Reconfiguration of memory by the garbage-collection process.}
@sp 0.0
@end iftex
@end float

Состояние процесса сборки мусора управляется содержимым двух регистров:
@code{free} и @code{scan}. Оба они сначала указывают на начало новой
памяти. При запуске алгоритма пара, на которую указывает @code{root},
переносится в начало новой памяти. Пара копируется, регистр @code{root}
переставляется в новое место, а указатель @code{free} увеличивается на
единицу. В дополнение к этому в старом месте, где хранилась пара,
делается пометка, которая говорит, что содержимое перенесено. Отметка
делается так: в позицию @code{car} мы помещаем особое значение,
показывающее, что объект перемещен. (По традиции, такой объект
называется (@newterm{broken heart}).)@footnote{Термин @emph{разбитое сердце}
придумал Дэвид Кресси, когда он писал сборщик мусора для MDL, диалекта
Лиспа, разработанного в MIT в начале 70-х годов.} В позицию @code{cdr}
мы помещаем (@newterm{forwarding address}), который указывает на место, куда
перемещен объект.

После того, как перемещен корневой объект, сборщик мусора входит в
основной цикл. На каждом шаге алгоритма регистр @code{scan} (вначале он
указывает на перемещенный корневой объект) содержит адрес пары, которая
сама перемещена в новую память, но @code{car} и @code{cdr} которой
по-прежнему указывают на объекты в старой памяти. Каждый из этих
объектов перемещается, а затем регистр @code{scan} увеличивается на
единицу. При перемещении объекта (например, того, на который указывает
@code{car} сканируемой пары) мы прежде всего проверяем, не перемещен ли
он уже (об этом нам говорит разбитое сердце в позиции @code{car}
объекта). Если объект еще не перемещен, мы переносим его в место, на
которое указывает @code{free}, увеличиваем @code{free}, записываем
разбитое сердце по старому местоположению объекта, и обновляем указатель
на объект (в нашем случае, @code{car} пары, которую мы сканируем) так,
чтобы он показывал на новое место. Если же объект уже был перемещен, то
его перенаправляющий адрес (он находится в позиции @code{cdr} разбитого
сердца) подставляется на место указателя в сканируемой паре. В конце
концов все доступные объекты окажутся перемещены и просканированы. В
этот момент указатель @code{scan} догонит указатель @code{free}, и
процесс завершится.

Алгоритм остановки с копированием можно описать как последовательность
команд регистровой машины. Базовый шаг, состоящий в перемещении объекта,
проделывается подпрограммой @code{relocate-old-result-in-new}. Эта
подпрограмма принимает свой аргумент, указатель на объект, подлежащий
перемещению, в регистре @code{old}. Она перемещает данный объект (по
пути обновляя @code{free}), помещает указатель на перемещенный объект в
регистр @code{new}, и возвращается, переходя на точку входа, хранимую в
регистре @code{relocate-continue}. В начале процесса сборки мы с помощью
этой подпрограммы перемещаем указатель @code{root}, после инициализации
@code{free} и @code{scan}. Когда @code{root} перемещен, мы записываем
новый указатель в регистр @code{root} и входим в основной цикл
сборщика мусора.

@lisp
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
@end lisp

@noindent
В основном цикле сборщика мусора нам нужно определить, есть ли еще
подлежащие сканированию объекты. Для этого мы проверяем, совпадает ли
указатель @code{scan} с указателем @code{free}. Если указатели равны,
значит, все доступные объекты перемещены, и мы переходим на
@code{gc-flip}. По этому адресу расположены восстановительные действия,
после которых можно продолжить прерванные вычисления. Если же еще есть
пары, которые требуется просканировать, мы зовем подпрограмму
перемещения для @code{car} следующей пары (при вызове мы помещаем
указатель @code{car} в регистр @code{old}). Регистр
@code{relocate-continue} устанавливается таким образом, чтобы при
возврате мы могли обновить указатель @code{car}.

@lisp
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
@end lisp

На метке @code{update-car} мы изменяем указатель @code{car} сканируемой
пары. После этого мы перемещаем ее @code{cdr}, а затем возвращаемся на
метку @code{update-cdr}. Наконец, когда @code{cdr} перемещен и обновлен,
сканирование пары закончено, и мы продолжаем главный цикл.

@lisp
update-car
  (perform (op vector-set!)
           (reg new-cars)
           (reg scan)
           (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))
update-cdr
  (perform (op vector-set!)
           (reg new-cdrs)
           (reg scan)
           (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
@end lisp

@noindent
Подпрограмма @code{relocate-old-result-in-new} перемещает объекты
следующим образом: если перемещаемый объект (на него указывает
@code{old}) не является парой, мы возвращаем указатель на него
неизменным (в регистре @code{new}). (К примеру, мы можем сканировать
пару, в @code{car} которой находится число 4. Если значение в
@code{car} представляется как @code{n4}, как описано в
разделе @ref{5.3.1}, то нам нужно, чтобы
<<перемещенный>> @code{car} по-прежнему равнялся @code{n4}.) В противном
случае требуется произвести перемещение. Если позиция @code{car}
перемещаемой пары содержит метку разбитого сердца, значит, сама пара уже
перенесена, и нам остается только взять перенаправляющий адрес (из
позиции @code{cdr} разбитого сердца) и вернуть его в регистре
@code{new}. Если же регистр @code{old} указывает на еще пе перенесенную
пару, то мы ее переносим в первую пустую ячейку новой памяти (на нее
указывает @code{free}), а затем строим разбитое сердце, записывая в
старой ячейке метку разбитого сердца и перенаправляющий адрес. Процедура
@code{relocate-old-result-in-new} хранит @code{car} или @code{cdr}
объекта, на который указывает @code{old}, в регистре
@code{oldcr}.@footnote{Сборщик мусора использует низкоуровневый предикат
@code{pointer-to-pair?} вместо обыкновенного @code{pair?}, поскольку в
настоящей системе могут иметься различные объекты, которые с точки
зрения сборщика будут являться парами. Например, в системе, которая
соответствует стандарту Scheme IEEE, объект-процедура может
реализовываться особого рода <<парой>>, которая не удовлетворяет
предикату @code{pair?}. В нашем имитаторе можно реализовать
@code{pointer-to-pair?} как @code{pair?}.}

@lisp
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) @r{; новое место для пары }
  @r{;; Обновить указатель @code{free} }
  (assign free (op +) (reg free) (const 1))
  @r{;; Скопировать @code{car} и @code{cdr} в новую память }
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  @r{;; Построить разбитое сердце }
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
@end lisp

В самом конце процесса сборки мусора мы меняем ролями старую и новую
память, обменивая указатели: @code{cars} меняется с @code{new-cars}, а
@code{cdrs} с @code{new-cdrs}. Теперь мы готовы запустить следующую
сборку, когда память опять кончится.

@lisp
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
@end lisp

@comment @section The Explicit-Control Evaluator
@section Вычислитель с явным управлением
@node	5.4, 5.5, 5.3, Chapter 5

В разделе @ref{5.1} мы видели, как простые
программы на Scheme можно преобразовывать в описания регистровых машин.
Теперь мы проделаем такое преобразование с более сложной программой ---
метациклическим интерпретатором из разделов @ref{4.1.1}--@ref{4.1.4},
который показал нам, как поведение процедур Scheme можно описать через
процедуры @code{eval} и @code{apply}. (explicit-control evaluator),
который мы разработаем в этом разделе, демонстрирует, как механизмы
вызова процедур и передачи параметров, используемые в процессе
вычисления, могут быть описаны в терминах действий, производимых над
регистрами и стеками. В дополнение к этому вычислитель с явным
управлением может служить реализацией интерпретатора Scheme, написанной
на языке, весьма близком к машинному языку обыкновенных компьютеров.
Этот вычислитель можно выполнить на имитаторе регистровых машин из
раздела @ref{5.2}. С другой стороны, его
можно использовать как основу для построения вычислителя Scheme,
написанного на машинном языке, или даже специализированной машины для
вычисления выражений на Scheme. На рисунке @ref{Рисунок 5.16}
показана такая аппаратная реализация: кремниевый чип, который работает
как вычислитель Scheme. Проектировщики чипа начали с описания путей
данных и контроллера, подобного вычислителю из этого раздела, а затем с
помощью программ автоматизированного проектирования построили разводку
интегральной микросхемы.@footnote{Информацию о микросхеме и методе ее
проектирования можно найти в Batali et al. 1982.}

@float
@quotation
@anchor{Рисунок 5.16}
@ifinfo
@strong{Рисунок 5.16:} A silicon-chip implementation of an evaluator for Scheme.

[A photograph of chip layout]

@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap5/chip,91mm,,,.jpg}
@sp 0.6
@caption{@strong{Рисунок 5.16:} A silicon-chip implementation of an evaluator for Scheme.}
@sp 0.6
@end iftex
@end quotation
@end float

@comment @subsubheading Registers and operations
@subsubheading Регистры и операции

При проектировании вычислителя с явным управлением требуется указать
операции, которые будут использоваться в нашей регистровой машине.
Метациклический интерпретатор мы описали, используя абстрактный
синтаксис, с процедурами вроде @code{quoted?} и @code{make-procedure}.
При реализации регистровой машины мы могли бы развернуть эти процедуры в
последовательности элементарных операций с памятью, работающих со
списковой структурой, и уже эти операции реализовать в нашей
регистровой машине. Однако при этом вычислитель получился бы слишком
длинным, а его структура была бы загромождена мелкими деталями. Для
большей ясности представления мы будем считать элементарными операциями
регистровой машины синтаксические процедуры из раздела @ref{4.1.2}, а
также процедуры для представления окружений и прочих данных
интерпретатора из разделов @ref{4.1.3} и @ref{4.1.4}.
Для того, чтобы полностью описать вычислитель, который можно было бы
запрограммировать на машинном языке низкого уровня или реализовать
аппаратно, пришлось бы заменить эти операции более примитивными на
основе реализации списковой структуры, которую мы описали в
разделе @ref{5.3}.

Наша регистровая машина-вычислитель Scheme имеет стек и семь регистров:
@code{exp}, @code{env}, @code{val}, @code{continue}, @code{proc},
@code{argl} и @code{unev}. В регистре @code{exp} хранится выражение,
подлежащее вычислению, а в регистре @code{env} окружение, в котором
нужно это вычисление произвести. В конце вычисления @code{val} содержит
значение, полученное при вычислении выражения в указанном окружении.
Регистр @code{continue} используется для реализации рекурсии, как
описано в разделе @ref{5.1.4}.
(Вычислитель вызывает сам себя рекурсивно, поскольку вычисление
выражения требует вычисления его подвыражений.) Регистры @code{proc},
@code{argl} и @code{unev} используются при работе с комбинациями.

Мы не будем ни рисовать диаграмму путей данных, показывающую, как
связаны между собой регистры и операции, ни давать полный список
машинных операций. Эти данные можно получить из текста контроллера,
который будет представлен полностью.

@menu
* 5-4-1::            Ядро вычислителя с явным управлением
* 5-4-2::            Вычисление последовательностей и хвостовая рекурсия
* 5-4-3::            Условные выражения присваивания и определения
* 5-4-4::            Запуск вычислителя
@end menu

@comment @subsection The Core of the Explicit-Control Evaluator
@subsection Ядро вычислителя с явным управлением
@node	5.4.1, 5.4.2, 5.4, 5.4

Центральным элементом вычислителя является последовательность команд,
расположенная по метке @code{eval-dispatch}. Она соответствует процедуре
@code{eval} метациклического интерпретатора из раздела @ref{4.1.1}.
Начиная с @code{eval-dispatch}, контроллер вычисляет выражение,
хранящееся в @code{exp}, в окружении, которое содержится в @code{env}.
Когда вычисление заканчивается, контроллер переходит на точку входа,
которая хранится в @code{continue}, а значение выражения при этом
находится в @code{val}. Как и в метациклическом @code{eval}, структура
@code{eval-dispatch} представляет собой анализ случаев по
синтаксическому типу выполняемого выражения@footnote{В нашем контроллере
анализ случаев написан как последовательность команд @code{test} и
@code{branch}. Можно было бы написать его и в стиле программирования,
управляемого данными (в реальной системе так, скорее всего, и было бы
сделано). При этом исчезла бы необходимость проводить последовательные
проверки, и легче было бы определять новые типы выражений. Машина,
рассчитанная на выполнение Лисп-программ, скорее всего, имела бы команду
@code{dispatch-on-type}, которая бы эффективно выполняла выбор,
управляемый данными.}.

@lisp
eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
@end lisp

@comment @subsubheading Evaluating simple expressions
@subsubheading Вычисление простых выражений

В числах и строках (значением которых являются они сами), переменных,
закавыченных выражениях и выражениях @code{lambda} не содержится
подлежащих вычислению подвыражений. В этих случаях вычислитель попросту
помещает нужное значение в регистр @code{val} и продолжает работу с
точки, указанной в регистре @code{continue}. Вычисление простых
выражений производится следующим кодом контроллера:

@lisp
ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
  (goto (reg continue))
@end lisp

@noindent
Обратите внимание, как @code{ev-lambda} пользуется регистрами
@code{unev} и @code{exp} для параметров и тела лямбда-выражения, которые
наряду с окружением в регистре @code{env} требуется передать операции
@code{make-procedure}.

@comment @subsubheading Evaluating procedure applications
@subsubheading Вычисление вызовов процедур

Вызов процедуры описывается комбинацией, состоящей из оператора и
операндов. Оператор --- подвыражение, значением которого является
процедура, а операнды --- подвыражения, значения которых являются
аргументами, к которым процедуру следует применить. Метациклический
@code{eval} при обработке вызовов зовет себя рекурсивно и вычисляет
таким образом все элементы комбинации, а затем передает результаты в
@code{apply}, которая и осуществляет собственно применение процедуры.
Вычислитель с явным управлением ведет себя точно так же; рекурсивные
вызовы осуществляются командами @code{goto}, и при этом на стеке
сохраняются регистры, значения которых нужно восстановить после возврата
из рекурсивного вызова. Перед каждым вызовом мы тщательно смотрим, какие
именно регистры требуется сохранить (поскольку их значения потребуются
позже).@footnote{Это важная, но сложная деталь при переводе алгоритмов из
процедурного языка типа Лиспа на язык регистровой машины. В качестве
альтернативы сохранению только нужных регистров мы могли бы сохранять их
все (кроме @code{val}) перед каждым рекурсивным вызовом. Такая тактика
называется (framed-stack discipline). Она работает, но при этом
сохраняется больше регистров, чем нужно; в системе, где стековые
операции дороги, это может оказаться важным. Кроме того, сохранение
регистров, с ненужными значениями может привести к удлиннению жизни
бесполезных данных, которые в противном случае освободились бы при
сборке мусора.}

В начале обработки процедурного вызова мы вычисляем оператор и получаем
процедуру, которую позже надо будет применить к вычисленным операндам.
Для того, чтобы вычислить оператор, мы переносим его в регистр
@code{exp} и переходим на @code{eval-dispatch}. В регистре @code{env}
уже находится то окружение, в котором оператор требуется вычислить.
Однако мы сохраняем @code{env}, поскольку его значение нам еще
потребуется для вычисления операндов. Кроме того, мы переносим
операнды в регистр @code{unev} и сохраняем его на стеке. Регистр
@code{continue} мы устанавливаем так, чтобы после вычисления оператора
работа продолжилась с @code{ev-appl-did-operator}. Однако перед этим мы
сохраняем старое значение @code{continue}, поскольку оно говорит нам,
куда требуется перейти после вычисления вызова.

\enlargethispage{\baselineskip}

@lisp
ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
@end lisp

После того, как вычислено значение подвыражения-оператора, мы вычисляем
операнды комбинации и собираем их значения в список, хранимый в
регистре @code{argl}. Прежде всего мы восстанавливаем невычисленные
операнды и окружение. Мы заносим пустой список в @code{argl} как
начальное значение. Затем заносим в регистр @code{proc} процедуру,
порожденную при вычислении оператора. Если операндов нет, мы напрямую
идем в @code{apply-dispatch}. В противном случае сохраняем @code{proc}
на стеке и запускаем цикл вычисления операндов:@footnote{К процедурам
работы со структурой данных вычислителя из раздела @ref{4.1.3} мы
добавляем следующие процедуры для работы со списками аргументов:

@smalllisp
(define (empty-arglist) '())
(define (adjoin-arg arg arglist) (append arglist (list arg)))
@end smalllisp

Кроме того, мы проверяем, является ли аргумент в комбинации последним,
при помощи дополнительной синтаксической процедуры:

@smalllisp
(define (last-operand? ops)
  (null? (cdr ops)))
@end smalllisp

}

@lisp
ev-appl-did-operator
  (restore unev)                  @r{; операнды }
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))         @r{; оператор }
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
@end lisp

При каждом проходе цикла вычисления аргументов вычисляется один
аргумент, и его значение добавляется к @code{argl}. Для того, чтобы
вычислить операнд, мы помещаем его в регистр @code{exp} и переходим к
@code{eval-dispatch}, установив предварительно @code{continue} так,
чтобы вычисление продолжилось на фазе сбора аргументов. Но еще до этого
мы сохраняем уже собранные аргументы (из @code{argl}), окружение (из
@code{env}) и оставшиеся операнды, подлежащие вычислению (из
@code{unev}). Вычисление последнего операнда считается особым случаем и
обрабатывается кодом по метке @code{ev-appl-last-arg}.

@lisp
ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
@end lisp

@noindent
После того, как аргумент вычислен, его значение подсоединяется в конец
списка, который хранится в @code{argl}. Затем операнд убирается из
списка невычисленных операндов в @code{unev}, и продолжается цикл
вычисления аргументов.

@lisp
ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
@end lisp

Последний аргумент обрабатывается отдельно. Здесь нет необходимости
сохранять окружение и список невычисленных операндов перед переходом в
@code{eval-dispatch}, поскольку после вычисления последнего операнда они
не понадобятся. Поэтому после вычисления мы возвращаемся к метке
@code{ev-appl-accum-last-arg}, где восстанавливается список аргументов,
на него наращивается новый (последний) аргумент, восстанавливается
сохраненная процедура, и, наконец, происходит переход к применению
процедуры.@footnote{Оптимизация при обработке последнего аргумента
известна как (evlis tail recursion) (см. Wand 1980). Можно было бы
особым образом обрабатывать еще и первый аргумент и получить некоторую
дополнительную выгоду. Это позволило бы отложить инициализацию
@code{argl} до того времени, когда будет вычислен первый операнд, и
избежать в этом случае сохранения @code{argl}. Компилятор в
разделе @ref{5.5} проделывает эту оптимизацию. (Сравните с
процедурой @code{construct-arglist} из
раздела @ref{5.5.3}.)}

@lisp
ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
@end lisp

Детали цикла вычисления аргументов определяют порядок, в котором
интерпретатор вычисляет операнды комбинации (то есть справа налево или
слева направо --- см. упражнение @ref{Упражнение 3.8}). Этот порядок
оставался неопределенным в метациклическом интерпретаторе, который
наследует свою управляющую структуру из нижележащей Scheme, на которой
он написан.@footnote{Порядок вычисления операндов в метациклическом
интерпретаторе определяется порядком вычисления аргументов
@code{cons} в процедуре @code{list-of-values} из раздела @ref{4.1.1}
(см. упражнение @ref{Упражнение 4.1}).} Поскольку селектор
@code{first-operand} (который используется в @code{ev-appl-operand-loop}
для последовательного извлечения операндов из @code{unev}) реализован
как @code{car}, а селектор @code{rest-operands} реализуется как
@code{cdr}, вычислитель с явным управлением будет вычислять операнды
комбинации в порядке слева направо.

@comment @subsubheading Procedure application
@subsubheading Применение процедур

Точка входа @code{apply-dispatch} соответствует процедуре @code{apply}
метациклического интерпретатора. К тому времени, когда мы попадаем в
@code{apply-dispatch}, в регистре @code{proc} содержится подлежащая
применению процедура, а в регистре @code{argl} список вычисленных
аргументов, к которым ее требуется применить. Сохраненное значение
@code{continue} (исходно оно передается подпрограмме
@code{eval-dispatch}, а затем сохраняется внутри @code{ev-application}),
которое определяет, куда нам надо вернуться с результатом применения
процедуры, находится на стеке. Когда вызов вычислен, контроллер передает
управление в точку входа, указанную в сохраненном @code{continue}, а
результат при этом хранится в @code{val}. Подобно метациклическому
@code{apply}, нужно рассмотреть два случая. Либо применяемая процедура
является примитивом, либо это составная процедура.

@lisp
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
@end lisp

Мы предполагаем, что все примитивы реализованы так, что они ожидают
аргументы в регистре @code{argl}, а результат возвращают в
@code{val}. Чтобы описать, как машина обрабатывает примитивы, нам
пришлось бы дать последовательность команд, которая реализует каждый
примитив, и заставить @code{primitive-apply} переходить к этим
командам в зависимости от содержимого @code{proc}. Поскольку нас
интересуют не детали примитивов, а структура процесса вычисления, мы
вместо этого будем просто использовать операцию
@code{apply-primitive-procedure}, которая применяет процедуру,
содержащуюся в @code{proc}, к аргументам, содержащимся в @code{argl}.
Чтобы смоделировать вычислитель имитатором из раздела @ref{5.2}, мы используем
процедуру @code{apply-primitive-procedure}, которая исполняет процедуру
с помощью нижележащей Scheme-системы, как мы это делали и в
метациклическом интерпретаторе из раздела @ref{4.1.4}.
После того, как элементарная процедура вычислена, мы восстанавливаем
регистр @code{continue} и переходим на указанную точку входа.

@lisp
primitive-apply  
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
@end lisp

Чтобы применить составную процедуру, мы действуем так же, как и в
метациклическом интерпретаторе. Мы строим кадр, который связывает
параметры процедуры с ее аргументами, расширяем этим кадром окружение,
хранимое в процедуре, и в этом расширенном окружении вычисляем
последовательность выражений, которая представляет собой тело процедуры.
Подпрограмма @code{ev-sequence}, описанная ниже в разделе @ref{5.4.2}, проводит
вычисление последовательности.

@lisp
compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
@end lisp

@noindent
Подпрограмма @code{compound-apply} --- единственное место в
интерпретаторе, где регистру @code{env} присваивается новое значение.
Подобно метациклическому интерпретатору, новое окружение строится из
окружения, хранимого в процедуре, а также списка аргументов и
соответствующего ему списка связываемых переменных.

@subsection Вычисление последовательностей и хвостовая рекурсия

Сегмент кода вычислителя с явным управлением, начинающийся с метки
@code{ev-sequence}, соответствует процедуре @code{eval-sequence}
метациклического интерпретатора. Он обрабатывает последовательности
выражений в телах процедур, а также явные выражения @code{begin}.

Явные выражения @code{begin} обрабатываются так: последовательность
подлежащих выполнению выражений помещается в @code{unev}, регистр
@code{continue} сохраняется на стеке, а затем происходит переход на
@code{ev-sequence}.

@lisp
ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
@end lisp

Неявные последовательности в телах процедур обрабатываются переходом на
@code{ev-sequence} из @code{compound-apply}, причем @code{continue} в
этот момент уже находится на стеке, поскольку он был сохранен в
@code{ev-application}.

Метки @code{ev-sequence} и @code{ev-sequence-continue} образуют цикл,
который по очереди вычисляет все выражения в последовательности. Список
невычисленных пока выражений хранится в @code{unev}. Прежде, чем
вычислять каждое выражение, мы смотрим, есть ли в последовательности
после него еще выражения, подлежащие вычислению. Если да, то мы
сохраняем список невычисленных выражений (из регистра @code{unev}) и
окружение, в котором их надо вычислить (из @code{env}), а затем
вызываем @code{eval-dispatch}, чтобы вычислить выражение. После того,
как вычисление закончено, два сохраненных регистра восстанавливаются на
метке @code{ev-sequence-continue}.

Последнее выражение в последовательности обрабатывается особым образом,
на метке @code{ev-sequence-last-exp}. Поскольку после этого выражения
никаких других вычислять не требуется, не нужно и сохранять @code{unev}
и @code{env} перед переходом на @code{eval-dispatch}. Значение всей
последовательности равно значению последнего выражения, так что после
вычисления последнего выражения требуется только продолжить вычисление
по адресу, который хранится на стеке (помещенный туда из
@code{ev-application} или @code{ev-begin}). Мы не устанавливаем
@code{continue} так, чтобы вернуться в текущее место, восстановить
@code{continue} со стека и продолжить с хранящейся в нем точки входа, а
восстанавливаем @code{continue} со стека перед переходом на
@code{eval-dispatch}, так что после вычисления выражения
@code{eval-dispatch} передаст управление по этому адресу.

@lisp
ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
@end lisp

Хвостовая рекурсия
В
главе @ref{Глава 1}
мы говорили, что процесс, который описывается процедурой вроде

@lisp
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
@end lisp

итеративен. Несмотря на то, что синтаксически процедура рекурсивна
(определена через саму себя), вычислителю нет логической необходимости
сохранять информацию при переходе от одного вызова @code{sqrt-iter} к
другому@footnote{В разделе @ref{5.1} мы
видели, как такие процессы можно реализовывать с помощью регистровой
машины, не имеющей стека; состояние машины хранилось в ограниченном
количестве регистров.}. Про вычислитель, который способен вычислить
процедуру типа @code{sqrt-iter}, не требуя дополнительной памяти по мере
ее рекурсивных вызовов, говорят, что он обладает свойством (tail
recursion). Метациклическая реализация вычислителя из
главы @ref{Глава 4} не
указывает, обладает ли вычислитель хвостовой рекурсией, поскольку он
наследует механизм сохранения состояния из нижележащей Scheme. Однако в
случае вычислителя с явным управлением мы можем проследить процесс
вычисления и увидеть, когда вызовы процедур приводят к росту информации
на стеке.

Наш вычислитель обладает хвостовой рекурсией, поскольку при вычислении
последнего выражения последовательности мы напрямую переходим к
@code{eval-dispatch}, никакую информацию не сохраняя на стеке.
Следовательно, при вычислении последнего выражения
последовательности --- даже если это рекурсивный вызов (как в
@code{sqrt-iter}, где выражение @code{if}, последнего выражения в теле
процедуры, сводится к вызову @code{sqrt-iter}) --- не происходит
никакого роста глубины стека@footnote{Наша реализация хвостовой рекурсии
в @code{ev-sequence} --- вариант хорошо известного метода оптимизации,
используемого во многих компиляторах. При компиляции процедуры, которая
заканчивается вызовом процедуры, можно заменить вызов переходом на
начало вызываемой процедуры. Встраивание такой стратегии в
интерпретатор (как сделано в этом разделе) единым образом
распространяет эту оптимизацию на весь язык.}.

Мы использовали тот факт, что сохранять информацию необязательно. Если
бы мы до этого не додумались, можно было бы реализовать
@code{eval-sequence} так, что все выражения в последовательности
обрабатываются одинаково --- сохранение регистров, вычисление
выражения, возврат с сохранением регистров, и повторение до тех пор,
пока не вычислятся все выражения@footnote{Можно определить
@code{no-more-exps?} как

@lisp
(define (no-more-exps? seq) (null? seq))
@end lisp

}.

@lisp
ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
@end lisp

Может показаться, что это мелкое изменение в предыдущем коде для
выполнения последовательности: единственная разница состоит в том, что
мы проходим через цикл сохранения-восстановления для последнего
выражения последовательности так же, как и для остальных. Интерпретатор
по-прежнему будет возвращать для всех выражений то же самое значение.
Однако такое изменение теряет свойство хвостовой рекурсии, поскольку
теперь после вычисления последнего выражения в последовательности нам
придется возвращаться и отменять (бесполезные) сохранения регистров. Эти
дополнительные сохранения будут накапливаться в гнезде рекурсивных
вызовов. Следовательно, процессы вроде @code{sqrt-iter} потребуют памяти
пропорционально количеству итераций, а не фиксированного объема. Такая
разница может быть существенна. Например, при наличии хвостовой рекурсии
можно выразить бесконечный цикл с помощью одного только механизма вызова
процедур:

@lisp
(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
@end lisp

Без хвостовой рекурсии такая процедура рано или поздно исчерпает место в
стеке, а итерацию придется выражать с помощью какого-то другого
механизма помимо вызовов процедур.

@comment @subsection Conditionals, Assignments, and Definitions
@subsection Условные выражения, присваивания и определения
@node	5.4.3, 5.4.4, 5.4.2, 5.4

Как и в метациклическом интерпретаторе, особые формы обрабатываются
путем частичного выполнения частей выражения. В выражении @code{if} нам
нужно вычислить предикат, а затем на основании его значения решить,
требуется нам выполнять следствие или альтернативу.

Прежде чем вычислять предикат, мы сохраняем само выражение @code{if},
поскольку позже из него потребуется извлекать следствие либо
альтернативу. Кроме того, мы сохраняем окружение, которое потребуется
при вычислении следствия или альтернативы, и @code{continue}, который
потребуется нам при возврате значения выражению, ждущему результата
@code{if}.

@lisp
ev-if
  (save exp)                    @r{; сохраняем выражение}
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  @r{; вычисляем предикат}
@end lisp

Вернувшись после вычисления предиката, мы смотрим, является ли его
значение истиной или ложью, в зависимости от этого переносим в регистр
@code{exp} следствие либо альтернативу, и идем на @code{eval-dispatch}.
Заметим, что после восстановления @code{env} и @code{continue}
@code{eval-dispatch} будет выполняться в правильном окружении и
вернется после вычисления выражения в правильное место.

@lisp
ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
@end lisp

\enlargethispage{\baselineskip}

@comment @subsubheading Assignments and definitions
@subsubheading Присваивания и определения

Присваивания обрабатываются по метке @code{ev-assignment}, на которую
переход происходит из @code{eval-dispatch} с выражением-присваиванием в
регистре @code{exp}. Код @code{ev-assignment} сначала вычисляет значение
присваиваемого выражения, а затем заносит это значение в окружение.
Предполагается, что @code{set-variable-value!} дана как машинная
операция.

@lisp
ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                  @r{; сохранить переменную}
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch)) @r{; вычислить присваиваемое значение}
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
@end lisp

Подобным образом обрабатываются и определения:

@lisp
ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   @r{; сохранить переменную}
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  @r{; вычислить значение переменной}
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
@end lisp

@quotation
@strong{@anchor{Упражнение 5.23}Упражнение 5.23:} Расширьте вычислитель так, чтобы обрабатывались
производные выражения @code{cond}, @code{let} и тому подобные (раздел @ref{4.1.2}).
Можно <<сжульничать>> и считать, что синтаксические трансформации вроде
@code{cond->if} имеются как машинные операции.@footnote{На самом деле это
не жульничество. В настоящей реализации, построенной с нуля, мы бы на
синтаксическом этапе, происходящем раньше собственно выполнения,
интерпретировали при помощи вычислителя с явным управлением
Scheme-программу, которая производит трансформации исходного кода вроде
@code{cond->if}.}
@end quotation

@quotation
@strong{@anchor{Упражнение 5.24}Упражнение 5.24:} Реализуйте @code{cond} как новую особую форму, не сводя
его к @code{if}. Придется организовать цикл, проверяющий предикаты
последовательных ветвей @code{cond}, пока один не окажется истинным, а
затем с помощью @code{ev-sequence} выполнять действия этой ветви.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.25}Упражнение 5.25:} Измените вычислитель так, чтобы он использовал нормальный
порядок вычислений, на основе ленивого интерпретатора из раздела @ref{4.2}.
@end quotation

@comment @subsection Running the Evaluator
@subsection Запуск вычислителя
@node	5.4.4,  , 5.4.3, 5.4

Реализовав вычислитель с явным управлением, мы подходим к концу сюжета,
начатого в главе @ref{Глава 1} ---
построения все более точных моделей для процесса вычисления. Мы начали с
относительно неформальной подстановочной модели, затем в главе @ref{Глава 3}
расширили ее до модели с окружениями, позволившей работать с состоянием
и его изменением. В метациклическом интерпретаторе из главы @ref{Глава 4}
мы, используя как язык саму Scheme, сделали более явной структуру
окружений, которые строятся при вычислении выражения. Теперь, рассмотрев
регистровые машины, мы внимательнее исследовали механизмы вычислителя
для работы с памятью, передачи аргументов и управления. На каждом новом
уровне нам приходилось сталкиваться с вопросами и разрешать неясности,
которые не были заметны при предыдущем, менее строгом описании
вычислений. Для того, чтобы понять поведение вычислителя с явным
управлением, мы можем построить его имитационную модель и рассмотреть ее
работу.

Введем в нашу машину-вычислитель управляющий цикл. Он играет роль
процедуры @code{driver-loop} из раздела @ref{4.1.4}.
Вычислитель будет в цикле печатать подсказку, считывать выражение,
выполнять его с помощью перехода на @code{eval-dispatch}, и печатать
результат. Следующая группа команд стоит в начале последовательности
команд контроллера в вычислителе с явным управлением.@footnote{Мы
предполагаем, что @code{read} и различные операции печати имеются как
элементарные машинные операции. Такое предположение разумно в целях
имитации, но на практике совершенно нереалистично. Эти операции
чрезвычайно сложны. На практике они реализовывались бы с помощью
низкоуровневых операций ввода-вывода, например, посимвольного ввода и
вывода печатных знаков на устройство.

Для поддержки операции @code{get-global-environment} мы определяем

@lisp
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
@end lisp
}

@lisp
read-eval-print-loop 
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
print-result  
  (perform
   (op announce-output) (const ";;; Значение EC-Eval:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
@end lisp

@noindent
Когда мы сталкиваемся с ошибкой (например, с ошибкой <<неизвестный тип
процедуры>> из @code{apply-dispatch}), мы печатаем сообщение об ошибке и
возвращаемся в управляющий цикл.@footnote{Хотелось бы обрабатывать и
другие типы ошибок, но этого не так легко добиться.
См. упражнение @ref{Упражнение 5.30}.}

@lisp
unknown-expression-type 
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
unknown-procedure-type 
  (restore continue)    @r{; очистить стек (после @code{apply-dispatch})}
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
signal-error 
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
@end lisp

Для целей имитации мы каждый раз в начале прохождения управляющего
цикла инициализируем стек, поскольку после того, как ошибка (например,
неопределенная переменная) прерывает вычисление, он может не быть
пуст@footnote{Можно было бы инициализировать стек только после ошибок,
однако если мы это делаем в управляющем цикле, оказывается удобнее
следить за производительностью вычислителя, как это описано ниже.}.

Если мы соберем все фрагменты кода, представленные в разделах @ref{5.4.1}--@ref{5.4.4},
то можно создать модель машины-вычислителя, которая запускается
имитатором регистровых машин из раздела @ref{5.2}.

@lisp
(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
  '(read-eval-print-loop
    @math{\langle}@emph{контроллер машины, как описано выше}@math{\rangle})))
@end lisp

Требуется определить процедуры Scheme, имитирующие операции, которые
считаются элементарными в вычислителе. Это те же операции, которые
использовались в метациклическом интерпретаторе из раздела @ref{4.1},
а также несколько дополнительных, определенных в примечаниях к разделу @ref{5.4}.

@lisp
(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        @math{\langle}@emph{полный список операций машины-вычислителя}@math{\rangle}
@end lisp

Наконец, мы можем проинициализировать глобальное окружение и запустить
вычислитель:

@lisp
(define the-global-environment (setup-environment))
(start eceval)
@i{;;; Ввод EC-Eval:}
(define (append x y)
  (if (null? x) y
      (cons (car x)
            (append (cdr x) y))))
@i{;;; Значение EC-Eval:}
@i{ok}
@i{;;; Ввод EC-Eval:}
(append '(a b c) '(d e f))
@i{;;; Значение EC-Eval:}
@i{(a b c d e f)}
@end lisp

Разумеется, вычисление выражений таким образом занимает намного больше
времени, чем если их вводить напрямую в Scheme, по причине многослойной
имитации. Наши выражения выполняются регистровой машиной-вычислителем с
явным управлением, которая имитируется программой на Scheme, которая, в
свою очередь, выполняется интерпретатором Scheme.

@comment @subsubheading Monitoring the performance of the evaluator
@subsubheading Отслеживание производительности вычислителя

Имитационное моделирование может служить мощным инструментом,
помогающим в реализации вычислителей. С помощью имитации легко можно не
только исследовать варианты построения регистровых машин, но и
отслеживать производительность имитируемого вычислителя. Например, один
из важных параметров производительности состоит в том, насколько
эффективно вычислитель использует стек. Можно отследить количество
стековых операций, которые требуются для вычисления различных выражений,
если взять версию имитатора, которая собирает статистику по
использованию стека (раздел @ref{5.2.4}) и добавить на точку входа
@code{print-result} дополнительную команду, распечатывающую эту статистику:

@lisp
print-result  
  (perform (op print-stack-statistics)) @r{; добавленная команда}
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  @dots{} @r{; как и раньше}
@end lisp

Теперь работа с вычислителем выглядит так:

@lisp
@i{;;; Ввод EC-Eval:}
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
@i{(total-pushes = 3 maximum-depth = 3)}
@i{;;; Значение EC-Eval:}
@i{ok}

@i{;;; Ввод EC-Eval:}
(factorial 5)
@i{(total-pushes = 144 maximum-depth = 28)}
@i{;;; Значение EC-Eval:}
@i{120}
@end lisp

Заметим, что управляющий цикл вычислителя на каждом проходе заново
инициализирует стек, так что печатаемая статистика будет относиться
только к стековым операциям, произведенным при выполнении последнего
выражения.

@quotation
@strong{@anchor{Упражнение 5.26}Упражнение 5.26:} С помощью отслеживания стека исследуйте хвостовую
рекурсию в нашем вычислителе (раздел @ref{5.4.2}). Запустите
вычислитель и определите итеративную процедуру @code{factorial} из
раздела @ref{1.2.1}:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp

Запустите эту процедуру с несколькими небольшими значениями @math{n}.
Для каждого из этих значений запишите максимальную глубину стека и
количество операций сохранения, потребных для вычисления @math{n!}.

@enumerate a.

@item
Вы увидите, что максимальная глубина стека, нужная для вычисления
@math{n!}, от @math{n} не зависит. Какова эта глубина?

@item
Составьте на основе своих данных формулу в зависимости от @math{n} числа
операций сохранения, необходимых для вычисления @math{n!} для любого
@math{n \ge 1}. Обратите внимание, что число операций --- линейная
функция от @math{n} и, следовательно, определяется двумя константами.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.27}Упражнение 5.27:} Для сравнения с упражнением @ref{Упражнение 5.26},
изучите поведение следующей процедуры для рекурсивного вычисления
факториала:

@lisp
(define (factorial n)
  (if (= n 1) 1
      (* (factorial (- n 1)) n)))
@end lisp

Запуская эту процедуру и отслеживая поведение стека, определите как
функции от @math{n} максимальную глубину стека и общее число сохранений,
требуемых для вычисления @math{n!}, при @math{n \ge
1}. (Эти функции также будут линейны.) Опишите общие результаты
экспериментов, записав в следующую таблицу соответствующие выражения
как формулы, зависящие от @math{n}:
@ifinfo

@example
               Maximum depth       Number of pushes

Recursive
factorial

Iterative
factorial
@end example

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut 	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil \cr

				& Maximum depth & Number of pushes \cr
	\noalign{\hrule}
	Recursive 		&  		&  \cr
	factorial 		&  		&  \cr
	\noalign{\hrule}
	Iterative 		&  		&  \cr
	factorial 		&  		&  \cr
}
}$$
@end tex
Максимальная глубина служит мерой объема памяти, используемой
вычислителем при обработке выражения, а количество сохранений хорошо
коррелирует со временем вычисления.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.28}Упражнение 5.28:} Измените в определении вычислителя @code{eval-sequence}
так, как описано в разделе @ref{5.4.2}, чтобы
вычислитель перестал обладать хвостовой рекурсией. Заново проведите
эксперименты из упражнений @ref{Упражнение 5.26} и
@ref{Упражнение 5.27} и покажите, что теперь обе версии процедуры
@code{factorial} требуют количества памяти, которое линейно зависит от
значения аргумента.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.29}Упражнение 5.29:} Проследите за использованием стека в вычислении чисел
Фибоначчи с помощью древовидной рекурсии:

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
@end lisp

@enumerate a.

@item
Дайте формулу, зависящую от @math{n}, для максимальной глубины стека,
требуемой при вычислении @math{\mathop{\rm Fib}(n)} при @math{n \ge 2}.
Подсказка: в разделе @ref{1.2.2} мы
утверждали, что требуемый объем памяти линейно зависит от @math{n}.

@item
Постройте формулу для количества сохранений, требуемых при вычислении
@math{{\rm Fib}(n)}, если @math{n \ge 2}. Вы увидите,
что количество сохранений (которое хорошо коррелирует со
временем исполнения) экспоненциально растет с ростом @math{n}.
Подсказка: пусть при вычислении @math{{\rm Fib}(n)} требуется
@math{S(n)} сохранений. Нужно показать, что имеется формула, которая
выражает @math{S(n)} в зависимости от @math{S(n-1)}, @math{S(n-2)} и
некоторой фиксированной <<дополнительной>> константы @math{k},
независимой от @math{n}. Приведите эту формулу и найдите, чему равно
@code{k}. Покажите теперь, что @math{S(n)} выражается как
@math{a\mathop{\rm Fib}(n+1) + b} и укажите значения @math{a} и @math{b}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.30}Упражнение 5.30:} Наш вычислитель отлавливает только два вида ошибок (и
сообщает о них) --- неизвестные типы выражений и неизвестные типы
процедур. При других ошибках он будет выпадать из управляющего цикла.
Когда мы запускаем вычислитель с помощью имитатора регистровых машин,
эти ошибки будут пойманы нижележащей Scheme-системой. Это похоже на
<<падение>> компьютера в случае ошибки пользовательской
программы@footnote{К сожалению, в обычных компиляторных языковых системах,
например, C, это обычное дело. В @acronym{UNIX}(tm) система <<кидает дамп>>, в
@acronym{DOS}/Windows(tm) впадает в кататонию. Macintosh(tm), если повезет,
рисует на экране взрывающуюся бомбу и предлагает перегрузиться.}. Построить настоящую
систему обработки ошибок --- большой проект, но понимание, что за
вопросы здесь возникают, стоит затраченных усилий.
 
@enumerate a.

@item
При ошибках, возникающих в процессе вычисления, например, при попытке
получить значение неопределенной переменной, можно заставить операцию
просмотра окружения возвращать особый код ошибки, который не может
служить значением пользовательской переменной. Тогда вычислитель может
проверять этот код и организовывать переход на @code{signal-error}.
Найдите в вычислителе все места, где нужно провести подобные изменения,
и исправьте их. (Потребуется много работы.)

@item
Значительно тяжелее проблема, которую представляют ошибки,
возникающие в элементарных процедурах, например, попытки поделить на
ноль или взять @code{car} символа. В профессионально написанной системе
высокого качества всякий вызов примитива проверяется на безопасность
внутри процедуры-примитива. Например, при всяком вызове @code{car}
требуется проверить, что аргумент --- пара. Если аргумент не является
парой, вызов вернет особый код ошибки, который вычислитель может
проверить и сообщить об ошибке. В нашем имитаторе регистровых машин
этого можно было бы добиться, если бы мы проверяли в каждой
элементарной процедуре правильность аргументов и при необходимости
возвращали соответствующий код. В таком случае код
@code{primitive-apply} мог бы проверять этот код и, если надо,
переходить на @code{signal-error}. Постройте такую структуру и заставьте
ее работать. (Это большой проект.)

@end enumerate
@end quotation

@comment @section Compilation
@section Компиляция
@node	5.5,  , 5.4, Chapter 5

Вычислитель с явным управлением из раздела @ref{5.4} --- регистровая
машина, контроллер которой исполняет Scheme-программы. В этом разделе мы
увидим, как выполнять программы на Scheme с помощью регистровой машины,
контроллер которой не является интерпретатором Scheme.

Машина-вычислитель с явным управлением универсальна --- она способна
выполнить любой вычислительный процесс, который можно описать на Scheme.
Контроллер вычислителя выстраивает использование своих путей данных так,
чтобы исполнялось нужное вычисление. Таким образом, пути данных
вычислителя универсальны: они достаточны для того, чтобы выполнить любое
необходимое нам вычисление, если снабдить их подходящим
контроллером@footnote{Это теоретическое утверждение. Мы не говорим, что
пути данных вычислителя как-то особенно удобны или эффективны для
компьютера общего назначения. Например, они не слишком хороши для
реализации высокоскоростных вычислений с плавающей точкой или для
вычислений, интенсивно работающих с битовыми векторами.}.

Коммерческие компьютеры общего назначения представляют собой регистровые
машины, построенные на множестве регистров и операций, составляющем
эффективный и удобный набор путей данных. Контроллер машины общего
назначения --- это интерпретатор языка регистровых машин, подобный
нашему. Язык называется (@newterm{native language}) машины, или попросту
(@newterm{machine language}). Программы, написанные на машинном языке --- это
последовательности команд, использующих пути данных машины. Например,
последовательность команд вычислителя с явным управлением можно
рассматривать как программу на машинном языке компьютера общего
назначения, а не как контроллер специализированной
машины-интерпретатора.

Есть две стратегии борьбы с разрывом между языками высокого и низкого
уровня. Вычислитель с явным управлением иллюстрирует стратегию
интерпретации. Интерпретатор, написанный на внутреннем языке машины,
конфигурирует машину так, что она начинает исполнять программы на языке
(называемом (@newterm{source language)}), который может отличаться от внутреннего
языка машины, производящей вычисление. Элементарные процедуры исходного
языка реализуются в виде библиотеки подпрограмм, написанных на
внутреннем языке данной машины. Интерпретируемая программа (называемая
(@newterm{source program)}) представляется как структура данных. Интерпретатор
просматривает эту структуру и анализирует исходную программу. В процессе
анализа он имитирует требуемое поведение исходной программы, вызывая
соответствующие элементарные подпрограммы из библиотеки.

В этом разделе мы исследуем альтернативную стратегию --- (@newterm{compilation}).
Компилятор для данного исходного языка и данной машины переводит
исходную программу в эквивалентную ей программу (называемую (@newterm{object program)}),
написанную на внутреннем языке машины. Компилятор, который мы
реализуем в этом разделе, переводит программы, написанные на Scheme, в
последовательности команд, которые подлежат исполнению с помощью путей
данных машины-вычислителя с явным управлением@footnote{На самом деле,
машина, исполняющая скомпилированный код, может быть проще, чем
машина-интерпретатор, поскольку регистры @code{exp} и @code{unev} мы
использовать не будем. В интерпретаторе они использовались для хранения
невычисленных выражений. Однако при использовании компилятора эти
выражения встраиваются в компилируемый код, который будет выполняться
на регистровой машине. По той же причине нам не нужны машинные операции,
работающие с синтаксисом выражений. Однако скомпилированный код будет
использовать некоторые дополнительные машинные операции (представляющие
скомпилированные объекты-процедуры), которых не было в
машине-вычислителе с явным управлением.}.

По сравнению с интерпретацией, компиляция может дать большой выигрыш в
эффективности исполнения программы. Это будет объяснено ниже, при обзоре
компилятора. С другой стороны, интерпретатор предоставляет более мощную
среду для интерактивной разработки программы и отладки, поскольку
исполняемая исходная программа присутствует во время выполнения, и ее
можно исследовать и изменять. В дополнение к этому, поскольку библиотека
примитивов присутствует целиком, во время отладки можно конструировать и
добавлять в систему новые программы.

Исходя из взаимно дополнительных преимуществ компиляции и интерпретации,
современные среды разработки программ следуют смешанной стратегии. Как
правило, интерпретаторы Лиспа устроены таким образом, что
интерпретируемые и скомпилированные процедуры могут вызывать друг друга.
Это позволяет программисту компилировать те части программы, которые он
считает отлаженными, пользуясь при этом преимуществом в эффективности,
предоставляемом компиляцией, но при этом сохранять интерпретационный
режим выполнения для тех частей программы, которые находятся в гуще
интерактивной разработки и отладки. В разделе @ref{5.5.7}, после
того, как компилятор будет разработан, мы покажем, как построить его
взаимодействие с нашим интерпретатором и получить интегрированную
систему разработки, состоящую из компилятора и интерпретатора.

@comment @subsubheading An overview of the compiler
@subsubheading Обзор компилятора

Наш компилятор во многом похож на наш интерпретатор, как по структуре,
так и по функции, которую он осуществляет. Соответственно, механизмы
анализа выражений, используемые компилятором, будут подобны тем же
механизмам для интерпретатора. Более того, чтобы упростить
взаимодействие компилируемого и интерпретируемого кода, мы построим
компилятор так, чтобы порождаемый им код следовал тем же соглашениям,
что и интерпретатор: окружение будет храниться в регистре @code{env},
списки аргументов будут собираться в @code{argl}, применяемая
процедура --- в @code{proc}, процедуры будут возвращать свое
значение в @code{val}, а место, куда им следует вернуться, будет
храниться в регистре @code{continue}. В общем, компилятор переводит
исходную программу в объектную программу, которая проделывает, в
сущности, те же самые операции с регистрами, которые провел бы
интерпретатор при выполнении той же самой исходной программы.

Это описание подсказывает стратегию для реализации примитивного
компилятора: разбирать выражение таким же образом, как это делает
интерпретатор. Когда мы встречаем команду работы с регистром, которую
интерпретатор выполнил бы при работе с выражением, мы эту команду не
выполняем, а добавляем к порождаемой нами последовательности.
Полученная последовательность команд и будет объектным кодом. Отсюда
видно преимущество в эффективности, которое компиляция имеет перед
интерпретацией. Каждый раз, когда интерпретатор выполняет выражение ---
например, @code{(f 48 96)}, --- он проделывает работу по распознаванию
выражения (определение того, что это вызов процедуры) и проверке, не
кончился ли список операндов (определение того, что операндов два). В
случае с компилятором выражение анализируется только один раз, когда во
время компиляции порождается последовательность команд. Объектный код,
порожденный компилятором, содержит только команды, которые вычисляют
оператор и два операнда, собирают список аргументов и применяют
процедуру (из @code{proc}) к аргументам (из @code{argl}).

Это тот же самый вид оптимизации, который мы применяли в анализирующем
интерпретаторе из раздела @ref{4.1.7}.
Однако в случае компиляции имеются дополнительные возможности повысить
эффективность. Интерпретатор при работе следует процессу, который обязан
быть приложимым к любому выражению языка. В противоположность этому,
всякий данный сегмент скомпилированного кода должен вычислять только
одно выражение. Это может приводить к большой разнице, например, при
использовании стека для сохранения регистров. Интерпретатор, выполняя
выражение, должен быть готов к любым неожиданностям. При вычислении
подвыражения он сохраняет все регистры, которые понадобятся в
дальнейшем, поскольку в подвыражении могут содержаться произвольные
действия. Напротив, компилятор может пользоваться структурой конкретного
выражения и порождать код, который избегает лишних операций со стеком.

Рассмотрим в качестве примера выражение @code{(f 84 96)}.
Интерпретатор, прежде чем вычислять оператор комбинации,
подготавливается к этому вычислению и сохраняет регистры с операндами и
окружением, чьи значения ему потребуются позже. Затем интерпретатор
вычисляет оператор, получая значение в @code{val}, восстанавливает
сохраненные регистры, и, наконец, переносит @code{val} в @code{proc}.
Однако в данном конкретном вычислении оператором служит символ
@code{f}, и его вычисление осуществляется командой
@code{lookup-variable-value}, которая никаких регистров не изменяет.
Компилятор, который мы разработаем в этом разделе, пользуется этим
фактом и порождает код для вычисления оператора командой

@lisp
(assign proc (op lookup-variable-value) (const f) (reg env))
@end lisp

Этот код не только избегает ненужных сохранений и восстановлений, но и
записывает значение переменной напрямую в регистр @code{proc}, в то
время как интерпретатор сначала получает его в @code{val}, а уж затем
переносит в @code{proc}.

Кроме того, компилятор может оптимизировать доступ к среде. Во многих
случаях при анализе кода компилятор может определять, в каком кадре
будет находиться конкретная переменная, и обращаться к этому кадру
напрямую, а не через поиск @code{lookup-variable-value}. Мы рассмотрим,
как реализуется такой доступ к переменным, в
разделе @ref{5.5.6}. До тех пор, впрочем, мы
сосредоточим внимание на оптимизациях доступа к регистрам и стеку,
описанным выше. Имеются и другие виды оптимизаций, которые может
производить компилятор: например, <<вставка>> кода элементарных операций
вместо общего механизма @code{apply}
(см. упражнение @ref{Упражнение 5.38}); однако эти оптимизации мы
здесь рассматривать не будем. В этом разделе наша цель ---
проиллюстрировать процесс компиляции в упрощенном (но все же интересном)
контексте.

@menu
* 5-5-1::            Структура компилятора
* 5-5-2::            Компиляция выражений
* 5-5-3::            Компиляция комбинаций
* 5-5-4::            Сочетание последовательностей команд
* 5-5-5::            Пример скомпилированного кода
* 5-5-6::            Лексическая адресация
* 5-5-7::            Связь скомпилированного кода с вычислителем
@end menu

@comment @subsection Structure of the Compiler
@subsection Структура компилятора
@node	5.5.1, 5.5.2, 5.5, 5.5

В разделе @ref{4.1.7} мы модифицировали исходный метациклический интерпретатор
и отделили анализ от выполнения. При анализе каждого выражения порождалась
исполнительная процедура, которая в качестве аргумента принимала
окружение и проделывала требуемые операции. В компиляторе мы будем
проводить, в сущности, такой же анализ. Однако вместо исполнительных
процедур мы будем порождать последовательности команд, предназначенных
для исполнения на нашей регистровой машине.

Процедура @code{compile} проводит в компиляторе анализ верхнего уровня.
Она соответствует процедуре @code{eval} из раздела @ref{4.1.1},
процедуре @code{analyze} из раздела @ref{4.1.7}
и точке входа @code{eval-dispatch} вычислителя с явным управлением из
раздела @ref{5.4.1}.
Подобно интерпретаторам, компилятор использует процедуры разбора
синтаксиса выражений из раздела @ref{4.1.2}@footnote{Заметим,
однако, что наш компилятор является программой на Scheme, и для анализа
синтаксиса он использует те же процедуры на Scheme, которые использовал
метациклический интерпретатор. Для вычислителя с явным управлением мы,
наоборот, предполагали, что эквивалентные синтаксические операции
присутствуют как примитивы в регистровой машине. (Разумеется, когда мы
имитировали эту машину на Scheme, в модели регистровой машины мы
использовали эти же процедуры Scheme.)}. Процедура @code{compile}
проводит разбор по случаям на основе синтаксического типа выражения,
подлежащего компиляции. Для каждого типа выражения она вызывает
специальный (code generator).

@lisp
(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type: COMPILE" exp))))
@end lisp

@comment @subsubheading Targets and linkages
@subsubheading Целевые регистры и типы связи

@code{compile} и вызываемые оттуда генераторы кода принимают, помимо
подлежащего компиляции выражения, еще два аргумента. Во-первых,
(@newterm{target}), в который компилируемый код должен поместить значение
выражения. Во-вторых, (@newterm{linkage descriptor}), который описывает, что код,
который получается при компиляции, должен делать после того, как он
закончит выполняться. Описатель типа связи может потребовать одного из
трех следующих действий:

@itemize @bullet

@item
продолжить со следующей команды в последовательности (на это указывает
описатель типа связи @code{next}),

@item
вернуться из компилируемой процедуры (на это указывает описатель типа
связи @code{return}), или

@item
перейти на указанную метку (на это указывает использование метки в
качестве описателя связи).

@end itemize

@noindent
Например, компиляция выражения @code{5} (значение которого равно ему
самому) с целевым регистром @code{val} и типом связи @code{next} должна
породить команду

@lisp
(aasign val (const 5))
@end lisp

Компиляция того же самого выражения с типом связи @code{return} должна
породить команды

@lisp
(assign val (const 5))
(goto (reg continue))
@end lisp

В первом случае выполнение продолжится на следующей команде
последовательности. Во втором мы вернемся из процедуры. В обоих случаях
значение выражения будет помещено в целевой регистр @code{val}.

@comment @subsubheading Instruction sequences and stack usage
@subsubheading Последовательности команд и использование стека

Каждый генератор кода возвращает (@newterm{instruction sequence}), содержащую
порожденный для выражения объектный код. Порождение кода для составных
выражений достигается путем сочетания более простых сегментов,
порожденных генераторами кода для подвыражений, так же, как вычисление
составного выражения проходит через вычисление подвыражений.

Простейший способ сочетания последовательностей команд --- процедура под
названием @code{append-instruction-sequences}. Она принимает в качестве
аргументов произвольное число последовательностей команд, которые надо
выполнить одну за другой. Процедура склеивает их и возвращает полученную
последовательность.  а именно, если
@math{\langle}@var{seq}@math{_1\rangle} и @math{\langle}@var{seq}@math{_2\rangle} ---
последовательности команд, то вычисление

@lisp
(append-instruction-sequences @math{\langle}@var{seq}@math{_{\mono{1}}\rangle} @math{\langle}@var{seq}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
вернет последовательность

@lisp
@math{\langle}@var{seq}@math{_{\mono{1}}\rangle}
@math{\langle}@var{seq}@math{_{\mono{2}}\rangle}
@end lisp

@noindent
Когда требуется сохранять регистры, генераторы кода используют
@code{preserving}, более сложный метод сочетания последовательностей
команд. @code{Preserving} принимает три аргумента: множество регистров и
две последовательности, которые требуется выполнить одна за другой. Эта
процедура склеивает последовательности таким образом, что содержимое
всех регистров из множества сохраняется во время выполнения первой
последовательности, если оно нужно при выполнении второй. Таким образом,
если первая последовательность изменяет регистр, а второй
последовательности нужно его исходное содержимое, @code{preserving}
оборачивает вокруг первой последовательности команды @code{save} и
@code{restore} для этого регистра, прежде чем склеить
последовательности. В противном случае она просто возвращает склеенные
последовательности команд. Так, например,

@lisp
(preserving (list @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}) @math{\langle}@var{seq}@math{_{\mono{1}}\rangle} @math{\langle}@var{seq}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
порождает одну из следующих четырех последовательностей команд, в
зависимости от того, как
@math{\langle}@var{seq}@math{_1\rangle} и @math{\langle}@var{seq}@math{_2\rangle} используют
@math{\langle}@var{reg}@math{_1\rangle} и @math{\langle}@var{reg}@math{_2\rangle}:
@ifinfo

@smallexample
<seq_1> | (save <reg_1>)    | (save <reg_2>)    | (save <reg_2>)
<seq_2> | <seq_1>           | <seq_1>           | (save <reg_1>)
        | (restore <reg_1>) | (restore <reg_2>) | <seq_1>
        | <seq_2>           | <seq_2>           | (restore <reg_1>)
        |                   |                   | (restore <reg_2>)
        |                   |                   | <seq_2>
@end smallexample

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut 	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil \cr

  $\langle{\mathit{seq}_1}\rangle$
& \hbox{\tt (save} $\langle{\mathit{reg}_1}\rangle${\tt)}
& \hbox{\tt (save} $\langle{\mathit{reg}_2}\rangle${\tt)}
& \hbox{\tt (save} $\langle{\mathit{reg}_2}\rangle${\tt)} \cr

  $\langle{\mathit{seq}_2}\rangle$
& $\langle{\mathit{seq}_1}\rangle$
& $\langle{\mathit{seq}_1}\rangle$
& \hbox{\tt (save} $\langle{\mathit{reg}_1}\rangle${\tt)} \cr

& \hbox{\tt (restore} $\langle{\mathit{reg}_1}\rangle${\tt)}
& \hbox{\tt (restore} $\langle{\mathit{reg}_2}\rangle${\tt)}
& $\langle{\mathit{seq}_1}\rangle$ \cr

& $\langle{\mathit{seq}_2}\rangle$
& $\langle{\mathit{seq}_2}\rangle$
& \hbox{\tt (restore} $\langle{\mathit{reg}_1}\rangle${\tt)} \cr

&  &
& \hbox{\tt (restore} $\langle{\mathit{reg}_2}\rangle${\tt)} \cr

&  &
& $\langle{\mathit{seq}_2}\rangle$ \cr
}
}$$
@end tex

@noindent
Сочетая последовательности команд с помощью @code{preserving},
компилятор избегает лишних операций со стеком. Кроме того, при этом
забота о том, стоит ли порождать @code{save} и @code{restore}, целиком
оказывается заключенной в процедуре @code{preserving} и отделяется от
забот, которые будут нас волновать при написании отдельных генераторов
кода. В сущности, ни одна команда @code{save} или @code{restore} не
порождается генераторами кода явно.

В принципе мы могли бы представлять последовательность команд просто как
список отдельных команд. В таком случае
@code{append-instruction-sequences} могла бы склеивать
последовательности с помощью обычного @code{append} для списков. Однако
тогда @code{preserving} оказалась бы более сложной операцией, поскольку
ей пришлось бы исследовать каждую последовательность команд и выяснять,
как там используются регистры. @code{Preserving} была бы при этом
сложной и неэффективной, поскольку она анализировала бы каждый из своих
аргументов-последовательностей, при том, что сами эти последовательности
могли быть созданы вызовами @code{preserving}, и в этом случае их части
были бы уже проанализированы. Чтобы избежать такого многократного
анализа, мы с каждой последовательностью команд будем связывать
некоторую информацию о том, как она использует регистры. При порождении
элементарной последовательности мы будем указывать эту информацию явно,
а процедуры, сочетающие последовательности, будут выводить информацию об
использовании регистров для составной последовательности из информации,
связанной с ее последовательностями-компонентами.

Последовательность команд будет содержать три вида информации:

@itemize @bullet

@item
множество регистров, которые должны быть инициализированы, прежде чем
выполняются команды из последовательности (говорится, что
последовательность (needs) в этих регистрах),

@item
множество регистров, значения которых последовательность изменяет, и

@item
сами команды (называемые также (statements)) в последовательности.

@end itemize

@noindent
Мы будем представлять последовательность команд в виде списка из трех
частей. Таким образом, конструктор для последовательностей команд таков:

@lisp
(define (make-instruction-sequence
         needs modifies statements)
  (list needs modifies statements))
@end lisp

@noindent
Например, последовательность из двух команд, которая ищет значение
переменной @code{x} в текущем окружении, присваивает его @code{val}, а
затем возвращается, требует, чтобы были проинициализированы регистры
@code{env} и @code{continue}, и изменяет регистр @code{val}.
Следовательно, эту последовательность можно построить так:

@lisp
(make-instruction-sequence
 '(env continue)
 '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
@end lisp

@noindent
Иногда нам нужно будет строить последовательность без команд:

@lisp
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
@end lisp

@noindent
Процедуры для сочетания последовательностей команд приведены в
разделе @ref{5.5.4}.

@quotation
@strong{@anchor{Упражнение 5.31}Упражнение 5.31:} Во время вычисления вызова процедуры вычислитель с явным
управлением всегда сохраняет и восстанавливает регистр @code{env} при
вычислении оператора, сохраняет и восстанавливает @code{env} при
вычислении каждого операнда (кроме последнего), сохраняет и
восстанавливает @code{argl} при вычислении каждого операнда, а также
сохраняет и восстанавливает @code{proc} при вычислении
последовательности операндов. Для каждой из следующих комбинаций
скажите, какие из этих операций @code{save} и @code{restore} излишни и
могут быть исключены с помощью механизма @code{preserving}:

@lisp
(f 'x 'y)
((f) 'x 'y)
(f (g 'x) y)
(f (g 'x) 'y)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.32}Упражнение 5.32:} С помощью механизма @code{preserving} компилятор сможет
избежать сохранения и восстановления @code{env} при вычислении оператора
комбинации в случае, если это символ. Такие оптимизации можно было бы
встроить и в интерпретатор. В сущности, вычислитель с явным управлением
из раздела @ref{5.4} уже проводит одну
подобную оптимизацию, поскольку рассматривает комбинацию без операндов
как особый случай.

@enumerate a.

@item
Расширьте вычислитель с явным управлением так, чтобы он как особый
случай рассматривал комбинации, в которых оператором является символ, и
при вычислении таких выражений использовал это свойство оператора.

@item
Лиза П. Хакер говорит, что если заставить интерпретатор рассматривать
все больше особых случаев, то можно включить в него все оптимизации
компилятора, и при этом все преимущество компиляции пропадет. Каково
Ваше мнение?

@end enumerate
@end quotation

@comment @subsection Compiling Expressions
@subsection Компиляция выражений
@node	5.5.2, 5.5.3, 5.5.1, 5.5

В этом и следующем разделе мы реализуем генераторы кода, на которые
ссылается процедура @code{compile}.

@comment @subsubheading Compiling linkage code
@subsubheading Компиляция связующего кода

В общем случае результат работы каждого генератора кода будет
заканчиваться командами --- порожденными процедурой
@code{compile-linkage}, --- которые реализуют требуемый тип связи. Если
это тип @code{return}, то нам надо породить команду
@code{(goto (reg continue))}. Она нуждается в регистре @code{continue}
и никаких регистров не меняет. Если тип связи @code{next}, то никаких
дополнительных команд порождать не надо. В остальных случаях тип
связи --- переход по метке, и мы порождаем команду @code{goto} на эту
метку, команду, которая ни в чем не нуждается и не изменяет никакие
регистры@footnote{В этой процедуре используется конструкция Лиспа,
называемая (backquote) или (quasiquote), с помощью которой удобно
строить списки. Обратная кавычка перед списком работает почти так же,
как обычная, но при этом все выражения внутри списка, перед которыми
стоит запятая, вычисляются.

Например, если значение @code{linkage} равно символу @code{branch25}, то
результатом выражения

@lisp
`((goto (label ,linkage)))
@end lisp

@noindent
будет список

@lisp
((goto (label branch25)))
@end lisp

@noindent
Подобным образом, если значением @code{x} является список @code{(a b c)}, то

@lisp
`(1 2 ,(car x))
@end lisp

@noindent
дает при вычислении список

@lisp
(1 2 a).
@end lisp
}

@c For example, if the value of @code{linkage} is the symbol@* @code{branch25},
@c then the expression@* @code{`((goto (label ,linkage)))}@* evaluates to the
@c list@* @code{((goto (label branch25)))}.@* Similarly, if the value of @code{x}
@c is the list @code{(a b c)}, then@* @code{`(1 2 ,(car x))}@* evaluates to the
@c list@* @code{(1 2 a)}.}

@lisp
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
@end lisp

Связующий код добавляется к последовательности команд с сохранением
через @code{preserving} регистра @code{continue}, поскольку связь
@code{return} нуждается в этом регистре: если данная последовательность
команд изменяет @code{continue}, а связующий код в нем нуждается,
@code{continue} будет сохранен и восстановлен.

@lisp
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
@end lisp

@comment @subsubheading Compiling simple expressions
@subsubheading Компиляция простых выражений

Генераторы кода для самовычисляющихся выражений, кавычек и переменных
строят последовательности команд, которые присваивают нужное значение
целевому регистру, а затем ведут себя в соответствии с описателем
связи.

@lisp
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
@end lisp

Все эти последовательности команд изменяют целевой регистр, а для
поиска значения переменной требуется регистр @code{env}.

Присваивания и определения обрабатываются во многом так же, как в
интерпретаторе. Мы рекурсивно порождаем код, вычисляющий значение,
которое следует присвоить переменной, и присоединяем его к
последовательности из двух команд, которая собственно присваивает
значение переменной или определяет ее, а затем заносит в целевой
регистр значение всего выражения (символ @code{ok}). Рекурсивная
компиляция вызывается с целевым регистром @code{val} и типом связи
@code{next}, так что порождаемый код положит результат в регистр
@code{val}, а затем продолжит выполнение с той последовательности,
которая идет за ним. При объединении кода сохраняется @code{env},
поскольку для определения и присваивания переменной требуется
окружение, а код, вычисляющий значение переменной, может оказаться
сложным выражением, которое изменяет регистры произвольным образом.

@lisp
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Двухкомандная последовательность в конце нуждается в @code{env} и
@code{val} и изменяет свой целевой регистр. Заметим, что мы сохраняем в
последовательности @code{env}, но не сохраняем @code{val}, поскольку
@code{get-value-code} для того и нужна, чтобы поместить в @code{val}
результат, которым затем воспользуется эта последовательность. (На самом
деле сохранение @code{val} было бы ошибкой, поскольку тогда сразу после
выполнения @code{get-value-code} восстановилось бы старое значение
@code{val}.)

@comment @subsubheading Compiling conditional expressions
@subsubheading Компиляция условных выражений

Код для выражения @code{if} с указанными целевым регистром и типом связи
имеет форму

@lisp
@math{\langle}@emph{скомпилированный код для предиката с целевым регистром @emph{val} и типом связи @emph{next}}@math{\rangle}
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
@math{\langle}@emph{скомпилированный код для следствия с указанным целевым регистром и указанным типом связи либо @emph{after-if}}@math{\rangle}
false-branch
@math{\langle}@emph{скомпилированный код для альтернативы с указанными целевым регистром и типом связи}@math{\rangle}
after-if
@end lisp

@noindent
Для того, чтобы породить этот код, мы компилируем предикат, следствие и
альтернативу, а затем сочетаем то, что получилось, с командами,
проверяющими значение предиката и со свежепорожденными метками, которые
отмечают истинную ветвь, ложную ветвь и конец условного
выражения@footnote{Просто использовать метки @code{true-branch},
@code{false-branch} и @code{after-if} нельзя, потому что в программе
может быть больше одного @code{if}. Компьютер порождает метки при помощи
процедуры @code{make-label}. Она принимает символ в качестве аргумента
и возвращает новый символ, имя которого начинается с данного. Например,
последовательные вызовы @code{(make-label 'a)} будут возвращать
@code{a1}, @code{a2} и так далее. Процедуру @code{make-label} можно
написать аналогично тому, как порождаются новые имена переменных в языке
запросов, а именно:

@lisp
(define label-counter 0)
(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)
(define (make-label name)
  (string->symbol 
    (string-append (symbol->string name)
                   (number->string (new-label-number)))))
@end lisp

}. В этом блоке кода нам требуется обойти истинную ветвь, если предикат
ложен. Единственная небольшая сложность состоит в том, какой тип связи
нужно указывать для истинной ветви. Если тип связи условного выражения
@code{return} или метка, то и истинная, и ложная ветка будут этот тип и
использовать. Если же тип связи @code{next}, то истинная ветвь
заканчивается переходом, обходящим код для ложной ветви, на метку,
которая стоит в конце условного выражения.

@lisp
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))                    
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
@end lisp

@noindent
При вычислении предиката сохраняется @code{env}, поскольку он может
потребоваться в истинной и ложной ветке, и @code{continue}, поскольку
он может потребоваться связующему коду в этих ветвях. Код для истинной
и ложной ветви (которые не выполняются последовательно) склеивается с
помощью особого комбинатора @code{parallel-instruction-sequences},
описанного в разделе @ref{5.5.4}.

Заметим, что поскольку @code{cond} является производным выражением, для
его обработки компилятор должен только запустить преобразование
@code{cond->if} (@ref{4.1.2}), а затем скомпилировать получившееся выражение
@code{if}.

@comment @subsubheading Compiling sequences
@subsubheading Компиляция последовательностей

Компиляция последовательностей (тел процедур и явных выражений
@code{begin}) происходит так же, как их выполнение. Компилируется каждое
из выражений последовательности --- последнее с типом связи, который
указан для всей последовательности, а остальные с типом связи
@code{next} (для того, чтобы потом выполнялись остальные выражения
последовательности). Последовательности команд для отдельных выражений
склеиваются и образуют единую последовательность, при этом сохраняются
@code{env} (необходимый для остатка последовательности) и
@code{continue} (возможно, требуемый для связи в конце
последовательности).

@lisp
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving
        '(env continue)
        (compile (first-exp seq) target 'next)
        (compile-sequence (rest-exps seq) target linkage))))
@end lisp

@comment @subsubheading Compiling @code{lambda} expressions
@subsubheading Компиляция выражений @code{lambda}

Выражения @code{lambda} строят процедуры. Объектный код для выражения
@code{lambda} должен иметь вид

@lisp
@math{\langle}@emph{построить процедурный объект и присвоить его целевому регистру}@math{\rangle}
@math{\langle}@emph{связь}@math{\rangle}
@end lisp

Компилируя выражения @code{lambda}, мы одновременно генерируем код для
тела процедуры. Несмотря на то, что во время построения процедурного
объекта тело исполняться не будет, удобно вставить его в код сразу
после кода для @code{lambda}. Если связь для выражения
@code{lambda} --- метка или @code{return}, никаких сложностей при этом
не возникает. Если же у нас тип связи @code{next}, то нужно обойти код
для тела процедуры, использовав связь, которая переходит на метку,
вставляемую сразу вслед за телом. Таким образом, объектный код принимает
вид

@lisp
@math{\langle}@emph{построить процедурный объект и присвоить его целевому регистру}@math{\rangle}
 @math{\langle}@emph{код для указанной связи}@math{\rangle} @emph{либо} @code{(goto (label after-lambda))}
 @math{\langle}@emph{скомпилированное тело процедуры}@math{\rangle}
after-lambda
@end lisp

Процедура @code{compile-lambda} порождает код, строящий процедурный
объект, вслед за которым идет код тела процедуры. Процедурный объект
порождается во время выполнения путем сочетания текущего окружения
(окружения, в котором исполняется определение) и точки входа для
скомпилированного тела процедуры (свежесгенерированной
метки)@footnote{@anchor{Footnote 38} Нам потребуются машинные операции, которые
реализуют структуру данных, представляющую скомпилированные процедуры,
аналогичную структуре для составных процедур, описанной в
разделе @ref{4.1.3}:

@lisp
(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))
(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))
(define (compiled-procedure-entry c-proc) (cadr c-proc))
(define (compiled-procedure-env c-proc) (caddr c-proc))
@end lisp
}.

@lisp
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
@end lisp

@noindent
В @code{compile-lambda} для того, чтобы добавить тело процедуры к коду
@code{lambda}-выражения, используется специальный комбинатор
@code{tack-on-instruction-sequence} (раздел @ref{5.5.4}), а не
обыкновенный @code{append-instruction-sequences}, поскольку тело
процедуры не является частью последовательности команд, выполняемой при
входе в общую последовательность; оно стоит в последовательности только
потому, что его удобно было сюда поместить.

Процедура @code{compile-lambda-body} строит код для тела процедуры. Этот
код начинается с метки для точки входа. Затем идут команды, которые
заставят машину во время выполнения войти в правильное окружение для
вычисления тела --- то есть окружение, где определена процедура,
расширенное связываниями формальных параметров с аргументами, с которыми
она вызвана. Затем следует код для последовательности выражений,
составляющих тело процедуры. Последовательность эта компилируется с
типом связи @code{return} и целевым регистром @code{val}, так что она
закончится возвратом из процедуры с результатом в регистре @code{val}.

@lisp
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
@end lisp

@comment @subsection Compiling Combinations
@subsection Компиляция комбинаций
@node	5.5.3, 5.5.4, 5.5.2, 5.5

Соль процесса компиляции заключается в компилировании вызовов процедур.
Код для комбинации, скомпилированный с данными целевым регистром и типом
связи, имеет вид

@lisp
@math{\langle}@emph{скомпилированный код оператора с целевым регистром @emph{proc} и типом}
@emph{связи @emph{next}}@math{\rangle}
@math{\langle}@emph{вычисление операндов и построение списка аргументов в @emph{argl}}@math{\rangle}
@math{\langle}@emph{скомпилированный код вызова процедуры с указанными целевым}
@emph{регистром и типом связи}@math{\rangle}
@end lisp

@noindent
Во время вычисления оператора и операндов может потребоваться сохранить
и восстановить регистры @code{env}, @code{proc} и @code{argl}. Заметим,
что это единственное место в компиляторе, где указывается целевой
регистр, отличный от @code{val}.

Требуемый код порождается процедурой @code{compile-application}. Она
рекурсивно компилирует оператор, порождая код, который помещает
подлежащую вызову процедуру в @code{proc}, и операнды, порождая код,
который по одному вычисляет операнды процедурного вызова.
Последовательности команд для операндов собираются (в процедуре
@code{construct-arglist}) вместе с кодом, который строит список
аргументов в регистре @code{argl}, а полученный код для порождения
списка аргументов склеивается с кодом вычисления процедуры и кодом,
который производит собственно вызов (он порождается с помощью
@code{compile-procedure-call}). При склеивании последовательностей
команд требуется сохранить регистр @code{env} на время вычисления
оператора (поскольку в это время @code{env} может измениться, а он еще
потребуется во время вычисления операндов), а регистр @code{proc}
требуется сохранить на время построения списка аргументов (при
вычислении операндов @code{proc} может измениться, а он потребуется во
время собственно вызова процедуры). Наконец, все время следует сохранять
@code{continue}, поскольку этот регистр нужен для связующего кода.

@lisp
(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
@end lisp

@noindent
Код для построения списка аргументов вычисляет каждый операнд, помещая
результат в @code{val}, а затем с помощью @code{cons} прицепляет его к
списку аргументов, собираемому в @code{argl}. Поскольку мы по очереди
нацепляем аргументы на @code{argl} через @code{cons}, нам нужно начать с
последнего аргумента и закончить первым, чтобы в получившемся списке
аргументы стояли в порядке от первого к последнему. Чтобы не тратить
команду на инициализацию @code{argl} пустым списком, прежде чем начать
последовательность вычислений, мы строим исходное значение
@code{argl} в первом участке кода. Таким образом, общая форма
построения списка аргументов такова:

@lisp
@math{\langle}@emph{компиляция последнего операнда с целью @emph{val}}@math{\rangle}
(assign argl (op list) (reg val))
@math{\langle}@emph{компиляция следующего аргумента с целью @emph{val}}@math{\rangle}
(assign argl (op cons) (reg val) (reg argl))
@dots{}
@math{\langle}@emph{компиляция первого аргумента с целью @emph{val}}@math{\rangle}
(assign argl (op cons) (reg val) (reg argl))
@end lisp

Нужно сохранять @code{argl} при вычислении всех операндов, кроме как в
самом начале (чтобы уже набранные аргументы не потерялись), а при
вычислении всех операндов, кроме как в самом конце, нужно сохранять
@code{env} (его могут использовать последующие вычисления операндов).

Компилировать код для аргументов довольно сложно, поскольку особым
образом обрабатывается первый вычисляемый операнд, и в различных местах
требуется сохранять @code{argl} и @code{env}. Процедура
@code{construct-arglist} принимает в качестве аргументов участки кода,
которые вычисляют отдельные операнды. Если никаких операндов нет вообще,
она попросту порождает команду

@lisp
(assign argl (const ()))
@end lisp

В остальных случаях @code{construct-arglist} порождает код, инициализирующий
@code{argl} последним аргументом, и добавляет к нему код, который по очереди
вычисляет остальные аргументы и добавляет их к @code{argl}. Для того,
чтобы аргументы обрабатывались от конца к началу, нам следует обратить
список последовательностей кода для операндов, подаваемый из
@code{compile-application}.

@lisp
(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
@end lisp

@endpage
@comment @subsubheading Applying procedures
@subsubheading Применение процедур

После того, как элементы комбинации вычислены, скомпилированный код
должен применить процедуру из регистра @code{proc} к аргументам из
регистра @code{argl}. Этот код рассматривает, в сущности, те же самые
случаи, что и процедура @code{apply} из метациклического
интерпретатора в разделе @ref{4.1.1} или точка входа @code{apply-dispatch}
из вычислителя с явным управлением в разделе @ref{5.4.1}.
Нужно проверить какая процедура применяется --- элементарная или
составная. В случае элементарной процедуры используется
@code{apply-primitive-procedure}; как ведется работа с составными
процедурами, мы скоро увидим. Код применения процедуры имеет такую
форму:

@lisp
(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 @math{\langle}@emph{код для применения скомпилированной процедуры с указанной целью}
 @emph{и подходящим типом связи}@math{\rangle}
primitive-branch
 (assign @math{\langle}@var{целевой регистр}@math{\rangle}
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 @math{\langle}@var{связующий код}@math{\rangle}
after-call
@end lisp

Заметим, что если выбрана ветвь для скомпилированной процедуры, машина
должна обойти ветвь для элементарной процедуры. Следовательно, если тип
связи для исходного вызова процедуры был @code{next}, ветвь для
составной процедуры должна использовать связь с переходом на метку,
стоящую после ветви для элементарной процедуры. (Подобным образом
работает связь для истинной ветви в @code{compile-if}.)

@lisp
(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
@end lisp

Ветви для элементарных и составных процедур, подобно истинной и ложной
ветвям в @code{compile-if}, склеиваются через
@code{parallel-instruction-sequences}, а не обыкновенной
@code{append-instruction-sequences}, поскольку они не выполняются
последовательно.

@comment @subsubheading Applying compiled procedures
@subsubheading Применение скомпилированных процедур

Код, обрабатывающий применение процедур, --- наиболее тонко устроенная
часть компилятора, при том, что он порождает очень короткие
последовательности команд. У скомпилированной процедуры (порожденной с
помощью @code{compile-lambda}) имеется точка входа, то есть метка,
указывающая, где начинается тело процедуры. Код, расположенный по этой
метке, вычисляет результат, помещая его в @code{val}, а затем
возвращается, исполняя команду @code{(goto (reg continue))}. Таким
образом, если в качестве связи выступает метка, мы можем ожидать, что
код для вызова скомпилированной процедуры (порождаемый с помощью
@code{compile-proc-appl}) с указанным целевым регистром будет выглядеть
так:

@lisp
(assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign @math{\langle}@var{целевой регистр}@math{\rangle} (reg val)) @r{; включается, если целевой регистр не @code{val}}
 (goto (label @math{\langle}@var{связующий код}@math{\rangle}))               @r{; связующий код}
@end lisp

либо, если тип связи @code{return}, так:

@lisp
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign @math{\langle}@var{целевой регистр}@math{\rangle} (reg val)) @r{; включается, если целевой регистр не @code{val}}
 (restore continue)
 (goto (label @math{\langle}@var{связующий код}@math{\rangle}))               @r{; связующий код}
@end lisp

Этот код устанавливает @code{continue} так, чтобы процедура вернулась на
метку @code{proc-return}, а затем переходит на входную точку процедуры.
Код по метке @code{proc-return} переносит результат процедуры из
@code{val} в целевой регистр (если нужно), а затем переходит в место,
определяемое типом связи. (Связь всегда @code{return} или метка,
поскольку процедура @code{compile-procedure-call} заменяет связь
@code{next} для ветви составной процедуры на переход к метке
@code{after-call}.)

На самом деле, если целевой регистр не равен @code{val}, то именно такой
код наш компилятор и породит@footnote{Мы сообщаем об ошибке, если
целевой регистр не @code{val}, а тип связи @code{return}, поскольку
единственное место, где мы требуем связи @code{return} --- это
компиляция процедур, а по нашему соглашению процедуры возвращают
значение в регистре @code{val}.}. Однако чаще всего целевым регистром
является @code{val} (единственное место, в котором компилятор
заказывает другой целевой регистр --- это когда вычисление оператора
имеет целью @code{proc}), так что результат процедуры помещается прямо в
целевой регистр, и возвращаться в особое место, где он копируется,
незачем. Вместо этого мы упрощаем код, так устанавливая @code{continue},
что процедура <<возвращается>> прямо на то место, которое указано типом
связи вызывающего кода:

@lisp
@math{\langle}@emph{установить @code{continue} в соответствии с типом вызова}@math{\rangle}
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

Если в качестве связи указана метка, мы устанавливаем @code{continue}
так, что возврат происходит на эту метку. (Таким образом, в приведенной
выше @code{proc-return}, команда @code{(goto (reg continue))}, которой
кончается процедура, оказывается равносильной
@code{(goto (label @math{\langle}@var{связь}@math{\rangle}))}.)

@lisp
(assign continue (label @math{\langle}@var{связь}@math{\rangle}))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

Если тип связи у нас @code{return}, нам вообще ничего не надо делать с
@code{continue}: там уже хранится нужное место возврата. (То есть
команда @code{(goto (reg continue))}, которой заканчивается процедура,
переходит прямо туда, куда перешла бы @code{(goto (reg-continue))},
расположенная по метке @code{proc-return}.)

@lisp
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

При такой реализации типа связи @code{return} компилятор порождает код,
обладающий свойством хвостовой рекурсии. Вызов процедуры, если это
последнее действие в теле процедуры, приводит к простой передаче
управления, когда на стек ничего не кладется.

Предположим, однако, что мы реализовали случай вызова процедуры с типом
связи @code{return} и целевым регистром @code{val} так, как показано
выше для случая с целью не-@code{val}. Хвостовая рекурсия оказалась бы
уничтожена. Наша система по-прежнему вычисляла бы то же значение для
всех выражений. Однако при каждом вызове процедур мы сохраняли бы
@code{continue}, а после вызова возвращались бы для (ненужного)
восстановления. В гнезде рекурсивных вызовов эти дополнительные
сохранения накапливались бы@footnote{Казалось бы, заставить компилятор
порождать код с хвостовой рекурсией --- естественная идея. Однако
большинство компиляторов для распространенных языков, включая C и
Паскаль, так не делают, и, следовательно, в этих языках итеративный
процесс нельзя представить только через вызовы процедур. Сложность с
хвостовой рекурсией в этих языках состоит в том, что их реализации
сохраняют на стеке не только адрес возврата, но еще и аргументы процедур
и локальные переменные. Реализации Scheme, описанные в этой книге,
хранят аргументы и переменные в памяти и подвергают их сборке мусора.
Причина использования стека для переменных и аргументов --- в том, что
при этом можно избежать сборки мусора в языках, которые не требуют ее
по другим причинам, и вообще считается, что так эффективнее. На самом
деле изощренные реализации Лиспа могут хранить аргументы на стеке, не
уничтожая хвостовую рекурсию. (Описание можно найти в Hanson 1990.)
Кроме того, ведутся споры о том, правда ли, что выделение памяти на
стеке эффективнее, чем сборка мусора, но тут результат, кажется, зависит
от тонких деталей архитектуры компьютера. (См. Appel 1987 и Miller and
Rozas 1994, где по этому вопросу высказываются противоположные
мнения.)}.

При порождении вышеописанного кода для применения процедуры
@code{compile-proc-appl} рассматривает четыре случая, в зависимости от
того, является ли @code{val} целевым регистром, и от того, дан ли нам
тип связи @code{return}. Обратите внимание: указано, что эти
последовательности команд изменяют все регистры, поскольку при
выполнении тела процедуры регистрам разрешено меняться как
угодно@footnote{Значением переменной @code{all-regs} является список
имен всех регистров:

@lisp
(define all-regs '(env proc val argl continue))
@end lisp
}. Заметим, кроме того, что в случае с целевым регистром @code{val} и
типом связи @code{return} говорится, что участок кода нуждается в
@code{continue}: хотя в этой двухкомандной последовательности
@code{continue} явно не упоминается, нам нужно знать, что при входе в
скомпилированную процедуру @code{continue} будет содержать правильное
значение.

@lisp
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "Тип связи return, цель не val -- COMPILE"
                target))))
@end lisp

@comment @subsection Combining Instruction Sequences
@subsection Сочетание последовательностей команд
@node	5.5.4, 5.5.5, 5.5.3, 5.5

В этом разделе в деталях описывается представление последовательностей
команд и их сочетание друг с другом. Напомним, что в
разделе @ref{5.5.1} мы решили, что
последовательность представляется в виде списка, состоящего из
множества требуемых регистров, множества изменяемых регистров, и
собственно кода. Кроме того, мы будем считать метку (символ) особым
случаем последовательности, которая не требует и не изменяет никаких
регистров. Таким образом, для определения регистров, в которых нуждается
и которые изменяет данная последовательность, мы пользуемся селекторами

@lisp
(define (registers-needed s)
  (if (symbol? s) '() (car s)))
(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
@end lisp

а для того, чтобы выяснить, нуждается ли последовательность в регистре
и изменяет ли она его, используются предикаты

@lisp
(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
@end lisp

С помощью этих селекторов и предикатов мы можем реализовать все
многочисленные комбинаторы последовательностей команд, которые
используются в тексте компилятора.

Основным комбинатором является @code{append-instruction-sequences}. Он
принимает как аргументы произвольное число последовательностей команд,
которые следует выполнить последовательно, а возвращает
последовательность команд, предложениями которой служат предложения всех
последовательностей, склеенные вместе. Сложность состоит в том, чтобы
определить регистры, которые требуются, и регистры, которые
изменяются в получаемой последовательности. Изменяются те регистры,
которые изменяются в какой-либо из подпоследовательностей; требуются те
регистры, которые должны быть проинициализированы прежде, чем можно
запустить первую подпоследовательность (регистры, требуемые первой
подпоследовательностью), а также регистры, которые требует любая из
оставшихся подпоследовательностей, не измененные (проинициализированные)
одной из подпоследовательностей, идущих перед ней.

Последовательности сливаются по две процедурой @code{append-2-sequences}.
Она берет две последовательности команд
@code{seq1} и @code{seq2}, и возвращает последовательность команд, в
которой предложениями служат предложения @code{seq1}, а затем в конце
добавлены предложения @code{seq2}. Ее изменяемые регистры --- те,
которые изменяет либо @code{seq1}, либо @code{seq2}, а требуемые
регистры --- те, что требует @code{seq1} плюс те, что требует
@code{seq2} и не изменяет @code{seq1}. (В терминах операций над
множествами, новое множество требуемых регистров является объединением
множества требуемых регистров @code{seq1} с множественной разностью
требуемых регистров @code{seq2} и изменяемых регистров @code{seq1}.)
Таким образом, @code{append-instruction-sequences} реализуется так:

@lisp
(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
@end lisp

В этой процедуре используются некоторые операции для работы с
множествами, представленными в виде списков, подобные
(неотсортированному) представлению множеств, описанному в разделе @ref{2.3.3}:

@lisp
(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
@end lisp

@noindent
Второй основной комбинатор последовательностей команд,
@code{preserving}, принимает список регистров @code{regs} и две
последовательности команд @code{seq1} и @code{seq2}, которые следует
выполнить последовательно. Он возвращает последовательность команд, чьи
предложения --- это предложения @code{seq1}, за которыми идут
предложения @code{seq2}, с командами @code{save} и @code{restore} вокруг
@code{seq1}, для того, чтобы защитить регистры из множества @code{regs},
изменяемые в @code{seq1}, но требуемые в @code{seq2}. Для того, чтобы
построить требуемую последовательность, сначала @code{preserving}
создает последовательность, содержащую требуемые команды @code{save},
команды из @code{seq1} и команды @code{restore}. Эта последовательность
нуждается в регистрах, которые подвергаются
сохранению/восстановлению, а также регистрах, требуемых @code{seq1}.
Она изменяет регистры, которые меняет @code{seq1}, за исключением тех,
которые сохраняются и восстанавливаются. Затем эта дополненная
последовательность и @code{seq2} сочетаются обычным образом. Следующая
процедура реализует эту стратегию рекурсивно, двигаясь по списку
сохраняемых регистров@footnote{Заметим, что @code{preserving} зовет
@code{append} с тремя аргументами. Хотя определение @code{append},
приводимое в этой книге, принимает только два аргумента, в стандарте
Scheme имеется процедура @code{append}, принимающая любое их
количество.}:

@lisp
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
@end lisp

@noindent
Еще один комбинатор последовательностей,
@code{tack-on-instruction-sequence}, используется в
@code{compile-lambda} для того, чтобы добавить тело процедуры к другой
последовательности. Поскольку тело процедуры не находится <<в потоке
управления>> и не должно выполняться как часть общей последовательности,
используемые им регистры никак не влияют на регистры, используемые
последовательностью, в которую оно включается. Таким образом, когда мы
добавляем тело процедуры к другой последовательности, мы игнорируем его
множества требуемых и изменяемых регистров.

@lisp
(define (tack-on-instruction-sequence seq body-seq) 
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
@end lisp

В процедурах @code{compile-if} и @code{compile-procedure-call}
используется специальный комбинатор
@code{parallel-instruction-sequences}, который склеивает две
альтернативные ветви, следующие за тестом. Эти две ветви никогда не
исполняются одна за другой; при каждом исполнении теста будет запущена
либо одна, либо другая ветвь. Поэтому регистры, требуемые во второй
ветви, по-прежнему требуются составной последовательности, даже если
первая ветвь их изменяет.

@lisp
(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
@end lisp

@comment @subsection An Example of Compiled Code
@subsection Пример скомпилированного кода
@node	5.5.5, 5.5.6, 5.5.4, 5.5

Теперь, когда мы рассмотрели все элементы компилятора, можно разобрать
пример скомпилированного кода и увидеть, как сочетаются его элементы. Мы
скомпилируем определение рекурсивной процедуры @code{factorial} с
помощью вызова @code{compile}:

@lisp
(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
@end lisp

Мы указали, что значение выражения @code{define} требуется поместить в
регистр @code{val}. Нам неважно, что будет делать скомпилированный код
после того, как будет выполнено @code{define}, так что выбор
@code{next} в качестве типа связи произволен.

Процедура @code{compile} распознает выражение как определение, так что
она зовет @code{compile-definition}, чтобы породить код для вычисления
присваиваемого значения (с целью @code{val}), затем код для внесения
определения в среду, затем код, который помещает значение @code{define}
(символ @code{ok}) в целевой регистр, и, наконец, связующий код. При
вычислении значения сохраняется @code{env}, поскольку этот регистр
требуется, чтобы внести определение в среду. Поскольку тип связи у нас
@code{next}, никакого связующего кода не порождается. Таким образом,
скелет скомпилированного кода таков:

@lisp
@math{\langle}@emph{сохранить @emph{env}, если его изменяет код для вычисления значения}@math{\rangle}
@math{\langle}@emph{скомпилированный код для значения определения, цель @emph{val}, связь @emph{next}}@math{\rangle}
@math{\langle}@emph{восстановить @emph{env}, если он сохранялся}@math{\rangle}
(perform (op define-variable!)
         (const factorial)
         (reg val)
         (reg env))
(assign val (const ok))
@end lisp

@noindent
Выражение, которое нужно скомпилировать, чтобы получить значение
переменной @code{factorial} --- это выражение @code{lambda}, и
значением его является процедура, вычисляющая факториалы. @code{Compile}
обрабатывает его путем вызова @code{compile-lambda}.
@code{Compile-lambda} компилирует тело процедуры, снабжает его меткой
как новую точку входа и порождает команду, которая склеит тело процедуры
по новой метке с окружением времени выполнения и присвоит значение
регистру @code{val}. Затем порожденная последовательность перепрыгивает
через скомпилированный код, который вставляется в этом месте. Сам код
процедуры начинается с того, что окружение, где процедура определена,
расширяется кадром, в котором формальный параметр @code{n} связывается
с аргументом процедуры. Затем идет собственно тело процедуры. Поскольку
код для определения значения переменной не изменяет регистр @code{env},
команды @code{save} и @code{restore}, которые показаны выше как
возможные, не порождаются. (В этот момент не выполняется код процедуры
по метке @code{entry2}, так что детали его работы с @code{env} значения
не имеют.) Следовательно, наш скелет скомпилированного кода становится
таким:

@lisp
(assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  @math{\langle}@emph{скомпилированный код тела процедуры}@math{\rangle}
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
@end lisp

Тело процедуры всегда компилируется (в @code{compile-lambda-body}) как
последовательность команд с целевым регистром @code{val} и типом связи
@code{return}. В данном случае в последовательности одно выражение
@code{if}:

@lisp
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
@end lisp

@code{сompile-if} порождает код, который сначала вычисляет предикат (с
целью @code{val}), затем проверяет его значение и, если предикат ложен,
обходит истинную ветвь. При вычислении предиката сохраняются @code{env}
и @code{continue}, поскольку они могут потребоваться в оставшейся части
выражения @code{if}. Поскольку выражение @code{if} последнее (и
единственное) в последовательности, составляющей тело процедуры, оно
имеет цель @code{val} и тип связи @code{return}, так что и истинная, и
ложная ветви компилируются с целью @code{val} и типом связи
@code{return}. (Это значит, что значение условного выражения, которое
вычисляется одной из его ветвей, является значением процедуры.)

@lisp
@math{\langle}@emph{сохранить @emph{continue}, @emph{env}, если они изменяются предикатом и требуются в ветвях}@math{\rangle}
  @math{\langle}@emph{скомпилированный код предиката, цель @emph{val}, связь @emph{next}}@math{\rangle}
  @math{\langle}@emph{восстановить @emph{continue}, @emph{env}, если они сохранялись}@math{\rangle}
  (test (op false?) (reg val))
  (branch (label false-branch4)
true-branch5
  @math{\langle}@emph{скомпилированный код истинной ветви, цель @emph{val}, связь @emph{return}}@math{\rangle}
false-branch4
  @math{\langle}@emph{скомпилированный код ложной ветви, цель @emph{val}, связь @emph{return}}@math{\rangle}
after-if3
@end lisp

Предикат @code{(= n 1)} является вызовом процедуры. Он ищет в окружении
оператор (символ @code{=}) и помещает его значение в @code{proc}. Затем
он собирает аргументы --- @code{1} и значение @code{n}, --- в
@code{argl}. Затем он проверяет, лежит ли в @code{proc} примитив или
составная процедура, и соответствующим образом переходит на ветвь
элементарной или составной процедуры. Обе ветви приводят к метке
@code{after-call}. Требование сохранять регистры при вычислении
оператора и операндов не приводит ни к каким операциям сохранения,
поскольку в этом случае вычисления не трогают нужные регистры.

@lisp
(assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call15
@end lisp

Истинная ветвь, константа 1, компилируется (с целевым регистром
@code{val} и типом связи @code{return}) в

@lisp
(assign val (const 1))
  (goto (reg continue))
@end lisp

Код для ложной ветви является еще одним вызовом процедуры, где
процедурой служит значение символа @code{}, а аргументами --- @code{n}
и значение еще одного вызова (вызова @code{factorial}). Каждый из этих
вызовов устанавливает значения @code{proc} и @code{argl}, а также свои
собственные ветви для элементарных и составных процедур. На
рисунке @ref{Рисунок 5.17} показан полный скомпилированный код для
определения процедуры @code{factorial}. Заметим, что возможные команды
@code{save} и @code{restore} для @code{continue} и @code{env} при
вычислении предиката, указанные выше, на самом деле порождаются,
поскольку эти регистры изменяются во время вызова процедуры в предикате
и нужны для вызова процедуры и связи @code{return} в ветвях.

@quotation
@strong{@anchor{Упражнение 5.33}Упражнение 5.33:} Рассмотрим следующее определение процедуры для вычисления
факториала, которое незначительно отличается от рассмотренного в тексте:

@lisp
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
@end lisp

Скомпилируйте эту процедуру и сравните получившийся код с кодом для
@code{factorial}. Объясните обнаруженные различия. Есть ли разница в
эффективности программ?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.34}Упражнение 5.34:} Скомпилируйте итеративную процедуру вычисления факториала:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp

Прокомментируйте полученный код и покажите существенное различие между
кодом для итеративной и рекурсивной версий @code{factorial}, благодаря
которому один процесс наращивает глубину стека, а второй выполняется при
фиксированной глубине.
@end quotation

@quotation
@strong{@anchor{Рисунок 5.17}Figure 5.17:} @math{\downarrow} Compilation of the definition of the
@code{factorial} procedure.

@smalllisp
@r{;; построить процедуру и обойти ее тело}
  (assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
entry2     @r{; вызовы @code{factorial} будут попадать сюда}
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env 
          (op extend-environment) (const (n)) (reg argl) (reg env))
@r{;; начинается собственно тело процедуры}
  (save continue)
  (save env)
@r{;; вычислить @code{(= n 1)}}
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call15   @r{; здесь @code{val} содержит результат @code{(= n 1)}}
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  @r{; вернуть 1 }
  (assign val (const 1))
  (goto (reg continue))
false-branch4
@r{;; вычислить и вернуть  @code{(* (factorial (- n 1) n))}}
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   @r{; сохранить процедуру @code{ *}}
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   @r{; сохранить частичный список аргументов для @code{ *}}
@r{;; вычислить  @code{(factorial (- n 1))}, еще один аргумент @code{ *}}
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  @r{; сохранить процедуру @code{ factorial}}
@r{;; вычислить @code{ (- n 1)}, аргумент @code{ factorial}}
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call6   @r{; теперь в @code{val} содержится результат @code{(- n 1)}}
  (assign argl (op list) (reg val))
  (restore proc)  @r{; восстановить @code{factorial}}
@r{;; применить @code{factorial}}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call9       @r{; теперь @code{val} содержит результат @code{(factorial (- n 1))}}
  (restore argl)  @r{; восстановить частичный список аргументов для @code{*}}
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)  @r{; восстановить @code{*}}
  (restore continue)
@r{;; применить @code{*} и вернуть}
@r{;; его результат}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
@r{;; обратите внимание:} 
@r{;; скомпилированная процедура здесь зовется}
@r{;; с хвостовой рекурсией}
(assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
@r{;; присвоить процедуру переменной @code{factorial}}
  (perform 
        (op define-variable!)
        (const factorial)
        (reg val)
        (reg env))
  (assign val (const ok))
@end smalllisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.35}Упражнение 5.35:} При компиляции какого выражения был получен код на
рисунке @ref{Рисунок 5.18}?
@end quotation

@quotation
@strong{@anchor{Рисунок 5.18}Figure 5.18:} @math{\downarrow} An example of compiler output.  See
@ref{Exercise 5.35}.

@smalllisp
(assign val
        (op make-compiled-procedure)
        (label entry16)
        (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment)
          (const (x))
          (reg argl)
          (reg env))
  (assign proc
          (op lookup-variable-value)
          (const +)
          (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc
          (op lookup-variable-value)
          (const g)
          (reg env))
  (save proc)
  (assign proc
          (op lookup-variable-value)
          (const +)
          (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value)
          (const x)
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val
          (op lookup-variable-value)
          (const x)
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!)
           (const f)
           (reg val)
           (reg env))
  (assign val (const ok))
@end smalllisp

@end quotation

@quotation
@strong{@anchor{Упражнение 5.36}Упражнение 5.36:} Какой порядок вычисления задает наш компилятор для
операндов комбинации --- слева направо, справа налево, или какой-либо
иной? Где в компиляторе задается этот порядок? Измените компилятор так,
чтобы он порождал какой-нибудь другой порядок вычисления. (См.
обсуждение порядка вычисления для вычислителя с явным управлением из
раздела @ref{5.4.1}.) Как
смена порядка вычисления операндов влияет на эффективность кода, который
строит список аргументов?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.37}Упражнение 5.37:} Вот один из способов понять, как механизм
@code{preserving} оптимизирует использование стека: рассмотреть, какие
дополнительные операции порождались бы, если бы мы этот механизм не
использовали. Измените @code{preserving} так, чтобы операции @code{save}
и @code{restore} порождались всегда. Скомпилируйте несколько простых
выражений и отметьте ненужные операции со стеком, которые станут
порождаться. Сравните этот код с тем, который порождается, если механизм
@code{preserving} присутствует.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.38}Упражнение 5.38:} Наш компилятор тщательно избегает ненужных операций со
стеком, но с точки зрения перевода вызовов элементарных процедур
языка в операции машины он очень слаб. Рассмотрим, например, сколько
кода порождается для вычисления @code{(+ a 1)}: код порождает список
аргументов в @code{argl}, помещает элементарную процедуру сложения
(которую он находит через поиск символа @code{+} в окружении) в
@code{proc}, затем проверяет, является ли эта процедура элементарной или
составной. Компилятор всегда порождает код этой проверки, а также код
для ветви элементарной процедуры и ветви составной процедуры (из которых
только одна будет выполняться). Мы не показали ту часть контроллера,
которая реализует примитивы, но мы предполагаем, что эти команды
используют элементарные арифметические операции в путях данных машины.
Рассмотрим, насколько меньше кода будет порождаться, если компилятор
сможет вставлять примитивы в виде (@newterm{open coding}) --- то есть порождать
код, который прямо использует эти машинные операции. Выражение
@code{(+ a 1)} можно было бы скомпилировать в простую
последовательность вроде@footnote{Здесь мы одним символом @code{+}
обозначаем и процедуру исходного языка, и машинную операцию. В общем
случае может не быть однозначного соответствия примитивов исходного
языка примитивам машины.}

@lisp
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
@end lisp

В этом упражнении мы расширим компилятор так, чтобы он поддерживал явное
кодирование отдельных примитивов. При обращениях к этим примитивам будет
порождаться специально написанный код, а не общий код для вызова
процедуры. Для того, чтобы поддержать такую работу, мы дополним машину
специальными регистрами для аргументов @code{arg1} и @code{arg2}.
Элементарные арифметические операции машины будут принимать свои
аргументы в @code{arg1} и @code{arg2}. Они могут помещать результаты в
@code{val}, @code{arg1} или @code{arg2}.

Компилятор должен уметь распознавать вызов явно кодируемого примитива в
исходной программе. Мы дополним распознаватель в процедуре
@code{compile}, так, чтобы он узнавал имена этих примитивов в
дополнение к зарезервированным словам (особым формам), которые он узнаёт
сейчас@footnote{Вообще говоря, превращение примитивов в
зарезервированные слова --- плохая идея, потому что тогда пользователь
не может связать эти имена с другими процедурами. Более того, если мы
добавим зарезервированные слова в компилятор, который уже используется,
перестанут работать существующие программы, которые определяют процедуры
с такими именами. Идеи, как можно избежать этой проблемы, можно найти в
упражнении @ref{Упражнение 5.44}.}. Для каждой особой формы в
компиляторе есть свой генератор кода. В этом упражнении мы построим
семью генераторов кода для явно кодируемых примитивов.

@enumerate a.

@item
В отличие от особых форм, явно кодируемые примитивы требуют, чтобы их
аргументы вычислялись. Напишите генератор кода @code{spread-arguments},
который будут использовать генераторы явного кода.
@code{Spread-arguments} должен принимать список операндов и
компилировать данные ему операнды, направляя их в последовательные
аргументные регистры. Заметим, что операнд может содержать вызов явно
кодируемого примитива, так что во время вычисления операндов придется
сохранять аргументные регистры.

@item
Для каждой из элементарных процедур @code{=}, @code{}, @code{-} и
@code{+} напишите по генератору кода, который принимает комбинацию,
содержащую этот оператор вместе с целевым регистром и описателем связи,
и порождает код, который раскидывает аргументы по регистрам, а затем
проводит операцию с данным целевым регистром и указанным типом связи.
Достаточно обрабатывать только выражения с двумя операндами. Заставьте
@code{compile} передавать управление этим генераторам кода.

@item
Опробуйте обновленный компилятор на примере с процедурой
@code{factorial}. Сравните полученный результат с результатом, который
получается без открытого кодирования.

@item
Расширьте свои генераторы кода для @code{+} и @code{} так, чтобы они
могли обрабатывать выражения с произвольным числом операндов.
Выражение, в котором операндов больше двух, придется компилировать в
последовательность операций, каждая из которых работает с двумя входами.

@end enumerate
@end quotation

@comment @subsection Lexical Addressing
@subsection Лексическая адресация
@node	5.5.6, 5.5.7, 5.5.5, 5.5

Одна из наиболее часто встречающихся в компиляторах оптимизаций связана
с поиском переменных. В нынешнем виде наш компилятор использует операцию
@code{lookup-variable-value} машины-вычислителя. Эта операция ищет
переменную, сравнивая ее со всеми переменными, связанными в данный
момент, и проходя кадр за кадром по окружению, имеющемуся во время
выполнения. Если кадр глубоко вложен или если имеется много переменных,
этот поиск может оказаться дорогим. Рассмотрим, например, задачу поиска
значения @code{x} при вычислении выражения @code{(* x y z)} внутри
процедуры, возвращаемой при вычислении

\enlargethispage{\baselineskip}

@lisp
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
@end lisp

Поскольку выражение @code{let} --- всего лишь синтаксический сахар для
комбинации @code{lambda}, это выражение равносильно

@lisp
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
@end lisp

Каждый раз, когда @code{lookup-variable-value} ищет @code{x}, она должна
убедиться, что символ @code{x} не равен (через @code{eq?}) ни @code{y},
ни @code{z} (в первом кадре), ни @code{a}, @code{b}, @code{c}, @code{d},
ни @code{e} (во втором). Предположим, временно, что в наших программах
не используется @code{define} --- что переменные связываются только
через @code{lambda}. Поскольку в нашем языке лексическая сфера действия,
во время выполнения окружение любого выражения будет иметь структуру,
параллельную лексической структуре программы, в которой это выражение
встречается@footnote{Это не так, если мы разрешаем внутренние
определения и если мы от них не избавляемся.
См. упражнение @ref{Упражнение 5.43}.}. Таким образом, компилятор при
анализе вышеуказанного выражения может узнать, что каждый раз, когда
процедура применяется, переменная @code{x} в @code{(* x y z)} будет найдена на два
кадра выше текущего, и в этом кадре будет первая.

Мы можем это использовать и ввести новый вид операции поиска переменной,
@code{lexical-address-lookup}, который в качестве аргументов берет
окружение и (@newterm{lexical address}), состоящий из двух чисел: (@newterm{frame number}),
который показывает, сколько кадров надо пропустить, и (displacement
number), которое показывает, сколько переменных нужно пропустить в этом
кадре. @code{Lexical-address-lookup} будет возвращать значение
переменной, которая имеет указанный лексический адрес по отношению к
текущему окружению. Добавив в свою машину
@code{lexical-address-lookup}, мы можем научить компилятор порождать
код, который обращается к переменным через эту операцию, а не через
@code{lookup-variable-value}. Подобным образом, скомпилированный код
может использовать новую операцию @code{lexical-address-set!} вместо
@code{set-variable-value!}.

Для того, чтобы порождать такой код, компилятор должен уметь определять
лексический адрес переменной, ссылку на которую он намерен
скомпилировать. Лексический адрес переменной зависит от того, где она
находится в коде. Например, в следующей программе адрес @code{x} в
выражении @math{\langle}@var{e1}@math{\rangle} есть (2,0) --- на два
кадра назад и первая переменная в кадре. В этом же месте @code{y} имеет
адрес (0,0), а @code{c} --- адрес (1,2). В выражении
@math{\langle}@var{e2}@math{\rangle} @code{x} имеет адрес (1,0),
@code{y} адрес (1,1), а @code{c} адрес (0,2).

@lisp
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) @math{\langle}@var{e1}@math{\rangle})
      @math{\langle}@var{e2}@math{\rangle}
      (+ c d x))))
 3
 4)
@end lisp

Один из способов породить в компиляторе код, который использует
лексическую адресацию, состоит в поддержании структуры данных,
называемой (compile-time environment). Она следит за тем, какие
переменные в каких позициях и в каких кадрах будут находиться в
окружении времени выполнения, когда будет выполняться определенная
операция доступа к переменной. Окружение времени компиляции представляет
собой список кадров, каждый из которых содержит список переменных.
(Разумеется, с переменными не будет связано никаких значений, поскольку
во время компиляции значения не вычисляются.) Окружение времени
компиляции становится дополнительным аргументом процедуры @code{compile}
и передается всем генераторам кода. Вызов @code{compile} верхнего уровня
использует пустое окружение времени компиляции. Когда компилируется тело
@code{lambda}, @code{compile-lambda-body} расширяет это окружение
кадром, содержащим параметры процедуры, так что последовательность,
которая является телом, компилируется в этом расширенном окружении. В
каждой точке компиляции @code{compile-variable} и
@code{compile-assignment} используют окружение времени компиляции для
порождения соответствующих лексических адресов.

Упражнения с @ref{Упражнение 5.39} по @ref{Упражнение 5.43} описывают,
как завершить этот набросок лексической адресации и включить в
компилятор лексический поиск. В упражнении @ref{Упражнение 5.44}
описывается еще один способ использовать окружение времени компиляции.

@quotation
@strong{@anchor{Упражнение 5.39}Упражнение 5.39:} Напишите процедуру @code{lexical-address-lookup}, которая
реализует новую операцию поиска. Она должна брать два аргумента ---
лексический адрес и окружение времени выполнения, --- и возвращать
значение переменной, находящейся по указанному лексическому адресу.
@code{Lexical-address-lookup} должна сообщать об ошибке, если значением
переменной является символ @code{unassigned*}@footnote{Эта
модификация в поиске переменной требуется в том случае, если мы
реализуем просмотр текста и уничтожение внутренних определений
(упражнение @ref{Упражнение 5.43}). Чтобы лексическая адресация
работала, их следует уничтожить.}. Кроме того, напишите процедуру
@code{lexical-address-set!}, реализующую операцию, которая изменяет
значение переменной по указанному лексическому адресу.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.40}Упражнение 5.40:} Модифицируйте компилятор так, чтобы он поддерживал
окружение времени компиляции, как описано выше.  а именно, добавьте
аргумент-окружение к @code{compile} и всем генераторам кода, и
расширяйте его в @code{compile-lambda-body}.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.41}Упражнение 5.41:} Напишите процедуру @code{find-variable}, которая в
качестве аргументов принимает переменную и окружение времени
компиляции, а возвращает лексический адрес переменной по отношению к
этому окружению. Например, во фрагменте программы, который приведен
выше, окружение времени компиляции при обработке выражения
@math{\langle}@var{e1}@math{\rangle} равно
@code{((y z) (a b c d e) (x y))}. @code{find-variable} должна давать

@lisp
(find-variable 'c '((y z) (a b c d e) (x y)))
@i{(1 2)}
(find-variable 'x '((y z) (a b c d e) (x y)))
@i{(2 0)}
(find-variable 'w '((y z) (a b c d e) (x y)))
@i{not-found}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.42}Упражнение 5.42:} С помощью @code{find-variable} из
упражнения @ref{Упражнение 5.41} перепишите @code{compile-variable} и
@code{compile-assignment} так, чтобы они порождали команды лексической
адресации. В случаях, когда @code{find-variable} возвращает
@code{not-found} (то есть, когда переменной нет в окружении времени
компиляции), нужно заставлять генераторы кода использовать, как и
раньше, операции вычислителя для поиска связывания. (Единственное место,
где может оказаться переменная, не найденная во время компиляции ---
это глобальное окружение, которое является частью окружения времени
выполнения, но не окружения времени компиляции@footnote{Для доступа к
переменным в глобальном окружении нельзя использовать лексические
адреса, поскольку эти имена можно определять и переопределять
интерактивно когда угодно. Если внутренние определения вычищены, как в
упражнении @ref{Упражнение 5.43}, то компилятор видит только
определения верхнего уровня, которые действуют на глобальное окружение.
Компиляция определения не приводит к тому, что определяемое имя
вводится в окружение времени компиляции.}. Поэтому, если хотите, можете
заставить операции вычислителя искать сразу в глобальном окружении,
которое можно получить с помощью операции
@code{(op get-global-environment)}, а не в полном локальном окружении,
которое хранится в @code{env}.) Проверьте измененный компилятор на
нескольких простых примерах, например, на вложенной комбинации
@code{lambda} из начала этого раздела.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.43}Упражнение 5.43:} В разделе @ref{4.1.6} мы
показали, что определения внутри блочной структуры не следует
рассматривать как <<настоящие>> @code{define}. Вместо этого тело
процедуры следует интерпретировать так, как будто внутренние переменные,
определяемые через @code{define}, были введены как обыкновенные
переменные @code{lambda}, а их настоящее значение было им присвоено
через @code{set!}. В разделе @ref{4.1.6} и
упражнении @ref{Упражнение 4.16} показывалось, как можно изменить
метациклический интерпретатор и добиться этого просмотром внутренних
определений. Измените компилятор так, чтобы он проводил такое же
преобразование, прежде чем компилировать тело процедуры.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.44}Упражнение 5.44:} В этом разделе мы в основном говорили о том, как с
помощью окружения времени компиляции порождать лексические адреса.
Однако такие окружения можно использовать и другими способами.
Например, в упражнении @ref{Упражнение 5.38} мы повысили
эффективность скомпилированного кода путем явного кодирования
элементарных процедур. Наша реализация обрабатывала имена явно
кодируемых процедур как зарезервированные слова. Если бы какая-либо
программа переопределяла такое имя, механизм, описанный в
упражнении @ref{Упражнение 5.38}, продолжал бы явно кодировать его как
примитив и игнорировал бы новое связывание. Рассмотрим, например,
процедуру

@lisp
(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
@end lisp

которая вычисляет линейную комбинацию @code{x} и @code{y}. Мы могли бы
вызвать такую процедуру с аргументами @code{+matrix}, @code{matrix} и
четырьмя матрицами, но явно кодирующий компилятор по-прежнему вставлял
бы код для @code{+} и @code{} в @code{(+ (* a x) (* b y))} как для
примитивов @code{+} и @code{}. Измените компилятор с явным кодированием
так, чтобы он проверял окружение времени компиляции и на его основе
порождал правильный код для выражений, в которых встречаются имена
элементарных процедур. (Код будет работать правильно, пока программа не
применяет к этим именам @code{define} или @code{set!}.)
@end quotation

@endpage
@comment @subsection Interfacing Compiled Code to the Evaluator
@subsection Связь скомпилированного кода с вычислителем
@node	5.5.7,  , 5.5.6, 5.5

We have not yet explained how to load compiled code into the evaluator machine
or how to run it.  We will assume that the explicit-control-evaluator machine
has been defined as in @ref{5.4.4}, with the additional operations
specified in @ref{Footnote 38}.  We will implement a procedure
@code{compile-and-go} that compiles a Scheme expression, loads the resulting
object code into the evaluator machine, and causes the machine to run the code
in the evaluator global environment, print the result, and enter the
evaluator's driver loop.  We will also modify the evaluator so that interpreted
expressions can call compiled procedures as well as interpreted ones.  We can
then put a compiled procedure into the machine and use the evaluator to call
it:

@lisp
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
@i{;;; EC-Eval value:}
@i{ok}
@i{;;; EC-Eval input:}
(factorial 5)
@i{;;; EC-Eval value:}
@i{120}
@end lisp

@noindent
To allow the evaluator to handle compiled procedures (for example, to evaluate
the call to @code{factorial} above), we need to change the code at
@code{apply-dispatch} (@ref{5.4.1}) so that it recognizes compiled
procedures (as distinct from compound or primitive procedures) and transfers
control directly to the entry point of the compiled code:@footnote{Of course,
compiled procedures as well as interpreted procedures are compound
(nonprimitive).  For compatibility with the terminology used in the
explicit-control evaluator, in this section we will use ``compound'' to mean
interpreted (as opposed to compiled).}

@lisp
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
@end lisp

@noindent
Note the restore of @code{continue} at @code{compiled-apply}.  Recall that the
evaluator was arranged so that at @code{apply-dispatch}, the continuation would
be at the top of the stack.  The compiled code entry point, on the other hand,
expects the continuation to be in @code{continue}, so @code{continue} must be
restored before the compiled code is executed.

To enable us to run some compiled code when we start the evaluator machine, we
add a @code{branch} instruction at the beginning of the evaluator machine,
which causes the machine to go to a new entry point if the @code{flag} register
is set.@footnote{Now that the evaluator machine starts with a @code{branch}, we
must always initialize the @code{flag} register before starting the evaluator
machine.  To start the machine at its ordinary read-eval-print loop, we could
use

@lisp
(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
@end lisp
}

@lisp
(branch (label external-entry))      @r{; branches if @code{flag} is set}
read-eval-print-loop
  (perform (op initialize-stack))
  @dots{}
@end lisp

\enlargethispage{\baselineskip}

@noindent
@code{external-entry} assumes that the machine is started with @code{val}
containing the location of an instruction sequence that puts a result into
@code{val} and ends with @code{(goto (reg continue))}.  Starting at this entry
point jumps to the location designated by @code{val}, but first assigns
@code{continue} so that execution will return to @code{print-result}, which
prints the value in @code{val} and then goes to the beginning of the
evaluator's read-eval-print loop.@footnote{Since a compiled procedure is an
object that the system may try to print, we also modify the system print
operation @code{user-print} (from @ref{4.1.4}) so that it will not
attempt to print the components of a compiled procedure:

@lisp
(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((compiled-procedure? object)
         (display '<compiled-procedure>))
        (else (display object))))
@end lisp
}

@lisp
external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
@end lisp

@noindent
Now we can use the following procedure to compile a procedure definition,
execute the compiled code, and run the read-eval-print loop so we can try the
procedure.  Because we want the compiled code to return to the location in
@code{continue} with its result in @code{val}, we compile the expression with a
target of @code{val} and a linkage of @code{return}.  In order to transform the
object code produced by the compiler into executable instructions for the
evaluator register machine, we use the procedure @code{assemble} from the
register-machine simulator (@ref{5.2.2}).  We then initialize the
@code{val} register to point to the list of instructions, set the @code{flag}
so that the evaluator will go to @code{external-entry}, and start the
evaluator.

@lisp
(define (compile-and-go expression)
  (let ((instructions
         (assemble
          (statements
           (compile expression 'val 'return))
          eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
@end lisp

@noindent
If we have set up stack monitoring, as at the end of @ref{5.4.4}, we
can examine the stack usage of compiled code:

@lisp
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
@i{(total-pushes = 0 maximum-depth = 0)}
@i{;;; EC-Eval value:}
@i{ok}
@i{;;; EC-Eval input:}
(factorial 5)
@i{(total-pushes = 31 maximum-depth = 14)}
@i{;;; EC-Eval value:}
@i{120}
@end lisp

@noindent
Compare this example with the evaluation of @code{(factorial 5)} using the
interpreted version of the same procedure, shown at the end of
@ref{5.4.4}.  The interpreted version required 144 pushes and a maximum stack
depth of 28.  This illustrates the optimization that results from our
compilation strategy.

@subsubheading Interpretation and compilation

With the programs in this section, we can now experiment with the alternative
execution strategies of interpretation and compilation.@footnote{We can do even
better by extending the compiler to allow compiled code to call interpreted
procedures.  See @ref{Exercise 5.47}.}  An interpreter raises the machine to
the level of the user program; a compiler lowers the user program to the level
of the machine language.  We can regard the Scheme language (or any programming
language) as a coherent family of abstractions erected on the machine language.
Interpreters are good for interactive program development and debugging because
the steps of program execution are organized in terms of these abstractions,
and are therefore more intelligible to the programmer.  Compiled code can
execute faster, because the steps of program execution are organized in terms
of the machine language, and the compiler is free to make optimizations that
cut across the higher-level abstractions.@footnote{Independent of the strategy
of execution, we incur significant overhead if we insist that errors
encountered in execution of a user program be detected and signaled, rather
than being allowed to kill the system or produce wrong answers.  For example,
an out-of-bounds array reference can be detected by checking the validity of
the reference before performing it.  The overhead of checking, however, can be
many times the cost of the array reference itself, and a programmer should
weigh speed against safety in determining whether such a check is desirable.  A
good compiler should be able to produce code with such checks, should avoid
redundant checks, and should allow programmers to control the extent and type
of error checking in the compiled code.

Compilers for popular languages, such as C and C++, put hardly any
error-checking operations into running code, so as to make things run as fast
as possible.  As a result, it falls to programmers to explicitly provide error
checking.  Unfortunately, people often neglect to do this, even in critical
applications where speed is not a constraint.  Their programs lead fast and
dangerous lives.  For example, the notorious ``Worm'' that paralyzed the
Internet in 1988 exploited the @acronym{UNIX}(tm) operating system's failure to
check whether the input buffer has overflowed in the finger daemon. (See
@ref{Spafford 1989}.)}

The alternatives of interpretation and compilation also lead to different
strategies for porting languages to new computers. Suppose that we wish to
implement Lisp for a new machine.  One strategy is to begin with the
explicit-control evaluator of @ref{5.4} and translate its instructions
to instructions for the new machine.  A different strategy is to begin with the
compiler and change the code generators so that they generate code for the new
machine.  The second strategy allows us to run any Lisp program on the new
machine by first compiling it with the compiler running on our original Lisp
system, and linking it with a compiled version of the run-time
library.@footnote{Of course, with either the interpretation or the compilation
strategy we must also implement for the new machine storage allocation, input
and output, and all the various operations that we took as ``primitive'' in our
discussion of the evaluator and compiler.  One strategy for minimizing work
here is to write as many of these operations as possible in Lisp and then
compile them for the new machine.  Ultimately, everything reduces to a small
kernel (such as garbage collection and the mechanism for applying actual
machine primitives) that is hand-coded for the new machine.} Better yet, we can
compile the compiler itself, and run this on the new machine to compile other
Lisp programs.@footnote{This strategy leads to amusing tests of correctness of
the compiler, such as checking whether the compilation of a program on the new
machine, using the compiled compiler, is identical with the compilation of the
program on the original Lisp system.  Tracking down the source of differences
is fun but often frustrating, because the results are extremely sensitive to
minuscule details.}  Or we can compile one of the interpreters of
@ref{4.1} to produce an interpreter that runs on the new machine.

@quotation
@strong{@anchor{Exercise 5.45}Exercise 5.45:} By comparing the stack operations
used by compiled code to the stack operations used by the evaluator for the
same computation, we can determine the extent to which the compiler optimizes
use of the stack, both in speed (reducing the total number of stack operations)
and in space (reducing the maximum stack depth).  Comparing this optimized
stack use to the performance of a special-purpose machine for the same
computation gives some indication of the quality of the compiler.

@enumerate a.

@item
@ref{Exercise 5.27} asked you to determine, as a function of @math{n}, the number
of pushes and the maximum stack depth needed by the evaluator to compute @math{n!}
using the recursive factorial procedure given above.  @ref{Exercise 5.14} asked
you to do the same measurements for the special-purpose factorial machine shown
in @ref{Рисунок 5.11}. Now perform the same analysis using the compiled
@code{factorial} procedure.

Take the ratio of the number of pushes in the compiled version to the number of
pushes in the interpreted version, and do the same for the maximum stack depth.
Since the number of operations and the stack depth used to compute @math{n!}  are
linear in @math{n}, these ratios should approach constants as @math{n} becomes large.
What are these constants?  Similarly, find the ratios of the stack usage in the
special-purpose machine to the usage in the interpreted version.

Compare the ratios for special-purpose versus interpreted code to the ratios
for compiled versus interpreted code.  You should find that the special-purpose
machine does much better than the compiled code, since the hand-tailored
controller code should be much better than what is produced by our rudimentary
general-purpose compiler.

@item
Can you suggest improvements to the compiler that would help it generate code
that would come closer in performance to the hand-tailored version?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Exercise 5.46}Exercise 5.46:} Carry out an analysis like the
one in @ref{Exercise 5.45} to determine the effectiveness of compiling the
tree-recursive Fibonacci procedure

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
@end lisp

@noindent
compared to the effectiveness of using the special-purpose Fibonacci machine of
@ref{Рисунок 5.12}.  (For measurement of the interpreted performance, see
@ref{Exercise 5.29}.)  For Fibonacci, the time resource used is not linear in
@math{n;} hence the ratios of stack operations will not approach a limiting value
that is independent of @math{n}.
@end quotation

@quotation
@strong{@anchor{Exercise 5.47}Exercise 5.47:} This section described how to
modify the explicit-control evaluator so that interpreted code can call
compiled procedures.  Show how to modify the compiler so that compiled
procedures can call not only primitive procedures and compiled procedures, but
interpreted procedures as well.  This requires modifying
@code{compile-procedure-call} to handle the case of compound (interpreted)
procedures.  Be sure to handle all the same @code{target} and @code{linkage}
combinations as in @code{compile-proc-appl}.  To do the actual procedure
application, the code needs to jump to the evaluator's @code{compound-apply}
entry point.  This label cannot be directly referenced in object code (since
the assembler requires that all labels referenced by the code it is assembling
be defined there), so we will add a register called @code{compapp} to the
evaluator machine to hold this entry point, and add an instruction to
initialize it:

@lisp
 (assign compapp (label compound-apply))
 (branch (label external-entry)) @r{; branches if @code{flag} is set}
read-eval-print-loop @dots{}
@end lisp

To test your code, start by defining a procedure @code{f} that calls a
procedure @code{g}.  Use @code{compile-and-go} to compile the definition of
@code{f} and start the evaluator.  Now, typing at the evaluator, define
@code{g} and try to call @code{f}.
@end quotation

@quotation
@strong{@anchor{Exercise 5.48}Exercise 5.48:} The @code{compile-and-go}
interface implemented in this section is awkward, since the compiler can be
called only once (when the evaluator machine is started).  Augment the
compiler-interpreter interface by providing a @code{compile-and-run} primitive
that can be called from within the explicit-control evaluator as follows:

@lisp
@i{;;; EC-Eval input:}
(compile-and-run
 '(define (factorial n)
    (if (= n 1) 1 (* (factorial (- n 1)) n))))
@i{;;; EC-Eval value:}
@i{ok}
@i{;;; EC-Eval input:}
(factorial 5)
@i{;;; EC-Eval value:}
@i{120}
@end lisp
@end quotation

@quotation
@strong{@anchor{Exercise 5.49}Exercise 5.49:} As an alternative to using the
explicit-control evaluator's read-eval-print loop, design a register machine
that performs a read-compile-execute-print loop.  That is, the machine should
run a loop that reads an expression, compiles it, assembles and executes the
resulting code, and prints the result.  This is easy to run in our simulated
setup, since we can arrange to call the procedures @code{compile} and
@code{assemble} as ``register-machine operations.''
@end quotation

@quotation
@strong{@anchor{Exercise 5.50}Exercise 5.50:} Use the compiler to compile the
metacircular evaluator of @ref{4.1} and run this program using the
register-machine simulator.  (To compile more than one definition at a time,
you can package the definitions in a @code{begin}.)  The resulting interpreter
will run very slowly because of the multiple levels of interpretation, but
getting all the details to work is an instructive exercise.
@end quotation

@quotation
@strong{@anchor{Exercise 5.51}Exercise 5.51:} Develop a rudimentary
implementation of Scheme in C (or some other low-level language of your choice)
by translating the explicit-control evaluator of @ref{5.4} into C.  In
order to run this code you will need to also provide appropriate
storage-allocation routines and other run-time support.
@end quotation

@quotation
@strong{@anchor{Exercise 5.52}Exercise 5.52:} As a counterpoint to
@ref{Exercise 5.51}, modify the compiler so that it compiles Scheme procedures
into sequences of C instructions.  Compile the metacircular evaluator of
@ref{4.1} to produce a Scheme interpreter written in C.
@end quotation
