@comment
@comment             **********************************************************
@setfilename         sicp
@settitle            Structure and Interpretation of Computer Programs, 2e
@comment             Unofficial Texinfo Format
@comment
@set utfversion      2.andresraba5.6
@set utfversiondate  February 2, 2016
@comment
@comment             This file is licensed under a Creative Commons
@comment             Attribution-ShareAlike 4.0 International License
@comment             (http://creativecommons.org/licenses/by-sa/4.0/).
@comment
@comment             This is a Texinfo file with embedded LaTeX commands.
@comment             To compile it to PDF, enter `make' in current directory.
@comment             For more information about this file, see the text under
@comment             `@node UTF' below.
@comment
@comment             Various versions of sicp.texi and preformatted sicp.info
@comment             can be found at the following Web pages:
@comment
@comment                 http://www.neilvandyke.org/sicp-texi/
@comment                 http://sicpebook.wordpress.com/
@comment                 [add your own here]
@comment
@comment             **********************************************************

@comment HISTORY:
@comment
@comment * Version 1 (April, 2001) by Lytha Ayth.
@comment
@comment * Version 2 (April 20, 2001) by Lytha Ayth.
@comment
@comment * Version 2.nwv1 (March 11, 2002) by Neil W. Van Dyke.
@comment   Cosmetic change to heading in Info format, and comment changes.
@comment
@comment * Version 2.neilvandyke1 (February 10, 2003) by Neil W. Van Dyke
@comment   Correction to Exercise 1.39 formula, spotted by Steve VanDevender.
@comment   Added URL of Abelson and Sussman video lectures.
@comment
@comment * Version 2.neilvandyke2 (unreleased)
@comment
@comment * Version 2.neilvandyke3 (April 20, 2006) by Neil W. Van Dyke
@comment   Pedro Kr@"oger patch to add missing Lisp example.
@comment
@comment * Version 2.neilvandyke4 (January 10, 2007) by Neil W. Van Dyke
@comment   Brad Walker patch to add @code{@@dircategory} and @code{@@direntry}.
@comment
@comment * Version 2.andresraba1 (May 23, 2011) by Andres Raba.
@comment   Mathematics typeset in TeX, figures redrawn in vector graphics,
@comment   typeface changed, cross-references improved, hyperlinks added,
@comment   known errors and typos corrected.
@comment
@comment * Version 2.andresraba2 (November 21, 2011) by Andres Raba.
@comment   Minor change to the appearance of diagrams. Adjusted page layout.
@comment   Fixed some typos. License changed from CC BY-NC to CC BY-SA.
@comment
@comment * Version 2.andresraba3 (November 22, 2012) by Andres Raba.
@comment   Improved layout and pagination. Included list of figures.
@comment   Added punctuation to displayed math. Updated citation links.
@comment
@comment * (Version 2.andresraba4 is the pocket version, described in
@comment   sicp-pocket.texi.)
@comment
@comment * Version 2.andresraba5 (September 20, 2013) by Andres Raba.
@comment   Texinfo source is converted to LaTeX. Pages are redesigned.
@comment
@comment * (Versions 2.andresraba5.{1..3} with minor fixes and additions.)
@comment
@comment * Version 2.andresraba5.4 (February 3, 2015) by Andres Raba.
@comment   Added noncommercial clause to the license. Fixed broken links
@comment   and added more fulltext links to References. Brian Wignall
@comment   decapitalized function names at the beginning of sentences.
@comment
@comment * Version 2.andresraba5.5 (September 15, 2015) by Andres Raba.
@comment   Updated license to CC BY-SA 4.0. Redesigned title page.
@comment   Tinted chapter and section numbers. Fixed broken links.
@comment
@comment * Version 2.andresraba5.6 (February 2, 2016) by Andres Raba.
@comment   Improved microtypography in code listings. Removed manual
@comment   word breaks. Fixed broken links.
@comment


\frontmatter

\includepdf[scale=0.92]{coverpage.pdf}

\pagebreak

\vspace*{\fill}
\thispagestyle{empty}

\begin{small}
\begin{center}

@noindent
@copyright{}1996 by The Massachusetts Institute of Technology

@sp 1.26
@noindent
Structure and Interpretation of Computer Programs,@*
second edition

@sp 1.26
@noindent
Harold Abelson and Gerald Jay Sussman@*
with Julie Sussman, foreword by Alan J. Perlis

@sp 1.6
@noindent
@image{fig/icons/cc, 3mm,,,.pdf}
@image{fig/icons/by, 3mm,,,.pdf}
@image{fig/icons/sa, 3mm,,,.pdf}

@sp 0.4
@noindent
This work is licensed under a Creative Commons@*
Attribution-ShareAlike 4.0 International License@*
(@url{http://creativecommons.org/licenses/by-sa/4.0/, @acronym{CC BY-SA 4.0}}).
Based on a work at @url{http://mitpress.mit.edu/sicp/, mitpress.mit.edu}.

@sp 1.26
@noindent
The @acronym{MIT} Press@*
Cambridge, Massachusetts@*
London, England

@sp 1.26
@noindent
McGraw-Hill Book Company@*
New York, St. Louis, San Francisco,@*
Montreal, Toronto

@sp 1.26
@noindent
Unofficial Texinfo Format @url{http://sicpebook.wordpress.com, @value{utfversion}} (@value{utfversiondate}),@*
based on @url{http://www.neilvandyke.org/sicp-texi/, 2.neilvandyke4} (January 10, 2007).

\end{center}
\end{small}

\pagebreak

\tableofcontents

@dircategory The Algorithmic Language Scheme
@direntry
* SICP: (sicp). Structure and Interpretation of Computer Programs
@end direntry

@macro newterm{term}
@cindex \term\
@dfn{\term\}
@end macro

@setshortcontentsaftertitlepage

@titlepage
@titlefont{Structure and Interpretation}
@title  of Computer Programs
@subtitle Second Edition
@subtitle Unofficial Texinfo Format @value{utfversion}
@author Harold Abelson and Gerald Jay Sussman
@author with Julie Sussman
@author foreword by Alan J. Perlis
@end titlepage

@everyheading @| @| @thispage

@finalout

@node Top, UTF, (dir), (dir)

@ifinfo

@heading Structure and Interpretation of Computer Programs

@noindent
Second Edition@*
by Harold Abelson and Gerald Jay Sussman, with Julie Sussman@*
foreword by Alan J. Perlis@*
@copyright{} 1996 Massachusetts Institute of Technology

@noindent
Unofficial Texinfo Format version @value{utfversion} (@value{utfversiondate})

@end ifinfo

@menu
* UTF::              Unofficial Texinfo Format
* Dedication::       Dedication
* Foreword::         Foreword
* Preface::          Preface to the Second Edition
* Preface 1e::       Preface to the First Edition
* Acknowledgments::  Acknowledgments
* Chapter 1::        Building Abstractions with Procedures
* Chapter 2::        Building Abstractions with Data
* Chapter 3::        Modularity, Objects, and State
* Chapter 4::        Metalinguistic Abstraction
* Chapter 5::        Computing with Register Machines
* References::       References
* Index::            Index

@detailmenu
 --- The Detailed Node Listing ---

Programming in Lisp

* 1-1::              The Elements of Programming
* 1-2::              Procedures and the Processes They Generate
* 1-3::              Formulating Abstractions with Higher-Order Procedures

The Elements of Programming

* 1-1-1::            Expressions
* 1-1-2::            Naming and the Environment
* 1-1-3::            Evaluating Combinations
* 1-1-4::            Compound Procedures
* 1-1-5::            The Substitution Model for Procedure Application
* 1-1-6::            Conditional Expressions and Predicates
* 1-1-7::            Example: Square Roots by Newton's Method
* 1-1-8::            Procedures as Black-Box Abstractions

Procedures and the Processes They Generate

* 1-2-1::            Linear Recursion and Iteration
* 1-2-2::            Tree Recursion
* 1-2-3::            Orders of Growth
* 1-2-4::            Exponentiation
* 1-2-5::            Greatest Common Divisors
* 1-2-6::            Example: Testing for Primality

Formulating Abstractions with Higher-Order Procedures

* 1-3-1::            Procedures as Arguments
* 1-3-2::            Constructing Procedures Using @code{lambda}
* 1-3-3::            Procedures as General Methods
* 1-3-4::            Procedures as Returned Values

Building Abstractions with Data

* 2-1::              Introduction to Data Abstraction
* 2-2::              Hierarchical Data and the Closure Property
* 2-3::              Symbolic Data
* 2-4::              Multiple Representations for Abstract Data
* 2-5::              Systems with Generic Operations

Introduction to Data Abstraction

* 2-1-1::            Example: Arithmetic Operations for Rational Numbers
* 2-1-2::            Abstraction Barriers
* 2-1-3::            What Is Meant by Data?
* 2-1-4::            Extended Exercise: Interval Arithmetic

Hierarchical Data and the Closure Property

* 2-2-1::            Representing Sequences
* 2-2-2::            Hierarchical Structures
* 2-2-3::            Sequences as Conventional Interfaces
* 2-2-4::            Example: A Picture Language

Symbolic Data

* 2-3-1::            Quotation
* 2-3-2::            Example: Symbolic Differentiation
* 2-3-3::            Example: Representing Sets
* 2-3-4::            Example: Huffman Encoding Trees

Multiple Representations for Abstract Data

* 2-4-1::            Representations for Complex Numbers
* 2-4-2::            Tagged data
* 2-4-3::            Data-Directed Programming and Additivity

Systems with Generic Operations

* 2-5-1::            Generic Arithmetic Operations
* 2-5-2::            Combining Data of Different Types
* 2-5-3::            Example: Symbolic Algebra

Modularity, Objects, and State

* 3-1::              Assignment and Local State
* 3-2::              The Environment Model of Evaluation
* 3-3::              Modeling with Mutable Data
* 3-4::              Concurrency: Time Is of the Essence
* 3-5::              Streams

Assignment and Local State

* 3-1-1::            Local State Variables
* 3-1-2::            The Benefits of Introducing Assignment
* 3-1-3::            The Costs of Introducing Assignment

The Environment Model of Evaluation

* 3-2-1::            The Rules for Evaluation
* 3-2-2::            Applying Simple Procedures
* 3-2-3::            Frames as the Repository of Local State
* 3-2-4::            Internal Definitions

Modeling with Mutable Data

* 3-3-1::            Mutable List Structure
* 3-3-2::            Representing Queues
* 3-3-3::            Representing Tables
* 3-3-4::            A Simulator for Digital Circuits
* 3-3-5::            Propagation of Constraints

Concurrency: Time Is of the Essence

* 3-4-1::            The Nature of Time in Concurrent Systems
* 3-4-2::            Mechanisms for Controlling Concurrency

Streams

* 3-5-1::            Streams Are Delayed Lists
* 3-5-2::            Infinite Streams
* 3-5-3::            Exploiting the Stream Paradigm
* 3-5-4::            Streams and Delayed Evaluation
* 3-5-5::            Modularity of Functional Programs and Modularity of
                     Objects

Metalinguistic Abstraction

* 4-1::              The Metacircular Evaluator
* 4-2::              Variations on a Scheme -- Lazy Evaluation
* 4-3::              Variations on a Scheme -- Nondeterministic Computing
* 4-4::              Logic Programming

The Metacircular Evaluator

* 4-1-1::            The Core of the Evaluator
* 4-1-2::            Representing Expressions
* 4-1-3::            Evaluator Data Structures
* 4-1-4::            Running the Evaluator as a Program
* 4-1-5::            Data as Programs
* 4-1-6::            Internal Definitions
* 4-1-7::            Separating Syntactic Analysis from Execution

Variations on a Scheme -- Lazy Evaluation

* 4-2-1::            Normal Order and Applicative Order
* 4-2-2::            An Interpreter with Lazy Evaluation
* 4-2-3::            Streams as Lazy Lists

Variations on a Scheme -- Nondeterministic Computing

* 4-3-1::            Amb and Search
* 4-3-2::            Examples of Nondeterministic Programs
* 4-3-3::            Implementing the @code{amb} Evaluator

Logic Programming

* 4-4-1::            Deductive Information Retrieval
* 4-4-2::            How the Query System Works
* 4-4-3::            Is Logic Programming Mathematical Logic?
* 4-4-4::            Implementing the Query System

Implementing the Query System

* 4-4-4-1::          The Driver Loop and Instantiation
* 4-4-4-2::          The Evaluator
* 4-4-4-3::          Finding Assertions by Pattern Matching
* 4-4-4-4::          Rules and Unification
* 4-4-4-5::          Maintaining the Data Base
* 4-4-4-6::          Stream Operations
* 4-4-4-7::          Query Syntax Procedures
* 4-4-4-8::          Frames and Bindings

Computing with Register Machines

* 5-1::              Designing Register Machines
* 5-2::              A Register-Machine Simulator
* 5-3::              Storage Allocation and Garbage Collection
* 5-4::              The Explicit-Control Evaluator
* 5-5::              Compilation

Designing Register Machines

* 5-1-1::            A Language for Describing Register Machines
* 5-1-2::            Abstraction in Machine Design
* 5-1-3::            Subroutines
* 5-1-4::            Using a Stack to Implement Recursion
* 5-1-5::            Instruction Summary

A Register-Machine Simulator

* 5-2-1::            The Machine Model
* 5-2-2::            The Assembler
* 5-2-3::            Generating Execution Procedures for Instructions
* 5-2-4::            Monitoring Machine Performance

Storage Allocation and Garbage Collection

* 5-3-1::            Memory as Vectors
* 5-3-2::            Maintaining the Illusion of Infinite Memory

Registers and operations

* 5-4-1::            The Core of the Explicit-Control Evaluator
* 5-4-2::            Sequence Evaluation and Tail Recursion
* 5-4-3::            Conditionals, Assignments, and Definitions
* 5-4-4::            Running the Evaluator

An overview of the compiler

* 5-5-1::            Structure of the Compiler
* 5-5-2::            Compiling Expressions
* 5-5-3::            Compiling Combinations
* 5-5-4::            Combining Instruction Sequences
* 5-5-5::            An Example of Compiled Code
* 5-5-6::            Lexical Addressing
* 5-5-7::            Interfacing Compiled Code to the Evaluator

@end detailmenu
@end menu

@unnumbered Unofficial Texinfo Format
@node    UTF, Dedication, Top, Top

This is the second edition @acronym{SICP} book, from Unofficial Texinfo
Format.

You are probably reading it in an Info hypertext browser, such as the Info
mode of Emacs.  You might alternatively be reading it @TeX{}-formatted on your
screen or printer, though that would be silly.  And, if printed, expensive.

The freely-distributed official @acronym{HTML}-and-@acronym{GIF} format was
first converted personally to Unofficial Texinfo Format (@acronym{UTF})
version 1 by Lytha Ayth during a long Emacs lovefest weekend in April, 2001.

The @acronym{UTF} is easier to search than the @acronym{HTML} format.  It is
also much more accessible to people running on modest computers, such as
donated '386-based PCs.  A 386 can, in theory, run Linux, Emacs, and a Scheme
interpreter simultaneously, but most 386s probably can't also run both Netscape
and the necessary X Window System without prematurely introducing budding young
underfunded hackers to the concept of @newterm{thrashing}.  @acronym{UTF} can also fit
uncompressed on a 1.44@acronym{MB} floppy diskette, which may come in handy for
installing @acronym{UTF} on PCs that do not have Internet or @acronym{LAN} access.

The Texinfo conversion has been a straight transliteration, to the extent
possible.  Like the @TeX{}-to-@acronym{HTML} conversion, this was not without
some introduction of breakage.  In the case of Unofficial Texinfo Format,
figures have suffered an amateurish resurrection of the lost art of
@acronym{ASCII}.  Also, it's quite possible that some errors of ambiguity
were introduced during the conversion of some of the copious superscripts (`\^{}')
and subscripts (`\_').  Divining @emph{which} has been left as an exercise to
the reader. But at least we don't put our brave astronauts at risk by encoding
the @emph{greater-than-or-equal} symbol as @code{<u>\&gt;</u>}.

If you modify @file{sicp.texi} to correct errors or improve the
@acronym{ASCII} art, then update the @code{@@set utfversion @value{utfversion}}
line to reflect your delta.  For example, if you started with Lytha's version
@code{1}, and your name is Bob, then you could name your successive versions
@code{1.bob1}, @code{1.bob2}, @dots{} @code{1.bob@i{n}}.  Also update
@code{utfversiondate}.  If you want to distribute your version on the Web, then
embedding the string ``sicp.texi'' somewhere in the file or Web page will make
it easier for people to find with Web search engines.

It is believed that the Unofficial Texinfo Format is in keeping with the
spirit of the graciously freely-distributed @acronym{HTML} version.  But you
never know when someone's armada of lawyers might need something to do, and get
their shorts all in a knot over some benign little thing, so think twice before
you use your full name or distribute Info, @acronym{DVI}, PostScript, or
@acronym{PDF} formats that might embed your account or machine name.

@sp 0.5
@noindent
@i{Peath, Lytha Ayth}

@sp 1.0
@noindent
@b{Addendum:} See also the @acronym{SICP} video lectures by Abelson and Sussman:@*
at @url{http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/, @acronym{MIT CSAIL}} or
@url{http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/, @acronym{MIT OCW}}.

@sp 0.5
@noindent
@b{Second Addendum:} Above is the original introduction to the @acronym{UTF}
from 2001. Ten years later, @acronym{UTF} has been transformed: mathematical
symbols and formulas are properly typeset, and figures drawn in
vector graphics. The original text formulas and @acronym{ASCII} art figures
are still there in the Texinfo source, but will display only when compiled
to Info output. At the dawn of e-book readers and tablets, reading a
@acronym{PDF} on screen is officially not silly anymore. Enjoy!

\enlargethispage{\baselineskip}

@sp 0.5
@noindent
@i{A.R, May, 2011}

@unnumbered Dedication
@node    Dedication, Foreword, UTF, Top

\lettrine{T}{his book is dedicated}, in respect and admiration, to the spirit that lives in
the computer.

@quotation
``I think that it's extraordinarily important that we in computer science keep
fun in computing.  When it started out, it was an awful lot of fun.  Of course,
the paying customers got shafted every now and then, and after a while we began
to take their complaints seriously.  We began to feel as if we really were
responsible for the successful, error-free perfect use of these machines.  I
don't think we are.  I think we're responsible for stretching them, setting
them off in new directions, and keeping fun in the house.  I hope the field of
computer science never loses its sense of fun.  Above all, I hope we don't
become missionaries.  Don't feel as if you're Bible salesmen.  The world has
too many of those already.  What you know about computing other people will
learn.  Don't feel as if the key to successful computing is only in your hands.
What's in your hands, I think and hope, is intelligence: the ability to see the
machine as more than when you were first led up to it, that you can make it
more.''

\enlargethispage{\baselineskip}

@noindent
---Alan J. Perlis (April 1, 1922 -- February 7, 1990)
@end quotation

@unnumbered Foreword
@node    Foreword, Preface, Dedication, Top

@c @sp -0.6

\lettrine{E}{ducators, generals, dieticians}, psychologists, and parents program.  Ar\-mies,
students, and some societies are programmed.  An assault on large problems
employs a succession of programs, most of which spring into existence en route.
These programs are rife with issues that appear to be particular to the problem
at hand.  To appreciate programming as an intellectual activity in its own
right you must turn to computer programming; you must read and write computer
programs---many of them.  It doesn't matter much what the programs are about or
what applications they serve.  What does matter is how well they perform and
how smoothly they fit with other programs in the creation of still greater
programs.  The programmer must seek both perfection of part and adequacy of
collection.  In this book the use of ``program'' is focused on the creation,
execution, and study of programs written in a dialect of Lisp for execution on
a digital computer.  Using Lisp we restrict or limit not what we may program,
but only the notation for our program descriptions.

Our traffic with the subject matter of this book involves us with three foci of
phenomena: the human mind, collections of computer programs, and the computer.
Every computer program is a model, hatched in the mind, of a real or mental
process.  These processes, arising from human experience and thought, are huge
in number, intricate in detail, and at any time only partially understood.
They are modeled to our permanent satisfaction rarely by our computer programs.
Thus even though our programs are carefully handcrafted discrete collections of
symbols, mosaics of interlocking functions, they continually evolve: we change
them as our perception of the model deepens, enlarges, generalizes until the
model ultimately attains a metastable place within still another model with
which we struggle.  The source of the exhilaration associated with computer
programming is the continual unfolding within the mind and on the computer of
mechanisms expressed as programs and the explosion of perception they generate.
If art interprets our dreams, the computer executes them in the guise of
programs!

For all its power, the computer is a harsh taskmaster.  Its programs must be
correct, and what we wish to say must be said accurately in every detail.  As
in every other symbolic activity, we become convinced of program truth through
argument.  Lisp itself can be assigned a semantics (another model, by the way),
and if a program's function can be specified, say, in the predicate calculus,
the proof methods of logic can be used to make an acceptable correctness
argument.  Unfortunately, as programs get large and complicated, as they almost
always do, the adequacy, consistency, and correctness of the specifications
themselves become open to doubt, so that complete formal arguments of
correctness seldom accompany large programs.  Since large programs grow from
small ones, it is crucial that we develop an arsenal of standard program
structures of whose correctness we have become sure---we call them idioms---and
learn to combine them into larger structures using organizational techniques of
proven value.  These techniques are treated at length in this book, and
understanding them is essential to participation in the Promethean enterprise
called programming.  More than anything else, the uncovering and mastery of
powerful organizational techniques accelerates our ability to create large,
significant programs.  Conversely, since writing large programs is very taxing,
we are stimulated to invent new methods of reducing the mass of function and
detail to be fitted into large programs.

Unlike programs, computers must obey the laws of physics.  If they wish to
perform rapidly---a few nanoseconds per state change---they must transmit
electrons only small distances (at most @math{1 {1\over2}} feet). The heat generated by
the huge number of devices so concentrated in space has to be removed.  An
exquisite engineering art has been developed balancing between multiplicity of
function and density of devices.  In any event, hardware always operates at a
level more primitive than that at which we care to program.  The processes that
transform our Lisp programs to ``machine'' programs are themselves abstract
models which we program.  Their study and creation give a great deal of insight
into the organizational programs associated with programming arbitrary models.
Of course the computer itself can be so modeled.  Think of it: the behavior of
the smallest physical switching element is modeled by quantum mechanics
described by differential equations whose detailed behavior is captured by
numerical approximations represented in computer programs executing on
computers composed of @dots{}!

It is not merely a matter of tactical convenience to separately identify the
three foci.  Even though, as they say, it's all in the head, this logical
separation induces an acceleration of symbolic traffic between these foci whose
richness, vitality, and potential is exceeded in human experience only by the
evolution of life itself.  At best, relationships between the foci are
metastable.  The computers are never large enough or fast enough.  Each
breakthrough in hardware technology leads to more massive programming
enterprises, new organizational principles, and an enrichment of abstract
models.  Every reader should ask himself periodically ``Toward what end, toward
what end?''---but do not ask it too often lest you pass up the fun of
programming for the constipation of bittersweet philosophy.

Among the programs we write, some (but never enough) perform a precise
mathematical function such as sorting or finding the maximum of a sequence of
numbers, determining primality, or finding the square root.  We call such
programs algorithms, and a great deal is known of their optimal behavior,
particularly with respect to the two important parameters of execution time and
data storage requirements.  A programmer should acquire good algorithms and
idioms.  Even though some programs resist precise specifications, it is the
responsibility of the programmer to estimate, and always to attempt to improve,
their performance.

Lisp is a survivor, having been in use for about a quarter of a century.  Among
the active programming languages only Fortran has had a longer life.  Both
languages have supported the programming needs of important areas of
application, Fortran for scientific and engineering computation and Lisp for
artificial intelligence.  These two areas continue to be important, and their
programmers are so devoted to these two languages that Lisp and Fortran may
well continue in active use for at least another quarter-century.

Lisp changes.  The Scheme dialect used in this text has evolved from the
original Lisp and differs from the latter in several important ways, including
static scoping for variable binding and permitting functions to yield functions
as values.  In its semantic structure Scheme is as closely akin to Algol 60 as
to early Lisps.  Algol 60, never to be an active language again, lives on in
the genes of Scheme and Pascal.  It would be difficult to find two languages
that are the communicating coin of two more different cultures than those
gathered around these two languages.  Pascal is for building
pyramids---imposing, breathtaking, static structures built by armies pushing
heavy blocks into place.  Lisp is for building organisms---imposing,
breathtaking, dynamic structures built by squads fitting fluctuating myriads of
simpler organisms into place.  The organizing principles used are the same in
both cases, except for one extraordinarily important difference: The
discretionary exportable functionality entrusted to the individual Lisp
programmer is more than an order of magnitude greater than that to be found
within Pascal enterprises.  Lisp programs inflate libraries with functions
whose utility transcends the application that produced them.  The list, Lisp's
native data structure, is largely responsible for such growth of utility.  The
simple structure and natural applicability of lists are reflected in functions
that are amazingly nonidiosyncratic.  In Pascal the plethora of declarable data
structures induces a specialization within functions that inhibits and
penalizes casual cooperation.  It is better to have 100 functions operate on
one data structure than to have 10 functions operate on 10 data structures.  As
a result the pyramid must stand unchanged for a millennium; the organism must
evolve or perish.

To illustrate this difference, compare the treatment of material and exercises
within this book with that in any first-course text using Pascal.  Do not labor
under the illusion that this is a text digestible at @acronym{MIT} only,
peculiar to the breed found there.  It is precisely what a serious book on
programming Lisp must be, no matter who the student is or where it is used.

Note that this is a text about programming, unlike most Lisp books, which are
used as a preparation for work in artificial intelligence.  After all, the
critical programming concerns of software engineering and artificial
intelligence tend to coalesce as the systems under investigation become larger.
This explains why there is such growing interest in Lisp outside of artificial
intelligence.

As one would expect from its goals, artificial intelligence research generates
many significant programming problems.  In other programming cultures this
spate of problems spawns new languages.  Indeed, in any very large programming
task a useful organizing principle is to control and isolate traffic within the
task modules via the invention of language.  These languages tend to become
less primitive as one approaches the boundaries of the system where we humans
interact most often.  As a result, such systems contain complex
language-processing functions replicated many times.  Lisp has such a simple
syntax and semantics that parsing can be treated as an elementary task.  Thus
parsing technology plays almost no role in Lisp programs, and the construction
of language processors is rarely an impediment to the rate of growth and change
of large Lisp systems.  Finally, it is this very simplicity of syntax and
semantics that is responsible for the burden and freedom borne by all Lisp
programmers.  No Lisp program of any size beyond a few lines can be written
without being saturated with discretionary functions.  Invent and fit; have
fits and reinvent!  We toast the Lisp programmer who pens his thoughts within
nests of parentheses.

@sp 0.5
@noindent
Alan J. Perlis@*
New Haven, Connecticut

@unnumbered Preface to the Second Edition
@node    Preface, Preface 1e, Foreword, Top

@quotation
Is it possible that software is not like anything else, that it is meant to be
discarded: that the whole point is to always see it as a soap bubble?

---Alan J. Perlis
@end quotation

@c @sp 0.7

@noindent
\lettrine{T}{he material in this book} has been the basis of @acronym{MIT}'s entry-level
computer science subject since 1980.  We had been teaching this material for
four years when the first edition was published, and twelve more years have
elapsed until the appearance of this second edition.  We are pleased that our
work has been widely adopted and incorporated into other texts.  We have seen
our students take the ideas and programs in this book and build them in as the
core of new computer systems and languages.  In literal realization of an
ancient Talmudic pun, our students have become our builders.  We are lucky to
have such capable students and such accomplished builders.

In preparing this edition, we have incorporated hundreds of clarifications
suggested by our own teaching experience and the comments of colleagues at
@acronym{MIT} and elsewhere.  We have redesigned most of the major programming
systems in the book, including the generic-arithmetic system, the interpreters,
the register-machine simulator, and the compiler; and we have rewritten all the
program examples to ensure that any Scheme implementation conforming to the
@acronym{IEEE} Scheme standard (@ref{IEEE 1990}) will be able to run the
code.

This edition emphasizes several new themes.  The most important of these is the
central role played by different approaches to dealing with time in
computational models: objects with state, concurrent programming, functional
programming, lazy evaluation, and nondeterministic programming.  We have
included new sections on concurrency and nondeterminism, and we have tried to
integrate this theme throughout the book.

The first edition of the book closely followed the syllabus of our
@acronym{MIT} one-semester subject.  With all the new material in the second
edition, it will not be possible to cover everything in a single semester, so
the instructor will have to pick and choose.  In our own teaching, we sometimes
skip the section on logic programming (@ref{4.4}), we have students use
the register-machine simulator but we do not cover its implementation (@ref{5.2}),
and we give only a cursory overview of the compiler (@ref{5.5}).
Even so, this is still an intense course.  Some instructors may
wish to cover only the first three or four chapters, leaving the other material
for subsequent courses.

The World-Wide-Web site @url{http://mitpress.mit.edu/sicp} provides
support for users of this book.  This includes programs from the book, sample
programming assignments, supplementary materials, and downloadable
implementations of the Scheme dialect of Lisp.

@unnumbered Preface to the First Edition
@node    Preface 1e, Acknowledgments, Preface, Top

@c @sp -0.6
@quotation
A computer is like a violin.  You can imagine a novice trying first a
phonograph and then a violin.  The latter, he says, sounds terrible.  That is
the argument we have heard from our humanists and most of our computer
scientists.  Computer programs are good, they say, for particular purposes, but
they aren't flexible.  Neither is a violin, or a typewriter, until you learn
how to use it.

---Marvin Minsky, ``Why Programming Is a Good Medium for Expressing
Poorly-Understood and Sloppily-Formulated Ideas''
@end quotation

@c @sp 0.8

@noindent
\lettrine[lhang=0.17]{``T}{he Structure and Interpretation of Computer Programs''} is the entry-level
subject in computer science at the Massachusetts Institute of Technology.  It
is required of all students at @acronym{MIT} who major in electrical
engineering or in computer science, as one-fourth of the ``common core
curriculum,'' which also includes two subjects on circuits and linear systems
and a subject on the design of digital systems.  We have been involved in the
development of this subject since 1978, and we have taught this material in its
present form since the fall of 1980 to between 600 and 700 students each year.
Most of these students have had little or no prior formal training in
computation, although many have played with computers a bit and a few have had
extensive programming or hardware-design experience.

Our design of this introductory computer-science subject reflects two major
concerns.  First, we want to establish the idea that a computer language is not
just a way of getting a computer to perform operations but rather that it is a
novel formal medium for expressing ideas about methodology.  Thus, programs
must be written for people to read, and only incidentally for machines to
execute.  Second, we believe that the essential material to be addressed by a
subject at this level is not the syntax of particular programming-language
constructs, nor clever algorithms for computing particular functions
efficiently, nor even the mathematical analysis of algorithms and the
foundations of computing, but rather the techniques used to control the
intellectual complexity of large software systems.

Our goal is that students who complete this subject should have a good feel for
the elements of style and the aesthetics of programming.  They should have
command of the major techniques for controlling complexity in a large
system. They should be capable of reading a 50-page-long program, if it is
written in an exemplary style. They should know what not to read, and what they
need not understand at any moment.  They should feel secure about modifying a
program, retaining the spirit and style of the original author.

These skills are by no means unique to computer programming.  The techniques we
teach and draw upon are common to all of engineering design.  We control
complexity by building abstractions that hide details when appropriate.  We
control complexity by establishing conventional interfaces that enable us to
construct systems by combining standard, well-understood pieces in a ``mix and
match'' way.  We control complexity by establishing new languages for
describing a design, each of which emphasizes particular aspects of the design
and deemphasizes others.

Underlying our approach to this subject is our conviction that ``computer
science'' is not a science and that its significance has little to do with
computers.  The computer revolution is a revolution in the way we think and in
the way we express what we think.  The essence of this change is the emergence
of what might best be called @newterm{procedural epistemology}---the study of
the structure of knowledge from an imperative point of view, as opposed to the
more declarative point of view taken by classical mathematical subjects.
Mathematics provides a framework for dealing precisely with notions of ``what
is.''  Computation provides a framework for dealing precisely with notions of
``how to.''

In teaching our material we use a dialect of the programming language Lisp.  We
never formally teach the language, because we don't have to.  We just use it,
and students pick it up in a few days.  This is one great advantage of
Lisp-like languages: They have very few ways of forming compound expressions,
and almost no syntactic structure.  All of the formal properties can be covered
in an hour, like the rules of chess.  After a short time we forget about
syntactic details of the language (because there are none) and get on with the
real issues---figuring out what we want to compute, how we will decompose
problems into manageable parts, and how we will work on the parts.  Another
advantage of Lisp is that it supports (but does not enforce) more of the
large-scale strategies for modular decomposition of programs than any other
language we know.  We can make procedural and data abstractions, we can use
higher-order functions to capture common patterns of usage, we can model local
state using assignment and data mutation, we can link parts of a program with
streams and delayed evaluation, and we can easily implement embedded languages.
All of this is embedded in an interactive environment with excellent support
for incremental program design, construction, testing, and debugging.  We thank
all the generations of Lisp wizards, starting with John McCarthy, who have
fashioned a fine tool of unprecedented power and elegance.

Scheme, the dialect of Lisp that we use, is an attempt to bring together the
power and elegance of Lisp and Algol.  From Lisp we take the metalinguistic
power that derives from the simple syntax, the uniform representation of
programs as data objects, and the garbage-collected heap-allocated data.  From
Algol we take lexical scoping and block structure, which are gifts from the
pioneers of programming-language design who were on the Algol committee.  We
wish to cite John Reynolds and Peter Landin for their insights into the
relationship of Church's λ-calculus to the structure of programming
languages.  We also recognize our debt to the mathematicians who scouted out
this territory decades before computers appeared on the scene.  These pioneers
include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.

@unnumbered Acknowledgments
@node       Acknowledgments, Chapter 1, Preface 1e, Top

\lettrine[findent=1pt]{W}{e would like to thank} the many people who have helped us develop this book and
this curriculum.

Our subject is a clear intellectual descendant of ``6.231,'' a wonderful
subject on programming linguistics and the λ-calculus taught at
@acronym{MIT} in the late 1960s by Jack Wozencraft and Arthur Evans, Jr.

We owe a great debt to Robert Fano, who reorganized @acronym{MIT}'s
introductory curriculum in electrical engineering and computer science to
emphasize the principles of engineering design.  He led us in starting out on
this enterprise and wrote the first set of subject notes from which this book
evolved.

Much of the style and aesthetics of programming that we try to teach were
developed in conjunction with Guy Lewis Steele Jr., who collaborated with
Gerald Jay Sussman in the initial development of the Scheme language.  In
addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will
Clinger have taught us many of the techniques of the functional programming
community that appear in this book.

Joel Moses taught us about structuring large systems.  His experience with the
Macsyma system for symbolic computation provided the insight that one should
avoid complexities of control and concentrate on organizing the data to reflect
the real structure of the world being modeled.

Marvin Minsky and Seymour Papert formed many of our attitudes about programming
and its place in our intellectual lives.  To them we owe the understanding that
computation provides a means of expression for exploring ideas that would
otherwise be too complex to deal with precisely.  They emphasize that a
student's ability to write and modify programs provides a powerful medium in
which exploring becomes a natural activity.

We also strongly agree with Alan Perlis that programming is lots of fun and we
had better be careful to support the joy of programming.  Part of this joy
derives from observing great masters at work.  We are fortunate to have been
apprentice programmers at the feet of Bill Gosper and Richard Greenblatt.

It is difficult to identify all the people who have contributed to the
development of our curriculum.  We thank all the lecturers, recitation
instructors, and tutors who have worked with us over the past fifteen years and
put in many extra hours on our subject, especially Bill Siebert, Albert Meyer,
Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein and
Peter Szolovits.  We would like to specially acknowledge the outstanding
teaching contributions of Franklyn Turbak, now at Wellesley; his work in
undergraduate instruction set a standard that we can all aspire to.  We are
grateful to Jerry Saltzer and Jim Miller for helping us grapple with the
mysteries of concurrency, and to Peter Szolovits and David McAllester for their
contributions to the exposition of nondeterministic evaluation in @ref{Chapter
4}.

Many people have put in significant effort presenting this material at other
universities.  Some of the people we have worked closely with are Jacob
Katzenelson at the Technion, Hardy Mayer at the University of California at
Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the
Norwegian University of Science and Technology.  We are exceptionally proud of
our colleagues who have received major teaching awards for their adaptations of
this subject at other universities, including Kenneth Yip at Yale, Brian Harvey
at the University of California at Berkeley, and Dan Huttenlocher at Cornell.

Al Moy@'e arranged for us to teach this material to engineers at
Hewlett-Packard, and for the production of videotapes of these lectures.  We
would like to thank the talented instructors---in particular Jim Miller, Bill
Siebert, and Mike Eisenberg---who have designed continuing education courses
incorporating these tapes and taught them at universities and industry all over
the world.

Many educators in other countries have put in significant work translating the
first edition.  Michel Briand, Pierre Chamard, and Andr@'e Pic produced a
French edition; Susanne Daniels-Herold produced a German edition; and Fumio
Motoyoshi produced a Japanese edition.  We do not know who produced the Chinese
edition, but we consider it an honor to have been selected as the subject of an
``unauthorized'' translation.

It is hard to enumerate all the people who have made technical contributions to
the development of the Scheme systems we use for instructional purposes.  In
addition to Guy Steele, principal wizards have included Chris Hanson, Joe
Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams.  Others who have put
in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft,
Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass,
Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony
Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.

Beyond the @acronym{MIT} implementation, we would like to thank the many people
who worked on the @acronym{IEEE} Scheme standard, including William Clinger and
Jonathan Rees, who edited the @math{\rm R^4RS}, and Chris Haynes, David Bartley,
Chris Hanson, and Jim Miller, who prepared the @acronym{IEEE} standard.

Dan Friedman has been a long-time leader of the Scheme community.  The
community's broader work goes beyond issues of language design to encompass
significant educational innovations, such as the high-school curriculum based
on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and by
Brian Harvey and Matthew Wright.

We appreciate the work of those who contributed to making this a real book,
especially Terry Ehling, Larry Cohen, and Paul Bethge at the @acronym{MIT}
Press.  Ella Mazel found the wonderful cover image.  For the second edition we
are particularly grateful to Bernard and Ella Mazel for help with the book
design, and to David Jones, @TeX{} wizard extraordinaire.  We also are indebted
to those readers who made penetrating comments on the new draft: Jacob
Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who did unto
this book as Julie did unto his book @cite{Simply Scheme}.

Finally, we would like to acknowledge the support of the organizations that
have encouraged this work over the years, including support from
Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support
from @acronym{DARPA}, made possible by Bob Kahn.

\mainmatter

@comment @chapter Building Abstractions with Procedures
@chapter Построение абстракций с помощью процедур
@node    Глава 1, Глава 2, Acknowledgments, Вверх

@quotation
Действия, в которых ум проявляет свои способности в отношении своих простых
идей, суть главным образом следующие три: 1. Соединение нескольких простых
идей в одну сложную; так образовались все сложные идеи,  2. Сведение вместе
двух идей, все равно, простых или сложных, и сопоставление их друг с другом
так, чтобы обозревать их сразу, но не соединять в одну; так ум приобретает все
свои идеи отношений, 3. Обособление идей от всех других идей, сопутствующих
им в реальной действительности; это действие называется абстрагированием, и
при его помощи образованы все общие идеи в уме.

---John Locke, @emph{An Essay Concerning Human Understanding} (1690)
@end quotation

@c @sp 1.0

@noindent
\lettrine[findent=1pt]{М}{ы собираемся изучать} понятие @newterm{computational
processes} (вычислительный процесс). Вычислительные процессы - это абстрактные
существа, которые живут в компьютерах. Развиваясь, процессы манипулируют
абстракциями другого типа, которые называются @newterm{data} (данные). Эволюция
процесса направляется набором правил, называемым @newterm{prorgam} (программа).
В сущности, мы заколдовываем духов компьютера с помощью своих чар.

Вычислительные процессы и вправду вполне соответствуют представлениям
колдуна о ду́хах. Их нельзя увидеть или потрогать. Они вообще сделаны не
из вещества. В то же время они совершенно реальны. Они могут выполнять
умственную работу, могут отвечать на вопросы. Они способны
воздействовать на внешний мир, оплачивая счета в банке или управляя
рукой робота на заводе. Программы, которыми мы пользуемся для заклинания
процессов, похожи на чары колдуна. Они тщательно составляются из
символических выражений на сложных и немногим известных @newterm{programming
languages} (языках программирования), описывающих задачи, которые мы хотим
поручить процессам.

На исправно работающем компьютере вычислительный процесс выполняет программы
точно и безошибочно. Таким образом, подобно ученику чародея, программисты-
новички должны научиться понимать и предсказывать последствия своих заклинаний.
Даже мелкие ошибки (их обычно называют @newterm{bugs} (блохами) или
@newterm{glitches} (глюками), могут привести к сложным и непредсказуемым
последствиям.

К счастью, обучение программированию не так опасно, как обучение колдовству,
поскольку духи, с которыми мы имеем дело, надежно связаны. В то же время
программирование в реальном мире требует осторожности, профессионализма и
мудрости. Например, мелкая ошибка в программе автоматизированного проектирования
может привести к катастрофе самолета, прорыву плотины или самоуничтожению
промышленного робота.

Специалисты по программному обеспечению умеют организовывать программы так,
чтобы быть потом обоснованно уверенными: получившиеся процессы будут выполнять
те задачи, для которых они предназначены. Они могут изобразить поведение
системы заранее.  Они знают, как построить программу так, чтобы непредвиденные
проблемы не привели к катастрофическим последствиям, а когда эти проблемы
возникают, программисты умеют @newterm{debugging} (отлаживать) свои программы.
Хорошо спроектированные вычислительные системы, подобно хорошо спроектированным
автомобилям или ядерным реакторам, построены модульно, так что их части могут
создаваться, заменяться и отлаживаться по отдельности.

@comment @subsubheading Programming in Lisp
@subsubheading Программирование на Лиспе

Для описания процессов нам нужен подходящий язык, и с этой целью мы
используем язык программирования Лисп. Точно так же, как обычные наши
мысли чаще всего выражаются на естественном языке (например, английском,
французском или японском), а описания количественных явлений выражаются
языком математики, наши процедурные мысли будут выражаться на Лиспе.
Лисп был изобретен в конце 1950-х как формализм для рассуждений об
определенном типе логических выражений, называемых @newterm{recursion
equations}, как о модели вычислений. Язык был придуман Джоном Маккарти
и основывается на его статье <<Рекурсивные функции над символьными
выражениями и их вычисление с помощью машины>> (McCarthy 1960).

Несмотря на то, что Лисп возник как математический формализм, это
практический язык программирования. @newterm{interpreter} Лиспа представляет
собой машину, которая выполняет процессы, описанные на языке Лисп.
Первый интерпретатор Лиспа написал сам Маккарти с помощью коллег и
студентов из Группы по Искусственному Интеллекту Исследовательской
лаборатории по Электронике MIT и Вычислительного центра.
@acronym{MIT} @footnote{ @cite{Руководство программиста по Лиспу 1} появилось в
1960 году, а @cite{Руководство программиста по Лиспу 1.5} (@ref{McCarthy
1965}) в 1962 году. Ранняя история Лиспа описана в (@ref{McCarthy 1978}).}.
Лисп, чье название происходит от сокращения английских слов LISt
Processing (обработка списков), был создан с целью обеспечить
возможность символьной обработки для решения таких программистских
задач, как символьное дифференцирование и интегрирование алгебраических
выражений. С этой целью он содержал новые объекты данных, известные под
названием атомов и списков, что резко отличало его от других языков
того времени.

Лисп не был результатом срежиссированного проекта. Он развивался
неформально, экспериментальным путем, с учетом запросов
пользователей и прагматических соображений реализации. Неформальная
эволюция Лиспа продолжалась долгие годы, и сообщество пользователей
Лиспа традиционно отвергало попытки провозгласить какое-либо
<<официальное>> описание языка. Вместе с гибкостью и изяществом
первоначального замысла такая эволюция позволила Лиспу, который сейчас
по возрасту второй из широко используемых языков (старше только
Фортран), непрерывно адаптироваться и вбирать в себя наиболее
современные идеи о проектировании программ. Таким образом, сегодня Лисп
представляет собой семью диалектов, которые, хотя и разделяют большую
часть изначальных свойств, могут существенным образом друг от друга
отличаться. Тот диалект, которым мы пользуемся в этой книге, называется
Scheme (Схема). @footnote{Большинство крупных Лисп-программ 1970х, были
написаны на одном из двух диалектов: MacLisp (@ref{Moon 1978}; @ref{Pitman 1983}),
разработанный в рамках проекта @acronym{MAC} в @acronym{MIT}, и InterLisp 
(@ref{Teitelman 1974}), разработанный в компании <<Болт, Беранек и Ньюман>>
и в Исследовательском центре компании Xerox в Пало Альто. Диалект Portable
Standard Lisp (Переносимый Стандартный Лисп, (@ref{Hearn 1969}; @ref{Griss 1981})
был спроектирован так, чтобы его легко было переносить на разные машины.
MacLisp породил несколько поддиалектов, например Franz Lisp,
разработанный в Калифорнийском университете в Беркли, и Zetalisp
(@ref{Moon and Weinreb 1981}), который основывался на специализированном процессоре,
спроектированном в лаборатории Искусственного Интеллекта в @acronym{MIT} для
наиболее эффективного выполнения программ на Лиспе. Диалект Лиспа,
используемый в этой книге, называется Scheme (@ref{Steele and Sussman 1975}).
Он был изобретен в 1975 году Гаем Льюисом Стилом мл. и Джеральдом Джеем
Сассманом в лаборатории Искусственного Интеллекта @acronym{MIT}, а затем заново
реализован для использования в учебных целях в @acronym{MIT}. Scheme стала
стандартом @acronym{IEEE} в 1990 году (@ref{IEEE 1900}). Диалект Common Lisp
(@ref{Steele 1982}; @ref{Steele 1990}) был специально разработан Лисп-
сообществом так, чтобы сочетать свойства более ранних диалектов Лиспа и стать
промышленным стандартом Лиспа. Common Lisp стал стандартом @acronym{ANSI} в 1994 году
(@ref{ANSI 1994})}.

Из-за своего экспериментального характера и внимания к символьной
обработке первое время Лисп был весьма неэффективен при решении
вычислительных задач, по крайней мере по сравнению с Фортраном. Однако
за прошедшие годы были разработаны компиляторы Лиспа, которые переводят
программы в машинный код, способный производить численные вычисления с
разумной эффективностью. А для специализированных приложений Лисп
удавалось использовать весьма эффективно. @footnote{Одним из таких
приложений был пионерский эксперимент, имевший научное значение ---
интегрирование движения Солнечной системы, которое превосходило по
точности предыдущие результаты примерно на два порядка и
продемонстрировало, что динамика Солнечной системы хаотична. Это
вычисление стало возможным благодаря новым алгоритмам интегрирования,
специализированному компилятору и специализированному компьютеру;
причем все они были реализованы с помощью программных средств,
написанных на Лиспе (@ref{Abelson et al. 1992}; @ref{Sussman and Wisdom 1992})}.
Хотя Лисп и не преодолел пока свою старую репутацию безнадежно
медленного языка, в наше время он используется во многих приложениях,
где эффективность не является главной заботой. Например, Лисп стал
любимым языком для оболочек операционных систем, а также в качестве
языка расширения для редакторов и систем автоматизированного
проектирования.

\enlargethispage{\baselineskip}

Но коль скоро Лисп не похож на типичные языки, почему же мы тогда
используем его как основу для нашего разговора о программировании?
Потому что этот язык обладает уникальными свойствами, которые делают его
замечательным средством для изучения важнейших конструкций
программирования и структур данных, а также для соотнесения их с
деталями языка, которые их поддерживают. Самое существенное из этих
свойств --- то, что лисповские описания процессов, называемые
(procedures), сами по себе могут представляться и обрабатываться как
данные Лиспа. Важность этого в том, что существуют мощные методы
проектирования программ, которые опираются на возможность сгладить
традиционное различение <<пассивных>> данных и <<активных>> процессов.
Как мы обнаружим, способность Лиспа рассматривать процедуры в качестве
данных делает его одним из самых удобных языков для исследования этих
методов. Способность представлять процедуры в качестве данных делает
Лисп еще и замечательным языком для написания программ, которые должны
манипулировать другими программами в качестве данных, таких как
интерпретаторы и компиляторы, поддерживающие компьютерные языки. А
помимо и превыше всех этих соображений, писать программы на Лиспе ---
громадное удовольствие.

@menu
* 1-1::              Элементы программирования
* 1-2::              Процедуры и порождаемые ими процессы
* 1-3::              Формулирование абстракций с помощью процедур высших порядков
@end menu

@comment @section The Elements of Programming
@section Элементы программирования
@node	1.1, 1.2, Глава 1, Глава 1

Мощный язык программирования --- это нечто большее. чем просто
средство, с помощью которого можно учить компьютер решать задачи. Язык
также служит средой, в которой мы организуем свое мышление о
процессах. Таким образом, когда мы описываем язык, мы должны уделять
особое внимание тем средствам, которые в нем имеются для того, чтобы
комбинировать простые понятия и получать из них сложные. Всякий язык
программирования обладает тремя предназначенными для этого механизмами:

@itemize @bullet

@item @b{элементарные выражения},
представляющие минимальные сущности, с которыми язык имеет дело;

@item @b{средства комбинирования},
с помощью которых из простых объектов составляются сложные;

@item @b{средства абстракции},
с помощью которых сложные объекты можно называть и обращаться с ними
как с единым целым.

@end itemize

@noindent
В программировании мы имеем дело с двумя типами объектов:
процедурами и данными. (Впоследствии мы обнаружим, что на самом деле
большой разницы между ними нет.) Говоря неформально, данные --- это
<<материал@math{\kern0.1em}>>, который мы хотим обрабатывать, а процедуры 
--- это описания правил обработки данных. Таким образом, от любого мощного
языка программирования требуется способность описывать простые данные и
элементарные процедуры, а также наличие средств комбинирования и
абстракции процедур и данных.

В этой главе мы будем работать только с простыми численными данными,
так что мы сможем сконцентрировать внимание на правилах построения
процедур.@footnote{Называть числа <<простыми данными>> --- это
бесстыдный блеф. На самом деле работа с числами является одной из самых
сложных и запутанных сторон любого языка программирования. Вот некоторые
из возникающих при этом вопросов: Некоторые компьютеры отличают
@newterm{integers}, вроде 2, от @newterm{real numbers}, вроде 2.71.
Отличается ли вещественное число 2.00 от целого 2? Используются ли одни и те
же арифметические операции для целых и для вещественных чисел? Что
получится, если 6 поделить на 2: 3 или 3.0? Насколько большие числа мы
можем представить? Сколько десятичных цифр после запятой мы можем
хранить? Совпадает ли диапазон целых чисел с диапазоном вещественных? И
помимо этих вопросов, разумеется, существует множество проблем,
связанных с ошибками округления --- целая наука численного анализа.
Поскольку в этой книге мы говорим о проектировании больших программ, а
не о численных методах, все эти проблемы мы будем игнорировать.
Численные примеры в этой главе будут демонстрировать такое поведение
при округлении, какое можно наблюдать, если использовать арифметические
операции, сохраняющие при работе с вещественными числами ограниченное
число десятичных цифр после запятой.}. В последующих главах мы увидим,
что те же самые правила позволяют нам строить процедуры для работы со
сложными данными.

@menu
* 1-1-1::            Выражения
* 1-1-2::            Имена и окружение
* 1-1-3::            Вычисление комбинаций
* 1-1-4::            Составные процедуры
* 1-1-5::            Подстановочная модель применения процедуры
* 1-1-6::            Условные выражения и предикаты
* 1-1-7::            Пример вычисление квадратного корня методом Ньютона
* 1-1-8::            Процедуры как абстракции типа <<черный ящик>>
@end menu

@comment @subsection Expressions
@subsection Выражения
@node	1.1.1, 1.1.2, 1.1, 1.1

Самый простой способ начать обучение программированию --- рассмотреть
несколько типичных примеров работы с интерпретатором диалекта Лиспа
Scheme. Представьте, что Вы сидите за терминалом компьютера. Вы
печатаете @newterm{expression}, а интерпретатор отвечает, выводя результат
@newterm{evaluation} этого выражения.

Один из типов элементарных выражений, которые Вы можете вводить --- это
числа. (Говоря точнее, выражение, которое Вы печатаете, состоит из цифр,
представляющих число по основанию 10.) Если Вы дадите Лиспу число

@lisp
486
@end lisp

@noindent
интерпретатор ответит Вам, напечатав@footnote{Здесь и далее, когда нам
нужно будет подчеркнуть разницу между вводом, который набирает на
терминале пользователь, и выводом, который производит компьютер, мы
будем изображать последний наклонным шрифтом.}

@lisp
@i{486}
@end lisp

@noindent
Выражения, представляющие числа, могут сочетаться с выражением,
представляющим элементарную процедуру (скажем, @code{+} или @code{*}),
так что получается составное выражение, представляющее собой применение
процедуры к этим числам. Например:

@lisp
(+ 137 349)
@i{486}
@end lisp

@lisp
(- 1000 334)
@i{666}
@end lisp

@lisp
(* 5 99)
@i{495}
@end lisp

@lisp
(/ 10 5)
@i{2}
@end lisp

@lisp
(+ 2.7 10)
@i{12.7}
@end lisp

@noindent
Выражения такого рода, образуемые путем заключения списка выражений в
скобки с целью обозначить применение функции к аргументам, называются
@newterm{combinations}. Самый левый элемент в списке называется @newterm{operator}, а
остальные элементы --- @newterm{operands}. Значение комбинации вычисляется
путем применения процедуры, задаваемой оператором, к @newterm{arguments},
которые являются значениями операндов.

Соглашение, по которому оператор ставится слева от операндов, известно
как @newterm{prefix notation}, и поначалу оно может сбивать с толку, поскольку
существенно отличается от общепринятой математической записи. Однако у
префиксной нотации есть несколько преимуществ. Одно из них состоит в
том, что префиксная запись может распространяться на процедуры с
произвольным количеством аргументов, как в следующих примерах:

@lisp
(+ 21 35 12 7)
@i{75}
@end lisp

@lisp
(* 25 4 12)
@i{1200}
@end lisp

@noindent
Не возникает никакой неоднозначности, поскольку оператор всегда
находится слева, а вся комбинация ограничена скобками.

Второе преимущество префиксной нотации состоит в том, что она
естественным образом расширяется, позволяя комбинациям @i{nested} друг в
друга, то есть допускает комбинации, элементы которых сами являются
комбинациями:

@lisp
(+ (* 3 5) (- 10 6))
@i{19}
@end lisp

@noindent
Не существует (в принципе) никакого предела для глубины такого
вложения и общей сложности выражений, которые может вычислять
интерпретатор Лиспа. Это мы, люди, путаемся даже в довольно простых
выражениях, например

@lisp
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
@end lisp

@noindent
а интерпретатор с готовностью вычисляет его и дает ответ 57. Мы можем
облегчить себе задачу, записывая такие выражения в форме

@lisp
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
@end lisp

@noindent
Эти правила форматирования называются @newterm{pretty printing}. Согласно им,
всякая длинная комбинация записывается так, чтобы ее операнды
выравнивались вертикально. Получающиеся отступы ясно показывают
структуру выражения.@footnote{Как правило, Лисп-системы содержат
средства, которые помогают пользователям форматировать выражения.
Особенно удобны две возможности: сдвигать курсор на правильную позицию
для красивой печати каждый раз, когда начинается новая строка и
подсвечивать нужную левую скобку каждый раз, когда печатается правая.}

Даже работая со сложными выражениями, интерпретатор всегда ведет себя
одинаковым образом: он считывает выражение с терминала, вычисляет его и
печатает результат. Этот способ работы иногда называют @newterm{read-eval-print
loop}. Обратите особое внимание на то, что не нужно специально просить
интерпретатор напечатать значение выражения.@footnote{Лисп следует
соглашению, что у всякого выражения есть значение. Это соглашение,
вместе со старой репутацией Лиспа как неэффективного языка, послужило
источником остроумного замечания Алана Перлиса (парафразы из Оскара
Уайльда), что <<Программисты на Лиспе знают значение всего на свете, но
ничему не знают цену>>.}

@comment @subsection Naming and the Environment
@subsection Имена и окружение
@node	1.1.2, 1.1.3, 1.1.1, 1.1

Одна из важнейших характеристик языка программирования --- какие в нем
существуют средства использования имен для указания на вычислительные
объекты. Мы говорим, что имя обозначает @newterm{variable}, чьим @newterm{value}
является объект.

В диалекте Лиспа Scheme мы даем вещам имена с помощью слова
@code{define}. Предложение

@lisp
(define size 2)
@end lisp

@noindent
заставляет интерпретатор связать значение 2 с именем
@code{size}.@footnote{Мы не печатаем в этой книге ответы интерпретатора
при вычислении определений, поскольку они зависят от конкретной
реализации языка.} После того, как имя @code{size} связано со значением
2, мы можем указывать на значение 2 с помощью имени:

@lisp
size
@i{2}
@end lisp

@lisp
(* 5 size)
@i{10}
@end lisp

@noindent
Вот еще примеры использования @code{define}:

@lisp
(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
@i{314.159}
(define circumference (* 2 pi radius))
circumference
@i{62.8318}
@end lisp

@noindent
Слово @code{define} служит в нашем языке простейшим средством
абстракции, поскольку оно позволяет нам использовать простые имена для
обозначения результатов сложных операций, как, например, вычисленная
только что длина окружности --- @code{circumference}. Вообще говоря,
вычислительные объекты могут быть весьма сложными структурами, и было
бы очень неудобно, если бы нам приходилось вспоминать и повторять все
их детали каждый раз, когда нам захочется их использовать. На самом деле
сложные программы конструируются методом построения шаг за шагом
вычислительных объектов возрастающей сложности. Интерпретатор делает
такое пошаговое построение программы особенно удобным, поскольку связи
между именами и объектами могут создаваться последовательно по мере
взаимодействия программиста с компьютером. Это свойство интерпретаторов
облегчает пошаговое написание и тестирование программ, и во многом
благодаря именно ему получается так, что программы на Лиспе обычно
состоят из большого количества относительно простых процедур.

Ясно, что раз интерпретатор способен ассоциировать значения с
символами и затем вспоминать их, то он должен иметь некоторого рода
память, сохраняющую пары имя-объект. Эта память называется @newterm{environment}
(а точнее, @newterm{global environment}, поскольку позже мы увидим, что
вычисление может иметь дело с несколькими окружениями).@footnote{ В
главе @ref{Chapter 3} мы увидим, что понятие окружения необходимо как для понимания работы
интерпретаторов, так и для их реализации.}

@comment @subsection Evaluating Combinations
@subsection Вычисление комбинаций
@node	1.1.3, 1.1.4, 1.1.2, 1.1

Одна из наших целей в этой главе --- выделить элементы процедурного
мышления. Рассуждая в этом русле, примем во внимание, что
интерпретатор, вычисляя значение комбинации, тоже следует процедуре:

Чтобы вычислить комбинацию, требуется:

@enumerate 1

@item
Вычислить все подвыражения комбинации.

@item
Применить процедуру, которая является значением самого левого
подвыражения (оператора) к аргументам --- значениям остальных
подвыражений (операндов).

@end enumerate

@noindent
Даже в этом простом правиле видны несколько важных свойств процессов в
целом. Прежде всего, заметим, что на первом шаге для того, чтобы
провести процесс вычисления для комбинации, нужно сначала проделать
процесс вычисления для каждого элемента комбинации. Таким образом,
правило вычисления (recursive) по своей природе; это означает, что в
качестве одного из своих шагов оно включает применение того же самого
правила.@footnote{Может показаться странным, что правило вычисления
предписывает нам в качестве части первого шага вычислить самый левый
элемент комбинации, --- ведь до сих пор это мог быть только оператор
вроде @code{+} или @code{*}, представляющий встроенную процедуру,
например, сложение или умножение. Позже мы увидим, что полезно иметь
возможность работать и с комбинациями, чьи операторы сами по себе
являются составными выражениями.}

Заметьте, какую краткость понятие рекурсии придает описанию того, что в
случае комбинации с глубоким вложением выглядело бы как достаточно
сложный процесс. Например, чтобы вычислить

@lisp
(* (+ 2 (* 4 6))
   (+ 3 5 7))
@end lisp

@noindent
требуется применить правило вычисления к четырем различным комбинациям.
Картину этого процесса можно получить, нарисовав комбинацию в виде
дерева, как показано на рис. @ref{Рисунок 1.1}. Каждая комбинация
представляется в видевершины, а ее оператор и операнды --- в виде
ветвей, исходящих из этой вершины. Концевые вершины (то есть те, из
которых не исходит ни одной ветви) представляют операторы или числа.
Рассматривая вычисление как дерево, мы можем представить себе, что
значения операндов распространяются от концевых вершин вверх и затем
комбинируются на все более высоких уровнях. Впоследствии мы увидим, что
рекурсия --- это вообще очень мощный метод обработки иерархических,
древовидных объектов. На самом деле форма правила вычисления
<<распространить значения наверх>> является примером общего типа
процессов, известного как @newterm{tree accumulation}.

@float
@quotation
@anchor{Рисунок 1.1}
@ifinfo
@strong{Рисунок 1.1:} Вычисление, представленное в виде дерева.

@example
   390
   /|\____________
  / |             \
 *  26            15
    /|\           /|\
   / | \         // \\
  +  2  24      / | | \
        /|\    +  3 5  7
       / | \
      *  4  6
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap1/Fig1.1g,31mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 1.1:} Вычисление, представленное в виде дерева.}
@sp 0.7
@end iftex
@end quotation
@end float

Далее, заметим, что многократное применение первого шага приводит нас к
такой точке, где нам нужно вычислять уже не комбинации, а элементарные
выражения, а именно числовые константы, встроенные операторы или другие
имена. С этими случаями мы справляемся, положив, что:

@itemize @bullet

@item
значением числовых констант являются те числа, которые они называют;

@item
значением встроенных операторов являются последовательности машинных
команд, которые выполняют соответствующие операции; и

@item
значением остальных имен являются те объекты, с которыми эти имена
связаны в окружении.

@end itemize

@noindent
Мы можем рассматривать второе правило как частный случай третьего,
постановив, что символы вроде @code{+} и @code{*} тоже включены в
глобальное окружение и связаны с последовательностями машинных команд,
которые и есть их <<значения>>. Главное здесь --- это роль окружения
при определении значения символов в выражениях. В таком диалоговом
языке, как Лисп, не имеет смысла говорить о значении выражения, скажем,
@code{(+ x 1)}, не указывая никакой информации об окружении, которое
дало бы значение символу @code{x} (и даже символу @code{+}). Как мы
увидим в главе @ref{Глава 3}, общее понятие окружения, предоставляющего
контекст, в котором происходит вычисление, будет играть важную роль в
нашем понимании того, как выполняются программы.

Заметим, что рассмотренное нами правило вычисления не обрабатывает
определений. Например, вычисление @code{(define x 3)} не означает
применение @code{define} к двум аргументам, один из которых значение
символа @code{x}, а другой равен 3, поскольку смысл @code{define} как
раз и состоит в том, чтобы связать @code{x} со значением. (Таким
образом, @code{(define x 3)} --- не комбинация.)

Такие исключения из вышеописанного правила вычисления называются
особыми формами (@newterm{special forms}). @code{define} --- пока что
единственный встретившийся нам пример особой формы, но очень скоро мы
познакомимся и с другими. У каждой особой формы свое собственное
правило вычисления. Разные виды выражений (вместе со своими правилами
вычисления) составляют синтаксис языка программирования. По сравнению с
большинством языков программирования, у Лиспа очень простой синтаксис;
а именно, правило вычисления для выражений может быть описано как очень
простое общее правило плюс специальные правила для небольшого числа
особых форм.@footnote{Особые синтаксические формы, которые представляют
собой просто удобное альтернативное поверхностное представление для
того, что можно выразить более унифицированным способом, иногда называют
синтаксический сахар (@newterm{syntactic sugar}), используя выражение
Питера Ландина. По сравнению с пользователями других языков, программистов
на Лиспе, как правило, мало волнует синтаксический сахар. (Для контраста
возьмите руководство по Паскалю и посмотрите, сколько места там уделяется
описанию синтаксиса).  Такое презрение к синтаксису отчасти происходит
от гибкости Лиспа, позволяющего легко изменять поверхностный синтаксис,
а отчасти из наблюдения, что многие <<удобные>> синтаксические конструкции,
которые делают язык менее последовательным, приносят в конце концов больше
вреда, чем пользы, когда программы становятся большими и сложными.
По словам Алана Перлиса, <<Синтаксический сахар вызывает рак точки с
запятой>>.}

@comment @subsection Compound Procedures
@subsection Составные процедуры
@node	1.1.4, 1.1.5, 1.1.3, 1.1

Мы нашли в Лиспе некоторые из тех элементов, которые должны
присутствовать в любом мощном языке программирования:

@itemize @bullet

@item
Числа и арифметические операции представляют собой элементарные
данные и процедуры.

@item
Вложение комбинаций дает возможность комбинировать операции.

@item
Определения, которые связывают имена со значениями, дают ограниченные
возможности абстракции.

@end itemize

@noindent
Теперь мы узнаем об (@newterm{procedure definitions}) --- значительно более
мощном методе абстракции, с помощью которого составной операции можно
дать имя и затем ссылаться на нее как на единое целое.

Для начала рассмотрим, как выразить понятие <<возведения в квадрат>>.
Можно сказать так: <<Чтобы возвести что-нибудь в квадрат, нужно
умножить его само на себя>>. Вот как это выражается в нашем языке:

@lisp
(define (square x) (* x x))
@end lisp

@noindent
Это можно понимать так:

@example
(define      (square            x)      (*      x        x))
   |            |               |        |      |        |
 Чтобы  возвести в квадрат  что-либо,  умножь  это  само на себя.
@end example

@noindent
Здесь мы имеем @newterm{compound procedure}, которой мы дали имя @code{square}.
Эта процедура представляет операцию умножения чего-либо само на себя. Та
вещь, которую нужно подвергнуть умножению, получает здесь имя @code{x},
которое играет ту же роль, что в естественных языках играет
местоимение. Вычисление этого определения создает составную процедуру и
связывает ее с именем @code{square}.@footnote{Заметьте, что здесь
присутствуют две различные операции: мы создаем процедуру, и мы даем ей
имя @code{square}. Возможно, и на самом деле даже важно, разделить эти
два понятия: создавать процедуры, никак их не называя, и давать имена
процедурам, уже созданным заранее. Мы увидим, как это делается, в
разделе @ref{1.3.2}.}

Общая форма определения процедуры такова:

@lisp
(define (@math{\langle}@var{имя}@math{\kern0.03em\rangle} @math{\langle}@var{формальные-параметры}@math{\kern0.02em\rangle})
  @math{\langle\kern0.08em}@var{тело}@math{\rangle})
@end lisp

@noindent
@math{\langle}@var{имя}@math{\kern0.08em\rangle} --- это тот символ, с которым
нужно связать в окружении определение процедуры.@footnote{На всем
протяжении этой книги мы будем описывать обобщенныйсинтаксис выражений,
используя курсив в угловых скобках --- напр. @math{\langle}@var{имя}@math{\kern0.08em\rangle},
чтобы обозначить <<дырки>> в выражении, которые нужно заполнить, когда это
выражение используется в языке.}
@math{\langle}@var{формальные-параметры}@math{\kern0.08em\rangle}--- это
имена, которые в теле процедуры используются для отсылки к
соответствующим аргументам процедуры.
@math{\langle}@var{тело}@math{\kern0.08em\rangle}--- это выражение, которое
вычислит результат применения процедуры, когда формальные параметры
будут заменены аргументами, к которым процедура будет
применяться.@footnote{В более общем случае тело процедуры может быть
последовательностью выражений. В этом случае интерпретатор вычисляет по
очереди все выражения в этой последовательности и возвращает в
качестве значения применения процедуры значение последнего выражения.}
@math{\langle}@var{имя}@math{\kern0.08em\rangle} и
@math{\langle}@var{формальные-параметры}@math{\kern0.08em\rangle} заключены
в скобки, как это было бы при вызове определяемой процедуры.

Теперь, когда процедура @code{square} определена, мы можем ее
использовать:

@lisp
(square 21)
@i{441}
(square (+ 2 5))
@i{49}
(square (square 3))
@i{81}
@end lisp

@noindent
Кроме того, мы можем использовать @code{square} при определении других
процедур. Например, @math{x^2 + y^2} можно записать как

@lisp
(+ (square x) (square y))
@end lisp

@noindent
Легко можно определить процедуру @code{sum-of-squares}, которая,
получая в качестве аргументов два числа, дает в результате сумму их
квадратов:

@lisp
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
@i{25}
@end lisp

@noindent
Теперь и @code{sum-of-squares} мы можем использовать как строительный
блок при дальнейшем определении процедур:

@lisp
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
@i{136}
@end lisp

@noindent
Составные процедуры используются точно так же, как элементарные. В
самом деле, глядя на приведенное выше определение @code{sum-of-squares},
невозможно выяснить, была ли @code{square} встроена в интерпретатор,
подобно @code{+} и @code{*}, или ее определили как составную процедуру.

@comment @subsection The Substitution Model for Procedure Application
@subsection Подстановочная модель применения процедуры
@node	1.1.5, 1.1.6, 1.1.4, 1.1

Вычисляя комбинацию, оператор которой называет составную процедуру,
интерпретатор осуществляет, вообще говоря, тот же процесс, что и для
комбинаций, операторы которых называют элементарные процедуры ---
процесс, описанный в разделе @ref{1.1.3}. А
именно, интерпретатор вычисляет элементы комбинации и применяет
процедуру (значение оператора комбинации) к аргументам (значениям
операндов комбинации).

Мы можем предположить, что механизм применения элементарных процедур к
аргументам встроен в интерпретатор. Для составных процедур процесс
протекает так:

@quotation
Чтобы применить составную процедуру к аргументам, требуется вычислить
тело процедуры, заменив каждый формальный параметр соответствующим
аргументом.
@end quotation

@noindent
Чтобы проиллюстрировать этот процесс, вычислим комбинацию

@lisp
(f 5)
@end lisp

@noindent
где @code{f} --- процедура, определенная в
разделе @ref{1.1.4}. Начинаем мы с того, что восстанавливаем тело @code{f}:

@lisp
(sum-of-squares (+ a 1) (* a 2))
@end lisp

@noindent
Затем мы заменяем формальный параметр @code{a} на аргумент 5:

@lisp
(sum-of-squares (+ 5 1) (* 5 2))
@end lisp

@noindent
Таким образом, задача сводится к вычислению комбинации с двумя
операндами и оператором @code{sum-of-squares}. Вычисление этой
комбинации включает три подзадачи. Нам нужно вычислить оператор, чтобы
получить процедуру, которую требуется применить, а также операнды,
чтобы получить аргументы. При этом @code{(+ 5 1)} дает 6, а
@code{(* 5 2)} дает 10, так что нам требуется применить процедуру
@code{sum-of-squares} к 6 и 10. Эти значения подставляются на место
формальных параметров @code{x} и @code{y} в теле @code{sum-of-squares},
приводя выражение к

@lisp
(+ (square 6) (square 10))
@end lisp

@noindent
Когда мы используем определение @code{square}, это приводится к

@lisp
(+ (* 6 6) (* 10 10))
@end lisp

@noindent
что при умножении сводится к

@lisp
(+ 36 100)
@end lisp

@noindent
и, наконец, к

@lisp
136
@end lisp

@noindent
Только что описанный нами процесс называется подстановочной
моделью (@newterm{substitution model}) применения процедуры. Ее можно
использовать как модель, которая определяет <<смысл>> понятия применения
процедуры, пока рассматриваются процедуры из этой главы. Имеются,
однако, две детали, которые необходимо подчеркнуть:

@itemize @bullet

@item
Цель подстановочной модели --- помочь нам представить, как применяются
процедуры, а не дать описание того, как на самом деле работает
интерпретатор. Как правило, интерпретаторы вычисляют применения
процедур к аргументам без манипуляций с текстом процедуры, которые
выражаются в подстановке значений для формальных параметров. На
практике <<подстановка>> реализуется с помощью локальных окружений для
формальных параметров. Более подробно мы обсудим это в
@ref{Глава 3} и @ref{Глава 4}, где мы детально исследуем реализацию
интерпретатора.

@item
На протяжении этой книги мы представим последовательность усложняющихся
моделей того, как работает интерпретатор, завершающуюся полным
воплощением интерпретатора и компилятора в @ref{Глава 5}.
Подстановочная модель --- только первая из них, способ начать формально
мыслить о моделях вычисления. Вообще, моделируя различные явления в
науке и технике, мы начинаем с упрощенных, неполных моделей.
Подстановочная модель в этом смысле не исключение. В частности,
когда в @ref{Глава 3}
мы обратимся к использованию процедур с <<изменяемыми данными>>, то мы
увидим, что подстановочная модель этого не выдерживает и ее нужно
заменить более сложной моделью применения процедур.@footnote{Несмотря на
простоту подстановочной модели, дать строгое математическое определение
процессу подстановки оказывается удивительно сложно. Проблема возникает
из-за возможности смешения имен, которые используются как формальные
параметры процедуры, с именами (возможно, с ними совпадающими), которые
используются в выражениях, к которым процедура может применяться.
Имеется долгая история неверных определений подстановки
(@newterm{substitution}) в литературе по логике и языкам программирования.
Подробное обсуждение подстановки можно найти в @ref{Stoy 1977}.}

@end itemize

@comment @subsubheading Applicative order versus normal order
@subsubheading Аппликативный и нормальный порядки вычисления

В соответствии с описанием из раздела @ref{1.1.3}, интерпретатор сначала
вычисляет оператор и операнды, а затем применяет получившуюся
процедуру к получившимся аргументам. Но это не единственный способ
осуществлять вычисления. Другая модель вычисления не вычисляет
аргументы, пока не понадобится их значение. Вместо этого она подставляет
на место параметров выражения-операнды, пока не получит выражение, в
котором присутствуют только элементарные операторы, и лишь затем
вычисляет его. Если бы мы использовали этот метод, вычисление
@code{(f 5)} прошло бы последовательность подстановок

@lisp
(sum-of-squares (+ 5 1) (* 5 2))
(+   (square (+ 5 1))      (square (* 5 2))  )
(+   (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
@end lisp

@noindent
за которыми последуют редукции

@lisp
(+      (* 6 6)      (* 10 10))
(+         36           100)
                136
@end lisp

@noindent
Это дает тот же результат, что и предыдущая модель вычислений, но
процесс его получения отличается. В частности, вычисление
@code{(+ 5 1)} и @code{(* 5 2)} выполняется здесь по два раза, в
соответствии с редукцией выражения @code{(* x x)} где @code{x} заменяется,
соответственно, на @code{(+ 5 1)} и @code{(* 5 2)}.

Альтернативный метод <<полная подстановка, затем редукция>> известен под
названием (@newterm{normal-order evaluation}), в противоположность методу
<<вычисление аргументов, затем применение процедуры>>, которое
называется (@newterm{applicative-order evaluation}). Можно показать, что для
процедур, которые правильно моделируются с помощью подстановки (включая
все процедуры из первых двух глав этой книги) и возвращают законные
значения, нормальный и аппликативный порядки вычисления дают одно и то
же значение. (См. упражнение @ref{Упражнение 1.5}, где приводится
пример <<незаконного>> выражения, для которого нормальный и
аппликативный порядки вычисления дают разные результаты.)

В Лиспе используется аппликативный порядок вычислений, отчасти из-за
дополнительной эффективности, которую дает возможность не вычислять
многократно выражения вроде приведенных выше @code{(+ 5 1)} и
@code{(* 5 2)}, а отчасти, что важнее, потому что с нормальным порядком
вычислений становится очень сложно обращаться, как только мы покидаем
область процедур, которые можно смоделировать с помощью подстановки. С
другой стороны, нормальный порядок вычислений может быть весьма ценным
инструментом, и некоторые его применения мы рассмотрим в @ref{Глава 3} и
@ref{Глава 4}.@footnote{В @ref{Глава 3}
мы описываем (@newterm{stream processing}), которая представляет собой способ
обработки структур данных, кажущихся <<бесконечными>>, с помощью
ограниченной формы нормального порядка вычислений. В разделе @ref{4.2}
мы модифицируем интерпретатор Scheme так, что получается вариант языка с
нормальным порядком вычислений.}

@comment @subsection Conditional Expressions and Predicates
@subsection Условные выражения и предикаты
@node	1.1.6, 1.1.7, 1.1.5, 1.1

Выразительная сила того класса процедур, которые мы уже научились
определять, очень ограничена, поскольку пока что у нас нет способа
производить проверки и выполнять различные операции в зависимости от
результата проверки. Например, мы не способны определить процедуру,
вычисляющую модуль числа, проверяя, положительное ли это число,
отрицательное или ноль, и предпринимая различные действия в
соответствии с правилом
@ifinfo

@example
      /
      |   x  if x > 0
|x| = <   0  if x = 0
      |  -x  if x < 0
      \
@end example

@end ifinfo
@tex
$$
 |x| = \left\{ \begin{array}{r@{\quad \mathrm{if} \quad}l}
        x  &  x > 0, \\
	0  &  x = 0, \\
  \!\! -x  &  x < 0. \end{array} \right.
$$
@end tex
Такая конструкция называется (@newterm{case analysis}). В Лиспе существует особая
форма для обозначения такого разбора случаев. Она называется @code{cond}
(от английского слова conditional, <<условный>>) и используется
так:

@lisp
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
@end lisp

@noindent
Общая форма условного выражения такова:

@lisp
(cond (@math{\langle}@var{p}@math{_{\mono{1}}\rangle} @math{\langle}@var{e}@math{_{\mono{1}}\rangle})
      (@math{\langle}@var{p}@math{_{\mono{2}}\rangle} @math{\langle}@var{e}@math{_{\mono{2}}\rangle})
      @dots{}
      (@math{\langle}@var{p}@math{_{\monoit{n}}\rangle} @math{\langle}@var{e}@math{_{\monoit{n}}\rangle}))
@end lisp

@noindent
Она состоит из символа @code{cond}, за которым следуют заключенные в
скобки пары выражений

@lisp
(@math{\langle}@var{p}@math{\rangle} @math{\langle}@var{e}@math{\rangle})
@end lisp

@noindent
называемых (@newterm{clauses}). В каждой из этих пар первое выражение ---
(@newterm{predicate}), то есть выражение, значение которого интерпретируется как
истина или ложь.@footnote{<<Интерпретируется как истина или ложь>>
означает следующее: в языке Scheme есть два выделенных значения,
которые обозначаются константами @code{\#t} и @code{\#f}. Когда
интерпретатор проверяет значение предиката, он интерпретирует @code{\#f}
как ложь. Любое другое значение считается истиной. (Таким образом,
наличие @code{\#t} логически не является необходимым, но иметь его
удобно.) В этой книге мы будем использовать имена @code{true} и
@code{false}, которые связаны со значениями @code{\#t} и @code{\#f},
соответственно.}

Условные выражения вычисляются так: сначала вычисляется предикат
@math{\langle{p_1}\rangle}. Если его значением является ложь, вычисляется
@math{\langle{p_2}\rangle}. Если значение @math{\langle{p_2}\rangle} также ложь,
вычисляется @math{\langle{p_3}\rangle}.
Этот процесс продолжается до тех пор, пока не найдется предикат,
значением которого будет истина, и в этом случае интерпретатор
возвращает значение соответствующего (@newterm{consequent expression})
в качестве значения всего условного выражения. Если ни один из
@math{\langle{p}\rangle} ни окажется истинным, значение
условного выражения @code{cond} не определено.

Словом (@newterm{predicate}) называют процедуры, которые возвращают истину или ложь, а также
выражения, которые имеют значением истину или ложь. Процедура вычисления
модуля @code{abs} использует элементарные предикаты @code{<}, @code{>}
и @code{=}.@footnote{Еще она использует операцию <<минус>> @code{-}, 
которая, когда используется с одним операндом, как в выражении @code{(- x)},
обозначает смену знака.}

Они принимают в качестве аргументов по два числа и, проверив, меньше ли
первое из них второго, равно ему или больше, возвращают в зависимости
от этого истину или ложь.

Можно написать процедуру вычисления модуля и так:

@lisp
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
@end lisp

@noindent
что на русском языке можно было бы выразить следующим образом: <<если
@math{x} меньше нуля, вернуть @math{-x}; иначе вернуть @math{x}>>.
@code{else} --- специальный символ, который в заключительной ветви
@code{cond} можно использовать на месте @math{\langle{p}\rangle}. Это
заставляет @code{cond} вернуть в качестве значения значение соответствующего
@math{\langle{e}\rangle} в случае, если все предыдущие
ветви были пропущены. На самом деле, здесь на месте
@math{\langle{p}\rangle} можно было бы использовать любое
выражение, которое всегда имеет значение истина.

Вот еще один способ написать процедуру вычисления модуля:

@lisp
(define (abs x)
  (if (< x 0)
      (- x)
      x))
@end lisp

@noindent
Здесь употребляется особая форма @code{if}, ограниченный вид условного
выражения. Его можно использовать при разборе случаев, когда есть ровно
два возможных исхода. Общая форма выражения @code{if} такова:

@lisp
(if @math{\langle\kern0.07em}@var{предикат}@math{\kern0.06em\rangle} @math{\langle\kern0.07em}@var{следствие}@math{\kern0.05em\rangle} @math{\langle\kern0.06em}@var{альтернатива}@math{\kern0.06em\rangle})
@end lisp

@noindent
Для того чтобы вычислить выражение @code{if}, интерпретатор сначала вычисляет
его @math{\langle}@var{предикат}@math{\kern0.04em\rangle}. Если
@math{\langle}@var{предикат}@math{\kern0.04em\rangle} дает истинное значение,
интерпретатор вычисляет @math{\langle}@var{следствие}@math{\kern0.04em\rangle} и возвращает его значение. В противном случае он вычисляет
@math{\langle}@var{альтернативу}@math{\kern0.04em\rangle} и возвращает ее
значение.@footnote{Небольшая разница между @code{if} и @code{cond}
состоит в том, что в @code{cond} каждое @math{\langle{e}\rangle}
может быть последовательностью выражений. Если соответствующее
@math{\langle{p}\rangle} оказывается истинным, выражения из
@math{\langle{e}\rangle} вычисляются по очереди, и в качестве значения
@code{cond} возвращается значение последнего из них. Напротив, в @code{if} как
@math{\langle}@var{следствие}@math{\kern0.04em\rangle}, так и
@math{\langle}@var{альтернатива}@math{\kern0.04em\rangle}
обязаны состоять из одного выражения.}

В дополнение к элементарным предикатам вроде @code{<}, @code{=} и
@code{>}, существуют операции логической композиции, которые позволяют
нам конструировать составные предикаты. Из них чаще всего используются
такие:

@itemize @bullet

@item
@math{\hbox{\tt(and }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)}}

Интерпретатор вычисляет выражения @math{\langle{e}\kern0.08em\rangle}
по одному, слева направо. Если какое-нибудь из
@math{\langle{e}\kern0.08em\rangle} дает ложное значение, значение всего
выражения @code{and} --- ложь, и остальные @math{\langle{e}\kern0.08em\rangle}
не вычисляются. Если все @math{\langle{e}\kern0.08em\rangle}
дают истинные значения, значением выражения @code{and} является истина.

@item
@math{\hbox{\tt(or }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)}}

Интерпретатор вычисляет выражения
@math{\langle{e}\kern0.08em\rangle} 
по одному, слева направо. Если какое-нибудь из
@math{\langle{e}\kern0.08em\rangle}
дает истинное значение, это значение возвращается как результат выражения
@code{or}, а остальные
@math{\langle{e}\kern0.08em\rangle}
не вычисляются. Если все
@math{\langle{e}\kern0.08em\rangle}
оказываются ложными, значением выражения @code{or} является ложь.

@item
@math{\hbox{\tt(not }\langle{e}\rangle\hbox{\tt)}}

Значение выражения @code{not} --- истина, если значение выражения
@math{\langle{e}\kern0.08em\rangle} ложно, и ложь в противном случае.

@end itemize

@noindent
Заметим, что @code{and} и @code{or} --- особые формы, а не процедуры,
поскольку не обязательно вычисляются все подвыражения. @code{Not} ---
обычная процедура.

Как пример на использование этих конструкций, условие что число @math{x}
находится в диапазоне @math{5 < x < 10}, можно выразить как

@lisp
(and (> x 5) (< x 10))
@end lisp

@noindent
Другой пример: мы можем определить предикат, который проверяет, что одно
число больше или равно другому, как

@lisp
(define (>= x y) (or (> x y) (= x y)))
@end lisp

@noindent
или как

@lisp
(define (>= x y) (not (< x y)))
@end lisp

@quotation
@strong{@anchor{Упражнение 1.1}Упражнение 1.1:} Ниже приведена
последовательность выражений. Какой результат
напечатает интерпретатор в ответ на каждое из них? Предполагается, что
выражения вводятся в том же порядке, в каком они написаны.

@lisp
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
@end lisp

@lisp
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
@end lisp

@lisp
(+ 2 (if (> b a) b a))
@end lisp

@lisp
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 1.2}Упражнение 1.2:} 
Переведите следующее выражение в префиксную форму:
@ifinfo

@example
5 + 4 + (2 - (3 - (6 + 4/5)))
-----------------------------
       3(6 - 2)(2 - 7)
@end example

@end ifinfo
@tex
$${5 + 4 + (2 - (3 - (6 + {4\over5})))\over3(6 - 2)(2 - 7)}.$$
@end tex
@end quotation

@quotation
@strong{@anchor{Упражнение 1.3}Упражнение 1.3:} 
Определите процедуру, которая принимает в качестве
аргументов три числа и возвращает сумму квадратов двух бо́льших из них.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.4}Упражнение 1.4:} Заметим, что наша модель
вычислений разрешает существование комбинаций, операторы которых --- составные
выражения. С помощью этого наблюдения опишите, как работает следующая процедура:

@lisp
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 1.5}Упражнение 1.5:}
Бен Битобор придумал тест для проверки интерпретатора на то, с каким
порядком вычислений он работает, аппликативным или нормальным.
Бен определяет такие две процедуры:

@lisp
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y
@end lisp

Затем он вычисляет выражение

@lisp
(test 0 (p))
@end lisp

Какое поведение увидит Бен, если интерпретатор использует аппликативный
порядок вычислений? Какое поведение он увидит, если интерпретатор
использует нормальный порядок? Объясните Ваш ответ. (Предполагается, что
правило вычисления особой формы @code{if} одинаково независимо от того,
какой порядок вычислений используется. Сначала вычисляется
выражение-предикат, и результат определяет, нужно ли вычислять
выражение-следствие или альтернативу.)

@end quotation

@endpage
@comment @subsection Example: Square Roots by Newton's Method
@subsection Пример: вычисление квадратного корня методом Ньютона
@node	1.1.7, 1.1.8, 1.1.6, 1.1

Процедуры, как они описаны выше, очень похожи на обыкновенные
математические функции. Они устанавливают значение, которое определяется
одним или более параметром. Но есть важное различие между
математическими функциями и компьютерными процедурами. Процедуры должны
быть эффективными.

В качестве примера рассмотрим задачу вычисления квадратного корня. Мы
можем определить функцию <<квадратный корень>> так:
@ifinfo

@example
sqrt(x) = такое y, что y >= 0 и y^2 = x
@end example

@end ifinfo
@tex
$$\sqrt{x} =  такое y, что y \ge 0 и y^2 = x$$
@end tex

@comment $$\sqrt{x}\;\; = {\rm\;\; такое\;\;} y
@comment {\rm\;\; что\;\;} y \ge 0 {\rm\;\; и\;\;} y^2 = x.$$

Это описывает совершенно нормальную математическую функцию. С помощью
такого определения мы можем решать, является ли одно число квадратным
корнем другого, или выводить общие свойства квадратных корней. С другой
стороны, это определение не описывает процедуры. В самом деле, оно почти
ничего не говорит о том, как найти квадратный корень данного числа. Не
поможет и попытка перевести это определение на псевдо-Лисп:

@lisp
(define (sqrt x)
  (the y (and (>= y 0)
              (= (square y) x))))
@end lisp

@noindent
Это только уход от вопроса.

Противопоставление функций и процедур отражает общее различие между
описанием свойств объектов и описанием того, как что-то делать, или,
как иногда говорят, различие между декларативным знанием и императивным
знанием. В математике нас обычно интересуют декларативные описания (что
такое), а в информатике императивные описания
(как).@footnote{Декларативные и императивные описания тесно связаны
между собой, как и математика с информатикой. Например, сказать, что
ответ, получаемый программой, <<верен>>, означает сделать об этой
программе декларативное утверждение. Существует большое количество
исследований, направленных на отыскание методов доказательства того, что
программа корректна, и большая часть сложности этого предмета
исследования связана с переходом от императивных утверждений (из
которых строятся программы) к декларативным (которые можно использовать
для рассуждений). Связана с этим и такая важная область современных
исследований по проектированию языков программирования, как исследование
так называемыхязыков сверхвысокого уровня, в которых программирование
на самом деле происходит в терминах декларативных утверждений. Идея
состоит в том, чтобы сделать интерпретаторы настолько умными, чтобы,
получая от программиста знание типа <<что такое>>, они были бы способны
самостоятельно породить знание типа <<как>>. В общем случае это сделать
невозможно, но есть важные области, где удалось достичь прогресса. Мы
вернемся к этой идее в @ref{Глава 4}.}

Как вычисляются квадратные корни? Наиболее часто применяется Ньютонов
метод последовательных приближений, который основан на том, что имея
некоторое неточное значение @math{y} для квадратного корня из числа
@math{x}, мы можем с помощью простой манипуляции получить более точное
значение (более близкое к настоящему квадратному корню), если возьмем
среднее между @math{y} и @math{x/y}.@footnote{На самом деле алгоритм
нахождения квадратного корня представляет собой частный случай метода
Ньютона, который является общим методом нахождения корней уравнений.
Собственно алгоритм нахождения квадратного корня был разработан Героном
Александрийским в первом веке @acronym{н.э.} Мы увидим, как выразить общий метод
Ньютона в виде процедуры на Лиспе, в разделе @ref{1.3.4}.} Например, мы
можем вычислить квадратный корень из 2 следующим образом: предположим,
что начальное приближение равно 1.

@sp -0.8
@smallexample
Приближение Частное                  Среднее
1           (2/1) = 2                ((2 + 1)/2) = 1.5
1.5         (2/1.5) = 1.3333         ((1.3333 + 1.5)/2) = 1.4167
1.4167      (2/1.4167) = 1.4118      ((1.4167 + 1.4118)/2) = 1.4142
1.4142      ...                      ...
@end smallexample

@noindent
Продолжая этот процесс, мы получаем все более точные
приближения к квадратному корню.

Теперь формализуем этот процесс в терминах процедур. Начнем с
подкоренного числа и какого-то значения приближения. Если приближение
достаточно хорошо подходит для наших целей, то процесс закончен; если
нет, мы должны повторить его с улучшенным значением приближения.
Запишем эту базовую стратегию в виде процедуры:

@lisp
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
@end lisp

@noindent
Значение приближения улучшается с помощью взятия среднего между ним и
частным подкоренного числа и старого значения приближения:

@lisp
(define (improve guess x)
  (average guess (/ x guess)))
@end lisp

@noindent
где

@lisp
(define (average x y)
  (/ (+ x y) 2))
@end lisp

@noindent
Нам нужно еще сказать, что такое для нас <<достаточно хорошее>>
приближение. Следующий вариант сойдет для иллюстрации, но на самом деле
это не очень хороший тест. (См. @ref{Упражнение 1.7}.) Идея
состоит в том, чтобы улучшать приближения до тех пор, пока его квадрат
не совпадет с подкоренным числом в пределах заранее заданного допуска
(здесь 0.001):@footnote{Обычно мы будем давать предикатам имена,
заканчивающиеся знаком вопроса, чтобы было проще запомнить, что это
предикаты. Это не более чем стилистическое соглашение. С точки зрения
интерпретатора, вопросительный знак --- обыкновенный символ.}

@lisp
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
@end lisp

@noindent
Наконец, нужно с чего-то начинать. Например, мы можем для начала
предполагать, что квадратный корень любого числа равен
1.@footnote{Обратите внимание, что мы записываем начальное приближение
как 1.0, а не как 1.Во многих реализациях Лиспа здесь не будет никакой
разницы. Однако интерпретатор @acronym{MIT} Scheme отличает точные целые числа от
десятичных значений, и при делении двух целых получается не десятичная
дробь, а рациональное число. Например, поделив 10/6, получим 5/3, а
поделив 10.0/6.0, получим 1.6666666666666667. (Мы увидим, как
реализовать арифметические операции над рациональными числами, в
разделе @ref{2.1.1}.)
Если в нашей программе квадратного корня мы начнем с начального
приближения 1, а @math{x} будет точным целым числом, все последующие
значения, получаемые при вычислении квадратного корня, будут не
десятичными дробями, а рациональными числами. Поскольку при смешанных
операциях над десятичными дробями и рациональными числами всегда
получаются десятичные дроби, то начав со значения 1.0, все прочие мы
получим в виде десятичных дробей.}

@lisp
(define (sqrt x)
  (sqrt-iter 1.0 x))
@end lisp

@noindent
Если мы введем эти определения в интерпретатор, мы сможем использовать
@code{sqrt} как любую другую процедуру:

@lisp
(sqrt 9)
@i{3.00009155413138}

(sqrt (+ 100 37))
@i{11.704699917758145}

(sqrt (+ (sqrt 2) (sqrt 3)))
@i{1.7739279023207892}

(square (sqrt 1000))
@i{1000.000369924366}
@end lisp

@noindent
Программа @code{sqrt} показывает также, что того простого процедурного
языка, который мы описали до сих пор, достаточно, чтобы написать любую
чисто вычислительную программу, которую можно было бы написать, скажем,
на Си или Паскале. Это может показаться удивительным, поскольку в наш
язык мы не включили никаких итеративных (циклических) конструкций,
указывающих компьютеру, что нужно производить некое действие несколько
раз. @code{sqrt-iter}, с другой стороны, показывает, как можно выразить
итерацию, не имея никакого специального конструкта, кроме обыкновенной
способности вызвать процедуру.@footnote{Читателям, которых заботят
вопросы эффективности, связанные с использованием вызовов процедур для
итерации, следует обратить внимание на замечания о <<хвостовой
рекурсии>> в разделе @ref{1.2.1}.}

@quotation
@strong{@anchor{Упражнение 1.6}Упражнение 1.6:}
Лиза П. Хакер не понимает, почему @code{if} должна быть
особой формой. <<Почему нельзя просто определить ее как обычную
процедуру с помощью @code{cond}?>> --- спрашивает она. Лизина подруга
Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую
версию @code{if}:

@lisp
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
@end lisp

Ева показывает Лизе новую программу:

@lisp
(new-if (= 2 3) 0 5)
@i{5}
(new-if (= 1 1) 0 5)
@i{0}
@end lisp

Обрадованная Лиза переписывает через @code{new-if} программу вычисления
квадратного корня:

@lisp
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
@end lisp

Что получится, когда Лиза попытается использовать эту процедуру для
вычисления квадратных корней? Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.7}Упражнение 1.7:}
Проверка @code{good-enough?}, которую мы использовали для
вычисления квадратных корней, будет довольно неэффективна для поиска
квадратных корней от очень маленьких чисел. Кроме того, в настоящих
компьютерах арифметические операции почти всегда вычисляются с
ограниченной точностью. Поэтому наш тест оказывается неадекватным и для
очень больших чисел. Альтернативный подход к реализации
@code{good-enough?} состоит в том, чтобы следить, как от одной
итерации к другой изменяется @code{guess}, и остановиться, когда
изменение оказывается небольшой долей значения приближения. Разработайте
процедуру вычисления квадратного корня, которая использует такой вариант
проверки на завершение. Верно ли, что на больших и маленьких числах она
работает лучше?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.8}Упражнение 1.8:}
Метод Ньютона для кубических корней основан на том, что если
@math{y} является приближением к кубическому корню из @math{x}, то мы
можем получить лучшее приближение по формуле
@ifinfo

@example
x/y^2 + 2y
----------
    3
@end example

@end ifinfo
@tex
$${{x / y^2} + 2y \over 3}.$$
@end tex
@noindent
С помощью этой формулы напишите процедуру
вычисления кубического корня, подобную процедуре для квадратного корня.
(В разделе @ref{1.3.4} мы увидим, что
можно реализовать общий метод Ньютона как абстракцию этих процедур для
квадратного и кубического корня.)
@end quotation

@comment @subsection Procedures as Black-Box Abstractions
@subsection Процедуры как абстракции типа <<черный ящик>>
@node	1.1.8,  , 1.1.7, 1.1

@code{sqrt} --- наш первый пример процесса, определенного множеством
зависимых друг от друга процедур. Заметим, что определение
@code{sqrt-iter} (@newterm{recursive}); это означает, что процедура
определяется в терминах самой себя. Идея, что можно определить
процедуру саму через себя, возможно, кажется Вам подозрительной; неясно,
как такое <<циклическое>> определение вообще может иметь смысл, не то
что описывать хорошо определенный процесс для исполнения компьютером.
Более осторожно мы подойдем к этому в
разделе @ref{1.2}.
Рассмотрим, однако, некоторые другие важные детали, которые иллюстрирует
пример с @code{sqrt}.

Заметим, что задача вычисления квадратных корней естественным образом
разбивается на подзадачи: как понять, что очередное приближение нас
устраивает, как улучшить очередное приближение, и так далее. Каждая из
этих задач решается с помощью отдельной процедуры. Вся программа
@code{sqrt} может рассматриваться как пучок процедур (показанный на
рис. @ref{Рисунок 1.2}), отражающий декомпозицию задачи на подзадачи.

@float
@quotation
@anchor{Рисунок 1.2}
@ifinfo
@strong{Рисунок 1.2:} Процедурная декомпозиция программы @code{sqrt}.

@example
                       sqrt
                        |
                    sqrt-iter
                    /       \
            good-enough    improve
              /     \          \
          square    abs      average
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap1/Fig1.2,44mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 1.2:} Процедурная декомпозиция программы @code{sqrt}.}
@sp 0.7
@end iftex
@end quotation
@end float

Важность декомпозиционной стратегии не просто в том, что задача
разделяется на части. В конце концов, можно взять любую большую
программу и поделить ее на части: первые десять строк, следующие десять
строк и так далее. Существенно то, что каждая процедура выполняет точно
определенную задачу, которая может быть использована при определении
других процедур. Например, когда мы определяем процедуру
@code{good-enough?} с помощью @code{square}, мы можем рассматривать
процедуру @code{square} как <<черный ящик>>. В этот момент нас не
интересует, @emph{как} она вычисляет свой результат, --- важно только
то, что она способна вычислить квадрат. О деталях того, как вычисляют
квадраты, можно сейчас забыть и рассмотреть их потом. Действительно,
пока мы рассматриваем процедуру @code{good-enough?}, @code{square} ---
не совсем процедура, но скорее абстракция процедуры, так называемая
(@newterm{procedural abstraction}). На этом уровне абстракции все процедуры,
вычисляющие квадрат, одинаково хороши.

Таким образом, если рассматривать только возвращаемые значения, то
следующие две процедуры для возведения числа в квадрат будут неотличимы
друг от друга. Каждая из них принимает числовой аргумент и возвращает в
качестве значения квадрат этого числа.@footnote{Неясно даже, которая из
этих процедур более эффективна. Это зависит от того, какая имеется
аппаратура. Существуют машины, на которых <<очевидная>> реализация будет
медленней. Представьте себе машину, в которой очень эффективным
способом хранятся большие таблицы логарифмов и обратных логарифмов.}

@lisp
(define (square x) (* x x))
(define (square x) (exp (double (log x))))
(define (double x) (+ x x))
@end lisp

@noindent
Таким образом, определение процедуры должно быть способно скрывать
детали. Может оказаться, что пользователь процедуры не сам ее
написал, а получил от другого программиста как черный ящик. От
пользователя не должно требоваться знания, как работает процедура, чтобы
ее использовать.

@comment @subsubheading Local name
@subsubheading Локальные имена

Одна из деталей реализации, которая не должна заботить пользователя
процедуры --- это то, какие человек, писавший процедуру, выбрал имена
для формальных параметров процедуры. Таким образом, следующие две
процедуры должны быть неотличимы:

@lisp
(define (square x) (* x x))
(define (square y) (* y y))
@end lisp

@noindent
Этот принцип --- что значение процедуры не должно зависеть от имен
параметров, которые выбрал ее автор, --- может сначала показаться
очевидным, однако он имеет глубокие следствия. Простейшее из этих
следствий состоит в том, что имена параметров должны быть локальными в
теле процедуры. Например, в программе вычисления квадратного корня при
определении @code{good-enough?} мы использовали @code{square}:

@lisp
(define (good-enough? guess x)
  (< (abs (- (square guess) x))
     0.001))
@end lisp

@noindent
Намерение автора @code{good-enough?} состоит в том, чтобы определить,
достаточно ли близко квадрат первого аргумента лежит ко второму. Мы
видим, что автор @code{good-enough?} обращается к первому аргументу с
помощью имени @code{guess}, а ко второму с помощью имени @code{x}.
Аргументом @code{square} является @code{guess}. Поскольку автор
@code{square} использовал имя @code{x} (как мы видели выше), чтобы
обратиться к этому аргументу, мы видим, что @code{x} в
@code{good-enough?} должно отличаться от @code{x} в @code{square}.
Запуск процедуры @code{square} не должен отразиться на значении
@code{x}, которое использует @code{good-enough?}, поскольку это значение
@code{x} понадобится @code{good-enough?}, когда @code{square} будет
вычислена.

Если бы параметры не были локальны по отношению к телам своих процедур,
то параметр @code{x} в @code{square} смешался бы с параметром @code{x}
из @code{good-enough?}, и поведение @code{good-enough?} зависело бы от
того, какую версию @code{square} мы использовали. Таким образом,
процедура @code{square} не была бы черным ящиком, как мы того хотим.

У формального параметра особая роль в определении процедуры: не имеет
значения, какое у этого параметра имя. Такое имя называется (@newterm{bound variable}),
и мы будем говорить, что определение процедуры (@newterm{binds}) свои
формальные параметры. Значение процедуры не изменяется, если во всем ее
определении параметры последовательным образом
переименованы.@footnote{Понятие последовательного переименования на самом
деле достаточно тонкое и трудное для определения. Знаменитым логикам
случалось делать здесь ужасные ошибки.} Если переменная не связана, мы
говорим, что она (@newterm{free}). Множество выражений, для которых связывание
определяет имя, называется (@newterm{scope}) этого имени. В определении процедуры
связанные переменные, объявленные как формальные параметры процедуры,
имеют своей областью действия тело процедуры.

В приведенном выше определении @code{good-enough?}, @code{guess} и
@code{x} --- связанные переменные, а @code{<}, @code{-}, @code{abs} и
@code{square} --- свободные. Значение @code{good-enough?} должно быть
независимо от того, какие имена мы выберем для @code{guess} и @code{x},
пока они остаются отличными друг от друга и от @code{<}, @code{-},
@code{abs} и @code{square}. (Если бы мы переименовали @code{guess} в
@code{abs}, то породили бы ошибку, (@newterm{capture}) переменную @code{abs}.
Она превратилась бы из свободной в связанную.) Однако значение
@code{good-enough?} не является независимым от ее свободных переменных.
Разумеется, оно зависит от того факта (внешнего по отношению к этому
определению), что символ @code{abs} называет процедуру вычисления модуля
числа. @code{good-enough?} будет вычислять совершенно другую функцию,
если в ее определении мы вместо @code{abs} подставим @code{cos}.

@comment @subsubheading Internal definitions and block structure
@subsubheading Внутренние определения и блочная структура

До сих пор нам был доступен только один вид изоляции имен: формальные
параметры процедуры локальны по отношению к телу этой процедуры.
Программа вычисления квадратного корня иллюстрирует еще один вид
управления использованием имен, которым мы хотели бы владеть.
Существующая программа состоит из отдельных процедур:

@lisp
(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))
@end lisp

@noindent
Проблема здесь состоит в том, что единственная процедура, которая важна
для пользователей @code{sqrt} --- это сама @code{sqrt}. Остальные
процедуры (@code{sqrt-iter}, @code{good-enough?} и @code{improve})
только забивают им головы. Теперь пользователи не могут определять
других процедур с именем @code{good-enough?} ни в какой другой
программе, которая должна работать совместно с программой вычисления
квадратного корня, поскольку @code{sqrt} требуется это имя. Эта проблема
становится особенно тяжелой при построении больших систем, которые пишут
много различных программистов. Например, при построении большой
библиотеки численных процедур многие числовые функции вычисляются как
последовательные приближения и могут потому иметь в качестве
вспомогательных процедуры @code{good-enough?} и @code{improve}. Нам
хотелось бы локализовать подпроцедуры, спрятав их внутри @code{sqrt},
так, чтобы @code{sqrt} могла сосуществовать с другими последовательными
приближениями, при том что у каждой из них была бы своя собственная
процедура @code{good-enough?}. Чтобы сделать это возможным, мы разрешаем
процедуре иметь внутренние определения, локальные для этой процедуры.
Например, при решении задачи вычисления квадратного корня мы можем
написать

@lisp
(define (sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x) (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
@end lisp

@noindent
Такое вложение определений, называемое (@newterm{block structure}), дает
правильное решение для простейшей задачи упаковки имен. Но здесь таится
еще одна идея. Помимо того, что мы можем вложить определения
вспомогательных процедур внутрь главной, мы можем их упростить.
Поскольку переменная @code{x} связана в определении @code{sqrt},
процедуры @code{good-enough?}, @code{improve} и @code{sqrt-iter},
которые определены внутри @code{sqrt}, находятся в области действия
@code{x}. Таким образом, нет нужды явно передавать @code{x} в каждую из
этих процедур. Вместо этого мы можем сделать @code{x} свободной
переменной во внутренних определениях, как это показано ниже. Тогда
@code{x} получит свое значение от аргумента, с которым вызвана
объемлющая их процедура @code{sqrt}. Такой порядок называется
(@newterm{lexical scoping})
переменных.@footnote{Правило лексической сферы действия говорит,
что свободные переменные в процедуре ссылаются на связывания этих
переменных, сделанные в объемлющих определениях процедур; то есть они
ищутся в окружении, в котором процедура была определена. Мы детально
рассмотрим, как это работает, в @ref{Глава 3},
когда будем подробно описывать окружения и работу интерпретатора.}

@lisp
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Мы будем часто использовать блочную структуру, чтобы разбивать большие
программы на куски разумного размера.@footnote{Внутренние
определения должны быть в начале тела процедуры. За последствия запуска
программ, перемешивающих определения и их использование, администрация
ответственности не несет.} Идея блочной структуры происходит из языка
программирования Алгол 60. Она присутствует в большинстве современных
языков программирования. Это важный инструмент, который помогает
организовать построение больших программ.

@comment @section Procedures and the Processes They @w{Generate}
@section Процедуры и @w{Порождаемые} ими процессы
@node	1.2, 1.3, 1.1, Глава 1

В предыдущем разделе мы рассмотрели элементы программирования. Мы
использовали элементарные арифметические операции, комбинировали их и
абстрагировали получившиеся составные операции путем определения
составных процедур. Но всего этого еще недостаточно, чтобы сказать, что
мы умеем программировать. Положение, в котором мы находимся, похоже на
положение человека, выучившего шахматные правила, но ничего не знающего
об основных дебютах, тактике и стратегии. Подобно шахматисту-новичку, мы
пока ничего не знаем об основных схемах использования понятий в нашей
области знаний. Нам недостает знаний о том, какие именно ходы следует
делать (какие именно процедуры имеет смысл определять), и не хватает
опыта предсказания последствий сделанного хода (выполнения процедуры).

Способность предвидеть последствия рассматриваемых действий необходима
для того, чтобы стать квалифицированным программистом, --- равно как и
для любой другой синтетической, творческой деятельности. Например,
квалифицированному фотографу нужно при взгляде на сцену понимать,
насколько темным каждый ее участок покажется после печати при разном
выборе экспозиции и разных условиях обработки. Только после этого можно
проводить обратные рассуждения и выбирать кадр, освещение,
экспозицию и условия обработки так, чтобы получить желаемый результат.
Чтобы стать специалистами, нам надо научиться представлять процессы,
генерируемые различными типами процедур. Только развив в себе такую
способность, мы сможем научиться надежно строить программы, которые
ведут себя так, как нам надо.

Процедура представляет собой шаблон (@newterm{local evolution}) вычислительного
процесса. Она указывает, как следующая стадия процесса строится из
предыдущей. Нам хотелось бы уметь строить утверждения об общем, или
глобальном (@newterm{global}) поведении процесса, локальная эволюция
которого описана процедурой. В общем случае это сделать очень сложно, но
по крайней мере мы можем попытаться описать некоторые типичные схемы
эволюции процессов.

В этом разделе мы рассмотрим некоторые часто встречающиеся <<формы>>
процессов, генерируемых простыми процедурами. Кроме того, мы рассмотрим,
насколько сильно эти процессы расходуют такие важные вычислительные
ресурсы, как время и память. Процедуры, которые мы будем рассматривать,
весьма просты. Они будут играть такую же роль, как простые схемы в
фотографии: это скорее упрощенные прототипические шаблоны, а не
практические примеры сами по себе.

@menu
* 1-2-1::            Линейные рекурсия и итерация
* 1-2-2::            Древовидная рекурсия
* 1-2-3::            Порядки роста
* 1-2-4::            Возведение в степень
* 1-2-5::            Нахождение наибольшего общего делителя
* 1-2-6::            Пример проверка на простоту
@end menu

@comment @subsection Linear Recursion and Iteration
@subsection Линейные рекурсия и итерация
@node	1.2.1, 1.2.2, 1.2, 1.2

Для начала рассмотрим функцию факториал, определяемую уравнением
@ifinfo

@example
n! = n * (n - 1) * (n - 2) ... 3 * 2 * 1
@end example

@end ifinfo
@tex
$$n! = n \cdot (n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1.$$
@end tex
Существует множество способов вычислять факториалы. Один из них
состоит в том, чтобы заметить, что @math{n!} для любого положительного
целого числа @math{n} равен @math{n}, умноженному на @math{(n - 1)!}:
@ifinfo

@example
n! = n * [(n - 1) * (n - 2) ... 3 * 2 * 1] = n * (n - 1)!
@end example

@end ifinfo
@tex
$$n! = n \cdot [(n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!.$$
@end tex
Таким образом, мы можем вычислить
@math{n!}, вычислив сначала @math{(n - 1)!}, а затем умножив его на
@math{n}. После того, как мы добавляем условие, что @math{1!} равен 1,
это наблюдение можно непосредственно перевести в процедуру:

@lisp
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
@end lisp

@noindent
Можно использовать подстановочную модель из раздела @ref{1.1.5} и увидеть эту
процедуру в действии при вычислении 6!, как показано на @ref{Рисунок 1.3}.

@float
@quotation
@anchor{Рисунок 1.3}
@ifinfo
@strong{Рисунок 1.3:} Линейно рекурсивный процесс для вычисления 6!.

@example
(factorial 6)        ----------------
(* 6 (factorial 5))                   \
(* 6 (* 5 (factorial 4)))               \
(* 6 (* 5 (* 4 (factorial 3))))           \
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
(* 6 (* 5 (* 4 (* 3 2))))                 /
(* 6 (* 5 (* 4 6)))                     /
(* 6 (* 5 24))                        /
(* 6 120)                           /
720          <---------------------
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap1/Fig1.3c,82mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 1.3:} Линейно рекурсивный процесс для вычисления 6!.}
@sp 1.0
@end iftex
@end quotation
@end float

Теперь рассмотрим вычисление факториала с другой точки зрения. Мы можем
описать правило вычисления @math{n!}, сказав, что мы сначала умножаем 1
на 2, затем результат умножаем на 3, затем на 4, и так пока не
достигнем @math{n}. Мы можем описать это вычисление, сказав, что
счетчик и произведение с каждым шагом одновременно изменяются согласно
правилу

@example
произведение @math{\gets} счетчик * произведение
счетчик @math{\gets} счетчик + 1
@end example

@noindent
и добавив условие, что @math{n!} --- это значение произведения
в тот момент, когда счетчик становится больше, чем @math{n}.

\enlargethispage{\baselineskip}

@float
@quotation
@anchor{Рисунок 1.4}
@ifinfo
@strong{Рисунок 1.4:} Линейно итеративный процесс для вычисления 6!.

@example
(factorial 6)   -----.
(fact-iter   1 1 6)  |
(fact-iter   1 2 6)  |
(fact-iter   2 3 6)  |
(fact-iter   6 4 6)  |
(fact-iter  24 5 6)  |
(fact-iter 120 6 6)  |
(fact-iter 720 7 6)  V
720
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap1/Fig1.4c,36mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 1.4:} Линейно итеративный процесс для вычисления 6!.}
@sp 1.0
@end iftex
@end quotation
@end float

Опять же, мы можем перестроить наше определение в процедуру вычисления
факториала:@footnote{В настоящей программе мы, скорее всего, спрятали бы
определение @code{fact-iter} с помощью блочной структуры, введенной в
предыдущем разделе:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp

Здесь мы этого не сделали, чтобы как можно меньше думать о разных вещах
одновременно.}

@lisp
(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
@end lisp

@noindent
Как и раньше, мы можем с помощью подстановочной модели изобразить
процесс вычисления 6!, как показано на @ref{Рисунок 1.4}.

Сравним эти два процесса. С одной стороны, они кажутся почти
одинаковыми. Оба они вычисляют одну и ту же математическую функцию с
одной и той же областью определения, и каждый из них для вычисления
@math{n!} требует количества шагов, пропорционального @math{n}.
Действительно, два этих процесса даже производят одну и ту же
последовательность умножений и получают одну и ту же
последовательность частичных произведений. С другой стороны, когда мы
рассмотрим <<формы>> этих двух процессов, мы увидим, что они ведут себя
совершенно по-разному

Возьмем первый процесс. Подстановочная модель показывает сначала серию
расширений, а затем сжатие, как показывает стрелка на @ref{Рисунок 1.3}.
Расширение происходит по мере того, как
процесс строит цепочку (@newterm{deferred operations}), в данном случае цепочку
умножений. Сжатие происходит тогда, когда выполняются эти отложенные
операции. Такой тип процесса, который характеризуется цепочкой
отложенных операций, называется (@newterm{recursive process}). Выполнение этого
процесса требует, чтобы интерпретатор запоминал, какие операции ему
нужно выполнить впоследствии. При вычислении @math{n!} длина цепочки
отложенных умножений, а следовательно, и объем информации, который
требуется, чтобы ее сохранить, растет линейно с ростом @math{n}
(пропорционален @math{n}), как и число шагов. Такой процесс называется
(@newterm{linear recursive process}).

Напротив, второй процесс не растет и не сжимается. На каждом шаге при
любом значении @math{n} необходимо помнить лишь текущие значения
переменных @code{product}, @code{counter} и @code{max-count}. Такой
процесс мы называем (@newterm{iterative process}).

В общем случае, итеративный процесс --- это такой процесс, состояние
которого можно описать конечным числом переменных состояния
(@newterm{state variables}) плюс заранее заданное правило, определяющее, как эти
переменные состояния изменяются от шага к шагу, и плюс (возможно) тест
на завершение, который определяет условия, при которых процесс должен
закончить работу. При вычислении @math{n!} число шагов линейно растет с
ростом @math{n}. Такой процесс называется (@newterm{linear iterative process}).

@endpage
Можно посмотреть на различие этих двух процессов и с другой точки
зрения. В итеративном случае в каждый момент переменные программы дают
полное описание состояния процесса. Если мы остановим процесс между
шагами, для продолжения вычислений нам будет достаточно дать
интерпретатору значения трех переменных программы. С рекурсивным
процессом это не так. В этом случае имеется дополнительная
<<спрятанная>> информация, которую хранит интерпретатор и которая не
содержится в переменных программы. Она указывает, <<где находится>>
процесс в терминах цепочки отложенных операций. Чем длиннее цепочка,
тем больше информации нужно хранить.@footnote{Когда в @ref{Глава 5}
мы будем обсуждать реализацию процедур с помощью регистровых машин, мы
увидим, что итеративный процесс можно реализовать <<в аппаратуре>> как
машину, у которой есть только конечный набор регистров и нет никакой
дополнительной памяти. Напротив, для реализации рекурсивного процесса
требуется машина со вспомогательной структурой данных, называемой
(stack).}

Противопоставляя итерацию и рекурсию, нужно вести себя осторожно и не
смешивать понятие рекурсивного процесса (@newterm{process}) с понятием рекурсивной
процедуры @newterm{procedure}. Когда мы говорим, что процедура рекурсивна, мы
имеем в виду факт синтаксиса: определение процедуры ссылается (прямо
или косвенно) на саму эту процедуру. Когда же мы говорим о процессе,
что он следует, скажем, линейно рекурсивной схеме, мы говорим о
развитии процесса, а не о синтаксисе, с помощью которого написана
процедура. Может показаться странным, например, высказывание
<<рекурсивная процедура @code{fact-iter} описывает итеративный
процесс>>. Однако процесс действительно является итеративным: его
состояние полностью описывается тремя переменными состояния, и чтобы
выполнить этот процесс, интерпретатор должен хранить значение только
трех переменных.

\enlargethispage{\baselineskip}

Различие между процессами и процедурами может запутывать отчасти потому,
что большинство реализаций обычных языков (включая Ada, Pascal и C)
построены так, что интерпретация любой рекурсивной процедуры поглощает
объем памяти, линейно растущий пропорционально количеству вызовов
процедуры, даже если описываемый ею процесс в принципе итеративен. Как
следствие, эти языки способны описывать итеративные процессы только с
помощью специальных<<циклических конструкций>> вроде @code{do},
@code{repeat}, @code{until}, @code{for} и @code{while}. Реализация
Scheme, которую мы рассмотрим в @ref{Глава 5},
свободна от этого недостатка. Она будет выполнять итеративный процесс,
используя фиксированный объем памяти, даже если он описывается
рекурсивной процедурой. Такое свойство реализации языка называется
поддержкой (@newterm{tail recursion}). Если реализация языка поддерживает
хвостовую рекурсию, то итерацию можно выразить с помощью обыкновенного
механизма вызова функций, так что специальные циклические конструкции
имеют смысл только как синтаксический сахар.@footnote{Довольно долго
считалось, что хвостовая рекурсия --- особый трюк в оптимизирующих
компиляторах. Ясное семантическое основание хвостовой рекурсии было
найдено Карлом Хьюиттом @ref{(Hewitt 1977}, который выразил ее в терминах
модели вычислений с помощью <<передачи сообщений>> (мы рассмотрим эту
модель в @ref{Глава 3}).
Вдохновленные этим, Джеральд Джей Сассман и Гай Льюис Стил мл. (см.
@ref{Steele and Sussman 1975}) построили интерпретатор Scheme с поддержкой хвостовой
рекурсии. Позднее Стил показал, что хвостовая рекурсия является
следствием естественного способа компиляции вызовов процедур (@ref{Steele 1977}).
Стандарт Scheme @acronym{IEEE} требует, чтобы все реализации Scheme
поддерживали хвостовую рекурсию.}.

@quotation
@strong{@anchor{Упражнение 1.9}Упражнение 1.9:} Каждая из следующих двух
процедур определяет способ сложения
двух положительных целых чисел с помощью процедур @code{inc}, которая
добавляет к своему аргументу 1, и @code{dec}, которая отнимает от
своего аргумента 1.

@lisp
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
@end lisp

Используя подстановочную модель, проиллюстрируйте процесс, порождаемый
каждой из этих процедур, вычислив @code{(+ 4 5)}. Являются ли эти
процессы итеративными или рекурсивными?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.10}Упражнение 1.10:} Следующая процедура
вычисляет математическую функцию, называемую функцией Аккермана.

@lisp
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
@end lisp

Каковы значения следующих выражений?

@lisp
(A 1 10)
(A 2 4)
(A 3 3)
@end lisp

Рассмотрим следующие процедуры, где @code{A} --- процедура, определенная
выше:

@lisp
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
@end lisp

Дайте краткие математические определения функций, вычисляемых
процедурами @code{f}, @code{g} и @code{h} для положительных целых
значений @math{n}. Например, @code{(k n)} вычисляет @math{5n^2}.
@end quotation

@comment @subsection Tree Recursion
@subsection Древовидная рекурсия
@node	1.2.2, 1.2.3, 1.2.1, 1.2

Существует еще одна часто встречающаяся схема вычислений, называемая
древовидная рекурсия (@newterm{tree recursion}). В качестве примера
рассмотрим вычисление последовательности чисел Фибоначчи, в которой
каждое число является суммой двух предыдущих:
@ifinfo
@center 0, 1, 1, 2, 3, 5, 8, 13, 21, @dots{}
@end ifinfo
@tex
$$ 0,\; 1,\; 1,\; 2,\; 3,\; 5,\; 8,\; 13,\; 21,\; \dots. $$
@end tex
Общее правило для чисел Фибоначчи можно сформулировать так:
@ifinfo

@example
         /
         |  0                        if n = 0
Fib(n) = <  1                        if n = 1
         |  Fib(n - 1) + Fib(n - 2)  otherwise
         \
@end example

@end ifinfo
@tex
$$ {\rm Fib}(n) =
\begin{cases}
        \; 0 & {\rm if} \;\; n=0, \\
	\; 1 & {\rm if} \;\; n=1, \\
	\; {\rm Fib}(n-1) + {\rm Fib}(n-2) \quad & {\rm otherwise}.
\end{cases} $$
@end tex
Можно немедленно преобразовать это определение в процедуру:

@lisp
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
@end lisp

@noindent
Рассмотрим схему этого вычисления. Чтобы вычислить @code{(fib 5)}, мы
сначала вычисляем @code{(fib 4)} и @code{(fib 3)}. Чтобы вычислить
@code{(fib 4)}, мы вычисляем @code{(fib 3)} и @code{(fib 2)}. В общем,
получающийся процесс похож на дерево, как показано на
рис. @ref{Рисунок 1.5}. Заметьте, что на каждом уровне (кроме дна)
ветви разделяются надвое; это отражает тот факт, что процедура
@code{fib} при каждом вызове обращается к самой себе дважды.

Эта процедура полезна как пример прототипической древовидной рекурсии,
но как метод получения чисел Фибоначчи она ужасна, поскольку производит
массу излишних вычислений. Обратите внимание на
рис. @ref{Рисунок 1.5}: все вычисление @code{(fib 3)} --- почти
половина общей работы, --- повторяется дважды. В сущности, нетрудно
показать, что общее число раз, которые эта процедура вызовет
@code{(fib 1)} или @code{(fib 0)} (в общем, число листьев) в точности
равняется Fib(@math{n+1}). Чтобы понять, насколько это
плохо, отметим, что значение Fib(@math{n}) растет экспоненциально при
увеличении @math{n}. Более точно (см. в @ref{Упражнение 1.13}),
Fib(@math{n}) --- это целое число, ближайшее к @math{\varphi^n / \sqrt{5}}, где
@ifinfo

@example
[phi] = (1 + [sqrt]5)/2 ~= 1.6180
@end example

@end ifinfo
@tex
$$\varphi = {1 + \sqrt{5}\over2} \approx 1.6180 $$
@end tex
@noindent
есть золотое сечение (@newterm{golden ratio}), которое удовлетворяет уравнению
@ifinfo

@example
[phi]^2 = [phi] + 1
@end example

@end ifinfo
@tex
$$\varphi^2 = \varphi + 1. $$
@end tex

@float
@quotation
@anchor{Рисунок 1.5}
@ifinfo
@strong{Рисунок 1.5:} Древовидно-рекурсивный процесс, порождаемый при вычислении @code{(fib 5)}.

@example

                   ..<............ fib5   <..........
                ...     ___________/  \___________   .
             ...       /       . .....            \    .
           ..       fib4     .        . . . .     fib3  .
         ..     ____/. \____  ..             .  __/  \__  .
       ..      /  . .  ..   \    .        ..   /  . .   \   .
     ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
   ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
 ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
.      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
.      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
.  fib1 .. fib0..  .   .   .   .   .   V   .   ..  .
.   |  .  . |  . .>     .>.     . .    ..>.      .>
.   1 .   . 0  .
 .   .     .  .
  .>.       ..

@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap1/Fig1.5c,90mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 1.5:} Древовидно-рекурсивный процесс, порождаемый при вычислении @code{(fib 5)}.}
@sp 0.0
@end iftex
@end quotation
@end float

@noindent
Таким образом, число шагов нашего процесса
растет экспоненциально при увеличении аргумента. С другой стороны,
требования к памяти растут при увеличении аргумента всего лишь линейно,
поскольку в каждой точке вычисления нам требуется запоминать только те
вершины, которые находятся выше нас по дереву. В общем случае число
шагов, требуемых древовидно-рекурсивным процессом, будет пропорционально
числу вершин дерева, а требуемый объем памяти будет пропорционален
максимальной глубине дерева.

Для получения чисел Фибоначчи мы можем сформулировать итеративный
процесс. Идея состоит в том, чтобы использовать пару целых @math{a} и
@math{b}, которым в начале даются значения
Fib(1) = 1 и Fib(0) = 0, и на каждом шаге применять одновременную трансформацию
@ifinfo

@example
a <- a + b
b <- a
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{\;\;\gets\;\;}l}
  a & a + b, \\
  b & a.
\end{array}
$$
@end tex
@noindent
Нетрудно показать, что после того, как мы проделаем эту
трансформацию @math{n} раз, @math{a} и @math{b} будут соответственно
равны Fib(@math{n + 1}) и Fib(@math{n}).
Таким образом, мы можем итеративно вычислять числа Фибоначчи при помощи
процедуры

@lisp
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
@end lisp

@noindent
Второй метод вычисления чисел Фибоначчи представляет собой линейную
итерацию. Разница в числе шагов, требуемых двумя этими методами ---
один пропорционален @math{n}, другой растет так же быстро, как и само
Fib(@math{n}), --- огромна, даже для небольших значений аргумента.

Не нужно из этого делать вывод, что древовидно-рекурсивные процессы
бесполезны. Когда мы будем рассматривать процессы, работающие не с
числами, а с иерархически структурированными данными, мы увидим, что
древовидная рекурсия является естественным и мощным
инструментом.@footnote{Пример этого был упомянут в
разделе @ref{1.1.3}: сам интерпретатор
вычисляет выражения с помощью древовидно-рекурсивного процесса.} Но
даже при работе с числами древовидно-рекурсивные процессы могут быть
полезны --- они помогают нам понимать и проектировать программы.
Например, хотя первая процедура @code{fib} и намного менее эффективна,
чем вторая, зато она проще, поскольку это немногим более, чем перевод
определения последовательности чисел Фибоначчи на Лисп. Чтобы
сформулировать итеративный алгоритм, нам пришлось заметить, что
вычисление можно перестроить в виде итерации с тремя переменными
состояния.

@comment @subsubheading Example: Counting change
@subsubheading Пример: Размен денег

Чтобы сочинить итеративный алгоритм для чисел Фибоначчи, нужно совсем
немного смекалки. Теперь для контраста рассмотрим следующую задачу:
сколькими способами можно разменять сумму в 1 доллар, если имеются
монеты по 50, 25, 10, 5 и 1 цент? В более общем случае, можно ли
написать процедуру подсчета способов размена для произвольной суммы
денег?

У этой задачи есть простое решение в виде рекурсивной процедуры.
Предположим, мы как-то упорядочили типы монет, которые у нас есть. В
таком случае верно будет следующее уравнение:

Число способов разменять сумму @math{a} с помощью @math{n} типов монет
равняется

@itemize @bullet

@item
числу способов разменять сумму @math{a} с помощью всех типов монет,
кроме первого, плюс

@item
число способов разменять сумму @math{a - d} с использованием всех @math{n}
типов монет, где @math{d} --- достоинство монет первого типа.

@end itemize

@noindent
Чтобы увидеть, что это именно так, заметим, что способы размена могут
быть поделены на две группы: те, которые не используют первый тип
монеты, и те, которые его используют. Следовательно, общее число
способов размена какой-либо суммы равно числу способов разменять эту
сумму без привлечения монет первого типа плюс число способов размена в
предположении, что мы этот тип используем. Но последнее число равно
числу способов размена для суммы, которая остается после того, как мы
один раз употребили первый тип монеты.

Таким образом, мы можем рекурсивно свести задачу размена данной суммы к
задаче размена меньших сумм с помощью меньшего количества типов монет.
Внимательно рассмотрите это правило редукции и убедите себя, что мы
можем использовать его для описания алгоритма, если укажем следующие
вырожденные случаи:@footnote{Рассмотрите для примера в деталях, как
применяется правило редукции, если нужно разменять 10 центов на
монеты в 1 и 5 центов.}

@itemize @bullet

@item
Если @math{a} в точности равно 0, мы считаем, что имеем 1 способ размена.

@item
Если @math{a} меньше 0, мы считаем, что имеем 0 способов размена.

@item
Если @math{n} равно 0, мы считаем, что имеем 0 способов размена.

@end itemize

@noindent
Это описание легко перевести в рекурсивную процедуру:

@lisp
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination
                         kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
@end lisp

@noindent
(Процедура @code{first-denomination} принимает в качестве входа число
доступных типов монет и возвращает достоинство первого типа. Здесь мы
упорядочили монеты от самой крупной к более мелким, но годился бы и
любой другой порядок.) Теперь мы можем ответить на исходный вопрос о
размене доллара:

@lisp
(count-change 100)
@i{292}
@end lisp

@noindent
@code{count-change} порождает древовидно-рекурсивный процесс с
избыточностью, похожей на ту, которая возникает в нашей первой
реализации @code{fib}. (На то, чтобы получить ответ 292, уйдет заметное
время.) С другой стороны, неочевидно, как построить более эффективный
алгоритм для получения этого результата, и мы оставляем это в качестве
задачи для желающих. Наблюдение, что древовидная рекурсия может быть
весьма неэффективна, но зато ее часто легко сформулировать и понять,
привело исследователей к мысли, что можно получить лучшее из двух
миров, если спроектировать <<умный компилятор>>, который мог бы
трансформировать древовидно-рекурсивные процедуры в более эффективные,
но вычисляющие тот же результат.@footnote{Один из способов избежать
избыточных вычислений состоит в том, чтобы автоматически строить
таблицу значений по мере того, как они вычисляются. Каждый раз, когда
нужно применить процедуру к какому-нибудь аргументу, мы могли бы
сначала обращаться к таблице, смотреть, не хранится ли в ней уже
значение, и в этом случае мы избежали бы избыточного вычисления. Такая
стратегия, называемая (@newterm{tabulation}) или (@newterm{memoization}), легко реализуется.
Иногда с помощью табуляризации можно преобразовать процессы, требующие
экспоненциального числа шагов (вроде @code{count-change}), в процессы,
требования которых к времени и памяти линейно растут по мере роста
ввода. См. @ref{Упражнение 3.27}.}

@quotation
@strong{@anchor{Упражнение 1.11}Упражнение 1.11:} Функция @math{f}
определяется правилом:
@tex
$$
f(n) =
\begin{cases}
\;\; n \quad \text{if \; \( n < 3 \),} \\
\;\; f(n-1) + 2\kern-0.08em f(n-2) + 3\kern-0.08em f(n-3) \quad \text{if \; \( n \ge 3 \).}
\end{cases}
$$
@end tex
Напишите процедуру, вычисляющую
@math{f} с помощью рекурсивного процесса. Напишите процедуру,
вычисляющую @math{f} с помощью итеративного процесса.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.12}Упражнение 1.12:} Приведенная ниже таблица называется триугольник Паскаля (@newterm{Pascal's triangle}).

@example
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
      . . .
@end example

Все числа по краям треугольника равны 1, а каждое число
внутри треугольника равно сумме двух чисел над ним.@footnote{Элементы
треугольника Паскаля называются (@newterm{binomial coefficients}), поскольку
@math{n}-й ряд состоит из коэффициентов термов при разложении
@math{(x + y)^n}. Эта схема вычисления коэффициентов появилась в
передовой работе Блеза Паскаля 1653 года по теории вероятностей
@cite{Trait@'e dutriangle arithm@'etique}. Согласно @ref{Knuth (1973)}, та же схема
встречается в труде @emph{Цзу-юань Юй-чэнь} (<<Драгоценное зеркало
четырех элементов>>), опубликованном китайским математиком Цзю Ши-Цзе в
1303 году, в трудах персидского поэта и математика двенадцатого века
Омара Хайяма и в работах индийского математика двенадцатого века
Бхаскары Ачарьи.} Напишите процедуру, вычисляющую элементы треугольника
Паскаля с помощью рекурсивного процесса.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.13}Упражнение 1.13:} Докажите, что Fib(@math{n})
есть целое число, ближайшее к @math{\varphi^n / \sqrt{5}}, где @math{\varphi = (1 + \sqrt{5}) / 2}.  Указание: пусть @math{\psi = (1 - \sqrt{5}) / 2}.
С помощью определения чисел Фибоначчи (см. @ref{1.2.2}) и индукции докажите,
что @math{\text{Fib}(n) = (\varphi^n - \psi^n) / \sqrt{5}}.
@end quotation

@comment @subsection Orders of Growth
@subsection Порядки роста
@node	1.2.3, 1.2.4, 1.2.2, 1.2

Предшествующие примеры показывают, что процессы могут значительно
различаться по количеству вычислительных ресурсов, которые они
потребляют. Удобным способом описания этих различий является понятие
(@newterm{order of growth}), которое дает общую оценку ресурсов, необходимых
процессу при увеличении его входных данных.

Пусть @math{n} --- параметр, измеряющий размер задачи, и пусть
@math{R(n)} --- количество ресурсов, необходимых процессу для решения
задачи размера @math{n}. В предыдущих примерах @math{n} было числом, для
которого требовалось вычислить некоторую функцию, но возможны и другие
варианты. Например, если требуется вычислить приближение к квадратному
корню числа, то @math{n} может быть числом цифр после запятой, которые
нужно получить. В задаче умножения матриц @math{n} может быть
количеством рядов в матрицах. Вообще говоря, может иметься несколько
характеристик задачи, относительно которых желательно проанализировать
данный процесс. Подобным образом, @math{R(n)} может измерять количество
используемых целочисленных регистров памяти, количество исполняемых
элементарных машинных операций, и так далее. В компьютерах, которые
выполняют определенное число операций за данный отрезок времени,
требуемое время будет пропорционально необходимому числу элементарных
машинных операций.

Мы говорим, что @math{R(n)} имеет порядок роста @math{\Theta(f(n))}, что
записывается @math{R(n) = \Theta(f(n))} и произносится <<тета от @math{f(n)}>>,
если существуют положительные постоянные @math{k_1} и @math{k_2}, независимые
от @math{n}, такие, что @math{k_1 f(n) \le R(n) \le k_2f(n)} для всякого
достаточно большого @math{n}. (Другими словами, значение @math{R(n)}
заключено между @math{k_1f(n)} и @math{k_2f(n)}.)

\enlargethispage{\baselineskip}

Например, для линейно рекурсивного процесса вычисления факториала,
описанного в разделе @ref{1.2.1},
число шагов растет пропорционально входному значению @math{n}. Таким
образом, число шагов, необходимых этому процессу, растет как
@math{\Theta(n)}. Мы видели также, что требуемый объем памяти растет как
@math{\Theta(n)}. Для итеративного факториала число шагов по-прежнему
@math{\Theta(n)}, но объем памяти @math{\Theta(1)} --- то есть
константа.@footnote{В этих утверждениях скрывается важное упрощение.
Например, если мы считаем шаги процесса как <<машинные операции>>, мы
предполагаем, что число машинных операций, нужных, скажем, для
вычисления произведения, не зависит от размера умножаемых чисел, а это
становится неверным при достаточно больших числах. Те же замечания
относятся и к оценке требуемой памяти. Подобно проектированию и
описанию процесса, анализ процесса может происходить на различных
уровнях абстракции.} Древовидно-рекурсивное вычисление чисел Фибоначчи
требует @math{\Theta(\phi^n)} шагов и @math{\Theta(n)} памяти, где
@math{\phi} --- золотое сечение, описанное в
разделе @ref{1.2.2}.

Порядки роста дают всего лишь грубое описание поведения процесса.
Например, процесс, которому требуется @math{n^2} шагов, процесс,
которому требуется @math{1000n^2} шагов и процесс, которому требуется
@math{3n^2 + 10n + 17} шагов --- все имеют порядок роста
@math{\Theta(n^2)}. С другой стороны, порядок роста показывает, какого
изменения можно ожидать в поведении процесса, когда мы меняем размер
задачи. Для процесса с порядком роста @math{\Theta(n)} (линейного)
удвоение размера задачи примерно удвоит количество используемых
ресурсов. Для экспоненциального процесса каждое увеличение размера
задачи на единицу будет умножать количество ресурсов на постоянный
коэффициент. В оставшейся части раздела @ref{1.2} мы
рассмотрим два алгоритма, которые имеют логарифмический порядок роста,
так что удвоение размера задачи увеличивает требования к ресурсам на
постоянную величину.
@endpage

@quotation
@strong{@anchor{Упражнение 1.14}Упражнение 1.14:} Нарисуйте дерево,
иллюстрирующее процесс, который порождается процедурой @code{count-change} из
раздела @ref{1.2.2} при размене 11 центов. Каковы
порядки роста памяти и числа шагов, используемых этим процессом при
увеличении суммы, которую требуется разменять?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.15}Упражнение 1.15:} Синус угла (заданного
в радианах) можно вычислить, если
воспользоваться приближением @w{@math{\sin x \approx x}} при малых
@math{x} и употребить тригонометрическое тождество

@ifinfo

@example
               x             x
sin x = 3 sin --- - 4 sin^3 ---
               3             3
@end example

@end ifinfo
@tex
$$\sin x = 3\sin {x\over3} - 4\sin^3 {x\over3} $$
@end tex
@noindent
для уменьшения значения аргумента sin. (В этом упражнении мы будем
считать, что угол <<достаточно мал>>, если он не больше 0.1 радиана.)
Эта идея используется в следующих процедурах:

@lisp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
@end lisp

@enumerate a.

@item
Сколько раз вызывается процедура @code{p} при вычислении @code{(sine 12.15)}?

@item
Каковы порядки роста в терминах количества шагов и используемой памяти
(как функция @math{a}) для процесса, порождаемого процедурой @code{sine}
при вычислении @code{(sine a)}?

@end enumerate
@end quotation

@comment @subsection Exponentiation
@subsection Возведение в степень
@node	1.2.4, 1.2.5, 1.2.3, 1.2

Рассмотрим задачу возведения числа в степень. Нам нужна процедура,
которая, приняв в качестве аргумента основание @math{b} и положительное
целое значение степени @math{n}, возвращает @math{b^n}. Один из способов
получить желаемое --- через рекурсивное определение
@ifinfo

@example
b^n = b * b^(n - 1)
b^0 = 1
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{{}={}}l}
  b^n & b\cdot b^{n-1}, \\
  b^0 & 1,
\end{array}
$$
@end tex
которое прямо переводится в процедуру

@lisp
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
@end lisp

@noindent
Это линейно рекурсивный процесс, требующий @math{\Theta(n)} шагов и
@math{\Theta(n)} памяти. Подобно факториалу, мы можем немедленно
сформулировать эквивалентную линейную итерацию:

@lisp
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
@end lisp

@noindent
Эта версия требует @math{\Theta(n)} шагов и @math{\Theta(1)} памяти.

Можно вычислять степени за меньшее число шагов, если использовать
последовательное возведение в квадрат. Например, вместо того, чтобы
вычислять @math{b^8} в виде
@ifinfo

@example
b * (b * (b * (b * (b * (b * (b * b))))))
@end example

@end ifinfo
@tex
$$ b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot b))))))\,, $$
@end tex
мы можем вычислить его за три умножения:
@ifinfo

@example
b^2 = b * b
b^4 = b^2 * b^2
b^8 = b^4 * b^4
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{{}={}}l}
  b^2 & b\cdot b, \\
  b^4 & b^2\cdot b^2, \\
  b^8 & b^4\cdot b^4.
\end{array}
$$
@end tex
Этот метод хорошо работает для степеней, которые сами являются степенями
двойки. В общем случае при вычислении степеней мы можем получить
преимущество от последовательного возведения в квадрат, если
воспользуемся правилом
@ifinfo

@example
b^n = (b^(n/2))^2    если n четно
b^n = b * b^(n - 1)  если n нечетно
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{{}={}}lr@{\ n\ }l}
  b^n & (b^{n / 2})^2  \;\; & \mbox{Если\,} & \mbox{\,четно}, \\
  b^n & b\cdot b^{n-1} \;\; & \mbox{if\,} & \mbox{\,нечетно}.
\end{array}
$$
@end tex
Этот метод можно выразить в виде процедуры

@lisp
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
@end lisp

@noindent
где предикат, проверяющий целое число на четность, определен через
элементарную процедуру @code{remainder}:

@lisp
(define (even? n)
  (= (remainder n 2) 0))
@end lisp

@noindent
Процесс, вычисляющий @code{fast-expt}, растет логарифмически как по
используемой памяти, так и по количеству шагов. Чтобы увидеть это,
заметим, что вычисление @math{b^{2n}} с помощью этого алгоритма требует
всего на одно умножение больше, чем вычисление @math{b^n}.
Следовательно, размер степени, которую мы можем вычислять, возрастает
примерно вдвое с каждым следующим умножением, которое нам разрешено
делать. Таким образом, число умножений, требуемых для вычисления степени
@math{n}, растет приблизительно так же быстро, как логарифм @math{n} по
основанию 2. Процесс имеет степень роста
@math{\Theta(\log(n))}.@footnote{Точнее, количество требуемых умножений
равно логарифму @math{n} по основанию 2 минус 1 и плюс количество
единиц в двоичном представлении @math{n}. Это число всегда меньше, чем
удвоенный логарифм @math{n} по основанию 2. Произвольные константы
@math{k_1} и @math{k_2} в определении порядка роста означают, что для
логарифмического процесса основание, по которому берется логарифм, не
имеет значения, так что все такие процессы описываются как
@math{\Theta(\log(n))}.}

Если @math{n} велико, разница между порядком роста
@math{\Theta(\log(n))} и @math{\Theta(n)} оказывается очень заметной.
Например, @code{fast-expt} при @math{n = 1000} требует всего 14
умножений.@footnote{Если Вас интересует, зачем это кому-нибудь может
понадобиться возводить числа в 1000-ю степень, смотрите
раздел @ref{1.2.6}.} С помощью идеи
последовательного возведения в квадрат можно построить также
итеративный алгоритм, который вычисляет степени за логарифмическое число
шагов (см. @ref{Упражнение 1.16}), хотя, как это часто
бывает с итеративными алгоритмами, его нельзя записать так же просто,
как рекурсивный алгоритм.@footnote{Итеративный алгоритм очень стар. Он
встречается в @cite{Чанда-сутре} Ачарьи Пингалы, написанной до 200 года
до н.э. В @ref{Knuth (1981)}, раздел 4.6.3, содержится полное обсуждение и
анализ этого и других методов возведения в степень.}

@quotation
@strong{@anchor{Упражнение 1.16}Упражнение 1.16:} Напишите процедуру,
которая развивается в виде
итеративного процесса и реализует возведение в степень за
логарифмическое число шагов, как @code{fast-expt}. (Указание: используя
наблюдение, что @math{(b^{n / 2})^2 = (b^2)^{n / 2}}, храните, помимо
значения степени @math{n} и основания @math{b}, дополнительную
переменную состояния @math{a}, и определите переход между состояниями
так, чтобы произведение @math{ab^n} от шага к шагу не менялось. Вначале
значение @math{a} берется равным 1, а ответ получается как значение
@math{a} в момент окончания процесса. В общем случае метод определения
(@newterm{invariant quantity}), который не изменяется при переходе между
шагами, является мощным способом размышления о построении итеративных
алгоритмов.)
@end quotation

@quotation
@strong{@anchor{Упражнение 1.17}Упражнение 1.17:} Алгоритмы возведения
в степень из этого раздела основаны
на повторяющемся умножении. Подобным же образом можно производить
умножение с помощью повторяющегося сложения. Следующая процедура
умножения (в которой предполагается, что наш язык способен только
складывать, но не умножать) аналогична процедуре @code{expt}:

@lisp
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
@end lisp

Этот алгоритм затрачивает количество шагов, линейно пропорциональное
@code{b}. Предположим теперь, что, наряду со сложением, у нас есть
операции @code{double}, которая удваивает целое число, и @code{halve},
которая делит (четное) число на 2. Используя их, напишите процедуру,
аналогичную @code{fast-expt}, которая затрачивает логарифмическое число
шагов.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.18}Упражнение 1.18:} Используя результаты
@ref{Упражнение 1.16} и @ref{Упражнение 1.17}, разработайте
процедуру, которая порождает
итеративный процесс для умножения двух чисел с помощью сложения,
удвоения и деления пополам, и затрачивает логарифмическое число
шагов.@footnote{Этот алгоритм, который иногда называют <<методом русского
крестьянина>>, очень стар. Примеры его использования найдены в Риндском
папирусе, одном из двух самых древних существующих математических
документов, который был записан (и при этом скопирован с еще более
древнего документа) египетским писцом по имени А'х-мосе около 1700 г. до
н.э.}
@end quotation

\enlargethispage{\baselineskip}

@quotation
@strong{@anchor{Упражнение 1.19}Упражнение 1.19:} Существует
хитрый алгоритм получения чисел Фибоначчи за
логарифмическое число шагов. Вспомните трансформацию переменных
состояния @math{a} и @math{b} процесса @code{fib-iter} из
раздела @ref{1.2.2}: @math{a \gets a+b} и
@math{b \gets a}. Назовем эту трансформацию @math{T} и заметим, что
@math{n}-кратное применение @math{T}, начиная с 1 и 0, дает нам пару
Fib(@math{n+1} и Fib(@math{n}. Другими
словами, числа Фибоначчи получаются путем применения @math{T^n},
@math{n}-ой степени трансформации @math{T}, к паре (1,0). Теперь
рассмотрим @math{T} как частный случай @math{p = 0, q =
1} в семействе трансформаций @math{T_{pq}}, где @math{T_{pq}}
преобразует пару @math{(a,b)} по правилу
@math{a \gets bq + aq + ap} и @math{b \gets bp + aq}. Покажите, что двукратное
применение трансформации @math{T_{pq}} равносильно однократному
применению трансформации @math{T_{p'\!q'}} того же типа, и вычислите
@math{p'\!} и @math{q'\!} через @math{p} и @math{q}. Это дает нам прямой
способ возводить такие трансформации в квадрат, и таким образом, мы
можем вычислить @math{T^n} с помощью последовательного возведения в
квадрат, как в процедуре @code{fast-expt}. Используя все эти идеи,
завершите следующую процедуру, которая дает результат за логарифмическое
число шагов:@footnote{Это упражнение нам предложил Джо Стой на основе
примера из @ref{Kaldewaij 1990}.}

@lisp
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   @math{\langle}??@math{\rangle}   @r{; вычислить @math{p'}}
                   @math{\langle}??@math{\rangle}   @r{; вычислить @math{q'}}
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
@end lisp
@end quotation

@comment @subsection Greatest Common Divisors
@subsection Нахождение наибольшего общего делителя
@node	1.2.5, 1.2.6, 1.2.4, 1.2

По определению, наибольший общий делитель (НОД) двух целых чисел
@math{a} и @math{b} --- это наибольшее целое число, на которое и
@math{a}, и @math{b} делятся без остатка. Например, НОД 16 и 28 равен
4. В @ref{Глава 2},
когда мы будем исследовать реализацию арифметики на рациональных числах,
нам потребуется вычислять НОДы, чтобы сокращать дроби. (Чтобы сократить
дробь, нужно поделить ее числитель и знаменатель на их НОД. Например,
16/28 сокращается до 4/7.) Один из способов найти НОД двух чисел состоит
в том, чтобы разбить каждое из них на простые множители и найти среди
них общие, однако существует знаменитый и значительно более эффективный
алгоритм.

Этот алгоритм основан на том, что если @math{r} есть остаток от деления
@math{a} на @math{b}, то общие делители @math{a} и @math{b} в точности
те же, что и общие делители @math{b} и @math{r}. Таким образом, можно
воспользоваться уравнением

@example
НОД(a,b) = НОД(b,r)
@end example

@noindent
чтобы последовательно свести задачу нахождения НОД к задаче нахождения НОД
все меньших и меньших пар целых чисел. Например,

@example
НОД(206,40) = НОД(40,6)
            = НОД(6,4)
            = НОД(4,2)
            = НОД(2,0)
            = 2
@end example

@noindent
сводит НОД(206, 40) к НОД(2, 0), что равняется двум. Можно показать,
что если начать с произвольных двух целых чисел и производить
последовательные редукции, в конце концов всегда получится пара, где
вторым элементом будет 0. Этот способ нахождения НОД известен как
(@newterm{Euclid's Algorithm}).@footnote{Алгоритм Евклида называется так потому,
что он встречается в @cite{Началах} Евклида (книга 7, ок. 300 г. до
н.э.). По утверждению Кнута @ref{Knuth (1973)}, его можно считать самым старым
из известных нетривиальных алгоритмов. Древнеегипетский метод умножения
(@ref{Упражнение 1.18}), разумеется, древнее, но, как
объясняет Кнут, алгоритм Евклида --- самый старый алгоритм,
представленный в виде общей процедуры, а не через набор иллюстрирующих
примеров.}

Алгоритм Евклида легко выразить в виде процедуры:

@lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
@end lisp

@noindent
Она порождает итеративный процесс, число шагов которого растет
пропорционально логарифму чисел-аргументов.

Тот факт, что число шагов, затрачиваемых алгоритмом Евклида, растет
логарифмически, интересным образом связан с числами Фибоначчи:

@quotation
@strong{Теорема Ламэ:}

Если алгоритму Евклида требуется @math{k} шагов для вычисления НОД
некоторой пары чисел, то меньший из членов этой пары больше или равен
@math{k}-тому числу Фибоначчи.@footnote{Эту теорему доказал в 1845 году
Габриэль Ламэ, французский математик и инженер, который больше всего
известен своим вкладом в математическую физику. Чтобы доказать теорему,
рассмотрим пары @math{(a_k, b_k)}, где @math{a_k \ge b_k} и алгоритм
Евклида завершается за @math{k} шагов. Доказательство основывается на
утверждении, что если
@math{(a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1},
b_{k-1})} --- три последовательные пары в процессе редукции, то
@math{b_{k+1} \ge b_k + b_{k-1}}. Чтобы доказать это утверждение,
вспомним, что шаг редукции определяется применением трансформации
@math{a_{k-1} = b_k, b_{k-1} =} остаток от деления @math{a_k} на
@math{b_k}. Второе из этих уравнений означает, что
@math{a_k = qb_k + b_{k-1}} для некоторого положительного числа
@math{q}. Поскольку @math{q} должно быть не меньше 1, имеем
@math{a_k = qb_k + b_{k-1} \ge b_k +
b_{k-1}}. Но из предыдущего шага редукции мы имеем @math{b_{k+1} = a_k}.
Таким образом, @math{b_{k+1} = a_k \ge b_k 
+ b_{k-1}}. Промежуточное утверждение доказано. Теперь можно доказать
теорему индукцией по @math{k}, то есть числу шагов, которые требуются
алгоритму для завершения. Утверждение теоремы верно при @math{k = 1},
поскольку при этом требуется всего лишь чтобы @math{b} было не меньше,
чем Fib(1) = 1. Теперь предположим, что утверждение верно для всех чисел,
меньших или равных @math{k}, и докажем его для @math{k + 1}. Пусть
@math{(a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1})} ---
последовательные пары в процессе редукции. Согласно гипотезе индукции,
@math{b_{k-1} \ge {\rm Fib}(k - 1), b_k \ge {\rm Fib} (k)}. Таким образом,
применение промежуточного
утверждения совместно с определением чисел Фибоначчи дает
@math{b_{k+1} \ge b_k + b_{k-1} \ge {\rm Fib}(k) + {\rm
Fib}(k-1) = {\rm Fib} (k+1)}, что и доказывает теорему Ламэ.}
@end quotation

@noindent
С помощью этой теоремы можно оценить порядок роста алгоритма Евклида.
Пусть @math{n} будет меньшим из двух аргументов процедуры. Если процесс
завершается за @math{k} шагов, должно выполняться
@math{n \ge {\rm Fib} (k) \approx
\phi^k / \sqrt{5}}. Следовательно, число шагов @math{k} растет как
логарифм @math{n} (по основанию @math{\varphi}). Следовательно, порядок
роста равен @math{\Theta(\log n)}.

@quotation
@strong{@anchor{Упражнение 1.20}Упражнение 1.20:} Процесс, порождаемый
процедурой, разумеется, зависит от того, по
каким правилам работает интерпретатор. В качестве примера рассмотрим
итеративную процедуру @code{gcd}, приведенную выше. Предположим, что мы
вычисляем эту процедуру с помощью нормального порядка, описанного в
разделе @ref{1.1.5}. (Правило нормального
порядка вычислений для @code{if} описано в
упражнении @ref{Упражнение 1.5}.) Используя подстановочную модель для
нормального порядка, проиллюстрируйте процесс, порождаемый при
вычислении @code{(gcd 206 40)} и укажите, какие операции вычисления
остатка действительно выполняются. Сколько операций @code{remainder}
выполняется на самом деле при вычислении @code{(gcd 206 40)} в
нормальном порядке? При вычислении в аппликативном порядке?
@end quotation

@comment @subsection Example: Testing for Primality
@subsection Пример: проверка на простоту
@node	1.2.6,  , 1.2.5, 1.2

В этом разделе описываются два метода проверки числа @math{n} на
простоту, один с порядком роста @math{\Theta
(\sqrt{n})}, и другой, <<вероятностный>>, алгоритм с порядком роста
@math{\Theta(\log n)}. В упражнениях, приводимых в конце раздела,
предлагаются программные проекты на основе этих алгоритмов.

@comment @subsubheading Searching for divisors
@subsubheading Поиск делителей

С древних времен математиков завораживали проблемы, связанные с
простыми числами, и многие люди занимались поисками способов выяснить,
является ли число простым. Один из способов проверки числа на простоту
состоит в том, чтобы найти делители числа. Следующая программа находит
наименьший целый делитель (больший 1) числа @math{n}. Она проделывает
это <<в лоб>>, путем проверки делимости @math{n} на все последовательные
числа, начиная с 2.

@lisp
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
@end lisp

@noindent
Мы можем проверить, является ли число простым, следующим образом:
@math{n} простое тогда и только тогда, когда @math{n} само является
своим наименьшим делителем.

@lisp
(define (prime? n)
  (= n (smallest-divisor n)))
@end lisp

@noindent
Тест на завершение основан на том, что если число @math{n} не
простое, у него должен быть делитель, меньше или равный
@math{\sqrt{n}}.@footnote{Если @math{d} --- делитель @math{n}, то
@math{n / d} тоже. Но @math{d} и @math{n /
d} не могут оба быть больше @math{\sqrt{n}}.} Это означает, что
алгоритм может проверять делители только от 1 до @math{\sqrt{n}}.
Следовательно, число шагов, которые требуются, чтобы определить, что
@math{n} простое, будет иметь порядок роста @math{\Theta(\sqrt{n})}.

@comment @subsubheading The Fermat test
@subsubheading Тест Ферма
Тест на простоту с порядком роста @math{\Theta(\log n)} основан на
утверждении из теории чисел, известном как Малая теорема
Ферма.@footnote{Пьер де Ферма (1601-1665) считается основателем
современной теории чисел. Он доказал множество важных теорем, однако,
как правило, он объявлял только результаты, не публикуя своих
доказательств. Малая теорема Ферма была сформулирована в письме, которое
он написал в 1640-м году. Первое опубликованное доказательство было
даноЭйлером в 1736 г. (более раннее, идентичное доказательство было
найдено в неопубликованных рукописях Лейбница). Самый знаменитый
результат Ферма, известный как Большая теорема Ферма, был записан в
1637 году в его экземпляре книги @cite{Арифметика} (греческого
математика третьего века Диофанта) с пометкой <<я нашел подлинно
удивительное доказательство, но эти поля слишком малы, чтобы вместить
его>>. Доказательство Большой теоремы Ферма стало одним из самых
известных вопросов теории чисел. Полное решение было найдено в 1995
году Эндрю Уайлсом из Принстонского университета.}

@quotation
@strong{Малая теорема Ферма:}
Если @math{n} --- простое число, а @math{a} --- произвольное целое число
меньше, чем @math{n}, то @math{a}, возведенное в @math{n}-ю степень,
равно @math{a} по модулю @math{n}.
@end quotation

@noindent
(Говорят, что два числа (congruent modulo @math{n}), если они дают
одинаковый остаток при делении на @math{n}. Остаток от деления числа
@math{a} на @math{n} называется также (remainder of @math{a} modulo
@math{n}) или просто @emph{@math{a} по модулю @math{n}}.)

Если @math{n} не является простым, то, вообще говоря, большинство чисел
@math{a < n} не будут удовлетворять этому условию. Это приводит к
следующему алгоритму проверки на простоту: имея число @math{n},
случайным образом выбрать число @math{a < n} и вычислить остаток от
@math{a^n} по модулю @math{n}. Если этот остаток не равен @math{a}, то
@math{n} определенно не является простым. Если он равен @math{a}, то мы
имеем хорошие шансы, что @math{n} простое. Тогда нужно взять еще одно
случайное @math{a} и проверить его тем же способом. Если и оно
удовлетворяет уравнению, мы можем быть еще более уверены, что @math{n}
простое. Испытывая все большее количество @math{a}, мы можем увеличивать
нашу уверенность в результате. Этот алгоритм называется тестом Ферма.

Для реализации теста Ферма нам нужна процедура, которая вычисляет
степень числа по модулю другого числа:

@lisp
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))
@end lisp

@noindent
Эта процедура очень похожа на @code{fast-expt} из
раздела @ref{1.2.4}. Она использует последовательное
возведение в квадрат, так что число шагов логарифмически растет с
увеличением степени.@footnote{Шаги редукции для случаев, когда степень
больше 1, основаны на том, что для любых целых чисел @math{x},
@math{y} и @math{m} мы можем найти остаток от деления произведения
@math{x} и @math{y} на @math{m} путем отдельного вычисления остатков
@math{x} по модулю @math{m}, @math{y} по модулю @math{m}, перемножения
их, и взятия остатка по модулю @math{m} от результата. Например, в
случае, когда @math{e} четно, мы можем вычислить остаток
@math{b^{e / 2}} по модулю @math{m}, возвести его в квадрат и взять
остаток по модулю @math{m}. Такой метод полезен потому, что с его
помощью мы можем производить вычисления, не используя чисел, намного
больших, чем @math{m}. (Сравните с @ref{Упражнение 1.25}.)}

Тест Ферма производится путем случайного выбора числа @math{a} между
1 и @math{n - 1} включительно и проверки, равен ли @math{a} остаток по
модулю @math{n} от @math{n}-ой степени @math{a}. Случайное число
@math{a} выбирается с помощью процедуры , про которую мы предполагаем,
что она встроена в Scheme в качестве элементарной процедуры.
@code{random} возвращает неотрицательное число, меньшее, чем ее целый
аргумент. Следовательно, чтобы получить случайное число между 1 и
@math{n - 1}, мы вызываем @code{random} с аргументом @math{n - 1} и
добавляем к результату 1:

@lisp
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
@end lisp

@noindent
Следующая процедура прогоняет тест заданное число раз, как указано ее
параметром. Ее значение истинно, если тест всегда проходит, и ложно в
противном случае.

@lisp
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
@end lisp

@comment @subsubheading Probabilistic methods
@subsubheading Вероятностные методы

Тест Ферма отличается по своему характеру от большинства известных
алгоритмов, где вычисляется результат, истинность которого
гарантирована. Здесь полученный результат верен лишь с какой-то
вероятностью. Более точно, если @math{n} не проходит тест Ферма, мы
можем точно сказать, что оно не простое. Но то, что @math{n} проходит
тест, хотя и является очень сильным показателем, все же не гарантирует,
что @math{n} простое. Нам хотелось бы сказать, что для любого числа
@math{n}, если мы проведем тест достаточное количество раз и @math{n}
каждый раз его пройдет, то вероятность ошибки в нашем тесте на простоту
может быть сделана настолько малой, насколько мы того пожелаем.

К сожалению, это утверждение неверно. Существуют числа, которые
<<обманывают>> тест Ферма: числа, которые не являются простыми и тем не
менее обладают свойством, что для всех целых чисел @math{a < n}
@math{a^n} равно @math{a} по модулю @math{n}. Такие числа очень редки,
так что на практике тест Ферма вполне надежен.@footnote{Числа,
<<обманывающие>> тест Ферма, называются (@newterm{Carmichael numbers}),
и про них
почти ничего неизвестно, кроме того, что они очень редки. Существует 255
чисел Кармайкла, меньших 100 000 000. Несколько первых --- 561, 1105,
1729, 2465, 2821 и 6601. При проверке на простоту больших чисел,
выбранных случайным образом, шанс наткнуться на число, <<обманывающее>>
тест Ферма, меньше, чем шанс, что космическое излучение заставит
компьютер сделать ошибку при вычислении <<правильного>> алгоритма. То,
что по первой из этих причин алгоритм считается неадекватным, а по
второй нет, показывает разницу между математикой и техникой.}

Существуют варианты теста Ферма, которые обмануть невозможно. В таких
тестах, подобно методу Ферма, проверка числа @math{n} на простоту
ведется путем выбора случайного числа @math{a < n} и проверки некоторого
условия, зависящего от @math{n} и @math{a}. (Пример такого теста см. в
упражнении @ref{Упражнение 1.28}.) С другой стороны, в отличие от
теста Ферма, можно доказать, что для любого @math{n} условие не
выполняется для большинства чисел @math{a < n}, если @math{n} не
простое. Таким образом, если @math{n} проходит тест для какого-то
случайного @math{a}, шансы, что @math{n} простое, уже больше половины.
Если @math{n} проходит тест для двух случайных @math{a}, шансы, что
@math{n} простое, больше, чем 3 из 4. Проводя тест с большим
количеством случайных чисел, мы можем сделать вероятность ошибки сколь
угодно малой.

Существование тестов, для которых можно доказать, что вероятность ошибки
можно сделать сколь угодно малой, вызвало большой интерес к алгоритмам
такого типа. Их стали называть (@newterm{probabilistic alorithms}).
В этой области
ведутся активные исследования, и вероятностные алгоритмы удалось с
успехом применить во многих областях@footnote{Одно из наиболее
впечатляющих применений вероятностные алгоритмы получили в области
криптографии. Хотя в настоящее время вычислительных ресурсов
недостаточно, чтобы разложить на множители произвольное число из 200
цифр, с помощью теста Ферма проверить, является ли оно простым, можно
за несколько секунд. Этот факт служит основой предложенного в @ref{Rivest,
Shamir, and Adleman (1977)} метода построения шифров, которые
<<невозможно>> взломать. Полученный алгоритм RSA (@newterm{RSA algorithm})
стал широко используемым методом повышения секретности электронных
средств связи. В результате этого и других связанных событий
исследование простых чисел, которое раньше считалось образцом <<чистой>>
математики, изучаемым исключительно ради самого себя, теперь получило
важные практические приложения в таких областях, как криптография,
электронная передача денежных сумм и хранение информации.}.

@quotation
@strong{@anchor{Упражнение 1.21}Упражнение 1.21:} С помощью процедуры
@code{smallest-divisor} найдите наименьший делитель следующих чисел: 199,
1999, 19999.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.22}Упражнение 1.22:} Бо́льшая часть реализаций
Лиспа содержат элементарную
процедуру @code{runtime}, которая возвращает целое число, показывающее,
как долго работала система (например, в миллисекундах). Следующая
процедура @code{timed-prime-test}, будучи вызвана с целым числом
@math{n}, печатает @math{n} и проверяет, простое ли оно. Если @math{n}
простое, процедура печатает три звездочки и количество времени,
затраченное на проверку.

@lisp
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
@end lisp

Используя эту процедуру, напишите процедуру @code{search-for-primes},
которая проверяет на простоту все нечетные числа в заданном диапазоне.
С помощью этой процедуры найдите наименьшие три простых числа после
1000; после 10 000; после 100 000; после 1 000 000. Посмотрите,
сколько времени затрачивается на каждое простое число. Поскольку
алгоритм проверки имеет порядок роста @math{\Theta (\sqrt{n})}, Вам
следовало бы ожидать, что проверка на простоту чисел, близких к
10 000, занимает в @math{\sqrt{10}} раз больше времени, чем для чисел,
близких к 1000. Подтверждают ли это Ваши замеры времени? Хорошо ли
поддерживают предсказание @math{\sqrt{n}} данные для 100 000 и
1 000 000? Совместим ли Ваш результат с предположением, что программы
на Вашей машине затрачивают на выполнение задач время, пропорциональное
числу шагов?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.23}Упражнение 1.23:} @code{smallest-divisor}
Процедура в начале этого раздела проводит множество лишних
проверок: после того, как она проверяет, делится ли число на 2, нет
никакого смысла проверять делимость на другие четные числа. Таким
образом, вместо последовательности 2, 3, 4, 5, 6 @dots{}, используемой
для @code{test-divisor}, было бы лучше использовать 2, 3, 5, 7, 9
@dots{}. Чтобы реализовать такое улучшение, напишите процедуру
@code{next}, которая имеет результатом 3, если получает 2 как
аргумент, а иначе возвращает свой аргумент плюс 2. Используйте
@code{(next test-divisor)} вместо @code{(+ test-divisor 1)} в
@code{smallest-divisor}. Используя процедуру @code{timed-prime-test} с
модифицированной версией @code{smallest-divisor}, запустите тест для
каждого из 12 простых чисел, найденных в @ref{Упражнение 1.22}.
Поскольку эта модификация снижает
количество шагов проверки вдвое, Вы должны ожидать двукратного ускорения
проверки. Подтверждаются ли эти ожидания? Если нет, то каково
наблюдаемое соотношение скоростей двух алгоритмов, и как Вы объясните
то, что оно отличается от 2?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.24}Упражнение 1.24:} Модифицируйте процедуру
@code{timed-prime-test} из упражнения @ref{Упражнение 1.22} так, чтобы
она использовала
@code{fast-prime?} (метод Ферма) и проверьте каждое из 12 простых
чисел, найденных в этом упражнении. Исходя из того, что у теста Ферма
порядок роста @math{\Theta (\log n)}, то какого соотношения времени Вы
бы ожидали между проверкой на простоту поблизости от 1 000 000 и
поблизости от 1000? Подтверждают ли это Ваши данные? Можете ли Вы
объяснить наблюдаемое несоответствие, если оно есть?
@end quotation

@quotation
@strong{@anchor{Упражнение 1.25}Упражнение 1.25:} Лиза П. Хакер жалуется, что при написании @code{expmod} мы
делаем много лишней работы. В конце концов, говорит она, раз мы уже
знаем, как вычислять степени, можно просто написать

@lisp
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
@end lisp

Права ли она? Стала бы эта процедура столь же хорошо работать при
проверке простых чисел? Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.26}Упражнение 1.26:} У Хьюго Дума большие трудности в @ref{Упражнение 1.24}. Процедура @code{fast-prime?} у него
работает медленнее, чем @code{prime?}. Хьюго просит помощи у своей
знакомой Евы Лу Атор. Вместе изучая код Хьюго, они обнаруживают, что тот
переписал процедуру @code{expmod} с явным использованием умножения
вместо того, чтобы вызывать @code{square}:

@lisp
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base
                       (expmod base (- exp 1) m))
                    m))))
@end lisp

Хьюго говорит: <<Я не вижу здесь никакой разницы>>. <<Зато я вижу, ---
отвечает Ева. --- Переписав процедуру таким образом, ты превратил
процесс порядка @math{\Theta(\log n)} в процесс порядка
@math{\Theta(n)}>>. Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.27}Упражнение 1.27:} Покажите, что числа Кармайкла, перечисленные в сноске
@ref{Сноска 47}, действительно <<обманывают>> тест Ферма: напишите
процедуру, которая берет целое число @math{n} и проверяет, правда ли
@math{a^n} равняется @math{a} по модулю @math{n} для всех
@math{a < n}, и проверьте эту процедуру на этих числах Кармайкла.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.28}Упражнение 1.28:} Один из вариантов
теста Ферма, который невозможно обмануть, называется
@newterm{Miller-Rabin test} (@ref{Miller 1976}; @ref{Rabin 1980}). Он основан
наальтернативной формулировке Малой теоремы Ферма, которая состоит в
том, что если @math{n} --- простое число, а @math{a} --- произвольное
положительное целое число, меньшее @math{n}, то @math{a} в
@math{n - 1}-ой степени равняется 1 по модулю @math{n}. Проверяя
простоту числа @math{n} методом Миллера--Рабина, мы берем случайное
число @math{a < n} и возводим его в @math{(n 
-1)}-ю степень по модулю @math{n} с помощью процедуры @code{expmod}.
Однако когда в процедуре @code{expmod} мы проводим возведение в
квадрат, мы проверяем, не нашли ли мы <<нетривиальный квадратный корень
из 1 по модулю @math{n}>>, то есть число, не равное 1 или @math{n - 1},
квадрат которого по модулю @math{n} равен 1. Можно доказать, что если
такой нетривиальный квадратный корень из 1 существует, то @math{n} не
простое число. Можно, кроме того, доказать, что если @math{n} ---
нечетное число, не являющееся простым, то по крайней мере для половины
чисел @math{a < n} вычисление @math{a^{n-1}} с помощью такой процедуры
обнаружит нетривиальный квадратный корень из 1 по модулю @math{n} (вот
почему тест Миллера--Рабина невозможно обмануть). Модифицируйте
процедуру @code{expmod} так, чтобы она сигнализировала обнаружение
нетривиального квадратного корня из 1, и используйте ее для реализации
теста Миллера--Рабина с помощью процедуры, аналогичной
@code{fermat-test}. Проверьте свою процедуру на нескольких известных Вам
простых и составных числах. Подсказка: удобный способ заставить
@code{expmod} подавать особый сигнал --- заставить ее возвращать 0.

@end quotation

@sp 0.5
@comment @section Formulating Abstractions@* with Higher-Order Procedures
@section Формулирование абстракций с помощью процедур высших порядков
@node	1.3,  , 1.2, Chapter 1

Мы видели, что процедуры, в сущности, являются абстракциями, которые
описывают составные операции над числами безотносительно к конкретным
числам. Например, когда мы определяем

@lisp
(define (cube x) (* x x x))
@end lisp

@noindent
мы говорим не о кубе какого-то конкретного числа, а о способе
получить куб любого числа. Разумеется, мы могли бы обойтись без
определения этой процедуры, каждый раз писать выражения вроде

@lisp
(* 3 3 3)
(* x x x)
(* y y y)
@end lisp

@noindent
и никогда явно не упоминать понятие куба. Это поставило бы нас перед
серьезным затруднением и заставило бы работать только в терминах тех
операций, которые оказались примитивами языка (в данном случае, в
терминах умножения), а не в терминах операций более высокого уровня.
Наши программы были бы способны вычислять кубы, однако в нашем языке не
было бы возможности выразить идею возведения в куб. Одна из тех вещей,
которых мы должны требовать от мощного языка программирования --- это
возможность строить абстракции путем присвоения имен общим схемам, а
затем прямо работать с этими абстракциями. Процедуры дают нам такую
возможность. Вот почему все языки программирования, кроме самых
примитивных, обладают механизмами определения процедур.

Но даже при обработке численных данных наши возможности создавать
абстракции окажутся сильно ограниченными, если мы сможем определять
только процедуры, параметры которых должны быть числами. Часто одна и
та же схема программы используется с различными процедурами. Для того
чтобы выразить эти схемы как понятия, нам нужно строить процедуры,
которые принимают другие процедуры как аргументы либо возвращают их как
значения. Процедура, манипулирующая другими процедурами, называется
(higher-order procedure). В этом разделе показывается, как процедуры
высших порядков могут служить в качестве мощного механизма абстракции,
резко повышая выразительную силу нашего языка.

@menu
* 1-3-1::            Процедуры в качестве аргументов
* 1-3-2::            Построение процедур с помощью @code{lambda}
* 1-3-3::            Процедуры как обобщенные методы
* 1-3-4::            Процедуры как возвращаемые значения
@end menu

@comment @subsection Procedures as Arguments
@subsection Процедуры в качестве аргументов
@node	1.3.1, 1.3.2, 1.3, 1.3

Рассмотрим следующие три процедуры. Первая из них вычисляет сумму целых
чисел от @code{a} до @code{b}:

@lisp
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))
@end lisp

@noindent
Вторая вычисляет сумму кубов целых чисел в заданном диапазоне:

@lisp
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
@end lisp

@noindent
Третья вычисляет сумму последовательности термов в ряде
@ifinfo

@example
  1       1       1
----- + ----- + ------ + ...
1 * 3   5 * 7   9 * 11
@end example

@end ifinfo
@tex
$$ {1\over1\cdot 3} +  {1\over5\cdot 7} + {1\over9\cdot 11} + \dots, $$
@end tex
@noindent
который (очень медленно) сходится к @math{\pi / 8}:@footnote{Этим рядом,
который обычно записывают в эквивалентной форме
@math{{pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots}, мы
обязаны Лейбницу. В разделе @ref{3.5.3}
мы увидим, как использовать его как основу для некоторых изощренных
вычислительных трюков.}

@lisp
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
@end lisp

@noindent
Ясно, что за этими процедурами стоит одна общая схема. Большей частью
они идентичны и различаются только именем процедуры, функцией, которая
вычисляет терм, подлежащий добавлению, и функцией, вычисляющей
следующее значение @code{a}. Все эти процедуры можно породить, заполнив
дырки в одном шаблоне:

@lisp
(define (@math{\langle}@var{имя}@math{\rangle} a b)
  (if (> a b)
      0
      (+ (@math{\langle}@var{терм}@math{\rangle} a)
         (@math{\langle}@var{имя}@math{\rangle} (@math{\langle}@var{следующий}@math{\rangle} a) b))))
@end lisp

@noindent
Присутствие такого общего шаблона является веским доводом в пользу
того, что здесь скрыта полезная абстракция, которую только надо вытащить
на поверхность. Действительно, математики давно выделили абстракцию
(summation of a series) и изобрели <<сигма-запись>>, например
@ifinfo

@example
  b
 ---
 >    f(n) = f(a) + ... + f(b)
 ---
 n=a
@end example

@end ifinfo
@tex
$$ \sum\limits_{n=a}^b f(n) = f(a) + \dots + f(b), $$
@end tex
@noindent
чтобы выразить это
понятие. Сила сигма-записи состоит в том, что она позволяет математикам
работать с самим понятием суммы, а не просто с конкретными суммами ---
например, формулировать общие утверждения о суммах, независимые от
конкретных суммируемых последовательностей.

Подобным образом, мы как проектировщики программ хотели бы, чтобы наш
язык был достаточно мощным и позволял написать процедуру, которая
выражала бы само понятие суммы, а не только процедуры, вычисляющие
конкретные суммы. В нашем процедурном языке мы можем без труда это
сделать, взяв приведенный выше шаблон и преобразовав <<дырки>> в
формальные параметры:

@lisp
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
@end lisp

@noindent
Заметьте, что @code{sum} принимает в качестве аргументов как нижнюю и
верхнюю границы @code{a} и @code{b}, так и процедуры @code{term} и
@code{next}. @code{Sum} можно использовать так, как мы использовали бы
любую другую процедуру. Например, с ее помощью (вместе с процедурой
@code{inc}, которая увеличивает свой аргумент на 1), мы можем определить
@code{sum-cubes}:

@lisp
(define (inc n) (+ n 1))
(define (sum-cubes a b)
  (sum cube a inc b))
@end lisp

@noindent
Воспользовавшись этим определением, мы можем вычислить сумму кубов чисел
от 1 до 10:

@lisp
(sum-cubes 1 10)
@i{3025}
@end lisp

@noindent
С помощью процедуры идентичности (которая просто возвращает свой
аргумент) для вычисления терма, мы можем определить @code{sum-integers}
через @code{sum}:

@lisp
(define (identity x) x)
(define (sum-integers a b)
  (sum identity a inc b))
@end lisp

@noindent
Теперь можно сложить целые числа от 1 до 10:

@lisp
(sum-integers 1 10)
@i{55}
@end lisp

@noindent
Таким же образом определяется @code{pi-sum}:@footnote{Обратите внимание,
что мы использовали блочную структуру
(раздел @ref{1.1.8}), чтобы
спрятать определения @code{pi-next} и @code{pi-term} внутри
@code{pi-sum}, поскольку вряд ли эти процедуры понадобятся зачем-либо
еще. В разделе @ref{1.3.2} мы совсем от них избавимся.}

@lisp
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
@end lisp

@noindent
С помощью этих процедур мы можем вычислить приближение к @math{\pi}:

@lisp
(* 8 (pi-sum 1 1000))
@i{3.139592655589783}
@end lisp

@noindent
Теперь, когда у нас есть @code{sum}, ее можно использовать в качестве
строительного блока при формулировании других понятий. Например,
определенный интеграл функции @math{f} между пределами @math{a} и
@math{b} можно численно оценить с помощью формулы
@ifinfo

@example
/b     /  /     dx \    /          dx \    /           dx \      \
|  f = | f| a + -- | + f| a + dx + -- | + f| a + 2dx + -- | + ...| dx
/a     \  \     2  /    \          2  /    \           2  /      /
@end example

@end ifinfo
@tex
$${\int_a^b \!\!\! f} = {\left[\;f\! \left(a + {dx \over 2}\right)
		+ f\! \left(a + dx + {dx \over 2}\right)
		+ f\! \left(a + 2dx + {dx \over 2}\right) + \,\dots \;\right]\! dx} $$
@end tex
@noindent
для малых значений @math{dx}. Мы можем прямо выразить это в виде процедуры:

@lisp
(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.01)
@i{.24998750000000042}

(integral cube 0 1 0.001)
@i{.249999875000001}
@end lisp

@noindent
(Точное значение интеграла @code{cube} от 0 до 1 равно 1/4.)

@quotation
@strong{@anchor{Упражнение 1.29}Упражнение 1.29:} Правило Симпсона --- более точный метод численного
интегрирования, чем представленный выше. С помощью правила Симпсона
интеграл функции @math{f} между @math{a} и @math{b} приближенно
вычисляется в виде
@ifinfo

@example
h
- (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_(n-2) + 4y_(n-1) + y_n)
3
@end example

@end ifinfo
@tex
$$ {h\over 3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \dots + 2y_{n-2} + 4y_{n-1} + y_n), $$
@end tex
@noindent
где @math{h = (b - a) / n}, для какого-то четного целого числа
@math{n}, а @math{y_k = f(a + kh)}.
(Увеличение @math{n} повышает точность приближенного вычисления.)
Определите процедуру, которая принимает в качестве аргументов @math{f},
@math{a}, @math{b} и @math{n}, и возвращает значение интеграла,
вычисленное по правилу Симпсона. С помощью этой процедуры
проинтегрируйте @code{cube} между 0 и 1 (с @math{n = 100} и @math{n =
1000}) и сравните результаты с процедурой @code{integral}, приведенной
выше.
@end quotation

@quotation
@strong{@anchor{Exercise 1.30}Exercise 1.30:} Процедура @code{sum}
порождает линейную рекурсию. Ее можно переписать
так, чтобы суммирование выполнялось итеративно. Покажите, как сделать
это, заполнив пропущенные выражения в следующем определении:

@lisp
(define (sum term a next b)
  (define (iter a result)
    (if @math{\langle}??@math{\rangle}
        @math{\langle}??@math{\rangle}
        (iter @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
  (iter @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle}))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 1.31}Упражнение 1.31:} @enumerate a.

@item
Процедура @code{sum} --- всего лишь простейшая из обширного множества
подобных абстракций, которые можно выразить через процедуры высших
порядков.@footnote{Смысл
упражнений @ref{Упражнение 1.31}--@ref{Упражнение 1.33} состоит в
том, чтобы продемонстрировать выразительную мощь, получаемую, когда с
помощью подходящей абстракции обобщается множество операций, казалось
бы, не связанных между собой. Однако, хотя накопление и фильтрация ---
изящные приемы, при их использовании руки у нас пока что несколько
связаны, поскольку пока что у нас нет структур данных, которые дают
подходящие к этим абстракциям средства комбинирования. В
разделе @ref{2.23} мы вернемся к этим приемам и покажем,
как использовать (@newterm{sequences}) в
качестве интерфейсов для комбинирования фильтров и накопителей, так что
получаются еще более мощные абстракции. Мы увидим, как эти методы сами
по себе становятся мощным и изящным подходом к проектированию
программ.}. Напишите аналогичную процедуру под названием , которая
вычисляет произведение значений функции в точках на указанном
интервале. Покажите, как с помощью этой процедуры определить
@code{factorial}. Кроме того, при помощи @code{product} вычислите
приближенное значение @math{\pi} по формуле@footnote{Эту формулу открыл
английский математик семнадцатого века Джон Уоллис.}
@ifinfo

@example
pi   2 * 4 * 4 * 6 * 6 * 8 ...
-- = -------------------------
 4   3 * 3 * 5 * 5 * 7 * 7 ...
@end example

@end ifinfo
@tex
$$ {\pi\over 4} = {2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdots\over
		   3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\cdots}\,. $$
@end tex
@item
Если Ваша процедура @code{product} порождает рекурсивный процесс,
перепишите ее так, чтобы она порождала итеративный. Если она порождает
итеративный процесс, перепишите ее так, чтобы она порождала рекурсивный.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 1.32}Упражнение 1.32:} @enumerate a.

@item
Покажите, что  и @code{product} (@ref{Упражнение 1.31})
являются частными случаями еще более общего понятия, называемого
@code{accumulation}, которое комбинирует множество термов с помощью
некоторой общей функции накопления:

@lisp
(accumulate combiner null-value term a next b)
@end lisp

@code{accumulate} принимает в качестве аргументов те же описания
термов и диапазона, что и @code{sum} с @code{product}, а еще
процедуру @code{combiner} (двух аргументов), которая указывает, как
нужно присоединить текущий терм к результату накопления предыдущих, и
@code{null-value}, базовое значение, которое нужно использовать, когда
термы закончатся. Напишите @code{accumulate} и покажите, как и
@code{sum}, и @code{product} можно определить в виде простых вызовов
@code{accumulate}.

@item
Если Ваша процедура @code{accumulate} порождает рекурсивный процесс,
перепишите ее так, чтобы она порождала итеративный. Если она порождает
итеративный процесс, перепишите ее так, чтобы она порождала рекурсивный.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 1.33}Упражнение 1.33:}  Можно получить
еще более общую версию @code{accumulate}
(@ref{Упражнение 1.32}), если ввести понятие (filter) на
комбинируемые термы. То есть комбинировать только те термы, порожденные
из значений диапазона, которые удовлетворяют указанному условию.
Получающаяся абстракция @code{filtered-accumulate} получает те же
аргументы, что и @code{accumulate}, плюс дополнительный одноаргументный
предикат, который определяет фильтр. Запишите
@code{filtered-accumulate} в виде процедуры. Покажите, как с помощью
@code{filtered-accumulate} выразить следующее:

@item
сумму квадратов простых чисел в интервале от @code{a} до @code{b} (в
предположении, что процедура @code{prime?} уже написана);

@item
произведение всех положительных целых чисел меньше @math{n}, которые
просты по отношению к @math{n} (то есть всех таких положительных целых
чисел @math{i < n}, что @math{\textsc{НОД}(i,n) = 1}).

@end enumerate
@end quotation

@comment @subsection Constructing Procedures Using @code{lambda}
@subsection Построение процедур с помощью @code{lambda}
@node	1.3.2, 1.3.3, 1.3.1, 1.3

Когда в разделе @ref{1.3.1} мы использовали
@code{sum}, очень неудобно было определять тривиальные процедуры вроде
@code{pi-term} и @code{pi-next} только ради того, чтобы передать их как
аргументы в процедуры высшего порядка. Было бы проще вместо того, чтобы
вводить имена @code{pi-next} и @code{pi-term}, прямо определить
<<процедуру, которая возвращает свой аргумент плюс 4>> и <<процедуру,
которая вычисляет число, обратное произведению аргумента и аргумента
плюс 2>>. Это можно сделать, введя особую форму @code{lambda}, которая
создает процедуры. С использованием @code{lambda} мы можем записать
требуемое в таком виде:

@lisp
(lambda (x) (+ x 4))
@end lisp

@noindent
и

@lisp
(lambda (x) (/ 1.0 (* x (+ x 2))))
@end lisp

@noindent
Тогда нашу процедуру @code{pi-sum} можно выразить безо всяких
вспомогательных процедур:

@lisp
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
@end lisp

@noindent
Еще с помощью @code{lambda} мы можем записать процедуру
@code{integral}, не определяя вспомогательную процедуру @code{add-dx}:

@lisp
(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
@end lisp

@noindent
В общем случае, @code{lambda} используется для создания процедур точно
так же, как @code{define}, только никакого имени для процедуры не
указывается:

@lisp
(lambda (@math{\langle}@var{формальные-параметры}@math{\rangle}) @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
Получается столь же полноценная процедура, как и с помощью
@code{define}. Единственная разница состоит в том, что она не связана
ни с каким именем в окружении. На самом деле

@lisp
(define (plus4 x) (+ x 4))
@end lisp

@noindent
эквивалентно

@lisp
(define plus4 (lambda (x) (+ x 4)))
@end lisp

@noindent
Можно читать выражение @code{lambda} так:

@example
(lambda        (x)                  (+       x   4))
    |           |                    |       |   |
Процедура от аргумента x, которая складывает x и 4
@end example

@noindent
Подобно любому выражению, значением которого является процедура,
выражение с @code{lambda} можно использовать как оператор в
комбинации, например

@lisp
((lambda (x y z) (+ x y (square z)))
 1 2 3)
@i{12}
@end lisp

@noindent
или, в более общем случае, в любом контексте, где обычно используется
имя процедуры.@footnote{Было бы более понятно и менее страшно для
изучающих Лисп, если бы здесь использовалось более ясное имя, чем
@code{lambda}, например @code{make-procedure}. Однако традиция уже
прочно укоренилась. Эта нотация заимствована из
@math{\lambda}-исчисления, формализма, изобретенного математическим
логиком Алонсо Чёрчем @ref{Church 1941}. Чёрч разработал
@math{\lambda}-исчисление, чтобы найти строгое основание для понятий
функции и применения функции. @math{\lambda}-исчисление стало основным
инструментом математических исследований по семантике языков
программирования.}

@comment @subsubheading Using @code{let} to create local variables
@subsubheading Создание локальных переменных с помощью @code{let}

Еще одно применение @code{lambda} состоит во введении локальных
переменных. Часто нам в процедуре бывают нужны локальные переменные
помимо тех, что связаны формальными параметрами. Допустим, например, что
нам надо вычислить функцию
@ifinfo

@example
f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)
@end example

@end ifinfo
@tex
$$ f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y), $$
@end tex
@noindent
которую мы также могли бы выразить как
@ifinfo

@example
     a = 1 + xy
     b = 1 - y
f(x,y) = xa^2 + yb + ab
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
  a 	  &  1 + xy, \\
  b 	  &  1 - y,  \\
  f(x,y)  &  xa^2 + yb + ab.
\end{array}
$$
@end tex
Когда мы пишем процедуру для вычисления @math{f}, хотелось
бы иметь как локальные переменные не только @math{x} и @math{y}, но и
имена для промежуточных результатов вроде @math{a} и @math{b}. Можно
сделать это с помощью вспомогательной процедуры, которая связывает
локальные переменные:

@lisp
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
@end lisp

@noindent
Разумеется, безымянную процедуру для связывания локальных переменных мы
можем записать через @code{lambda}-выражение. При этом тело @code{f}
оказывается просто вызовом этой процедуры.

@lisp
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
@end lisp

@noindent
Такая конструкция настолько полезна, что есть особая форма под названием
@code{let}, которая делает ее более удобной. С использованием @code{let}
процедуру @code{f} можно записать так:

@lisp
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
@end lisp

@noindent
Общая форма выражения с @code{let} такова:

@lisp
(let ((@math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle})
      (@math{\langle}@var{пер}@math{_{\mono{2}}\rangle} @math{\langle}@var{выр}@math{_{\mono{2}}\rangle})
      @dots{}
      (@math{\langle}@var{пер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
   @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
Это можно понимать как

@lisp
@w{Пусть} @math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @w{имеет значение} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle} @w{и}
    @math{\langle}@var{пер}@math{_{\mono{2}}\rangle} @w{имеет значение} @math{\langle}@var{выр}@math{_{\mono{2}}\rangle} @w{и}
    @dots{}
    @math{\langle}@var{пер}@math{_{\monoit{n}}\rangle} @w{имеет значение} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}
@w{в}  @math{\langle}@var{теле}@math{\rangle}
@end lisp

@noindent
Первая часть @code{let}-выражения представляет собой список пар вида
имя--значение. Когда @code{let} вычисляется, каждое имя связывается со
значением соответствующего выражения. Затем вычисляется тело @code{let},
причем эти имена связаны как локальные переменные. Происходит это так:
выражение @code{let} интерпретируется как альтернативная форма для

@lisp
((lambda (@math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{пер}@math{_{\monoit{n}}\rangle})
    @math{\langle}@var{тело}@math{\rangle})
 @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}
 @dots{}
 @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
От интерпретатора не требуется никакого нового механизма связывания
переменных. Выражение с @code{let} --- это всего лишь синтаксический
сахар для вызова @code{lambda}.

Из этой эквивалентности мы видим, что область определения переменной,
введенной в @code{let}-выражении --- тело @code{let}. Отсюда следует,
что:


@itemize @bullet

@item
@code{let} позволяет связывать переменные сколь угодно близко к тому
месту, где они используются. Например, если значение @code{x} равно 5,
значение выражения

@lisp
(+ (let ((x 3))
     (+ x (* x 10)))
   x)
@end lisp

@noindent
равно 38. Значение @code{x} в теле @code{let} равно 3, так что значение
@code{let}-выражения равно 33. С другой стороны, @code{x} как второй
аргумент к внешнему @code{+} по-прежнему равен 5.

@item
Значения переменных вычисляются за пределами @code{let}. Это
существенно, когда выражения, дающие значения локальным переменным,
зависят от переменных, которые имеют те же имена, что и сами локальные
переменные. Например, если значение @code{x} равно 2, выражение

@lisp
(let ((x 3)
      (y (+ x 2)))
  (* x y))
@end lisp

@noindent
будет иметь значение 12, поскольку внутри тела @code{let} @code{x} будет
равно 3, а @code{y} 4 (что равняется внешнему @code{x} плюс 2).

@end itemize

@noindent
Иногда с тем же успехом, что и @code{let}, можно использовать
внутренние определения. Например, вышеописанную процедуру @code{f} мы
могли бы определить как

@lisp
(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
@end lisp

@noindent
В таких ситуациях, однако, мы предпочитаем использовать @code{let}, а
@code{define} писать только при определении локальных
процедур.@footnote{Если мы хотим понимать внутренние определения
настолько, чтобы быть уверенными, что программа действительно
соответствует нашим намерениям, то нам требуется более сложная модель
процесса вычислений, чем приведенная в этой главе. Однако с внутренними
определениями процедур эти тонкости не возникают. К этому вопросу мы
вернемся в разделе @ref{4.1.6}, после того, как больше узнаем о вычислении.}

@quotation
@strong{@anchor{Упражнение 1.34}Упражнение 1.34:} Suppose we define the procedure

@lisp
(define (f g) (g 2))
@end lisp

Тогда мы имеем

@lisp
(f square)
@i{4}
(f (lambda (z) (* z (+ z 1))))
@i{6}
@end lisp

Что случится, если мы (извращенно) попросим интерпретатор вычислить
комбинацию @code{(f f)}? Объясните.
@end quotation

@comment @subsection Procedures as General Methods
@subsection Процедуры как обобщенные методы
@node	1.3.3, 1.3.4, 1.3.2, 1.3

Мы ввели составные процедуры в разделе @ref{1.1.4} в качестве механизма для
абстракции схем числовых операций, так, чтобы они были независимы от
конкретных используемых чисел. С процедурами высших порядков, такими,
как процедура @code{integral} из раздела @ref{1.3.1}, мы начали исследовать
более мощный тип абстракции: процедуры, которые используются для
выражения обобщенных методов вычисления, независимо от конкретных
используемых функций. В этом разделе мы рассмотрим два более подробных
примера --- общие методы нахождения нулей и неподвижных точек функций,
--- и покажем, как эти методы могут быть прямо выражены в виде
процедур.

@comment @subsubheading Finding roots of equations by the half-interval method
@subsubheading Нахождение корней уравнений методом половинного деления

(@newterm{half-interval method}) --- это простой, но мощный способ нахождения
корней уравнения @math{f(x) = 0}, где @math{f} --- непрерывная функция.
Идея состоит в том, что если нам даны такие точки @math{a} и @math{b},
что @math{f(a) < 0 < f(b)}, то функция @math{f} должна иметь по крайней мере
один ноль на отрезке между @math{a} и @math{b}. Чтобы найти его, возьмем
@math{x}, равное среднему между @math{a} и @math{b}, и вычислим @math{f(x)}.
Если @math{f(x) > 0}, то @math{f} должна иметь ноль на отрезке между
@math{a} и @math{x}. Если @math{f(x) < 0}, то @math{f} должна иметь ноль на
отрезке между @math{x} и @math{b}.
Продолжая таким образом, мы сможем находить все более узкие интервалы,
на которых @math{f} должна иметь ноль. Когда мы дойдем до точки, где
этот интервал достаточно мал, процесс останавливается. Поскольку
интервал неопределенности уменьшается вдвое на каждом шаге процесса,
число требуемых шагов растет как @math{\Theta(\log(L / T))}, где
@math{L} есть длина исходного интервала, а @math{T} есть допуск ошибки
(то есть размер интервала, который мы считаем <<достаточно малым>>). Вот
процедура, которая реализует эту стратегию:

@lisp
(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
@end lisp

@noindent
Мы предполагаем, что вначале нам дается функция @math{f} и две
точки, в одной из которых значение функции отрицательно, в другой
положительно. Сначала мы вычисляем среднее между двумя краями интервала.
Затем мы проверяем, не является ли интервал уже достаточно малым, и
если да, сразу возвращаем среднюю точку как ответ. Если нет, мы
вычисляем значение @math{f} в средней точке. Если это значение
положительно, мы продолжаем процесс с интервалом от исходной
отрицательной точки до средней точки. Если значение в средней точке
отрицательно, мы продолжаем процесс с интервалом от средней точки до
исходной положительной точки. Наконец, существует возможность, что
значение в средней точке в точности равно 0, и тогда средняя точка и
есть тот корень, который мы ищем.

Чтобы проверить, достаточно ли близки концы интервала, мы можем взять
процедуру, подобную той, которая используется в разделе @ref{1.1.7} при
вычислении квадратных корней:@footnote{Мы использовали 0.001 как
достаточно <<малое>> число, чтобы указать допустимую ошибку вычисления.
Подходящий допуск в настоящих вычислениях зависит от решаемой задачи,
ограничений компьютера и алгоритма. Часто это весьма тонкий вопрос, в
котором требуется помощь специалиста по численному анализу или
волшебника какого-нибудь другого рода.}

@lisp
(define (close-enough? x y) (< (abs (- x y)) 0.001))
@end lisp

@noindent
Использовать процедуру @code{search} непосредственно ужасно неудобно,
поскольку случайно мы можем дать ей точки, в которых значения @math{f}
не имеют нужных знаков, и в этом случае мы получим неправильный ответ.
Вместо этого мы будем использовать @code{search} посредством следующей
процедуры, которая проверяет, который конец интервала имеет
положительное, а который отрицательное значение, и соответствующим
образом зовет @code{search}. Если на обоих концах интервала функция
имеет одинаковый знак, метод половинного деления использовать нельзя, и
тогда процедура сообщает об ошибке:@footnote{Этого можно добиться с
помощью процедуры @code{error}, которая в качестве аргументов принимает
несколько значений и печатает их как сообщение об ошибке.}

@lisp
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else
           (error "Values are not of opposite sign" a b)))))
@end lisp

@noindent
В следующем примере метод половинного деления используется, чтобы вычислить
@math{\pi} как корень уравнения @math{\sin x = 0}, лежащий между 2 и 4.

@lisp
(half-interval-method sin 2.0 4.0)
@i{3.14111328125}
@end lisp

@noindent
Во втором примере через метод половинного деления ищется корень
уравнения @math{x^3 - 2x - 3 = 0}, расположенный между 1 и 2:

@lisp
(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0)
@i{1.89306640625}
@end lisp

@comment @subsubheading Finding fixed points of functions
@subsubheading Нахождение неподвижных точек функций

Число @math{x} называется (fixed point) функции @math{f}, если оно
удовлетворяет уравнению @math{f(x) =
x}. Для некоторых функций @math{f} можно найти неподвижную точку,
начав с какого-то значения и применяя @math{f} многократно:
@ifinfo

@example
f(x), f(f(x)), f(f(f(x))), ...
@end example

@end ifinfo
@tex
$$ f(x),\quad f(f(x)),\quad f(f(f(x))), \quad\dots, $$
@end tex
@noindent
пока значение не перестанет
сильно изменяться. С помощью этой идеи мы можем составить процедуру
@code{fixed-point}, которая в качестве аргументов принимает функцию и
начальное значение и производит приближение к неподвижной точке
функции. Мы многократно применяем функцию, пока не найдем два
последовательных значения, разница между которыми меньше некоторой
заданной чувствительности:

@lisp
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
@end lisp

@noindent
Например, с помощью этого метода мы можем приближенно вычислить
неподвижную точку функции косинус, начиная с 1 как стартового
приближения:@footnote{Попробуйте во время скучной лекции установить
калькулятор в режим радиан и нажимать кнопку @code{cos}, пока не
найдете неподвижную точку.}

@lisp
(fixed-point cos 1.0)
@i{.7390822985224023}
@end lisp

@noindent
Подобным образом можно найти решение уравнени
@math{y = \sin y + \cos y}:

@lisp
(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
@i{1.2587315962971173}
@end lisp

@noindent
Процесс поиска неподвижной точки похож на процесс, с помощью которого мы
искали квадратный корень в разделе @ref{1.1.7}. И тот, и
другой основаны на идее последовательного улучшения приближений, пока
результат не удовлетворит какому-то критерию. На самом деле мы без труда
можем сформулироватьвычисление квадратного корня как поиск неподвижной
точки. Вычислить квадратный корень из произвольного числа @math{x}
означает найти такое @math{y}, что @math{y^2 = x}. Переведя это
уравнение в эквивалентную форму @math{y = x / y}, мы обнаруживаем, что
должны найти неподвижную точку функции@footnote{@math{\mapsto}
(произносится <<отображается в>>) --- это математический способ написать
@code{lambda}. @math{y \mapsto x / y} означает
@code{(lambda (y) (/ x y))}, то есть функцию, значение которой в точке
@math{y} есть @math{x / y}.} @math{y \mapsto x / y}, и, следовательно,
мы можем попытаться вычислять квадратные корни так:

@lisp
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
@end lisp

@noindent
К сожалению, этот поиск неподвижной точки не сходится. Рассмотрим
исходное значение @math{y_1}. Следующее значение равно
@math{y_2 = x / y_1}, а следующее за ним
@math{y_3 = x / y_2 = x / (x / y_1) = y_1}. В результате выходит
бесконечный цикл, в котором два значения @math{y_1} и @math{y_2}
повторяются снова и снова, прыгая вокруг правильного ответа.

Один из способов управлять такими прыжками состоит в том, чтобы
заставить значения изменяться не так сильно. Поскольку ответ всегда
находится между текущим значением @math{y} и @math{x
/ y}, мы можем взять новое значение, не настолько далекое от @math{y},
как @math{x / y}, взяв среднее между ними, так что следующее значение
будет не @math{x / y}, а @math{{1\over2}(y + x / y)}. Процесс
получения такой последовательности есть всего лишь процесс поиска
неподвижной точки @math{y \mapsto {1\over2}(y + x / y)}.

@lisp
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y)))
               1.0))
@end lisp

@noindent
(Заметим, что @math{y = {1\over2} (y + x / y)} всего лишь простая
трансформация уравнения @math{y = x / y}; чтобы ее получить, добавьте
@math{y} к обоим частям уравнения и поделите пополам.)

После такой модификации процедура поиска квадратного корня начинает
работать. В сущности, если мы рассмотрим определения, мы увидим, что
последовательность приближений к квадратному корню, порождаемая
здесь, в точности та же, что порождается нашей исходной процедурой
поиска квадратного корня из раздела @ref{1.1.7}. Этот подход с усреднением
последовательных приближений к решению, метод, который мы называем
(@newterm{average damping}), часто помогает достичь сходимости
при поисках неподвижной точки.

@quotation
@strong{@anchor{Упражнение 1.35}Упражнение 1.35:} Покажите, что золотое сечение
@math{\varphi} (раздел @ref{1.2.2}) есть неподвижная точка трансформации
@math{x \mapsto 1 + 1 / x}, и используйте этот факт для вычисления 
@math{\varphi} с помощью процедуры @code{fixed-point}.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.36}Упражнение 1.36:} Измените процедуру
@code{fixed-point} так, чтобы она
печатала последовательность приближений, которые порождает, с помощью
примитивов @code{newline} и @code{display} показанных в упражнении
@ref{Упражнение 1.22}. Затем найдите решение уравнения @math{x^x = 1000}
путем поиска неподвижной точки @math{x \mapsto \log(1000) / \log(x)}.
(Используйте встроенную процедуру Scheme @code{log}
которая вычисляет натуральные логарифмы.)
Посчитайте, сколько шагов это занимает при использовании торможения
усреднением и без него. (Учтите, что нельзя начинать @code{fixed-point}
со значения 1, поскольку это вызовет деление на @math{\log(1) = 0}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 1.37}Упражнение 1.37:} @enumerate a.

@item
Бесконечная дробь (@newterm{continued fraction}) есть выражение вида
@ifinfo

@example
           N_1
f = ---------------------
               N_2
    D_1 + ---------------
                   N_3
          D_2 + ---------
                D_3 + ...
@end example

@end ifinfo
@tex
$$ {f} = \cfrac{N_1}{D_1 + \cfrac{N_2}{D_2 + \cfrac{N_3}{D_3 + \dots}}}\,. $$
@end tex
В качестве примера можно показать, что расширение бесконечной цепной
дроби при всех @math{N_i} и @math{D_i}, равных 1, дает @math{1 / \phi},
где @math{\phi} --- золотое сечение (описанное в
разделе @ref{1.2.2}). Один из способов вычислить цепную
дробь состоит в том, чтобы после заданного количества термов оборвать
вычисление. Такой обрыв --- так называемая (@newterm{@i{k}-term finite continued fraction})
из @math{k} элементов, --- имеет вид
@ifinfo

@example
       N_1
-----------------
          N_2
D_1 + -----------
      ...    N_K
          + -----
             D_K
@end example

@end ifinfo
@tex
$$ \cfrac{N_1}{D_1 + \cfrac{N_2}{\ddots + \cfrac{N_k}{D_k}}}\,. $$
@end tex
Предположим, что @code{n} и @code{d} --- процедуры одного аргумента
(номера элемента @math{i}), возвращающие @math{N_i} и @math{D_i}
элементов цепной дроби. Определите процедуру @code{cont-frac} так, чтобы
вычисление @code{(cont-frac n d k)} давало значение @math{k}-элементной
конечной цепной дроби. Проверьте свою процедуру, вычисляя приближения к
@math{1 / \varphi} с помощью

@lisp
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
@end lisp

@noindent
для последовательных значений @code{k}. Насколько большим пришлось
сделать @code{k}, чтобы получить приближение, верное с точностью 4 цифры
после запятой?

@item
Если Ваша процедура @code{cont-frac} порождает рекурсивный процесс,
напишите вариант, который порождает итеративный процесс. Если она
порождает итеративный процесс, напишите вариант, порождающий рекурсивный
процесс.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 1.38}Упражнение 1.38:} В 1737 году швейцарский
математик Леонард Эйлер опубликовал
статью @cite{De functionibus Continuis}, которая содержала расширение
цепной дроби для @math{e - 2}, где @math{e} --- основание натуральных
логарифмов. В этой дроби все @math{N_i} равны 1, а @math{D_i}
последовательно равны @math{1, 2, 1, 1, 4, 1, 1, 6,
1, 1, 8, \ldots}Напишите программу, использующую Вашу процедуру
@code{cont-frac} из упражнения @ref{Упражнение 1.37} для вычисления
@math{e} на основании формулы Эйлера.
@end quotation

@quotation
@strong{@anchor{Exercise 1.39}Exercise 1.39:} Представление тангенса
в виде цепной дроби было
опубликовано в 1770 году немецким математиком Й.Х. Ламбертом:
@ifinfo

@example
              x
tan x = ---------------
                x^2
        1 - -----------
                  x^2
            3 - -------
                5 - ...
@end example

@end ifinfo
@tex
$$ {\tan x} = \cfrac{x}{1 - \cfrac{x^2}{3 - \cfrac{x^2}{5 - \dots}}}\,, $$
@end tex
@noindent
где @math{x} дан в радианах. Определите процедуру @code{(tan-cf x k)},
которая вычисляет приближение к тангенсу на основе формулы Ламберта.
@code{K} указывает количество термов, которые требуется вычислить,
как в упражнении @ref{Упражнение 1.37}.

@end quotation

@comment @subsection Procedures as Returned Values
@subsection Процедуры как возвращаемые значения
@node	1.3.4,  , 1.3.3, 1.3

Предыдущие примеры показывают, что возможность передавать процедуры в
качестве аргументов значительно увеличивает выразительную силу нашего
языка программирования. Мы можем добиться еще большей выразительной
силы, создавая процедуры, возвращаемые значения которых сами являются
процедурами.

Эту идею можно проиллюстрировать примером с поиском неподвижной точки,
обсуждаемым в конце раздела @ref{1.3.3}. Мы сформулировали
новую версию процедуры вычисления квадратного корня как поиск
неподвижной точки, начав с наблюдения, что @math{\sqrt{x}} есть
неподвижная точка функции @math{y \mapsto x / y}. Затем мы использовали
торможение усреднением, чтобы заставить приближения сходиться.
Торможение усреднением само по себе является полезным приемом. А именно,
получив функцию @math{f}, мы возвращаем функцию, значение которой в
точке х есть среднее арифметическое между @math{x} и @math{f(x)}.

Идею торможения усреднением мы можем выразить при помощи следующей
процедуры:

@lisp
(define (average-damp f)
  (lambda (x) (average x (f x))))
@end lisp

@noindent
@code{average-damp} --- это процедура, принимающая в качестве аргумента
процедуру @code{f} и возвращающая в качестве значения процедуру
(полученную с помощью @code{lambda}), которая, будучи применена к
числу @code{x}, возвращает среднее между @code{x} и @code{(f x)}.
Например, применение @code{average-damp} к процедуре @code{square}
получает процедуру, значением которой для некоторого числа @math{x}
будет среднее между @math{x} и @math{x^2}. Применение этой процедуры к
числу 10 возвращает среднее между 10 и 100, то есть
55:@footnote{Заметьте, что здесь мы имеем комбинацию, оператор которой
сам по себе комбинация. В @ref{Упражнение 1.4} уже была
продемонстрирована возможность таких комбинаций, но то был всего лишь
игрушечный пример. Здесь мы начинаем чувствовать настоящую
потребность в выражениях такого рода --- когда нам нужно применить
процедуру, полученную в качестве значения из процедуры высшего
порядка.}

@lisp
((average-damp square) 10)
@i{55}
@end lisp

@noindent
Используя @code{average-damp}, мы можем переформулировать процедуру
вычисления квадратного корня следующим образом:

@lisp
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
@end lisp

@noindent
Обратите внимание, как такая формулировка делает явными три идеи нашего
метода: поиск неподвижной точки, торможение усреднением и функцию
@math{y \mapsto x / y}. Полезно сравнить такую формулировку метода поиска
квадратного корня с исходной версией, представленной в разделе @ref{1.1.7}.
Вспомните, что обе процедуры выражают один и тот же процесс, и посмотрите,
насколько яснее становится его идея, когда мы выражаем процесс в
терминах этих абстракций. В общем случае существует много способов
сформулировать процесс в виде процедуры. Опытные программисты знают,
как выбрать те формулировки процедур, которые наиболее ясно выражают их
мысли, и где полезные элементы процесса показаны в виде отдельных
сущностей, которые можно использовать в других приложениях. Чтобы
привести простой пример такого нового использования, заметим, что
кубический корень @math{x} является неподвижной точкой функции
@math{y \mapsto x / y^2}, так что мы можем немедленно обобщить нашу
процедуру поиска квадратного корня так, чтобы она извлекала кубические
корни:@footnote{См. дальнейшее обобщение в @ref{Упражнение 1.45}}

@lisp
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
@end lisp

@comment @subsubheading Newton's method
@subsubheading Метод Ньютона

Когда в разделе @ref{1.1.7} мы
впервые представили процедуру извлечения квадратного корня, мы
упомянули, что это лишь частный случай метода Ньютона (@newterm{Newton's method}).
Если @math{x \mapsto g(x)} есть дифференцируемая функция, то
решение уравнения @math{g(x) = 0} есть неподвижная точка функции
@math{x \mapsto f(x)}, где 

@ifinfo

@example
           g(x)
f(x) = x - -----
           Dg(x)
@end example

@end ifinfo
@tex
$$ {f(x) = x} - {g(x)\over Dg(x)} $$
@end tex
@noindent
а @math{Dg(x)} есть производная @math{g}, вычисленная в точке @math{x}.
Метод Ньютона состоит в том, чтобы применить описанный способ поиска
неподвижной точки и аппроксимировать решение уравнения путем поиска
неподвижной точки функции @math{f}.@footnote{Вводные курсы анализа
обычно описывают метод Ньютона через последовательность приближений
@math{x_{n+1} = x_n - g(x_n) / Dg(x_n)}. Наличие языка, на котором
мы можем говорить о процессах, а
также использование идеи неподвижных точек, упрощают описание этого
метода.} Для многих функций @math{g} при достаточно хорошем начальном
значении @math{x} метод Ньютона очень быстро приводит к решению
уравнения @math{g(x) = 0}.@footnote{Метод Ньютона не всегда приводит к
решению, но можно показать, что в удачных случаях каждая итерация
удваивает точность приближения в терминах количества цифр после
запятой. Для таких случаев метод Ньютона сходится гораздо быстрее, чем
метод половинного деления.}

Чтобы реализовать метод Ньютона в виде процедуры, сначала нужно
выразить понятие производной. Заметим, что <<взятие производной>>,
подобно торможению усреднением, трансформирует одну функцию в другую.
Например, производная функции @math{x \mapsto x^3} есть функция
@math{x \mapsto 3x^2}. В общем случае, если @math{g} есть функция, а
@math{dx} --- маленькое число, то производная @math{Dg} функции @math{g}
есть функция, значение которой в каждой точке @math{x} описывается
формулой (при @math{dx}, стремящемся к нулю)
@ifinfo

@example
        g(x + dx) - g(x)
Dg(x) = ----------------
               dx
@end example

@end ifinfo
@tex
$$ {Dg(x)} = {g(x + {\it dx}) - g(x) \over {\it dx}}\,. $$
@end tex
@noindent
Таким образом, мы можем выразить понятие производной (взяв @math{dx}
равным, например, 0.00001) в виде процедуры

@lisp
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
@end lisp

@noindent
дополненной определением

@lisp
(define dx 0.00001)
@end lisp

@noindent
Подобно @code{average-damp}, @code{deriv} является процедурой, которая
берет процедуру в качестве аргумента и возвращает процедуру как
значение. Например, чтобы найти приближенное значение производной
@math{x \mapsto x^3} в точке 5 (точное значение производной равно 75),
можно вычислить

@lisp
(define (cube x) (* x x x))
((deriv cube) 5)
@i{75.00014999664018}
@end lisp

@noindent
С помощью @code{deriv} мы можем выразить метод Ньютона как процесс
поиска неподвижной точки:

@lisp
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
@end lisp

@noindent
Процедура @code{newton-transform} выражает формулу, приведенную в начале
этого раздела, а @code{newtons-method} легко определяется с ее
помощью. В качестве аргументов она принимает процедуру, вычисляющую
функцию, чей ноль мы хотим найти, а также начальное значение
приближения. Например, чтобы найти квадратный корень @math{x}, мы
можем с помощью метода Ньютона найти ноль функции
@math{y \mapsto y^2 - x}, начиная со значения 1.@footnote{При поиске
квадратных корней метод Ньютона быстро сходится к правильному решению,
начиная с любой точки.} Это дает нам еще одну форму процедуры
вычисления квадратного корня:

@lisp
(define (sqrt x)
  (newtons-method
   (lambda (y) (- (square y) x)) 1.0))
@end lisp

@comment @subsubheading Abstractions and first-class procedures
@subsubheading Абстракции и процедуры как полноправные объекты

Мы видели два способа представить вычисление квадратного корня как
частный случай более общего метода; один раз это был поиск неподвижной
точки, другой --- метод Ньютона. Поскольку сам метод Ньютона был
выражен как процесс поиска неподвижной точки, на самом деле мы увидели
два способа вычислить квадратный корень как неподвижную точку. Каждый из
этих методов получает некоторую функцию и находит неподвижную точку для
некоторой трансформации этой функции. Эту общую идею мы можем выразить
как процедуру:

@lisp
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
@end lisp

@noindent
Эта очень общая процедура принимает в качестве аргументов процедуру
@code{g}, которая вычисляет некоторую функцию, процедуру, которая
трансформирует @code{g}, и начальное приближение. Возвращаемое значение
есть неподвижная точка трансформированной функции.

С помощью такой абстракции можно переформулировать процедуру вычисления
квадратного корня из этого раздела (ту, где мы ищем неподвижную точку
версии @math{y \mapsto x / y}, заторможенной усреднением) как частный
случай общего метода:

@lisp
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))
@end lisp

@noindent
Подобным образом, вторую процедуру нахождения квадратного корня из этого
раздела (пример применения метода Ньютона, который находит неподвижную
точку Ньютонова преобразования @math{y \mapsto y^2 - x}) можно
представить так:

@lisp
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x)) newton-transform 1.0))
@end lisp

@noindent
Мы начали раздел @ref{1.3}
с наблюдения, что составные процедуры являются важным механизмом
абстракции, поскольку они позволяют выражать общие методы вычисления в
виде явных элементов нашего языка программирования. Теперь мы увидели,
как процедуры высших порядков позволяют нам манипулировать этими общими
методами и создавать еще более глубокие абстракции.

Как программисты, мы должны быть готовы распознавать возможности поиска
абстракций, лежащих в основе наших программ, строить нашу работу на
таких абстракциях и обобщать их, создавая еще более мощные абстракции.
Это не значит, что программы всегда нужно писать на возможно более
глубоком уровне абстракции: опытные программисты умеют выбирать тот
уровень, который лучше всего подходит к их задаче. Однако важно быть
готовыми мыслить в терминах этих абстракций и быть готовым применить
их в новых контекстах. Важность процедур высшего порядка состоит в
том, что они позволяют нам явно представлять эти абстракции в качестве
элементов нашего языка программирования, так что мы можем обращаться с
ними так же, как и с другими элементами вычисления.

В общем случае языки программирования накладывают ограничения на
способы, с помощью которых можно манипулировать элементами вычисления.
Говорят, что элементы, на которые накладывается наименьшее число
ограничений, имеют статус элементов вычисления (@newterm{first-class}) или . Вот
некоторые из их <<прав и привилегий>>:@footnote{Понятием полноправного
статуса элементов языка программирования мы обязаны британскому
специалисту по информатике Кристоферу Стрейчи (1916-1975).}

@itemize @bullet

@item
Их можно называть с помощью переменных.

@item
Их можно передавать в процедуры в качестве аргументов.

@item
Их можно возвращать из процедур в виде результата.

@item
Их можно включать в структуры данных.@footnote{Примеры этого мы увидим
после того, как введем понятие структур данных в @ref{Глава 2}.}

@end itemize

@noindent
Лисп, в отличие от других распространенных языков программирования,
дает процедурам полноправный статус. Это может быть проблемой для
эффективной реализации, но зато получаемый выигрыш в выразительной силе
огромен.@footnote{Основная цена, которую реализации приходится платить за
придание процедурам статуса полноправных объектов, состоит в том, что,
поскольку мы разрешаем возвращать процедуры как значения, нам нужно
оставлять память для хранения свободных переменных процедуры даже тогда,
когда она не выполняется. В реализации Scheme, которую мы рассмотрим в
разделе @ref{4.1}, эти переменные хранятся в окружении процедуры.}

@quotation
@strong{@anchor{Упражнение 1.40}Упражнение 1.40:} Определите процедуру @code{cubic}, которую можно было бы
использовать совместно с процедурой @code{newtons-method} в выражениях
вида

@lisp
(newtons-method (cubic a b c) 1)
@end lisp

@noindent
для приближенного вычисления нулей кубических уравнений @math{x^3 + ax^2 + bx + c}.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.41}Упражнение 1.41:} Определите процедуру
@code{double}, которая принимает как
аргумент процедуру с одним аргументом и возвращает процедуру, которая
применяет исходную процедуру дважды. Например, если процедура @code{inc}
добавляет к своему аргументу 1, то @code{(double inc)} должна быть
процедурой, которая добавляет 2. Скажите, какое значение возвращает

@lisp
(((double (double double)) inc) 5)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 1.42}Упражнение 1.42:} Пусть @math{f} и
@math{g} --- две одноаргументные функции.
По определению, (@newterm{composition}) @math{f} и @math{g} есть функция
@math{x \mapsto f(g(x))}. Определите процедуру @code{compose} которая
реализует композицию. Например, если @code{inc} --- процедура,
добавляющая к своему аргументу 1,

@lisp
((compose square inc) 6)
@i{49}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 1.43}Упражнение 1.43:} Если @math{f}
есть численная функция, а @math{n} ---
положительное целое число, то мы можем построить @math{n}-кратное
применение @math{f}, которое определяется как функция, значение
которой в точке @math{x} равно @math{f(f( \dots (f(x)) \dots ))}.
Например, если @math{f} есть функция @math{x \mapsto x + 1}, то
@math{n}-кратным применением @math{f} будет функция
@math{x \mapsto x + n}. Если @math{f} есть операция возведения в
квадрат, то @math{n}-кратное применение @math{f} есть функция, которая
возводит свой аргумент в @math{2^n}-ю степень. Напишите процедуру,
которая принимает в качестве ввода процедуру, вычисляющую @math{f}, и
положительное целое @math{n}, и возвращает процедуру, вычисляющую
@math{n}-кратное применение @math{f}. Требуется, чтобы Вашу процедуру
можно было использовать в таких контекстах:

@lisp
((repeated square 2) 5)
@i{625}
@end lisp

Подсказка: может оказаться удобно использовать @code{compose} из
упражнения @ref{Упражнение 1.42}.
@end quotation

@quotation
@strong{@anchor{Упражнение 1.44}Упражнение 1.44:} Идея (@newterm{smoothing a function}) играет важную роль в обработке
сигналов. Если @math{f} --- функция, а @math{dx} --- некоторое малое
число, то сглаженная версия @math{f} есть функция, значение которой в
точке @math{x} есть среднее между @math{f (x-dx)}, @math{f(x)} и
@math{f
(x+dx)}. Напишите процедуру @code{smooth}, которая в качестве ввода
принимает процедуру, вычисляющую @math{f}, и возвращает процедуру,
вычисляющую сглаженную версию @math{f}. Иногда бывает удобно проводить
повторное сглаживание (то есть сглаживать сглаженную функцию и т.д.),
получая (n-fold smoothed function). Покажите, как породить
@math{n}-кратно сглаженную функцию с помощью @code{smooth} и
@code{repeated} из упражнения @ref{Упражнение 1.43}.

@end quotation

@quotation
@strong{@anchor{Упражнение 1.45}Упражнение 1.45:} В разделе @ref{1.3.3} мы
видели, что попытка вычисления квадратных корней путем наивного поиска
неподвижной точки @math{y \mapsto x / y} не сходится, и что это можно
исправить путем торможения усреднением. Тот же самый метод работает для
нахождения кубического корня как неподвижной точки @math{y \mapsto x / y^2},
заторможенной усреднением. К сожалению, этот процесс не
работает для корней четвертой степени --- однажды примененного
торможения усреднением недостаточно, чтобы заставить сходиться процесс
поиска неподвижной точки @math{y \mapsto x / y^3}.
С другой стороны, если мы применим торможение усреднением дважды
(т.е. применим торможение усреднением к результату торможения
усреднением от @math{y \mapsto x / y^3}), то поиск неподвижной точки
начнет сходиться. Проделайте эксперименты, чтобы понять, сколько
торможений усреднением нужно, чтобы вычислить корень @math{n}-ой степени
как неподвижную точку на основе многократного торможения усреднением
функции @math{y \mapsto x / y^{n-1}}.
Используя свои результаты для того, напишите простую процедуру
вычислениякорней @math{n}-ой степени с помощью процедур
@code{fixed-point}, @code{average-damp} и @code{repeated} из
упражнения @ref{Упражнение 1.43}. Считайте, что все арифметические
операции, какие Вам понадобятся, присутствуют в языке как примитивы.
@end quotation

@endpage
@quotation
@strong{@anchor{Упражнение 1.46}Упражнение 1.46:} Некоторые из
вычислительных методов, описанных в этой
главе, являются примерами чрезвычайно общей вычислительной стратегии,
называемой (@newterm{iterative improvement}). Пошаговое улучшение состоит в
следующем: чтобы что-то вычислить, нужно взять какое-то начальное
значение, проверить, достаточно ли оно хорошо, чтобы служить ответом, и
если нет, то улучшить это значение и продолжить процесс с новым
значением. Напишите процедуру @code{iterative-improve}, которая
принимает в качестве аргументов две процедуры: проверку, достаточно ли
хорошо значение, и метод улучшения значения. @code{Iterative-improve}
должна возвращать процедуру, которая принимает начальное значение в
качестве аргумента и улучшает его, пока оно не станет достаточно
хорошим. Перепишите процедуру @code{sqrt} из раздела @ref{1.1.7} и
процедуру @code{fixed-point} из раздела @ref{1.3.3} в терминах
@code{iterative-improve}.
@end quotation

@comment @chapter Building Abstractions with Data
@chapter Построение абстракций с помощью данных
@node    Глава 2, Глава 3, Глава 1, Вверх

@quotation
Теперь мы подходим к решающему шагу в математической абстракции: мы
забываем, что обозначают наши символы. ...[Математик] не должен стоять
на месте: есть много операций, которые он может производить с этими
символами, не обращая внимания на те вещи, которые они обозначают.

---Hermann Weyl, @cite{The Mathematical Way of Thinking}
@end quotation

@c @sp 1.0

@noindent
\lettrine[findent=1pt]{М}{ы сконцентрировали} внимание в @ref{Главе 1}
на вычислительных процессах и роли процедур
в проектировании программ. Мы рассмотрели, как использовать простейшие
данные (числа) и простейшие операции (арифметические), как сочетать
процедуры и получать составные процедуры с помощью композиции, условных
выражений и использования параметров, а также как строить абстрактные
процедуры при помощи @code{define}. Мы убедились, что процедуру можно
рассматривать как схему локального развития процесса; мы
классифицировали некоторые общие схемы процессов, воплощенные в
процедурах, строили о них умозаключения и производили их простейший
алгоритмический анализ. Кроме того, мы увидели, что процедуры высших
порядков увеличивают выразительную силу нашего языка, позволяя
оперировать общими методами вычисления, а следовательно, и проводить
рассуждения в их терминах. Это во многом и составляет сущность
программирования.

В этой главе мы будем рассматривать более сложные данные. Все процедуры
главы 1 работают с простыми численными данными, а простых численных данных
часто бывает недостаточно для тех задач, которые мы хотим решать с помощью
вычислений. Программы, как правило, пишут, чтобы моделировать сложные
явления, и чаще всего приходится строить вычислительные объекты,
состоящие из нескольких частей, чтобы смоделировать многосторонние
явления реального мира. Таким образом, в отличие от
главы 1, где наше внимание было в основном направлено на создание абстракций
с помощью сочетания процедур и построения составных процедур, в этой главе
мы обращаемся к другой важной характеристике всякого языка
программирования: тем средствам, которые он предоставляет для создания
абстракций с помощью сочетания объектов данных и построения (compound
data).

Для чего в языке программирования нужны составные данные? По тем же
причинам, по которым нужны составные процедуры: мы хотим повысить
понятийный уровень, на котором мы проектируем программы, хотим сделать
наши проекты более модульными и увеличить выразительную силу языка.
Точно так же, как способность определять процедуры дает возможность
работать с процессами на более высоком содержательном уровне, чем
уровень элементарных операций языка, способность конструировать
составные объекты данных позволяет работать с данными на более высоком
понятийном уровне, чем уровень элементарных данных нашего языка.

\enlargethispage{\baselineskip}

Рассмотрим задачу проектирования системы для арифметических вычислений с
рациональными числами. Мы можем представить себе операцию
@code{add-rat}, которая принимает два рациональных числа и вычисляет их
сумму. В терминах простейших данных, рациональное число можно
рассматривать как два целых числа: числитель и знаменатель. Таким
образом, мы могли бы сконструировать программу, в которой всякое
рациональное число представлялось бы как пара целых (числитель и
знаменатель) и @code{add-rat} была бы реализована как две процедуры
(одна из которых вычисляла бы числитель суммы, а другая знаменатель).
Однако это было бы крайне неудобно, поскольку нам приходилось бы
следить, какие числители каким знаменателям соответствуют. Если бы
системе требовалось производить большое количество операций над большим
количеством рациональных чисел, такие служебные детали сильно затемняли
бы наши программы, не говоря уже о наших мозгах. Было бы намного проще,
если бы мы могли <<склеить>> числитель со знаменателем и получить пару
--- (@newterm{compound data object}), --- с которой наши программы могли бы
обращаться способом, соответствующим нашему представлению о рациональном
числе как о едином понятии.

Кроме того, использование составных данных позволяет увеличить
модульность программ. Если бы мы могли обрабатывать рациональные числа
непосредственно как объекты, то можно было бы отделить ту часть
программы, которая работает собственно с рациональными числами, от
деталей представления рационального числа в виде пары целых. Общий метод
отделения частей программы, которые имеют дело с представлением объектов
данных, от тех частей, где эти объекты данных используются, --- это
мощная методология проектирования, называемая (@newterm{data abstraction}). Мы
увидим, как с помощью абстракции данных программы становится легче
проектировать, поддерживать и изменять.

Использование составных данных ведет к настоящему увеличению
выразительной силы нашего языка программирования. Рассмотрим идею
порождения <<линейной комбинации>> @math{ax + by}. Нам может
потребоваться процедура, которая принимала бы как аргументы @math{a},
@math{b}, @math{x} и @math{y} и возвращала бы значение @math{ax + by}.
Если аргументы являются числами, это не представляет никакой трудности,
поскольку мы сразу можем определить процедуру

@lisp
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))
@end lisp

@noindent
Предположим, однако, что нас интересуют не только числа. Предположим,
что нам хотелось бы выразить в процедурных терминах идею о том, что
можно строить линейные комбинации всюду, где определены сложение и
умножение --- для рациональных и комплексных чисел, многочленов и
многого другого. Мы могли бы выразить это как процедуру в следующей
форме:

@lisp
(define (linear-combination a b x y)
  (add (mul a x) (mul b y)))
@end lisp

@noindent
где @code{add} и @code{mul} --- не элементарные процедуры @code{+} и
@code{*}, а более сложные устройства, которые проделывают соответствующие
операции, какие бы типы данных мы ни передавали как аргументы @code{a},
@code{b}, @code{x} и @code{y}. Здесь важнейшая деталь состоит в том, что
единственное, что требуется знать процедуре @code{linear-combination} об
@code{a}, @code{b}, @code{x} и @code{y} --- это то, что процедуры
@code{add} и @code{mul} проделывают соответствующие действия. С точки
зрения процедуры @code{linear-combination} несущественно, что такое
@code{a}, @code{b}, @code{x} и @code{y}, и еще менее существенно, как
они могут быть представлены через более простые данные. Этот же пример
показывает, почему так важно, чтобы в нашем языке программирования была
возможность прямо работать с составными объектами: иначе у процедур,
подобных @code{linear-combination}, не было бы способа передать
аргументы в @code{add} и @code{mul}, не зная деталей их
устройства.@footnote{Способность прямо оперировать процедурами
увеличивает выразительную силу нашего языка программирования подобным же
образом. Например, в разделе @ref{1.3.1} мы
ввели процедуру @code{sum}, которая принимает в качестве аргумента
процедуру @code{term} и вычисляет сумму значений @code{term} на
некотором заданном интервале. Чтобы определить @code{sum}, нам
необходимо иметь возможность говорить о процедуре типа @code{term} как о
едином целом, независимо от того, как она выражена через более простые
операции. Вообще говоря, не имей мы понятия <<процедуры>>, вряд ли мы и
думать могли бы о возможности определения такой операции, как
@code{sum}. Более того, пока мы размышляем о суммировании, детали того,
как @code{term} может быть составлен из более простых операций,
несущественны.}

Мы начинаем эту главу с реализации описанной выше системы арифметики
рациональных чисел. Это послужит основанием для обсуждения составных
данных и абстракции данных. Как и в случае с составными процедурами,
основная мысль состоит в том, что абстракция является методом
ограничения сложности, и мы увидим, как абстракция данных позволяет нам
возводить полезные (@newterm{abstraction barriers}) между разными частями
программы.

Мы увидим, что главное в работе с составными данными --- то, что язык
программирования должен предоставлять нечто вроде <<клея>>, так, чтобы
объекты данных могли сочетаться, образуя более сложные объекты данных.
Существует множество возможных типов клея. На самом деле мы обнаружим,
что составные данные можно порождать вообще без использования каких-либо
специальных операций, относящихся к <<данным>> --- только с помощью
процедур. Это еще больше размоет границу между <<процедурами>> и
<<данными>>, которая уже к концу
главы 1 оказалась весьма тонкой. Мы также исследуем некоторые общепринятые
методы представления последовательностей и деревьев. Важная идея в
работе с составными данными --- понятие (@newterm{closure}): клей для сочетания
объектов данных должен позволять нам склеивать не только элементарные
объекты данных, но и составные. Еще одна важная идея состоит в том, что
составные объекты данных могут служить (@newterm{conventional interfaces}), так,
чтобы модули программы могли сочетаться методом подстановки. Некоторые
из этих идей мы продемонстрируем с помощью простого графического языка,
использующего замыкание.

\enlargethispage{\baselineskip}

Затем мы увеличим выразительную мощность нашего языка путем введения
(@newterm{symbolic expressions}) --- данных, элементарные части которых могут
быть произвольными символами, а не только числами. Мы рассмотрим
различные варианты представления множеств объектов. Мы обнаружим, что,
подобно тому, как одна и та же числовая функция может вычисляться
различными вычислительными процессами, существует множество способов
представить некоторую структуру данных через элементарные объекты, и
выбор представления может существенно влиять на запросы манипулирующих
этими данными процессов к памяти и ко времени. Мы исследуем эти идеи в
контексте символьного дифференцирования, представления множеств и
кодирования информации.

После этого мы обратимся к задаче работы с данными, которые по-разному
могут быть представлены в различных частях программы. Это ведет к
необходимости ввести (@newterm{generic operations}), которые обрабатывают много
различных типов данных. Поддержка модульности в присутствии обобщенных
операций требует более мощных барьеров абстракции, чем тех, что
получаются с помощью простой абстракции данных. А именно, мы вводим
(@newterm{data-directed programming}) как метод, который позволяет проектировать
представления данных отдельно, а затем сочетать их (@newterm{additively}) (т. е.,
без модификации). Чтобы проиллюстрировать силу этого подхода к
проектированию систем, в завершение главы мы применим то, чему в ней
научились, к реализации пакета символьной арифметики многочленов,
коэффициенты которых могут быть целыми, рациональными числами,
комплексными числами и даже другими многочленами.

@menu
* 2-1::              Введение в абстракцию данных
* 2-2::              Иерархические данные и свойство замыкания
* 2-3::              Символьные данные
* 2-4::              Множественные представления для абстрактных данных
* 2-5::              Системы с обобщенными операциями
@end menu

@comment @section Introduction to Data Abstraction
@section Введение в абстракцию данных
@node	 2.1, 2.2, Глава 2, Глава 2

В разделе @ref{1.1.8}
мы заметили, что процедура, которую мы используем как элемент при
создании более сложной процедуры, может рассматриваться не только как
последовательность определенных операций, но и как процедурная
абстракция: детали того, как процедура реализована, могут быть скрыты, и
сама процедура может быть заменена на другую с подобным поведением.
Другими словами, мы можем использовать абстракцию для отделения способа
использования процедуры от того, как эта процедура реализована в
терминах более простых процедур. Для составных данных подобное понятие
называется (@newterm{data abstraction}). Абстракция данных --- это методология,
которая позволяет отделить способ использования составного объекта
данных от деталей того, как он составлен из элементарных данных.

Основная идея абстракции данных состоит в том, чтобы строить программы,
работающие с составными данными, так, чтобы иметь дело с <<абстрактными
данными>>. То есть, используя данные, наши программы не должны делать о
них никаких предположений, кроме абсолютно необходимых для выполнения
поставленной задачи. В то же время <<конкретное>> представление данных
определяется независимо от программ, которые эти данные используют.
Интерфейсом между двумя этими частями системы служит набор процедур,
называемых (@newterm{selectors}) и (@newterm{constructors}), реализующих
абстрактные данные в терминах конкретного представления. Чтобы
проиллюстрировать этот метод, мы рассмотрим, как построить набор процедур
для работы с рациональными числами.

@menu
* 2-1-1::             Пример арифметические операции над рациональными числами
* 2-1-2::             Барьеры абстракции
* 2-1-3::             Что значит слово <<данные>>?
* 2-1-4::             Расширенный пример интервальная арифметика
@end menu

@comment @subsection Example: Arithmetic Operations@* for Rational Numbers
@subsection Пример: арифметические операции над рациональными числами
@node	2.1.1, 2.1.2, 2.1, 2.1

Допустим, нам нужно работать с рациональной арифметикой. Нам требуется
складывать, вычитать, умножать и делить рациональные числа, а также
проверять, равны ли два рациональных числа друг другу.

Для начала предположим, что у нас уже есть способ построить рациональное
число из его числителя и знаменателя. Кроме того, мы предполагаем, что
имея рациональное число, мы можем получить его числитель и знаменатель.
Допустим также, что эти конструктор и два селектора доступны нам в виде
процедур:

@itemize @bullet

@item
@math{\hbox{\tt(make-rat}\;\langle{n}\rangle\;\langle{d}\kern0.06em\rangle\hbox{\tt)}} возвращает рациональное число, числитель которого целое @math{\langle{n}\rangle} а знаменатель --- целое @math{\langle{d}\kern0.06em\rangle}.

@item
@math{\hbox{\tt(numer}\;\;\langle{x}\rangle\hbox{\tt)}} возвращает числитель рационального числа
@math{\langle{x}\rangle}.

@item
@math{\hbox{\tt(denom}\;\;\langle{x}\rangle\hbox{\tt)}} возвращает знаменатель рационального
@math{\langle{x}\rangle}.

@end itemize

@noindent
Здесь мы используем мощную стратегию синтеза: (@newterm{wishful thinking}).
Пока что мы не сказали, как представляется рациональное число и как должны
реализовываться процедуры @code{numer}, @code{denom} и @code{make-rat}.
Тем не менее, если бы эти процедуры у нас были, мы могли бы складывать,
вычитать, умножать, делить и проверять на равенство с помощью следующих
отношений:
@ifinfo

@example
n_1   n_2   n_1 d_2 + n_2 d_1
--- + --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 d_2 - n_2 d_1
--- - --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 n_2
--- * --- = -------
d_1   d_2   d_1 d_2

n_1 / d_1   n_1 d_2
--------- = -------
n_2 / d_2   d_1 n_2

n_1   n_2
--- = ---  тогда и только тогда, когда if n_1 d_2 = n_2 d_1
d_1   d_2
@end example
@end ifinfo
\begin{align*}
  {n_1 \over d_1} + {n_2 \over d_2} 	&= {n_1 d_2 + n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} - {n_2 \over d_2} 	&= {n_1 d_2 - n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} \cdot {n_2 \over d_2}	&= {n_1 n_2 \over d_1 d_2}, \\
  {n_1 / d_1} \over {n_2 / d_2} 	&= {n_1 d_2 \over d_1 n_2}, \\
  {n_1 \over d_1} 			&= {n_2 \over d_2}
\end{align*}
тогда и только тогда, когда:
\begin{align*}
   n_1 d_2 = n_2 d_1.
\end{align*}
@noindent
Мы можем выразить эти правила в процедурах:

@lisp
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
@end lisp

Теперь у нас есть операции над рациональными числами, определенные в
терминах процедур --- селекторов и конструкторов @code{numer},
@code{denom} и @code{make-rat}. Однако сами эти процедуры мы еще не
написали. Нам нужен какой-нибудь способ склеить вместе числитель и
знаменатель, чтобы получить рациональное число.

@comment @subsubheading Pairs
@subsubheading Пары

Для реализации конкретного уровня абстракции данных в нашем языке
имеется составная структура, называемая (@newterm{pair}), и она создается с
помощью элементарной процедуры @code{cons}. Эта процедура принимает два
аргумента и возвращает объект данных, который содержит эти два аргумента
в качестве частей. Имея пару, мы можем получить ее части с помощью
элементарных процедур @code{ car} и @code{cdr}.@footnote{@code{cons}
означает @emph{construct} (построить, сконструировать, собрать). Имена
@code{car} и @code{cdr} происходят из исходной реализации Лиспа на IBM
704. Схема адресации этой машины позволяла обращаться к <<адресной>> и
<<декрементной>> частям ячейки памяти. @code{car} означает
@emph{Contents of Address Part of Register} (содержимое адресной части
регистра), а @code{cdr} (произносится <<куддер>>) означает
@emph{Contents of Decrement Part of Register} (содержимое декрементной
части регистра).} Таким образом, использовать @code{cons}, @code{car} и
@code{cdr} можно так:

@lisp
(define x (cons 1 2))
(car x)
@i{1}
(cdr x)
@i{2}
@end lisp

@noindent
Заметим, что пара является объектом, которому можно дать имя и работать
с ним, подобно элементарному объекту данных. Более того, можно
использовать @code{cons} для создания пар, элементы которых сами пары, и
так далее:

@lisp
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
@i{1}
(car (cdr z))
@i{3}
@end lisp

@noindent
В разделе @ref{2.2} мы
увидим, что из этой возможности сочетать пары следует возможность их
использовать как строительные блоки общего назначения при создании любых
сложных структур данных. Один-единственный примитив составных данных
@emph{пара}, реализуемый процедурами @code{cons}, @code{car} и
@code{cdr}, --- вот и весь клей, который нам нужен. Объекты данных,
составленные из пар, называются (@newterm{list-structured data}).

\enlargethispage{\baselineskip}

@comment @subsubheading Representing rational numbers
@subsubheading Представление рациональных чисел

Пары позволяют нам естественным образом завершить построение системы
рациональных чисел. Будем просто представлять рациональное число в виде
пары двух целых чисел: числителя и знаменателя. Тогда @code{make-rat},
@code{numer} и @code{denom} немедленно реализуются следующим
образом:@footnote{Другой способ определить селекторы и конструктор был бы

@lisp
(define make-rat cons)
(define numer car)
(define denom cdr)
@end lisp

Первое определение связывает имя @code{make-rat} со значением выражения
@code{cons}, то есть элементарной процедурой, которая строит пары. Таким
образом, @code{make-rat} и @code{cons} становятся именами для одного и
того же элементарного конструктора.

Такое определение конструкторов и селекторов эффективно: вместо того,
чтобы заставлять @code{make-rat} @emph{вызывать} @code{cons}, мы делаем
@code{make-rat} и @code{cons} @emph{одной и той же процедурой}, так что
когда вызывается @code{make-rat}, происходит вызов только одной
процедуры, а не двух. С другой стороны, это не дает работать отладочным
средствам, которые отслеживают вызовы процедур или устанавливают на них
контрольные точки: Вам может потребоваться следить за вызовами
@code{make-rat}, но Вы уж точно никогда не захотите отслеживать каждый
вызов @code{cons}.

В этой книге мы решили не использовать такой стиль определений.}

@lisp
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
@end lisp

@noindent
Кроме того, когда нам требуется выводить результаты вычислений, мы
печатаем рациональное число, сначала выводя его числитель, затем косую
черту и затем знаменатель:@footnote{--- элементарная процедура языка
Scheme для печати данных. Другая элементарная процедура, @code{newline},
переводит строку при печати. Эти процедуры не возвращают никакого
полезного значения, так что в примерах использования @code{print-rat}
ниже, мы показываем только то, что печатает @code{print-rat}, а не то,
что интерпретатор выводит как значение @code{print-rat}.}

@lisp
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
@end lisp

@noindent
Теперь мы можем опробовать процедуры работы с рациональными числами:

@lisp
(define one-half (make-rat 1 2))
(print-rat one-half)
@i{1/2}
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
@i{5/6}
(print-rat (mul-rat one-half one-third))
@i{1/6}
(print-rat (add-rat one-third one-third))
@i{6/9}
@end lisp

@noindent
Как показывает последний пример, наша реализация рациональных чисел не
приводит их к наименьшему знаменателю. Мы можем исправить это упущение,
изменив @code{make-rat}. Если у нас есть процедура @code{gcd},
вычисляющая наибольший общий делитель двух целых чисел, вроде той,
которая описана в разделе @ref{1.2.5 }, мы
можем с помощью @code{gcd} сокращать числитель и знаменатель, прежде,
чем построить пару:

@lisp
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
@end lisp

@noindent
Теперь мы имеем

@lisp
(print-rat (add-rat one-third one-third))
@i{2/3}
@end lisp

@noindent
как нам того и хотелось. Эта модификация была произведена путем
изменения конструктора @code{make-rat}, и мы не тронули ни одну из
процедур (скажем, @code{add-rat} или @code{mul-rat}), которые реализуют
сами операции.

@quotation
@strong{@anchor{Упражнение 2.1}Упражнение 2.1:}
Определите улучшенную версию @code{make-rat}, которая
принимала бы как положительные, так и отрицательные аргументы.
@code{make-rat} должна нормализовывать знак так, чтобы в случае, если
рациональное число положительно, то и его числитель, и знаменатель были
бы положительны, а если оно отрицательно, то чтобы только его числитель
был отрицателен.
@end quotation

@comment @subsection Abstraction Barriers
@subsection Барьеры абстракции
@node	2.1.2, 2.1.3, 2.1.1, 2.1

Прежде чем мы перейдем к другим примерам работы с составными данными и
абстракцией данных, рассмотрим несколько вопросов, относящихся к примеру
с рациональными числами. Мы определили операции над рациональными
числами через конструктор @code{make-rat} и селекторы @code{numer} и
@code{denom}. В общем случае основная идея абстракции данных состоит в
том, чтобы определить для каждого типа объектов данных набор базовых
операций, через которые будут выражаться все действия с объектами этого
типа, и затем при работе с данными использовать только этот набор
операций.

@float
@anchor{Рисунок 2.1}
@ifinfo
@quotation
@strong{Рисунок 2.1:} Data-abstraction barriers in the rational-number package.

@example
        +------------------------------------+
--------| Programs that use rational numbers |--------
        +------------------------------------+
          Rational numbers in problem domain
            +---------------------------+
------------|   add-rat  sub-rat  ...   |-------------
            +---------------------------+
   Rational numbers as numerators and denominators
              +------------------------+
--------------| make-rat  numer  denom |--------------
              +------------------------+
              Rational numbers as pairs
                  +----------------+
------------------| cons  car  cdr |------------------
                  +----------------+
            However pairs are implemented
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap2/Fig2.1c,91mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.1:} Data-abstraction barriers in the rational-number package.}
@center @caption{@strong{Рисунок 2.1:} Барьеры абстракции данных в пакете для работы с рациональными числами.}
@sp 0.6
@end iftex
@end float

Мы можем представить себе структуру системы работы с рациональными
числами так, как это показано на @ref{Рисунок 2.1}.
Горизонтальные линии обозначают (@newterm{abstraction barriers}), которые отделяют
различные <<уровни>> системы друг от друга. На каждом из этих уровней
барьер отделяет программы, которые используют абстрактные данные
(сверху) от программ, которые реализуют эту абстракцию данных (внизу).
Программы, использующие рациональные числа, работают с ними
исключительно в терминах процедур, которые пакет работы с рациональными
числами предоставляет <<для общего пользования>>: @code{add-rat},
@code{sub-rat}, @code{mul-rat}, @code{div-rat} и @code{equal-rat?}. В
свою очередь, эти процедуры используют только конструктор и селекторы
@code{make-rat}, @code{numer} и @code{denom}, которые сами реализованы
при помощи пар. Детали реализации пар не имеют значения для остальной
части пакета работы с рациональными числами; существенно только, что с
парами можно работать при помощи @code{cons}, @code{car} и @code{cdr}.
По существу, процедуры на каждом уровне являются интерфейсами, которые
определяют барьеры абстракции и связывают различные уровни.

У этой простой идеи много преимуществ. Одно из них состоит в том, что
программы становится намного проще поддерживать и изменять. Любая
сложная структура может быть представлена через элементарные структуры
данных языка программирования многими способами. Разумеется, выбор
представления влияет на программы, работающие с этим представлением; так
что, если когда-нибудь позднее его нужно будет изменить, соответственно
придется изменить и все эти программы. В случае больших программ эта
задача может быть весьма трудоемкой и дорогой, если зависимость от
представления не будет при проектировании ограничена несколькими
программными модулями.

Например, другим способом решения задачи приведения рациональных чисел к
наименьшему знаменателю было бы производить сокращение не тогда, когда
мы конструируем число, а каждый раз, как мы к нему обращаемся. При этом
потребуются другие конструктор и селекторы:

@lisp
(define (make-rat n d) (cons n d))
(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
@end lisp

@noindent
Разница между этой реализацией и предыдущей состоит в том, когда мы
вычисляем НОД с помощью @code{gcd}. Если при типичном использовании
рациональных чисел к числителю и знаменателю одного и того же
рационального числа мы обращаемся по многу раз, вычислять НОД лучше
тогда, когда рациональное число конструируется. Если нет, нам может быть
выгодно подождать с его вычислением до времени обращения. В любом
случае, когда мы переходим от одной реализации к другой, нам ничего не
нужно менять в процедурах @code{add-rat}, @code{sub-rat} и прочих.

То, что мы ограничиваем зависимость от представления несколькими
интерфейсными процедурами, помогает нам и проектировать программы, и
изменять их, поскольку таким образом мы сохраняем гибкость и получаем
возможность рассматривать другие реализации. Продолжая наш простой
пример, представим себе, что мы строим пакет работы с рациональными
числами и не можем сразу решить, вычислять ли НОД при построении числа
или при обращении к нему. Методология абстракции данных позволяет нам
отложить это решение, не теряя возможности продолжать разработку
остальных частей системы.

@quotation
@strong{@anchor{Упражнение 2.2}Упражнение 2.2:}
Рассмотрим задачу представления отрезков прямой на плоскости.
Каждый отрезок представляется как пара точек: начало и конец. Определите
конструктор @code{make-segment} и селекторы @code{start-segment} и
@code{end-segment}, которые определяют представление отрезков в терминах
точек. Далее, точку можно представить как пару чисел: координата
@math{x} и координата @math{y}. Соответственно, напишите конструктор
@code{make-@/point} и селекторы @code{x-point} и @code{y-point}, которые
определяют такое представление. Наконец, используя свои селекторы и
конструктор, напишите процедуру @code{midpoint-segment}, которая
принимает отрезок в качестве аргумента и возвращает его середину (точку,
координаты которой являются средним координат концов отрезка). Чтобы
опробовать эти процедуры, Вам потребуется способ печатать координаты
точек:

@endpage
@lisp
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.3}Упражнение 2.3:}
Реализуйте представление прямоугольников на плоскости.
(Подсказка: Вам могут потребоваться результаты
упражнения @ref{Упражнение 2.2}.) Определите в терминах своих
конструкторов и селекторов процедуры, которые вычисляют периметр и
площадь прямоугольника. Теперь реализуйте другое представление для
прямоугольников. Можете ли Вы спроектировать свою систему с подходящими
барьерами абстракции так, чтобы одни и те же процедуры вычисления
периметра и площади работали с любым из Ваших представлений?
@end quotation

@comment @subsection What Is Meant by Data?
@subsection Что значит слово <<данные>>?
@node	2.1.3, 2.1.4, 2.1.2, 2.1

Свою реализацию рациональных чисел в разделе @ref{2.1.1} мы начали с
определения операций над рациональными числами @code{add-rat},
@code{sub-rat} и так далее в терминах трех неопределенных процедур:
@code{make-rat}, @code{numer} и @code{denom}. В этот момент мы могли
думать об операциях как определяемых через объекты данных ---
числители, знаменатели и рациональные числа, --- поведение которых
определялось тремя последними процедурами.

Но что в точности означает слово (@newterm{data})? Здесь недостаточно просто
сказать <<то, что реализуется некоторым набором селекторов и
конструкторов>>. Ясно, что не любой набор из трех процедур может служить
основой для реализации рациональных чисел. Нам нужно быть уверенными в
том, что если мы конструируем рациональное число @code{x} из пары целых
@code{n} и @code{d}, то получение @code{numer} и @code{denom} от
@code{x} и деление их друг на друга должно давать тот же результат, что
и деление @code{n} на @code{d}. Другими словами, @code{make-rat},
@code{numer} и @code{denom} должны удовлетворять следующему условию: для
каждого целого числа @code{n} и не равного нулю целого @code{d}, если
@code{x} есть @code{(make-rat n d)}, то
@ifinfo

@example
(numer x)    n
--------- = ---
(denom x)    d
@end example

@end ifinfo
@tex
$$ {\hbox{\tt(numer x)} \over \hbox{\tt(denom x)}} = {{\tt n} \over {\tt d}}\,.  $$
@end tex
Это на самом деле единственное
условие, которому должны удовлетворять @code{make-rat}, @code{numer} и
@code{denom}, чтобы служить основой для представления рациональных
чисел. В общем случае можно считать, что данные --- это то, что
определяется некоторым набором селекторов и конструкторов, а также
некоторыми условиями, которым эти процедуры должны удовлетворять, чтобы
быть правильным представлением.@footnote{Как ни странно, эту мысль очень
трудно строго сформулировать. Существует два подхода к такой
формулировке. Один, начало которому положил Ч. А. Р. Хоар @ref{Hoare 1972},
известен как метод (@newterm{abstract models}). Он формализует спецификацию вида
<<процедуры плюс условия>> вроде описанной выше в примере с
рациональными числами. Заметим, что условие на представление
рациональных чисел было сформулировано в терминах утверждений о целых
числах (равенство и деление). В общем случае абстрактные модели
определяют новые типы объектов данных в терминах типов данных,
определенных ранее. Следовательно, утверждения об объектах данных могут
быть проверены путем сведения их к утверждениям об объектах данных,
которые были определены ранее. Другой подход, который был введен
Зиллесом из MIT, Гогеном, Тэтчером, Вагнером и Райтом из IBM (см.
@ref{Thatcher et al. 1978}) и Гаттэгом из университета Торонто
(см. @ref{Guttag 1977}), называется (@newterm{algebraic specification}).
Этот подход рассматривает <<процедуры>> как элементы абстрактной алгебраической
системы, чье поведение определяется аксиомами, соответствующими нашим
<<условиям>>, и использует методы абстрактной алгебры для проверки
утверждений об объектах данных. Оба этих метода описаны в статье Лисков
и Зиллеса @ref{Liskov and Zilles (1975)}.}

Эта точка зрения может послужить для определения не только
<<высокоуровневых>> объектов данных, таких как рациональные числа, но и
объектов низкого уровня. Рассмотрим понятие пары, с помощью которого мы
определили наши рациональные числа. Мы ведь ни разу не сказали, что
такое пара, и указывали только, что для работы с парами язык дает нам
процедуры @code{cons}, @code{car} и @code{cdr}. Но единственное, что нам
надо знать об этих процедурах --- это что если мы склеиваем два объекта
при помощи @code{cons}, то с помощью @code{car} и @code{cdr} мы можем
получить их обратно. То есть эти операции удовлетворяют условию, что для
любых объектов @code{x} и @code{y}, если @code{z} есть
@code{(cons x y)}, то @code{(car z)} есть @code{x}, а @code{(cdr z)}
есть @code{y}. Действительно, мы упомянули, что три эти процедуры
включены в наш язык как примитивы. Однако любая тройка процедур, которая
удовлетворяет вышеуказанному условию, может использоваться как основа
реализации пар. Эта идея ярко иллюстрируется тем, что мы могли бы
реализовать @code{cons}, @code{car} и @code{cdr} без использования
каких-либо структур данных, а только при помощи одних процедур. Вот эти
определения:

@lisp
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
@end lisp

@noindent
Такое использование процедур совершенно не соответствует нашему
интуитивному понятию о том, как должны выглядеть данные. Однако для
того, чтобы показать, что это законный способ представления пар,
требуется только проверить, что эти процедуры удовлетворяют
вышеуказанному условию.

Тонкость здесь состоит в том, чтобы заметить, что значение, возвращаемое
@code{cons}, есть процедура, --- а именно процедура @code{dispatch},
определенная внутри @code{cons}, которая принимает один аргумент и
возвращает либо @code{x}, либо @code{y} в зависимости от того, равен ли
ее аргумент 0 или 1. Соответственно, @code{(car z)} определяется как
применение @code{z} к 0. Следовательно, если @code{z} есть процедура,
полученная из @code{(cons x y)}, то @code{z}, примененная к 0, вернет
@code{x}. Таким образом, мы показали, что @code{(car (cons x y))}
возвращает @code{x}, как нам и хотелось. Подобным образом
@code{(cdr (cons x y))} применяет процедуру, возвращаемую
@code{(cons x y)}, к 1, что дает нам @code{y}. Следовательно, эта
процедурная реализация пар законна, и если мы обращаемся к парам только
с помощью @code{cons}, @code{car} и @code{cdr}, то мы не сможем отличить
эту реализацию от такой, которая использует <<настоящие>> структуры
данных.

Демонстрировать процедурную реализацию имеет смысл не для того, чтобы
показать, как работает наш язык (Scheme, и вообще Лисп-системы,
реализуют пары напрямую из соображений эффективности), а в том, чтобы
показать, что он мог бы работать и так. Процедурная реализация, хотя она
и выглядит трюком, --- совершенно адекватный способ представления пар,
поскольку она удовлетворяет единственному условию, которому должны
соответствовать пары. Кроме того, этот пример показывает, что
способность работать с процедурами как с объектами автоматически дает
нам возможность представлять составные данные. Сейчас это может
показаться курьезом, но в нашем программистском репертуаре процедурные
представления данных будут играть центральную роль. Такой стиль
программирования часто называют (@newterm{message passing}), и в
главе @ref{Глава 3},
при рассмотрении вопросов моделирования, он будет нашим основным
инструментом.

@quotation
@strong{@anchor{Упражнение 2.4}Упражнение 2.4:}
Вот еще одно процедурное представление для пар. Проверьте для
этого представления, что при любых двух объектах @code{x} и @code{y}
@code{(car (cons x y))} возвращает @code{x}.

@lisp
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
@end lisp

Каково соответствующее определение @code{cdr}? (Подсказка: Чтобы
проверить, что это работает, используйте подстановочную модель из
раздела @ref{1.1.5}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.5}Упражнение 2.5:}
Покажите, что можно представлять пары неотрицательных целых
чисел, используя только числа и арифметические операции, если
представлять пару @math{a} и @math{b} как произведение @math{2^a 3^b}.
Дайте соответствующие определения процедур @code{cons}, @code{car} и
@code{cdr}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.6}Упражнение 2.6:}
Если представление пар как процедур было для Вас еще
недостаточно сумасшедшим, то заметьте, что в языке, который способен
манипулировать процедурами, мы можем обойтись и без чисел (по крайней
мере, пока речь идет о неотрицательных числах), определив 0 и операцию
прибавления 1 так:

@lisp
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
@end lisp

Такое представление известно как (@newterm{Church numerals}), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал
@math{\lambda}-исчисление.

Определите @code{one} (единицу) и @code{two} (двойку) напрямую (не через
@code{zero} и @code{add-1}). (Подсказка: вычислите @code{(add-1 zero)} с
помощью подстановки.) Дайте прямое определение процедуры сложения
@code{+} (не в терминах повторяющегося применения @code{add-1}).
@end quotation

@comment @subsection Extended Exercise: Interval Arithmetic
@subsection Расширенный пример: интервальная арифметика
@node	2.1.4,  , 2.1.3, 2.1

Лиза П. Хакер проектирует систему, которая помогала бы в решении
технических задач. Одна из возможностей, которые она хочет реализовать в
своей системе, --- способность работать с неточными величинами
(например, измеренные параметры физических устройств), обладающими
известной погрешностью, так что когда с такими приблизительными
величинами производятся вычисления, результаты также представляют собой
числа с известной погрешностью.

Инженеры-электрики будут с помощью Лизиной системы вычислять
электрические величины. Иногда им требуется вычислить сопротивление
@math{R_p} параллельного соединения двух резисторов @math{R_1} и
@math{R_2} по формуле
@ifinfo

@example
            1
R_p = -------------
      1/R_1 + 1/R_2
@end example

@end ifinfo
@tex
$$ R_p = {1 \over 1 / R_1 + 1 / R_2}.  $$
@end tex
Обычно
сопротивления резисторов известны только с некоторой точностью, которую
гарантирует их производитель. Например, покупая резистор с надписью
<<6.8 Ом с погрешностью 10%>>, Вы знаете только то, что сопротивление
резистора находится между @math{6.8 - 0.68 = 6.12} и
@math{6.8 + 0.68 = 7.48} Ом. Так что если резистор в 6.8 Ом с
погрешностью 10% подключен параллельно резистору в 4.7 Ом с погрешностью
5%, то сопротивление этой комбинации может быть примерно от 2.58 Ом
(если оба резистора находятся на нижней границе интервала допустимых
значений) до 2.97 Ом (если оба резистора находятся на верхней границе).

Идея Лизы состоит в том, чтобы реализовать <<интервальную арифметику>>
как набор арифметических операций над <<интервалами>> (объектами,
которые представляют диапазоны возможных значений неточной величины).
Результатом сложения, вычитания, умножения или деления двух интервалов
также будет интервал, который представляет диапазон возможных значений
результата.

Лиза постулирует существование абстрактного объекта, называемого
<<интервал>>, у которого есть два конца: верхняя и нижняя границы. Кроме
того, она предполагает, что имея два конца интервала, мы можем
сконструировать его при помощи конструктора @code{make-interval}.
Сначала Лиза пишет процедуру сложения двух интервалов. Она рассуждает
так: минимальное возможное значение суммы равно сумме нижних границ
интервалов, а максимальное возможное значение сумме верхних границ
интервалов.

@lisp
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
@end lisp

@noindent
Кроме того, она вычисляет произведение двух интервалов путем нахождения
минимума и максимума произведений концов интервалов и использования в
качестве границ интервала-результата. (@code{min} и @code{max} ---
примитивы, которые находят минимум и максимум при любом количестве
аргументов.)

@lisp
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
@end lisp

@noindent
При делении двух интервалов Лиза умножает первый из них на интервал,
обратный второму. Заметим, что границами обратного интервала являются
числа, обратные верхней и нижней границе исходного интервала, именно в
таком порядке.

@lisp
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.7}Упражнение 2.7:}
Программа Лизы неполна, поскольку она не определила, как
реализуется абстракция интервала. Вот определение конструктора
интервала:

@lisp
(define (make-interval a b) (cons a b))
@end lisp

Завершите реализацию, определив селекторы @code{upper-bound} и
@code{lower-bound}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.8}Упражнение 2.8:}
Рассуждая в духе Лизы, опишите, как можно вычислить разность
двух интервалов. Напишите соответствующую процедуру вычитания,
называемую @code{sub-interval}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.9}Упражнение 2.9:}
Радиус (@newterm{width}) интервала определяется как половина
расстояния между его верхней и нижней границами. Радиус является мерой
неопределенности числа, которое обозначает интервал. Есть такие
математические операции, для которых радиус результата зависит только от
радиусов интервалов-аргументов, а есть такие, для которых радиус
результата не является функцией радиусов аргументов. Покажите, что
радиус суммы (или разности) двух интервалов зависит только от радиусов
интервалов, которые складываются (или вычитаются). Приведите примеры,
которые показывают, что для умножения или деления это не так.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.10}Упражнение 2.10:}
Бен Битобор, системный программист-эксперт, смотрит через
плечо Лизы и замечает: неясно, что должно означать деление на интервал,
пересекающий ноль. Модифицируйте код Лизы так, чтобы программа проверяла
это условие и сообщала об ошибке, если оно возникает.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.11}Упражнение 2.11:}
Проходя мимо, Бен делает туманное замечание: <<Если
проверять знаки концов интервалов, можно разбить @code{mul-interval} на
девять случаев, из которых только в одном требуется более двух
умножений>>. Перепишите эту процедуру в соответствии с предложением
Бена.

Отладив программу, Лиза показывает ее потенциальному пользователю, а тот
жалуется, что она решает не ту задачу. Ему нужна программа, которая
работала бы с числами, представленными в виде срединного значения и
аддитивной погрешности; например, ему хочется работать с интервалами
вида @math{3.5 \pm 0.15}, а не [3.35, 3.65]. Лиза
возвращается к работе и исправляет этот недочет, добавив дополнительный
конструктор и дополнительные селекторы:

@lisp
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
@end lisp

К сожалению, большая часть Лизиных пользователей --- инженеры. В
реальных технических задачах речь обычно идет об измерениях с небольшой
погрешностью, которая измеряется как отношение радиуса интервала к его
средней точке. Инженеры обычно указывают в параметрах устройств
погрешность в процентах, как в спецификациях резисторов, которые мы
привели в пример выше.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.12}Упражнение 2.12:}
Определите конструктор @code{make-center-percent}, который
принимает среднее значение и погрешность в процентах и выдает требуемый
интервал. Нужно также определить селектор @code{percent}, который для
данного интервала выдает погрешность в процентах. Селектор @code{center}
остается тем же, что приведен выше.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.13}Упражнение 2.13:}
Покажите, что, если предположить, что погрешность
составляет малую долю величины интервала, то погрешность в процентах
произведения двух интервалов можно получить из погрешности в процентах
исходных интервалов по простой приближенной формуле. Задачу можно
упростить, если предположить, что все числа положительные.

После долгой работы Лиза П. Хакер сдает систему пользователям. Несколько
лет спустя, уже забыв об этом, она получает жалобу от разгневанного
пользователя Дайко Поправича. Оказывается, Дайко заметил, что формулу
для параллельных резисторов можно записать двумя алгебраически
эквивалентными способами:
@ifinfo

@example
 R_1 R_2
---------
R_1 + R_2
@end example

@end ifinfo
@tex
$$ R_1 R_2 \over R_1 + R_2 $$
@end tex
@noindent
и
@ifinfo

@example
      1
-------------
1/R_1 + 1/R_2
@end example

@end ifinfo
@tex
$$ {1 \over 1 / R_1 + 1 / R_2}. $$
@end tex
Он написал следующие две программы, каждая из
которых считает формулу для параллельных резисторов своим способом:

@lisp
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
@end lisp

@lisp
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
@end lisp
@sp 0.3

Дайко утверждает, что для двух способов вычисления Лизина программа дает
различные результаты. Это серьезное нарекание.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.14}Упражнение 2.14:}
Покажите, что Дайко прав. Исследуйте поведение системы на
различных арифметических выражениях. Создайте несколько интервалов
@math{A} и @math{B} и вычислите с их помощью выражения @math{A/A} и
@math{A/B}. Наибольшую пользу Вы получите, если будете использовать
интервалы, радиус которых составляет малую часть от среднего значения.
Исследуйте результаты вычислений в форме центр/проценты (см.
упражнение @ref{Упражнение 2.12}).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.15}Упражнение 2.15:}
Ева Лу Атор, другой пользователь Лизиной программы, тоже
заметила, что алгебраически эквивалентные, но различные выражения могут
давать разные результаты. Она говорит, что формула для вычисления
интервалов, которая использует Лизину систему, будет давать более узкие
границы погрешности, если ее удастся записать так, чтобы ни одна
переменная, представляющая неточную величину, не повторялась. Таким
образом, говорит она, @code{par2} <<лучше>> как программа для
параллельных резисторов, чем @code{par1}. Права ли она? Почему?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.16}Упражнение 2.16:}
Объясните в общем случае, почему эквивалентные
алгебраические выражения могут давать разные результаты. Можете ли Вы
представить себе пакет для работы с интервальной арифметикой, который бы
не обладал этим недостатком, или такое невозможно? (Предупреждение: эта
задача очень сложна.)
@end quotation


@comment @section Hierarchical Data and the Closure Property
@section Иерархические данные и свойство замыкания
@node	2.2, 2.3, 2.1, Глава 2

Как мы уже видели, пары служат элементарным <<клеем>>, с помощью
которого можно строить составные объекты данных. На
рис. @ref{Рисунок 2.2} показан стандартный способ рисовать пару --- в
данном случае, пару, которая сформирована выражением @code{(cons 1 2)}.
В этом представлении, которое называется (box-and-pointer notation),
каждый объект изображается в виде (pointer), указывающей на какую-нибудь
ячейку. Ячейка, изображающая элементарный объект, содержит представление
этого объекта. Например, ячейка, соответствующая числу, содержит
числовую константу. Изображение пары состоит из двух ячеек, причем левая
из них содержит (указатель на) @code{car} этой пары, а правая --- ее
@code{cdr}.

Мы уже видели, что @code{cons} способен соединять не только числа, но и
пары. (Вы использовали это свойство, или, по крайней мере, должны были
использовать, когда выполняли @ref{Упражнение 2.2} и
@ref{Упражнение 2.3}). Как следствие этого, пары являются универсальным
материалом, из которого можно строить любые типы структур данных. На
@ref{Рисунок 2.3} показаны два способа соединить числа 1, 2, 3 и 4
при помощи пар.

@float
@quotation
@anchor{Рисунок 2.2}
@ifinfo
@strong{Рисунок 2.2:} Box-and-pointer representation of @code{(cons 1 2)}.

@example
     +---+---+     +---+
---->| * | *-+---->| 2 |
     +-|-+---+     +---+
       |
       V
     +---+
     | 1 |
     +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.2c,34mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.2:} Box-and-pointer representation of @code{(cons 1 2)}.}
@center @caption{@strong{Рисунок 2.2:} Представление @code{(cons 1 2)} в виде стрелочной диаграммы.}
@sp 1
@end iftex
@end quotation
@end float

@float
@quotation
@anchor{Рисунок 2.3}
@ifinfo
@strong{Рисунок 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.

@example
     +---+---+     +---+---+         +---+---+     +---+
---->| * | *-+---->| * | * |    ---->| * | *-+---->| 4 |
     +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
       |             |   |             |
       V             V   V             V
   +---+---+      +---+ +---+      +---+---+     +---+---+
   | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
   +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
     |   |                           |             |   |
     V   V                           V             V   V
  +---+ +---+                      +---+        +---+ +---+
  | 1 | | 2 |                      | 1 |        | 2 | | 3 |
  +---+ +---+                      +---+        +---+ +---+

  (cons (cons 1 2)                 (cons (cons 1
        (cons 3 4))                            (cons 2 3))
                                         4)
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.3c,96mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.}
@center @caption{@strong{Рисунок 2.3:} Два способа соединить 1, 2, 3 и 4 с помощью пар.}
@sp 0.7
@end iftex
@end quotation
@end float

Возможность создавать пары, элементы которых сами являются парами,
определяет значимость списковой структуры как средства представления
данных. Мы называем эту возможность (@newterm{closure property})
для @code{cons}.
В общем случае, операция комбинирования объектов данных обладает
свойством замыкания в том случае, если результаты соединения объектов с
помощью этой операции сами могут соединяться этой же
операцией.@footnote{Такое употребление слова <<замыкание>> происходит из
абстрактной алгебры. Алгебраисты говорят, что множество замкнуто
относительно операции, если применение операции к элементам этого
множества дает результат, который также является элементом множества. К
сожалению, в сообществе программистов, пишущих на Лиспе, словом
<<замыкание>> обозначается еще и совершенно другое понятие: замыканием
называют способ представления процедур, имеющих свободные переменные. В
этом втором смысле мы слово <<замыкание>> в книге не используем.}
Замыкание --- это ключ к выразительной силе для любого средства
комбинирования, поскольку оно позволяет строить (@newterm{hierarchical})
структуры, то есть структуры, которые составлены из частей, которые сами
составлены из частей, и так далее.

С самого начала главы @ref{Глава 1}
мы существенным образом использовали свойство замыкания при работе с
процедурами, поскольку все программы, кроме самых простых, опираются на
то, что элементы комбинации сами могут быть комбинациями. В этом разделе
мы рассмотрим, какое значение замыкание имеет для составных данных. Мы
опишем несколько распространенных методов использования пар для
представления последовательностей и деревьев, а также построим
графический язык, который наглядно иллюстрирует замыкание.@footnote{Идея,
что средство комбинирования должно удовлетворять условию замыкания,
очень проста. К сожалению, такие средства во многих популярных языках
программирования либо не удовлетворяют этому условию, либо делают
использование замыканий неудобным. В Фортране и Бейсике элементы данных
обычно группируются путем создания массивов --- но массивы, элементы
которых сами являются массивами, строить нельзя. Паскаль и Си позволяют
иметь структуры, члены которых являются структурами. Однако при этом
требуется, чтобы программист напрямую работал с указателями и соблюдал
ограничение, по которому каждое поле структуры может содержать только
элементы заранее заданной формы. В отличие от Лиспа с его парами, в этих
языках нет встроенного универсального клея, который позволял бы легко
работать с составными данными единым способом. Это ограничение дало
Алану Перлису повод сказать в предисловии к этой книге: <<В Паскале
обилие объявляемых структур данных ведет к специализации функций,
которая сдерживает и наказывает случайное взаимодействие между ними.
Лучше иметь 100 функций, которые работают с одной структурой данных, чем
10 функций, работающих с 10 структурами>>.}

@menu
* 2-2-1::            Представление последовательностей
* 2-2-2::            Иерархические структуры
* 2-2-3::            Последовательности как стандартные интерфейсы
* 2-2-4::            Пример язык описания изображений
@end menu

@comment @subsection Representing Sequences
@node	2.2.1, 2.2.2, 2.2, 2.2

Одна из полезных структур, которые можно построить с помощью пар ---
это (sequence), то есть упорядоченная совокупность объектов данных.
Разумеется, существует много способов представления последовательностей
при помощи пар. Один, особенно простой, показан на
рисунке @ref{Рисунок 2.4}, где последовательность 1, 2, 3, 4
представлена как цепочка пар. В каждой паре @code{car} --- это
соответствующий член цепочки, а @code{cdr} --- следующая пара цепочки.
@code{Cdr} последней пары указывает на особое значение, не являющееся
парой, которое на диаграммах изображается как диагональная линия, а в
программах как значение переменной @code{nil}. Вся последовательность
порождается несколькими вложенными операциями @code{cons}:

@lisp
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
@end lisp

@float
@quotation
@anchor{Рисунок 2.4}
@ifinfo
@strong{Рисунок 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.

@example
     +---+---+     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+     +-|-+---+
       |             |             |             |
       V             V             V             V
     +---+         +---+         +---+         +---+
     | 1 |         | 2 |         | 3 |         | 4 |
     +---+         +---+         +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.4c,76mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.}
@center @caption{@strong{Рисунок 2.4:} Последовательность 1, 2, 3, 4, представленная в виде цепочки пар.}
@sp 0.8
@end iftex
@end quotation
@end float

Такая последовательность пар, порождаемая вложенными @code{cons}-ами,
называется (@newterm{list}). В Scheme имеется примитив, который называется
@code{ list} и помогает строить списки@footnote{В этой книге термин
всегда означает цепочку пар, которая завершается маркером конца списка.
Напротив, термин (@newterm{list structure}) относится к любой структуре данных,
составленной из пар, а не только к спискам.}. Вышеуказанную
последовательность можно было бы получить с помощью
@code{(list 1 2 3 4)}. В общем случае

@lisp
(list @math{\langle}@var{a}@math{_{\mono{1}}\rangle} @math{\langle}@var{a}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{a}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
эквивалентно

@lisp
(cons @math{\langle}@var{a}@math{_{\mono{1}}\rangle}
      (cons @math{\langle}@var{a}@math{_{\mono{2}}\rangle}
            (cons @dots{}
                  (cons @math{\langle}@var{a}@math{_{\monoit{n}}\rangle}
                        nil)@dots{})))
@end lisp

@noindent
По традиции, Лисп-системы печатают списки в виде последовательности их
элементов, заключенной в скобки. Таким образом, объект данных с
рисунка @ref{Рисунок 2.4} выводится как @code{(1 2 3 4)}:

@lisp
(define one-through-four (list 1 2 3 4))
one-through-four
@i{(1 2 3 4)}
@end lisp

@noindent
Внимание: не путайте выражение @code{(list 1 2 3 4)} со списком
@code{(1 2 3 4)}, который является результатом вычисления этого
выражения. Попытка вычислить выражение @code{(1 2 3 4)} приведет к
сообщению об ошибке, когда интерпретатор попробует применить процедуру 1
к аргументам 2, 3 и 4.

Мы можем считать, что процедура @code{car} выбирает первый элемент из
списка, а @code{cdr} возвращает подсписок, состоящий из всех элементов,
кроме первого. Вложенные применения @code{car} и @code{cdr} могут
выбрать второй, третий и последующие элементы списка.@footnote{Поскольку
записывать вложенные применения @code{car} и @code{cdr} громоздко, в
диалектах Лиспа существуют сокращения --- например,

@lisp
(cadr @math{\langle}@var{arg}@math{\rangle}) = (car (cdr @math{\langle}@var{arg}@math{\rangle}))
@end lisp

У всех таких процедур имена начинаются с @code{c}, а кончаются на
@code{r}. Каждое @code{a} между ними означает операцию @code{car}, а
каждое @code{d} операцию @code{cdr}, и они применяются в том же порядке,
в каком идут внутри имени. Имена @code{car} и @code{cdr} сохраняются,
поскольку простые их комбинации вроде @code{cadr} нетрудно произнести.}
Конструктор @code{cons} порождает список, подобный исходному, но с
дополнительным элементом в начале.

@lisp
(car one-through-four)
@i{1}
(cdr one-through-four)
@i{(2 3 4)}
(car (cdr one-through-four))
@i{2}
(cons 10 one-through-four)
@i{(10 1 2 3 4)}
(cons 5 one-through-four)
@i{(5 1 2 3 4)}
@end lisp

@noindent
Значение @code{nil}, которым завершается цепочка пар, можно
рассматривать как последовательность без элементов, (@newterm{empty list}). Слово
(@newterm{nil}) произошло от стяжения латинского @emph{nihil}, что значит
<<ничто>>.@footnote{Удивительно, сколько энергии при стандартизации
диалектов Лиспа было потрачено на споры буквально ни о чем: должно ли
слово @code{nil} быть обычным именем? Должно ли значение @code{nil}
являться символом? Должно ли оно являться списком? Парой? В Scheme
@code{nil} --- обычное имя, и в этом разделе мы используем его как
переменную, значение которой --- маркер конца списка (так же, как
@code{true} --- это обычная переменная, значение которой истина).
Другие диалекты Лиспа, включая Common Lisp, рассматривают @code{nil} как
специальный символ. Авторы этой книги пережили слишком много скандалов
со стандартизацией языков и хотели бы не возвращаться к этим вопросам.
Как только в разделе @ref{1.3} мы введем кавычку, мы
станем обозначать пустой список в виде @code{'()}, а от переменной
@code{nil} полностью избавимся.}

@comment @subsubheading List operations
@subsubheading Операции со списками

Использованию пар для представления последовательностей элементов в виде
списков сопутствуют общепринятые методы программирования, которые,
работая со списками, последовательно их <<у@code{cdr}ивают>>. Например,
процедура @code{list-ref} берет в качестве аргументов список и число
@math{n} и возвращает @math{n}-й элемент списка. Обычно элементы списка
нумеруют, начиная с 0. Метод вычисления @code{list-ref} следующий:

@itemize @bullet

@item
Если @math{n = 0}, @code{list-ref} должна вернуть @code{car} списка.

@item
В остальных случаях @code{list-ref} должна вернуть @math{(n - 1)}-й
элемент от @code{cdr} списка.

@end itemize

@lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
@i{16}
@end lisp

@noindent
Часто мы про@code{cdr}иваем весь список. Чтобы помочь нам с этим, Scheme
включает элементарную процедуру , которая определяет, является ли ее
аргумент пустым списком. Процедура , которая возвращает число элементов
в списке, иллюстрирует эту характерную схему использования операций над
списками:

@lisp
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))
(length odds)
@i{4}
@end lisp

@noindent
Процедура @code{length} реализует простую рекурсивную схему. Шаг
редукции таков:

@itemize @bullet

@item
Длина любого списка равняется 1 плюс длина @code{cdr} этого списка

@end itemize

@noindent
Этот шаг последовательно применяется, пока мы не достигнем базового
случая:

@itemize @bullet

@item
Длина пустого списка равна 0.

@end itemize

@noindent
Мы можем вычислить @code{length} и в итеративном стиле:

@lisp
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
@end lisp

@noindent
Еще один распространенный программистский прием состоит в том, чтобы
<<с@code{cons}ить>> результат по ходу у@code{cdr}ивания списка, как это
делает процедура @code{append}, которая берет в качестве аргументов два
списка и составляет из их элементов один общий список:

@lisp
(append squares odds)
@i{(1 4 9 16 25 1 3 5 7)}
(append odds squares)
@i{(1 3 5 7 1 4 9 16 25)}
@end lisp

@noindent
@code{append} также реализуется по рекурсивной схеме. Чтобы соединить
списки @code{list1} и @code{list2}, нужно сделать следующее:

@itemize @bullet

@item
Если список @code{list1} пуст, то результатом является просто
@code{list2}.

@item
В противном случае, нужно соединить @code{cdr} от @code{list1} с
@code{list2}, а к результату прибавить @code{car} от @code{list1} с
помощью @code{cons}:

@end itemize

@lisp
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.17}Упражнение 2.17:}
Определите процедуру @code{last-pair}, которая возвращает
список, содержащий только последний элемент данного (непустого) списка.

@lisp
(last-pair (list 23 72 149 34))
@i{(34)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.18}Упражнение 2.18:}
Определите процедуру @code{reverse}, которая принимает
список как аргумент и возвращает список, состоящий из тех же элементов в
обратном порядке:

@lisp
(reverse (list 1 4 9 16 25))
@i{(25 16 9 4 1)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.19}Упражнение 2.19:}
Рассмотрим программу подсчета способов размена из
раздела @ref{1.2.2}. Было бы приятно иметь
возможность легко изменять валюту, которую эта программа использует,
так, чтобы можно было, например, вычислить, сколькими способами можно
разменять британский фунт. Эта программа написана так, что знание о
валюте распределено между процедурами @code{first-denomination} и
@code{count-change} (которая знает, что существует пять видов
американских монет). Приятнее было бы иметь возможность просто задавать
список монет, которые можно использовать при размене.

Мы хотим переписать процедуру @code{cc} так, чтобы ее вторым аргументом
был список монет, а не целое число, которое указывает, какие монеты
использовать. Тогда у нас могли бы быть списки, определяющие типы валют:

@lisp
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
@end lisp

Можно было бы вызывать @code{cc} следующим образом:

@lisp
(cc 100 us-coins)
@i{292}
@end lisp

Это потребует некоторых изменений в программе @code{cc}. Ее форма
останется прежней, но со вторым аргументом она будет работать иначе, вот
так:

@lisp
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
@end lisp

Определите процедуры @code{first-denomination},
@code{no-more?} и @code{except-first-denomination} в терминах
элементарных операций над списковыми структурами. Влияет ли порядок
списка @code{coin-values} на результат, получаемый @code{cc}? Почему?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.20}Упражнение 2.20:}
Процедуры @code{+}, @code{*} и @code{list} принимают
произвольное число аргументов. Один из способов определения таких
процедур состоит в использовании (@newterm{dotted-tail notation}). В определении
процедуры список параметров с точкой перед именем последнего члена
означает, что, когда процедура вызывается, начальные параметры (если они
есть) будут иметь в качестве значений начальные аргументы, как и обычно,
но значением последнего параметра будет @emph{список} (@newterm{list}) всех оставшихся
аргументов. Например, если дано определение

@lisp
(define (f x y . z) @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
то процедуру @code{f} можно вызывать с двумя и более аргументами. Если
мы вычисляем

@lisp
(f 1 2 3 4 5 6)
@end lisp

@noindent
то в теле @code{f} переменная @code{x} будет равна 1, @code{y} будет
равно 2, а @code{z} будет списком (3 4 5 6). Если дано определение

@lisp
(define (g . w) @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
то процедура @code{g} может вызываться с нулем и более аргументов. Если
мы вычислим

@lisp
(g 1 2 3 4 5 6)
@end lisp

@noindent
то в теле @code{g} значением переменной @code{w} будет список
@code{(1 2 3 4 5 6)}.@footnote{Для того, чтобы определить @code{f} и
@code{g} при помощи @code{lambda}, надо было бы написать

@lisp
(define f (lambda (x y . z) @math{\langle}@var{тело}@math{\rangle}))
(define g (lambda w @math{\langle}@var{тело}@math{\rangle}))
@end lisp
}

Используя эту нотацию, напишите процедуру @code{same-parity}, которая
принимает одно или несколько целых чисел и возвращает список всех тех
аргументов, у которых четность та же, что у первого аргумента. Например,

@lisp
(same-parity 1 2 3 4 5 6 7)
@i{(1 3 5 7)}
(same-parity 2 3 4 5 6 7)
@i{(2 4 6)}
@end lisp
@end quotation

@comment @subsubheading Mapping over lists
@subsubheading Отображение списков

Крайне полезной операцией является применение какого-либо преобразования
к каждому элементу списка и порождение списка результатов. Например,
следующая процедура умножает каждый элемент списка на заданное число.

@lisp
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items)
                        factor))))
(scale-list (list 1 2 3 4 5) 10)
@i{(10 20 30 40 50)}
@end lisp

@noindent
Мы можем выделить здесь общую идею и зафиксировать ее как схему,
выраженную в виде процедуры высшего порядка, в точности как в
разделе @ref{1.3}.
Здесь эта процедура высшего порядка называется @code{map}. @code{map}
берет в качестве аргументов процедуру от одного аргумента и список, а
возвращает список результатов, полученных применением процедуры к
каждому элементу списка:@footnote{@anchor{Сноска 2.12} Стандартная Scheme содержит
более общую процедуру @code{map}, чем описанная здесь. Этот вариант
@code{map} принимает процедуру от @math{n} аргументов и @math{n} списков
и применяет процедуру ко всем первым элементам списков, всем вторым
элементам списков и так далее. Возвращается список результатов.
Например:

@lisp
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
@i{(741 852 963)}
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
@i{(9 12 15)}
@end lisp
}

@lisp
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
@i{(10 2.5 11.6 17)}
(map (lambda (x) (* x x)) (list 1 2 3 4))
@i{(1 4 9 16)}
@end lisp

@noindent
Теперь мы можем дать новое определение @code{scale-list} через
@code{map}:

@lisp
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
@end lisp

@noindent
@code{map} является важным конструктом, не только потому, что она
фиксирует общую схему, но и потому, что она повышает уровень абстракции
при работе со списками. В исходном определении @code{scale-list}
рекурсивная структура программы привлекает внимание к поэлементной
обработке списка. Определение @code{scale-list} через @code{map}
устраняет этот уровень деталей и подчеркивает, что умножение преобразует
список элементов в список результатов. Разница между этими двумя
определениями состоит не в том, что компьютер выполняет другой процесс
(это не так), а в том, что мы думаем об этом процессе по-другому. В
сущности, @code{map} помогает установить барьер абстракции, который
отделяет реализацию процедур, преобразующих списки, от деталей того, как
выбираются и комбинируются элементы списков. Подобно барьерам на
рисунке @ref{Рисунок 2.1}, эта абстракция позволяет нам свободно
изменять низкоуровневые детали того, как реализованы списки, сохраняя
концептуальную схему с операциями, переводящими одни последовательности
в другие. В разделе @ref{2.2.3}
такое использование последовательностей как способ организации программ
рассматривается более подробно.

@quotation
@strong{@anchor{Упражнение 2.21}Упражнение 2.21:}
Процедура @code{square-list} принимает в качестве аргумента
список чисел и возвращает список квадратов этих чисел.

@lisp
(square-list (list 1 2 3 4))
@i{(1 4 9 16)}
@end lisp

Перед Вами два различных определения @code{square-list}. Закончите их,
вставив пропущенные выражения:

@lisp
(define (square-list items)
  (if (null? items)
      nil
      (cons @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
(define (square-list items)
  (map @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle}))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.22}Упражнение 2.22:}
LХьюго Дум пытается переписать первую из процедур
@code{square-list} из упражнения @ref{Упражнение 2.21} так, чтобы она
работала как итеративный процесс:

@lisp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
@end lisp

К сожалению, такое определение @code{square-list} выдает список
результатов в порядке, обратном желаемому. Почему?

Затем Хьюго пытается исправить ошибку, обменяв аргументы @code{cons}:

@lisp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
@end lisp

И так программа тоже не работает. Объясните это.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.23}Упражнение 2.23:}
Процедура @code{for-each} похожа на @code{map}. В качестве
аргументов она принимает процедуру и список элементов. Однако вместо
того, чтобы формировать список результатов, @code{for-each} просто
применяет процедуру по очереди ко всем элементам слева направо.
Результаты применения процедуры к аргументам не используются вообще ---
@code{for-each} применяют к процедурам, которые осуществляют какое-либо
действие вроде печати. Например,

@lisp
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
@i{57}
@i{321}
@i{88}
@end lisp

Значение, возвращаемое вызовом @code{for-each} (оно в листинге не
показано) может быть каким угодно, например истина. Напишите реализацию
@code{for-each}.
@end quotation

@endpage
@comment @subsection Hierarchical Structures
@subsection Иерархические структуры
@node	2.2.2, 2.2.3, 2.2.1, 2.2

Представление последовательностей в виде списков естественно
распространить на последовательности, элементы которых сами могут быть
последовательностями. Например, мы можем рассматривать объект
@code{((1 2) 3 4)}, получаемый с помощью

@lisp
(cons (list 1 2) (list 3 4))
@end lisp

@noindent
как список с тремя членами, первый из которых сам является списком. В
сущности, это подсказывается формой, в которой результат печатается
интерпретатором. Рисунок @ref{Рисунок 2.5} показывает представление
этой структуры в терминах пар.

@float
@quotation
@anchor{Рисунок 2.5}
@ifinfo
@strong{Рисунок 2.5:} Structure formed by @code{(cons (list 1 2) (list 3 4))}.

@example
                                          (3 4)
                                            |
                                            V
((1 2) 3 4)  +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +-|-+---+                  +-|-+---+     +-|-+---+
               |                          |             |
               V                          V             V
      (1 2)  +---+---+     +---+---+    +---+         +---+
        ---->| * | *-+---->| * | / |    | 3 |         | 4 |
             +-|-+---+     +-|-+---+    +---+         +---+
               |             |
               V             V
             +---+         +---+
             | 1 |         | 2 |
             +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.5c,91mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.5:} Structure formed by @code{(cons (list 1 2) (list 3 4))}.}
@center @caption{@strong{Рисунок 2.5:} Структура, формируемая @code{(cons (list 1 2) (list 3 4))}}
@sp 0.7
@end iftex
@end quotation
@end float

Еще один способ думать о последовательностях последовательностей ---
(@newterm{trees}). Элементы последовательности являются ветвями дерева, а
элементы, которые сами по себе последовательности --- поддеревьями.
Рисунок @ref{Рисунок 2.6} показывает структуру, изображенную на рис.
@ref{Рисунок 2.5}, в виде дерева.

@float
@quotation
@anchor{Рисунок 2.6}
@ifinfo
@strong{Рисунок 2.6:} The list structure in @ref{Рисунок 2.5} viewed as a tree.

@example
 ((1 2) 3 4)
     /\\
    /  | \
(1 2)  3 4
 / \
 1 2
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.6a,22mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.6:} The list structure in @ref{Рисунок 2.5} viewed as a tree.}
@center @caption{@strong{Рисунок 2.6:} Списковая структура с рис. @ref{Рисунок 2.5}, рассматриваемая как дерево.}
@sp 0.0
@end iftex
@end quotation
@end float

Естественным инструментом для работы с деревьями является рекурсия,
поскольку часто можно свести операции над деревьями к операциям над их
ветвями, которые сами сводятся к операциям над ветвями ветвей, и так
далее, пока мы не достигнем листьев дерева. Например, сравним процедуру
@code{length} из раздела @ref{2.2.1} с
процедурой @code{count-leaves}, которая подсчитывает число листьев
дерева:

@lisp
(define x (cons (list 1 2) (list 3 4)))
(length x)
@i{3}
(count-leaves x)
@i{4}
(list x x)
@i{(((1 2) 3 4) ((1 2) 3 4))}
(length (list x x))
@i{2}
(count-leaves (list x x))
@i{8}
@end lisp

@noindent
Чтобы реализовать @code{count-leaves}, вспомним рекурсивную схему
вычисления @code{length}:

@itemize @bullet

@item
Длина списка @code{x} есть 1 плюс длина @code{cdr} от @code{x}.

@item
Длина пустого списка есть 0.

@end itemize

@noindent
@code{count-leaves} очень похожа на эту схему. Значение для пустого
списка остается тем же:

@itemize @bullet

@item
@code{count-leaves} от пустого списка равна 0.

@end itemize

@noindent
Однако в шаге редукции, когда мы выделяем @code{car} списка, нам нужно
учесть, что @code{car} сам по себе может быть деревом, листья которого
нам требуется сосчитать. Таким образом, шаг редукции таков:

@itemize @bullet

@item
@code{count-leaves} от дерева @code{x} есть @code{count-leaves} от
@code{(car x)} плюс @code{count-leaves} от @code{(cdr x)}.

@end itemize

@noindent
Наконец, вычисляя @code{car}-ы, мы достигаем листьев, так что нам
требуется еще один базовый случай:

@itemize @bullet

@item
@code{count-leaves} от листа равна 1.

@end itemize

@noindent
Писать рекурсивные процедуры над деревьями в Scheme помогает
элементарный предикат @code{pair?}, который проверяет, является ли его
аргумент парой. Вот процедура целиком:@footnote{Порядок первых двух
ветвей существен, поскольку пустой список удовлетворяет предикату
@code{null?} и при этом не является парой.}

@lisp
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.24}Упражнение 2.24:}
Предположим, мы вычисляем выражение
@code{(list 1 (list 2 (list 3 4)))}. Укажите, какой результат напечатает
интерпретатор, изобразите его в виде стрелочной диаграммы, а также его
интерпретацию в виде дерева (как на рисунке @ref{Рисунок 2.6}).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.25}Упражнение 2.25:}
Укажите комбинации @code{car} и @code{cdr}, которые
извлекают 7 из следующих списков:

@lisp
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.26}Упражнение 2.26:}
Допустим, мы определили @code{x} и @code{y} как два списка:

@lisp
(define x (list 1 2 3))
(define y (list 4 5 6))
@end lisp

Какой результат напечатает интерпретатор в ответ на следующие выражения:

@lisp
(append x y)
(cons x y)
(list x y)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.27}Упражнение 2.27:}
Измените свою процедуру @code{reverse} из
упражнения @ref{Упражнение 2.18} так, чтобы получилась процедура
@code{deep-reverse}, которая принимает список в качестве аргумента и
возвращает в качестве значения список, где порядок элементов обратный и
подсписки также обращены. Например:

@lisp
(define x (list (list 1 2) (list 3 4)))
x
@i{((1 2) (3 4))}
(reverse x)
@i{((3 4) (1 2))}
(deep-reverse x)
@i{((4 3) (2 1))}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.28}Упражнение 2.28:}
Напишите процедуру @code{fringe}, которая берет в качестве
аргумента дерево (представленное в виде списка) и возвращает список,
элементы которого --- все листья дерева, упорядоченные слева направо.
Например,

@lisp
(define x (list (list 1 2) (list 3 4)))
(fringe x)
@i{(1 2 3 4)}
(fringe (list x x))
@i{(1 2 3 4 1 2 3 4)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.29}Упражнение 2.29:}
Бинарный мобиль состоит из двух ветвей, левой и правой.
Каждая ветвь представляет собой стержень определенной длины, с которого
свисает либо гирька, либо еще один бинарный мобиль. Мы можем представить
бинарный мобиль в виде составных данных, соединив две ветви (например, с
помощью @code{list}):

@lisp
(define (make-mobile left right)
  (list left right))
@end lisp

Ветвь составляется из длины @code{length} (которая должна быть числом) и
структуры @code{structure}, которая может быть либо числом
(представляющим простую гирьку), либо еще одним мобилем:

@lisp
(define (make-branch length structure)
  (list length structure))
@end lisp

@enumerate a.

@item
Напишите соответствующие селекторы @code{left-branch} и
@code{right-branch}, которые возвращают левую и правую ветви мобиля, а
также @code{branch-length} и @code{branch-structure}, которые возвращают
компоненты ветви.

@item
С помощью этих селекторов напишите процедуру @code{total-weight},
которая возвращает общий вес мобиля.

@item
Говорят, что мобиль @emph{сбалансирован} (@newterm{balanced}), если момент вращения,
действующий на его левую ветвь, равен моменту вращения, действующему на
правую ветвь (то есть длина левого стержня, умноженная на вес груза,
свисающего с него, равна соответствующему произведению для правой
стороны), и если все подмобили, свисающие с его ветвей, также
сбалансированы. Напишите предикат, который проверяет мобили на
сбалансированность.

@item
Допустим, мы изменили представление мобилей, так что конструкторы теперь
приняли такой вид:

@lisp
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
@end lisp

Как много Вам нужно изменить в программах, чтобы перейти на новое
представление?

@end enumerate
@end quotation

@comment @subsubheading Mapping over trees
@subsubheading Отображение деревьев

Подобно тому, как @code{map} может служить мощной абстракцией для работы
с последовательностями, @code{map}, совмещенная с рекурсией, служит
мощной абстракцией для работы с деревьями. Например, процедура
@code{scale-tree}, аналогичная процедуре @code{scale-list} из
раздела @ref{2.2.1}, принимает в качестве
аргумента числовой множитель и дерево, листьями которого являются числа.
Она возвращает дерево той же формы, где каждое число умножено на
множитель. Рекурсивная схема @code{scale-tree} похожа на схему
@code{count-leaves}:

@lisp
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
@i{(10 (20 (30 40) 50) (60 70))}
@end lisp

@noindent
Другой способ реализации @code{scale-tree} состоит в том, чтобы
рассматривать дерево как последовательность поддеревьев и использовать
@code{map}. Мы отображаем последовательность, масштабируя по очереди
каждое поддерево, и возвращаем список результатов. В базовом случае,
когда дерево является листом, мы просто умножаем:

@lisp
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
@end lisp

@noindent
Многие операции над деревьями могут быть реализованы с помощью такого
сочетания операций над последовательностями и рекурсии.

@quotation
@strong{@anchor{Упражнение 2.30}Упражнение 2.30:}
Определите процедуру @code{square-@/tree}, подобную процедуре
@code{square-list} из упражнения @ref{Упражнение 2.21}. А именно,
@code{square-tree} должна вести себя следующим образом:

@lisp
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
@i{(1 (4 (9 16) 25) (36 49))}
@end lisp

Определите @code{square-tree} как прямо (то есть без использования
процедур высших порядков), так и с помощью @code{map} и рекурсии.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.31}Упражнение 2.31:}
Абстрагируйте свой ответ на
упражнение @ref{Упражнение 2.30}, получая процедуру , так, чтобы
@code{square-tree} можно было определить следующим образом:

@lisp
(define (square-tree tree) (tree-map square tree))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.32}Упражнение 2.32:}
Множество можно представить как список его различных
элементов, а множество его подмножеств как список списков. Например,
если множество равно @code{(1 2 3)}, то множество его подмножеств равно
@code{(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))}. Закончите следующее
определение процедуры, которая порождает множество подмножеств и дайте
ясное объяснение, почему она работает:

@lisp
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map @math{\langle}??@math{\rangle} rest)))))
@end lisp
@end quotation

@comment @subsection Sequences as Conventional Interfaces
@subsection Последовательности как стандартные интерфейсы
@node	2.2.3, 2.2.4, 2.2.2, 2.2

При работе с составными данными мы подчеркивали, что абстракция
позволяет проектировать программы, не увязая в деталях представления
данных, и оставляет возможность экспериментировать с различными
способами представления. В этом разделе мы представляем еще один мощный
принцип проектирования для работы со структурами данных ---
использование (@newterm{conventional interfaces}).

В разделе @ref{1.3}
мы видели, как абстракции, реализованные в виде процедур высших
порядков, способны выразить общие схемы программ, которые работают с
числовыми данными. Наша способность формулировать подобные операции с
составными данными существенным образом зависит от того, в каком стиле
мы манипулируем своими структурами данных. Например, рассмотрим
следующую процедуру, аналогичную @code{count-leaves} из
раздела @ref{2.2.2}. Она принимает в качестве
аргумента дерево и вычисляет сумму квадратов тех из его листьев, которые
являются нечетными числами:

@lisp
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
@end lisp

@noindent
При поверхностном взгляде кажется, что эта процедура очень сильно
отличается от следующей, которая строит список всех четных чисел
Фибоначчи @math{{\rm Fib}(k)}, где @math{k} меньше или равно
данного целого числа @math{n}:

@lisp
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
@end lisp

@noindent
Несмотря на то, что структурно эти процедуры весьма различны, более
абстрактное описание двух процессов вычисления раскрывает немалую долю
сходства. Первая программа

@itemize @bullet

@item
перечисляет листья дерева;

@item
просеивает их, отбирая нечетные;

@item
возводит в квадрат каждое из отобранных чисел; и

@item
накапливает результаты при помощи @code{+}, начиная с 0.

@end itemize

@noindent
Вторая программа

@itemize @bullet

@item
перечисляет числа от 1 до @math{n};

@item
вычисляет для каждого из них число Фибоначчи;

@item
просеивает их, выбирая нечетные; и

@item
собирает их с помощью @code{cons}, начиная с пустого списка.

@end itemize

@float
@anchor{Рисунок 2.7}
@ifinfo
@quotation
@strong{Рисунок 2.7:} The signal-flow plans for the
procedures @code{sum-odd-squares} (top) and @code{even-fibs} (bottom) reveal
the commonality between the two programs.

@example
+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
| tree leaves |   | odd?        |   | square      |   | +, 0        |
+-------------+   +-------------+   +-------------+   +-------------+

+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
| integers    |   | fib         |   | even?       |   | cons, ()    |
+-------------+   +-------------+   +-------------+   +-------------+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap2/Fig2.7d,111mm,,,.pdf}
@c 187mm
@sp 0.4
@quotation
@comment @caption{@strong{Рисунок 2.7:} The signal-flow plans for the procedures @code{sum-@/odd-@/squares} (top) and @code{even-fibs} (bottom) reveal the commonality between the two programs.}
@center @caption{@strong{Рисунок 2.7:} Диаграммы потока сигналов для процедур @code{sum-odd-squares} (сверху) и @code{even-fibs} (снизу) раскрывают схожесть этих двух программ.}
@end quotation
@sp 0.7
@end iftex
@end float

@noindent
Специалисту по обработке сигналов покажется естественным выразить эти
процессы в терминах сигналов, проходящих через ряд стадий, каждая из
которых реализует часть плана программы, как это показано на
рисунке @ref{Рисунок 2.7}. В процедуре @code{sum-odd-squares} мы
начинаем с (@newterm{enumerator}), который порождает <<сигнал>>, состоящий из
листьев данного дерева. Этот сигнал пропускается через (@newterm{filter}), который
удаляет все элементы, кроме нечетных. Получившийся после этого сигнал, в
свою очередь, проходит (@newterm{map}), которое представляет собой
<<преобразователь>>, применяющий к каждому элементу процедуру
@code{square}. Наконец, выход отображения идет в (@newterm{accumulator}), который
собирает элементы при помощи @code{+}, начиная с 0. Для @code{even-fibs}
план аналогичен.

К сожалению, два определения процедур, приведенные выше, не отражают эту
структуру потока сигналов. Например, если мы рассмотрим
@code{sum-oddsquares}, мы обнаружим, что перечисление отчасти
реализуется проверками @code{null?} и @code{pair?}, а отчасти
древовидно-рекурсивной структурой процедуры. Подобным образом,
накопление отчасти происходит в проверках, а отчасти в сложении, которое
выполняется при рекурсивном вызове. Вообще, никакая отдельная часть этих
процедур не соответствует элементу потоковой диаграммы. Наши две
процедуры дробят вычисление другим образом, раскидывая перечисление по
программе и смешивая его с отображением, просеиванием и накоплением.
Если бы мы смогли организовать свои программы так, чтобы структура
обработки потока сигналов была ясно видна в написанных нами процедурах,
то это сделало бы смысл получаемого кода более прозрачным.

@comment @subsubheading Sequence Operations
@subsubheading Операции над последовательностями

Итак, наши программы должны яснее отражать структуру потока сигналов.
Ключевым моментом здесь будет перенос внимания на <<сигналы>>, которые
передаются от одной стадии процесса к другой. Если мы представим эти
сигналы в виде списков, то сможем использовать операции над списками,
чтобы реализовать обработку на каждом этапе. Например, мы можем
реализовать стадии отображения из диаграмм потоков сигналов с помощью
процедуры @code{map} из раздела @ref{2.2.1}:

@lisp
(map square (list 1 2 3 4 5))
@i{(1 4 9 16 25)}
@end lisp

@noindent
Просеивание последовательности, выбирающее только те элементы, которые
удовлетворяют данному предикату, осуществляется при помощи

@lisp
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
@end lisp

@noindent
Например,

@lisp
(filter odd? (list 1 2 3 4 5))
@i{(1 3 5)}
@end lisp

@noindent
Накопление осуществляется посредством

@lisp
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
@i{15}
(accumulate * 1 (list 1 2 3 4 5))
@i{120}
(accumulate cons nil (list 1 2 3 4 5))
@i{(1 2 3 4 5)}
@end lisp

@noindent
Чтобы реализовать диаграммы потока сигналов, нам остается только
перечислить последовательности элементов, с которыми мы будем работать.
Для @code{even-fibs} нужно породить последовательность целых чисел в
заданном диапазоне. Это можно сделать так:

@lisp
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
@i{(2 3 4 5 6 7)}
@end lisp

@noindent
Чтобы перечислить листья дерева, можно использовать такую
процедуру:@footnote{Это в точности процедура @code{fringe} из
упражнения @ref{Упражнение 2.28}. Здесь мы ее переименовали, чтобы
подчеркнуть, что она входит в семейство общих процедур обработки
последовательностей.}

@lisp
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
@i{(1 2 3 4 5)}
@end lisp

@noindent
Теперь мы можем переформулировать @code{sum-odd-squares} и
@code{even-fibs} соответственно тому, как они изображены на диаграммах
потока сигналов. В случае @code{sum-odd-squares} мы вычисляем
последовательность листьев дерева, фильтруем ее, оставляя только
нечетные числа, возводим каждый элемент в квадрат и суммируем
результаты:

@lisp
(define (sum-odd-squares tree)
  (accumulate
   + 0 (map square (filter odd? (enumerate-tree tree)))))
@end lisp

@noindent
В случае с @code{even-fibs} мы перечисляем числа от 0 до @math{n},
порождаем для каждого из них число Фибоначчи, фильтруем получаемую
последовательность, оставляя только четные элементы, и собираем
результаты в список:

@lisp
(define (even-fibs n)
  (accumulate
   cons
   nil
   (filter even? (map fib (enumerate-interval 0 n)))))
@end lisp

@noindent
Польза от выражения программ в виде операций над последовательностями
состоит в том, что эта стратегия помогает нам строить модульные проекты
программ, то есть проекты, которые получаются путем сборки из
относительно независимых частей. Можно поощрять модульное
проектирование, давая разработчику набор стандартных компонент и
унифицированный интерфейс, предназначенный для гибкого соединения этих
компонентов.

Модульное построение является мощной стратегией управления сложностью в
инженерном проектировании. Например, в реальных приложениях по обработке
сигналов проектировщики обычно строят системы путем каскадирования
элементов, которые выбираются из стандартизованных семейств фильтров и
преобразователей. Подобным образом операции над последовательностями
составляют библиотеку стандартных элементов, которые мы можем связывать
и смешивать. К примеру, можно составить куски из процедур
@code{sum-odd-squares} и @code{even-fibs} и получить программу, которая
строит список квадратов первых @code{n+1} чисел Фибоначчи:

@lisp
(define (list-fib-squares n)
  (accumulate
   cons
   nil
   (map square (map fib (enumerate-interval 0 n)))))
(list-fib-squares 10)
@i{(0 1 1 4 9 25 64 169 441 1156 3025)}
@end lisp

@noindent
Можно переставить куски и использовать их, чтобы вычислить произведение
квадратов нечетных чисел в последовательности:

@lisp
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
@i{225}
@end lisp

@noindent
Часто встречающиеся приложения по обработке данных можно также
формулировать в терминах операций над последовательностями. Допустим, у
нас есть последовательность записей о служащих, и нам требуется найти
зарплату самого высокооплачиваемого программиста. Пусть у нас будет
селектор @code{salary}, который возвращает зарплату служащего, и
предикат @code{programmer?}, который проверяет, относится ли запись к
программисту. Тогда мы можем написать:

@lisp
(define (salary-of-highest-paid-programmer records)
  (accumulate max 0 (map salary (filter programmer? records))))
@end lisp

@noindent
Все эти примеры дают лишь слабое представление об огромной области
задач, выразимых в виде операций над
последовательностями.@footnote{Ричард Уотерс @ref{Waters (1979)} разработал
программу, которая анализирует традиционные программы на Фортране,
представляя их в терминах отображений, фильтров и накоплений. Он
обнаружил, что 90 процентов кода в Пакете Научных Подпрограмм на
Фортране хорошо укладывается в эту парадигму. Одна из причин успеха
Лиспа как языка программирования заключается в том, что списки дают
стандартное средство представления упорядоченных множеств, с которыми
можно работать при помощи процедур высших порядков. Язык
программирования APL своей мощности и красоте во многом обязан подобному
же выбору. В APL все данные выражаются как массивы, и существует
универсальный и удобный набор общих операторов для всевозможных действий
над массивами.}

Последовательности, здесь реализованные в виде списков, служат
стандартным интерфейсом, который позволяет комбинировать обрабатывающие
модули. Кроме того, если мы представляем все структуры единым образом
как последовательности, то нам удается локализовать зависимость структур
данных в своих программах в небольшом наборе операций с
последовательностями. Изменяя эти последние, мы можем экспериментировать
с различными способами представления последовательностей, оставляя
неприкосновенной общую структуру своих программ. Этой возможностью мы
воспользуемся в разделе @ref{3.5}, когда обобщим
парадигму обработки последовательностей и введем бесконечные
последовательности.

@quotation
@strong{@anchor{Упражнение 2.33}Упражнение 2.33:}
Заполните пропущенные выражения, так, чтобы получились
определения некоторых базовых операций по работе со списками в виде
накопления:

@lisp
(define (map p sequence)
  (accumulate (lambda (x y) @math{\langle}??@math{\rangle}) nil sequence))
(define (append seq1 seq2)
  (accumulate cons @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle}))
(define (length sequence)
  (accumulate @math{\langle}??@math{\rangle} 0 sequence))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.34}Упражнение 2.34:}
Вычисление многочлена с переменной @math{x} при данном
значении @math{x} можно сформулировать в виде накопления. Мы вычисляем
многочлен
@ifinfo

@example
a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0
@end example

@end ifinfo
@tex
$$ a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0 $$
@end tex
@noindent
по известному алгоритму, называемому (@newterm{Horner's rule}), которое переписывает
формулу в виде
@ifinfo

@example
(... (a_n x + a_(n-1)) x + ... + a_1) x + a_0
@end example

@end ifinfo
@tex
$$ (\dots (a_n x + a_{n-1}) x + \dots + a_1) x + a_0. $$
@end tex
@noindent
Другими словами, мы начинаем с @math{a_n}, умножаем его на @math{x},
@math{a_{n-1}}, умножаем его на @math{x}, и так далее, пока не достигнем
@math{a_0}.@footnote{Согласно Кнуту @ref{Knuth 1981}, это правило было
сформулировано У. Г. Горнером в начале
девятнадцатого века, но на самом деле его использовал Ньютон более чем
на сто лет раньше. По схеме Горнера многочлен вычисляется с помощью
меньшего количества сложений и умножений, чем при прямолинейном способе:
вычислить сначала @math{a^n x^n}, затем добавить @math{a_{n-1} x^{n-1}}
и так далее. На самом деле можно доказать, что любой алгоритм для
вычисления произвольных многочленов будет использовать по крайней мере
столько сложений и умножений, сколько схема Горнера, и, таким образом,
схема Горнера является оптимальным алгоритмом для вычисления
многочленов. Это было доказано (для числа сложений) А. М. Островским в
статье 1954 года, которая по существу заложила основы современной науки
об оптимальных алгоритмах. Аналогичное утверждение для числа умножений
доказал В. Я. Пан в 1966 году. Книга Бородина и Мунро @ref{Borodin and
Munro (1975)} дает обзор этих результатов, а также других достижений в области
оптимальных алгоритмов.}

Заполните пропуски в следующей заготовке так,
чтобы получить процедуру, которая вычисляет многочлены по схеме Горнера.
Предполагается, что коэффициенты многочлена представлены в виде
последовательности, от @math{a_0} до @math{a_n}.

@lisp
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) @math{\langle}??@math{\rangle})
              0
              coefficient-sequence))
@end lisp

Например, чтобы вычислить @math{1 + 3x + 5x^3 + x^5} в точке
@math{x = 2}, нужно ввести

@lisp
(horner-eval 2 (list 1 3 0 5 0 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.35}Упражнение 2.35:}
Переопределите @code{count-leaves} из
раздела @ref{2.2.2} в виде накопления:

@lisp
(define (count-leaves t)
  (accumulate @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} (map @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.36}Упражнение 2.36:}
Процедура @code{accumulate-n} подобна @code{accumulate},
только свой третий аргумент она воспринимает как последовательность
последовательностей, причем предполагается, что все они содержат
одинаковое количество элементов. Она применяет указанную процедуру
накопления ко всем первым элементам последовательностей, вторым
элементам последовательностей и так далее, и возвращает
последовательность результатов. Например, если @code{s} есть
последовательность, состоящая из четырех последовательностей,
@code{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}, то значением
@code{(accumulate-n + 0 s)} будет последовательность @code{(22 26 30)}.
Заполните пробелы в следующем определении @code{accumulate-n}:

@lisp
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init @math{\langle}??@math{\rangle})
            (accumulate-n op init @math{\langle}??@math{\rangle}))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.37}Упражнение 2.37:}
Предположим, что мы представляем векторы @math{v =
(v_i)} как последовательности чисел, а матрицы @math{m
=(m_{ij})} как последовательности векторов (рядов матрицы). Например,
матрица
@ifinfo

@example
+-         -+
|  1 2 3 4  |
|  4 5 6 6  |
|  6 7 8 9  |
+-         -+
@end example

@end ifinfo
@tex
$$
\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9
\end{array}
\right)
$$
@end tex
@noindent
представляется в виде последовательности
@code{((1 2 3 4) (4 5 6 6) (6 7 8 9))}. Имея такое представление, мы
можем использовать операции над последовательностями, чтобы кратко
выразить основные действия над матрицами и векторами. Эти операции
(описанные в любой книге по матричной алгебре) следующие:
@ifinfo

@example
                                        __
(dot-product v w)      возвращает сумму >_i v_i w_i

(matrix-*-vector m v)  возвращает вектор t,
                                 __
                       где t_i = >_j m_(ij) v_j

(matrix-*-matrix m n)  возвращает матрицу p,
                                    __
                       где p_(ij) = >_k m_(ik) n_(kj)

(transpose m)          возвращает матрицу n,
                       где n_(ij) = m_(ji)
@end example

@end ifinfo
@tex
$$
\begin{array}{rl}
    \hbox{\tt (dot-product v w)} 		& {\rm возвращает сумму;} \Sigma_i v_i w_i; \\
    \hbox{\tt (matrix-*-vector m v)} 	& {\rm возвращает вектор;} \hbox{\bf t},  \\
        & {\rm где\;} t_i = \Sigma_{\kern-0.1em j} m_{i\!j} v_{\kern-0.1em j};      \\
    \hbox{\tt (matrix-*-matrix m n)} 	& {\rm возвращает матрицу\;} \hbox{\bf p},  \\
        & {\rm где\;} p_{i\!j} = \Sigma_k m_{ik} n_{k\!j};                          \\
    \hbox{\tt (transpose m)} 		& {\rm возвращает матрицу\;} \hbox{\bf n},  \\
        & {\rm где\;} n_{i\!j} = m_{\kern-0.1em ji}.
\end{array}
$$
@end tex
Скалярное произведение мы можем определить так:@footnote{Это определение
использует расширенную версию @code{map}, описанную в сноске
@ref{Сноска 2.12}.}

@lisp
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
@end lisp

Заполните пропуски в следующих процедурах для вычисления остальных
матричных операций. (Процедура @code{accumulate-n} описана в
упражнении @ref{Упражнение 2.36}.)

@lisp
(define (matrix-*-vector m v)
  (map @math{\langle}??@math{\rangle} m))
(define (transpose mat)
  (accumulate-n @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map @math{\langle}??@math{\rangle} m)))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.38}Упражнение 2.38:}
Процедура @code{accumulate} известна также как
@code{fold-right} (правая свертка), поскольку она комбинирует первый
элемент последовательности с результатом комбинирования всех элементов
справа от него. Существует также процедура @code{fold-left} (левая
свертка), которая подобна @code{fold-right}, но комбинирует элементы в
противоположном направлении:

@lisp
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
@end lisp

Каковы значения следующих выражений?

@lisp
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
@end lisp

Укажите свойство, которому должна удовлетворять @code{op}, чтобы для
любой последовательности @code{fold-right} и @code{fold-left} давали
одинаковые результаты.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.39}Упражнение 2.39:}
Закончите следующие определения @code{reverse}
(упражнение @ref{Упражнение 2.18}) в терминах процедур
@code{fold-right} и @code{fold-left} из упражнения @ref{Упражнение 2.38}.
@end quotation

@comment @subsubheading Nested Mappings
@subsubheading Вложенные отображения

Расширив парадигму последовательностей, мы можем включить в нее многие
вычисления, которые обычно выражаются с помощью вложенных
циклов.@footnote{Этот подход к вложенным отображениям нам показал Дэвид
Тёрнер, чьи языки KRC и Миранда обладают изящным формализмом для работы
с такими конструкциями. Примеры из этого раздела (см. также
упражнение @ref{Упражнение 2.42}) адаптированы из @ref{Turner 1981}. В
разделе @ref{3.5.3}
мы увидим, как этот подход можно обобщить на бесконечные
последовательности.} Рассмотрим следующую задачу: пусть дано
положительное целое число @math{n}; найти все такие упорядоченные пары
различных целых чисел @math{i} и @math{j}, где @math{1 \le j < i \le
n}, что @math{i + j} является простым. Например, если @math{n} равно 6,
то искомые пары следующие:
@ifinfo

@example
  i   | 2 3 4 4 5 6 6
  j   | 1 2 1 3 2 1 5
------+---------------
i + j | 3 5 5 7 7 7 11
@end example

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut \hfil \quad #\quad \hfil & \vrule
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil \cr

$i$ 	& 2 & 3 & 4 & 4 & 5 & 6 & 6 \cr
$j$ 	& 1 & 2 & 1 & 3 & 2 & 1 & 5 \cr
\noalign{\hrule}
$i + j$	& 3 & 5 & 5 & 7 & 7 & 7 & 11 \cr}
}$$
@end tex
Естественный способ организации этого вычисления состоит в
том, чтобы породить последовательность всех упорядоченных пар
положительных чисел, меньших @math{n}, отфильтровать ее, выбирая те
пары, где сумма чисел простая, и затем для каждой пары @math{(i, j)},
которая прошла через фильтр, сгенерировать тройку @math{(i, j, i+j)}.

Вот способ породить последовательность пар: для каждого целого
@math{i \le n} перечислить целые числа @math{j < i},
и для каждых таких @math{i} и @math{j} породить пару @math{(i, j)}.
В терминах операций над последовательностями, мы производим отображение
последовательности @code{(enumerate-interval 1 n)}. Для каждого @math{i}
из этой последовательности мы производим отображение последовательности
@code{(enumerate-interval 1 (- i 1))}. Для каждого @math{j} в этой
последовательности мы порождаем пару @code{(list i j)}. Это дает нам
последовательность пар для каждого @math{i}. Скомбинировав
последовательности для всех @math{i} (путем накопления через
@code{append}), получаем необходимую нам последовательность
пар:@footnote{Здесь мы представляем пару в виде списка из двух элементов,
а не в виде лисповской пары. Иначе говоря, <<пара>> @math{(i, j)}
представляется как @code{(list i j)}, а не как @code{(cons i j)}.}

@lisp
(accumulate
 append nil (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
@end lisp

@noindent
Комбинация из отображения и накопления через @code{append} в такого рода
программах настолько обычна, что мы ее выразим как отдельную процедуру:

@lisp
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
@end lisp

@noindent
Теперь нужно отфильтровать эту последовательность пар, чтобы найти те из
них, где сумма является простым числом. Предикат фильтра вызывается для
каждой пары в последовательности; его аргументом является пара и он
должен обращаться к элементам пары. Таким образом, предикат, который мы
применяем к каждому элементу пары, таков:

@lisp
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
@end lisp

@noindent
Наконец, нужно породить последовательность результатов, отобразив
отфильтрованную последовательность пар при помощи следующей процедуры,
которая создает тройку, состоящую из двух элементов пары и их суммы:

@lisp
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
@end lisp

@noindent
Сочетание всех этих шагов дает нам процедуру целиком:

@smalllisp
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (flatmap
                           (lambda (i)
                             (map (lambda (j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                           (enumerate-interval 1 n)))))
@end smalllisp

@noindent
Вложенные отображения полезны не только для таких последовательностей,
которые перечисляют интервалы. Допустим, нам нужно перечислить все
перестановки множества @math{S}, то есть все способы упорядочить это
множество. Например, перестановки множества @math{\{1, 2, 3\}} --- это
@math{\{1, 2, 3\}}, @math{\{1, 3, 
2\}}, @math{\{2, 1, 3\}}, @math{\{2, 3, 1\}}, @math{\{3, 1, 2\}} и
@math{\{3, 2, 1\}}. Вот план того, как можно породить все перестановки
@math{S}: Для каждого элемента @math{x} из @math{S}, нужно рекурсивно
породить все множество перестановок @math{S - x},@footnote{Множество
@math{S - x} есть множество, состоящее из всех
элементов @math{S}, кроме @math{x}.} затем добавить @math{x} к началу
каждой из них. Для каждого @math{x} из @math{S} это дает множество всех
перестановок @math{S}, которые начинаются с @math{x}. Комбинация всех
последовательностей для всех @math{x} дает нам все перестановки
@math{S}:@footnote{Точки с запятой в коде на Scheme начинают (comments).
Весь текст, начиная от точки с запятой и заканчивая концом строки,
интерпретатор игнорирует. В этой книге мы мало используем комментарии;
мы стараемся, чтобы программы документировали себя сами при помощи
описательных имен переменных.}

@lisp
(define (permutations s)
  (if (null? s)              @r{; empty set?}
      (list nil)             @r{; sequence containing empty set}
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
@end lisp

@noindent
Заметим, что такая стратегия сводит задачу порождения перестановок
@math{S} к задаче порождения перестановок для множества, которое меньше,
чем @math{S}. В граничном случае мы добираемся до пустого списка,
который представляет множество, не содержащее элементов. Для этого
множества мы порождаем @code{(list nil)}, которое является
последовательностью из одного члена, а именно множества без элементов.
Процедура @code{remove}, которую мы используем внутри
@code{permutations}, возвращает все элементы исходной
последовательности, за исключением данного. Ее можно выразить как
простой фильтр:

@lisp
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.40}Упражнение 2.40:}
Определите процедуру , которая, получая целое число
@math{n}, порождает последовательность пар @math{(i, j)}, таких, что
@math{1 \le j
< i \le n}. С помощью @code{unique-pairs} упростите данное выше
определение @code{prime-sum-pairs}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.41}Упражнение 2.41:}
Напишите процедуру, которая находит все такие упорядоченные
тройки различных положительных целых чисел @math{i}, @math{j} и
@math{k}, меньших или равных данному целому числу @math{n}, сумма
которых равна данному числу @math{s}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.42}Упражнение 2.42:}
В <<задаче о восьми ферзях>> спрашивается, как расставить
на шахматной доске восемь ферзей так, чтобы ни один из них не бил
другого (то есть никакие два ферзя не должны находиться на одной
вертикали, горизонтали или диагонали). Одно из возможных решений
показано на рисунке @ref{Рисунок 2.8}. Один из способов решать эту
задачу состоит в том, чтобы идти поперек доски, устанавливая по ферзю в
каждой вертикали. После того, как @math{k-1} ферзя мы уже разместили,
нужно разместить @math{k}-го в таком месте, где он не бьет ни одного из
тех, которые уже находятся на доске. Этот подход можно сформулировать
рекурсивно: предположим, что мы уже породили последовательность из всех
возможных способов разместить @math{k-1} ферзей на первых @math{k-1}
вертикалях доски. Для каждого из этих способов мы порождаем расширенный
набор позиций, добавляя ферзя на каждую горизонталь @math{k}-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те,
где ферзь на @math{k}-й вертикали не бьется ни одним из остальных.
Продолжая этот процесс, мы породим не просто одно решение, а все решения
этой задачи.

@float
@anchor{Рисунок 2.8}
@ifinfo
@strong{Рисунок 2.8:} A solution to the eight-queens puzzle.

@example
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | Q |   |   |
+---+---+---+---+---+---+---+---+
|   |   | Q |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| Q |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | Q |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   | Q |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   | Q |
+---+---+---+---+---+---+---+---+
|   | Q |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | Q |   |   |   |   |
+---+---+---+---+---+---+---+---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap2/Fig2.8c,48mm,,,.pdf}      @c 73mm
@sp 0.3
@comment @center @caption{@strong{Рисунок 2.8:} A solution to the eight-queens puzzle.}
@center @caption{@strong{Рисунок 2.8:} Решение задачи о восьми ферзях.}
@sp 0.0
@end iftex
@end float

Это решение мы реализуем в процедуре @code{queens}, которая возвращает
последовательность решений задачи размещения @math{n} ферзей на доске
@math{n \times
n}. В процедуре @code{queens} есть внутренняя процедура
@code{queen-cols}, которая возвращает последовательность всех способов
разместить ферзей на первых @math{k} вертикалях доски.

@lisp

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
@end lisp

В этой процедуре @code{rest-of-queens} есть способ размещения @math{k-1}
ферзя на первых @math{k-1} вертикалях, а @code{new-row} --- это
горизонталь, на которую предлагается поместить ферзя с @math{k}-й
вертикали. Завершите эту программу, реализовав представление множеств
позиций ферзей на доске, включая процедуру @code{adjoin-position},
которая добавляет нового ферзя на определенных горизонтали и вертикали к
заданному множеству позиций, и @code{empty-board}, которая представляет
пустое множество позиций. Еще нужно написать процедуру @code{safe?},
которая для множества позиций определяет, находится ли ферзь с
@math{k}-й вертикали в безопасности от остальных. (Заметим, что нам
требуется проверять только то, находится ли в безопасности новый
ферзь --- для остальных ферзей безопасность друг от друга уже
гарантирована.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.43}Упражнение 2.43:}
У Хьюго Дума ужасные трудности при решении
упражнения @ref{Упражнение 2.42}. Его процедура @code{queens} вроде бы
работает, но невероятно медленно. (Хьюго ни разу не удается дождаться,
пока она решит хотя бы задачу @math{6 \times 6}.) Когда Хьюго просит о
помощи Еву Лу Атор, она указывает, что он поменял местами порядок
вложенных отображений в вызове процедуры @code{flatmap}, записав его в
виде

@lisp
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
@end lisp

Объясните, почему из-за такой перестановки программа работает медленно.
Оцените, насколько долго программа Хьюго будет решать задачу с восемью
ферзями, если предположить, что программа, приведенная в
упражнении @ref{Упражнение 2.42}, решает ее за время @math{T}.

@comment @subsection Example: A Picture Language
@subsection Пример: язык описания изображений
@node	2.2.4,  , 2.2.3, 2.2

В этой главе мы представляем простой язык для рисования картинок,
иллюстрирующий силу абстракции данных и свойства замыкания; кроме того,
он существенным образом опирается на процедуры высших порядков. Язык
этот спроектирован так, чтобы легко было работать с узорами вроде тех,
которые показаны на рисунке @ref{Рисунок 2.9}, составленными из
элементов, которые повторяются в разных положениях и меняют
размер.@footnote{Этот язык описания картинок основан на языке, который
создал Питер Хендерсон для построения изображений, подобных гравюре М.
К. Эшера <<Предел квадрата>> (см. @ref{Henderson 1982}). На гравюре изображен
повторяющийся с уменьшением элемент, подобно картинкам, получающимся при
помощи процедуры @code{square-limit} из этого раздела.} В этом языке
комбинируемые объекты данных представляются не как списковая структура,
а как процедуры. Точно так же, как @code{cons}, которая обладает
свойством замыкания, позволила нам строить списковые структуры
произвольной сложности, операции этого языка, также обладающие свойством
замыкания, позволяют нам строить сколь угодно сложные узоры.

@comment @subsubheading The picture language
@subsubheading Язык описания изображений

Когда в разделе @ref{1.1}
мы начинали изучать программирование, мы подчеркивали важность описания
языка через рассмотрение его примитивов, методов комбинирования и
методов абстракции. Мы будем следовать этой схеме и здесь.

@float
@quotation
@anchor{Рисунок 2.9}
@ifinfo
@strong{Рисунок 2.9:} Designs generated with the picture language.

[two graphic images not included]
@end ifinfo
@end quotation
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.9-bigger,111mm,48mm,,.png}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.9:} Designs generated with the picture language.}
@center @caption{@strong{Рисунок 2.9:} Узоры, порождаемые языком описания изображений.}
@sp 0.6
@end iftex
@end float

@float
@quotation
@anchor{Рисунок 2.10}
@ifinfo
@strong{Рисунок 2.10:} Images produced by the @code{wave}
painter, with respect to four different frames.  The frames, shown with dotted
lines, are not part of the images.

[four graphic images not included]
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap2/Fig2.10,50mm,,,.pdf}
@sp 0.6
@comment @caption{@strong{Рисунок 2.10:} Images produced by the @code{wave} painter, with respect to four different frames.  The frames, shown with dotted lines, are not part of the images.}
@center @caption{@strong{Рисунок 2.10:} Изображения, порожденные рисовалкой @code{wave} по отношению к четырем различным рамкам.  Рамки, показанные пунктиром, не являются частью изображений.}
@sp 0.0
@end iftex
@end quotation
@end float

Одно из элегантных свойств языка описания изображений состоит в том, что
в нем есть только один тип элементов, называемый (@newterm{painter}). Рисовалка
рисует изображение с необходимым смещением и масштабом, чтобы попасть в
указанную рамку в форме параллелограмма. Например, существует
элементарная рисовалка @code{wave}, которая порождает грубую картинку из
линий, как показано на рисунке @ref{Рисунок 2.10}. Форма изображения
зависит от рамки  --- все четыре изображения на
рисунке @ref{Рисунок 2.10} порождены одной и той же рисовалкой
@code{wave}, но по отношению к четырем различным рамкам. Рисовалки могут
быть и более изощренными: элементарная рисовалка по имени @code{rogers}
рисует портрет основателя MIT Уильяма Бартона Роджерса, как показано на
рисунке @ref{Рисунок 2.11}.@footnote{Уильям Бартон Роджерс (1804-1882)
был основателем и первым президентом MIT. Будучи геологом и способным
педагогом, он преподавал в Колледже Вильгельма и Марии, а также в
университете штата Виргиния. В 1859 году он переехал в Бостон, где у
него было больше времени для исследований, разработал план создания
<<политехнического института>> и служил первым Инспектором штата
Массачусетс по газовым счетчикам.

Когда в 1861 году был основан MIT, Роджерс был избран его первым
президентом. Роджерс исповедовал идеал <<полезного обучения>>, отличного
от университетского образования его времени с чрезмерным вниманием к
классике, которое, как он писал, <<стояло на пути более широкого,
высокого и практического обучения и преподавания в естественных и
общественных науках>>. Это образование должно было отличаться и от
узкого образования коммерческих школ. По словам Роджерса:

@quotation
Повсеместно проводимое разделение между практическим и научным
работником совершенно бесполезно, и весь опыт нашего времени показывает
его полную несостоятельность.
@end quotation

Роджерс был президентом MIT до 1870 года, когда он ушел в отставку по
состоянию здоровья. В 1878 году второй президент MIT Джон Ранкл оставил
свой пост из-за финансового кризиса, вызванного биржевой паникой 1873
года, и напряженной борьбы с попытками Гарварда поглотить MIT. Роджерс
вернулся и оставался на посту президента до 1881 года.

Роджерс умер от приступа во время своей речи перед студентами MIT на
выпускной церемонии 1882 года. В речи, посвященной его памяти и
произнесенной в том же году, Ранкл приводит последние его слова:

@quotation
<<Стоя здесь и видя, чем стал Институт, @dots{} я вспоминаю о начале
научных исследований. Я вспоминаю, как сто пятьдесят лет назад Стивен
Хейлс опубликовал статью на тему о светящемся газе, где он утверждал,
что его исследования показали, что 128 гран битумного угля@dots{}>>

<<Битумный уголь>> --- были его последние слова в этом мире. Он
склонился вперед, как будто справляясь со своими заметками, которые
лежали перед ним на столе, затем медленно выпрямился, поднял руки, и был
перенесен со сцены своих земных забот и триумфов в <<завтра смерти>>,
где решены тайны жизни, и бестелесный дух находит неизмеримое
наслаждение в созерцании новых и по-прежнему необъяснимых загадок
бесконечного будущего.
@end quotation

По словам Фрэнсиса А. Уокера (третьего президента MIT):

@quotation
Всю свою жизнь он провел с огромной верой и героизмом, и умер так, как,
наверное, и должен был желать столь превосходный рыцарь, в полном
вооружении, на своем посту, и во время самого акта исполнения
общественных обязанностей.
@end quotation} Четыре изображения на рисунке @ref{Рисунок 2.11}
нарисованы относительно тех же рамок, что и картинки @code{wave} на
рисунке @ref{Рисунок 2.10}.

@float
@quotation
@anchor{Рисунок 2.11}
@ifinfo
@strong{Рисунок 2.11:} Images of William Barton Rogers,
founder and first president of @acronym{MIT}, painted with respect to the same
four frames as in @ref{Рисунок 2.10} (original image reprinted with the
permission of the @acronym{MIT} Museum).

[four graphic images not included]
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.11,48mm,,,.pdf}
@sp 0.4
@comment @caption{@strong{Рисунок 2.11:} Images of William Barton Rogers, founder and first president of @acronym{MIT}, painted with respect to the same four frames as in @ref{Рисунок 2.10} (original image from Wikimedia Commons).}
@center @caption{@strong{Рисунок 2.11:} Изображения Уильяма Бартона Роджерса, основателя и первого президента MIT, нарисованные по отношению к тем же четырем рамкам, что и на рисунке @ref{Рисунок 2.10} (первоначальное изображение печатается с разрешения музея MIT).}
@sp 0.8
@end iftex
@end quotation
@end float

При комбинировании изображений мы используем различные операции, которые
строят новые рисовалки из рисовалок, полученных в качестве аргументов.
Например, операция @code{beside} получает две рисовалки и порождает
новую составную рисовалку, которая рисует изображение первой рисовалки в
левой половине рамки, а изображение второй рисовалки в правой половине
рамки. Подобным образом, @code{below} принимает две рисовалки и
порождает составную рисовалку, рисующую изображение первого аргумента
под изображением второго аргумента. Некоторые операции преобразуют одну
рисовалку и получают другую. Например, @code{flip-vert} получает
рисовалку и порождает новую, рисующую изображение вверх ногами, а
@code{flip-horiz} порождает рисовалку, рисующую изображение исходной в
зеркальном отображении.

На картинке @ref{Рисунок 2.12} показан результат работы рисовалки,
называемой @code{wave4}, который строится в два этапа, начиная с
@code{wave}:

@lisp
(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
@end lisp

@float
@quotation
@anchor{Рисунок 2.12}
@ifinfo
@strong{Рисунок 2.12:} Creating a complex figure, starting
from the @code{wave} painter of @ref{Рисунок 2.10}.

[two graphic images not included]

@lisp
(define wave2                      (define wave4
  (beside wave (flip-vert wave)))    (below wave2 wave2))
@end lisp
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.12,50mm,,,.pdf}
@sp 0.4
@comment @caption{@strong{Рисунок 2.12:} Creating a complex figure, starting from the @code{wave} painter of @ref{Рисунок 2.10}.}
@center @caption{@strong{Рисунок 2.12:} Построение составного изображения, начиная с рисовалки @code{wave} с рисунка @ref{Рисунок 2.10}}
@sp 0.7
@end iftex
@end quotation
@end float

Строя таким образом составные рисовалки, мы используем тот факт, что
рисовалки замкнуты относительно средств комбинирования нашего языка.
@code{beside} или @code{below} от двух рисовалок само является
рисовалкой; следовательно, мы можем ее использовать как элемент при
построении еще более сложных рисовалок. Так же, как при построении
списковых структур с помощью @code{cons}, замкнутость наших данных
относительно средств комбинирования служит основой способности строить
сложные структуры при помощи всего лишь нескольких операций.

Раз мы можем комбинировать рисовалки, нам хотелось бы уметь выделять
типичные схемы их комбинирования. Операции над рисовалками мы реализуем
как процедуры языка Scheme. Это означает, что нам в языке изображений не
требуется специального механизма абстракции: поскольку средства
комбинирования являются обычными процедурами Scheme, у нас автоматически
есть право делать с операциями над рисовалками все то, что мы можем
делать с процедурами. Например, схему построения @code{wave4} мы можем
абстрагировать в виде

@lisp
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
@end lisp

@noindent
и определить @code{wave4} как пример применения этой схемы:

@lisp
(define wave4 (flipped-pairs wave))
@end lisp

@float
@anchor{Рисунок 2.13}
@ifinfo
@quotation
@strong{Рисунок 2.13:} Recursive plans for @code{right-split} and @code{corner-split}.

@example
+-------------+-------------+    +------+------+-------------+
|             |             |    | up-  | up-  |             |
|             | right-split |    | split| split| corner-split|
|             |             |    |      |      |             |
|             |     n-1     |    |  n-1 |  n-1 |     n-1     |
|             |             |    |      |      |             |
|  identity   +-------------+    +------+------+-------------+
|             |             |    |             | right-split |
|             | right-split |    |             |     n-1     |
|             |             |    |  identity   +-------------+
|             |     n-1     |    |             | right-split |
|             |             |    |             |     n-1     |
+-------------+-------------+    +-------------+-------------+

       right-split n                    corner-split n
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap2/Fig2.13a,111mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.13:} Recursive plans for @code{right-split} and @code{corner-split}. }@short
@center @caption{@strong{Рисунок 2.13:} Рекурсивные планы для @code{right-split} и @code{corner-split}.}
@sp 0.7
@end iftex
@end float

@noindent
Мы можем определять и рекурсивные операции. Вот пример, который
заставляет рисовалки делиться и ветвиться направо, как показано на
рисунках @ref{Рисунок 2.13} и @ref{Рисунок 2.14}:

@lisp
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
@end lisp

@noindent
Можно порождать сбалансированные узоры, наращивая их не только направо,
но и вверх (см. упражнение @ref{Упражнение 2.44} и
рисунки @ref{Рисунок 2.13} и @ref{Рисунок 2.14}):

@lisp
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
@end lisp

@noindent
Соответствующим образом расположив четыре копии @code{corner-split}, мы
получаем схему под названием @code{square-limit}, применение которой к
@code{wave} и @code{rogers} показано на рисунке @ref{Рисунок 2.9}:

@lisp
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.44}Упражнение 2.44:}
Определите процедуру @code{up-split}, которую использует
@code{corner-@/split}. Она подобна @code{right-split}, но только меняет
местами роли @code{below} и @code{beside}.
@end quotation

@float[tbp]
@quotation
@anchor{Рисунок 2.14}
@ifinfo
@strong{Рисунок 2.14:} The recursive operations @code{right-split} and @code{corner-split} applied to the painters @code{wave} and @code{rogers}.  Combining four @code{corner-split} figures produces symmetric @code{square-limit} designs as shown in @ref{Рисунок 2.9}.

[two graphic images not included]

@lisp
(right-split wave 4)         (right-split rogers 4)
@end lisp

[two graphic images not included]

@lisp
(corner-split wave 4)        (corner-split rogers 4)
@end lisp
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.14b,91mm,,,.pdf}
@sp 0.4
@comment @caption{@strong{Рисунок 2.14:} The recursive operations @code{right-split} and @code{corner-@/split} applied to the painters @code{wave} and @code{rogers}.  Combining four @code{corner-split} figures produces symmetric @code{square-limit} designs as shown in @ref{Рисунок 2.9}.}
@caption{@strong{Рисунок 2.14:} Рекурсивные операции @code{right-split} и @code{corner-split} в применении к рисовалкам @code{wave} и @code{rogers}. Комбинирование четырех картинок @code{corner-split} дает симметричные узоры @code{square-limit}, как показано на рисунке @ref{Рисунок 2.9}.}
@sp 0.0
@end iftex
@end quotation
@end float

@comment @subsubheading Higher-order operations
@subsubheading Операции высших порядков

В дополнение к абстрагированию схем комбинирования рисовалок, мы можем
работать и на более высоком уровне, абстрагируя схемы комбинирования
операций над рисовалками. А именно, мы можем рассматривать операции над
рисовалками в качестве элементов, подлежащих манипуляции, и писать
средства комбинирования этих элементов --- операции, которые принимают
операции над рисовалками как аргументы и создают новые операции.

Например, и @code{flipped-pairs}, и @code{square-limit} располагают
определенным образом в виде квадрата четыре копии порождаемого
рисовалкой изображения; они отличаются только тем, как они ориентируют
эти копии. Один из способов абстрагировать такую схему комбинирования
рисовалок представлен следующей процедурой, которая принимает четыре
одноаргументных операции и порождает операцию над рисовалками, которая
трансформирует данную ей рисовалку с помощью этих четырех операций и
расставляет результаты по квадрату. @code{Tl}, @code{tr}, @code{bl} и
@code{br} --- это трансформации, которые следует применить к верхней
левой, верхней правой, нижней левой и нижней правой копиям,
соответственно.

@lisp
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
@end lisp

@noindent
Тогда в терминах @code{square-of-four} можно определить
@code{flipped-pairs} следующим образом:@footnote{Мы также могли бы
написать

@lisp
(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
@end lisp
}:

@lisp
(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
@end lisp

@noindent
а @code{square-limit} можно выразить как@footnote{@code{Rotate180}
поворачивает рисовалку на 180 градусов (см.
упражнение @ref{Упражнение 2.50}). Вместо @code{rotate180} мы могли бы
сказать @code{(compose flip-vert flip-horiz)}, используя процедуру
@code{compose} из упражнения @ref{Упражнение 1.42}.}

@lisp
(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.45}Упражнение 2.45:}
@code{right-split} и @code{up-split} можно выразить как
разновидности общей операции разделения. Определите процедуру с таким
свойством, что вычисление

@lisp
(define right-split (split beside below))
(define up-split (split below beside))
@end lisp

порождает процедуры @code{right-split} и @code{up-split} с таким же
поведением, как и определенные ранее.
@end quotation

@comment @subsubheading Frames
@subsubheading Рамки

Прежде, чем мы сможем показать, как реализуются рисовалки и средства их
комбинирования, нам нужно рассмотреть рамки. Рамку можно описать как три
вектора --- вектор исходной точки и два вектора краев рамки. Вектор
исходной точки @math{\mbox{\rm Origin}} указывает смещение исходной
точки рамки от некой абсолютной начальной точки, а векторы краев
@math{\mbox{\rm Edge}_1} и @math{\mathop{\rm Edge}_2} указывают смещение
углов рамки от ее исходной точки. Если края перпендикулярны, рамка будет
прямоугольной. В противном случае рамка будет представлять более общий
случай параллелограмма. На рис. @ref{Рисунок 2.15} показаны рамка и
соответствующие ей вектора. В соответствии с принципами абстракции
данных, нам пока незачем указывать, каким образом представляются рамки;
нужно только сказать, что есть конструктор @code{make-frame}, который
принимает три вектора и выдает рамку, и что есть еще три селектора
@code{origin-frame}, @code{edge1-frame} и @code{edge2-frame} (см.
упражнение @ref{Упражнение 2.47}).

@float
@quotation
@anchor{Рисунок 2.15}
@ifinfo
@strong{Рисунок 2.15:} A frame is described by three vectors
-- an origin and two edges.

@example
                         __
                     __--  \
                 __--       \
      __     __--            \   __
     |\  __--                 \__-|
       \-                  __--
frame   \              __--
edge2    \         __--    frame
vector    \    __--        edge1
           \_--            vector
            -   <--+
          frame    |
          origin   +-- (0, 0) point
          vector       on display screen
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.15a,51mm,,,.pdf}
@sp 0.2
@comment @caption{@strong{Рисунок 2.15:} A frame is described by three vectors --- an origin and two edges.}
@caption{@strong{Рисунок 2.15:} Рамка представляется в виде трех векторов --- начальной точки и двух краев.}
@sp 0.6
@end iftex
@end quotation
@end float

Для определения изображений мы будем использовать координаты в единичном
квадрате @math{(@newterm{0 \le x, y \le 1})}. Каждой рамке мы
сопоставляем (frame coordinate map), которое будет
использоваться, чтобы сдвигать и масштабировать изображения так, чтобы
они умещались в рамку. Это отображение трансформирует единичный квадрат
в рамку, переводя вектор @math{{\bf v} = (x, y)} в сумму векторов
@ifinfo

@example
Origin(Frame) + x * Edge_1(Frame) + y * Edge_2(Frame)
@end example

@end ifinfo
@tex
$$ {\rm Origin(Frame)} + x \cdot {\rm Edge_1(Frame)} + y \cdot {\rm Edge_2(Frame)}. $$
@end tex
@noindent
Например, (0, 0)
отображается в исходную точку рамки, (1, 1) в вершину, противоположную
исходной точке по диагонали, а (0.5, 0.5) в центр рамки. Мы можем
создать отображение координат рамки при помощи следующей
процедуры:@footnote{@code{Frame-coord-map} использует векторные операции,
определенные ниже в упражнении @ref{Упражнение 2.46}, и мы
предполагаем, что они реализованы для какого-нибудь представления
векторов. Благодаря абстракции данных, неважно, каково это
представление; нужно только, чтобы операции над векторами вели себя
правильно.}

@lisp
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
               (scale-vect (ycor-vect v) (edge2-frame frame))))))
@end lisp

@noindent
Заметим, что применение @code{frame-coord-map} к рамке дает нам
процедуру, которая, получая вектор, возвращает тоже вектор. Если
вектор-аргумент находится в единичном квадрате, вектор-результат
окажется в рамке. Например,

@lisp
((frame-coord-map a-frame) (make-vect 0 0))
@end lisp

@noindent
возвращает тот же вектор, что и

@lisp
(origin-frame a-frame)
@end lisp

@quotation
@strong{@anchor{Упражнение 2.46}Упражнение 2.46:}
Двумерный вектор @math{{\bf v}}, идущий от начала координат
к точке, можно представить в виде пары, состоящей из @math{x}-координаты
и @math{y}-координаты. Реализуйте абстракцию данных для векторов,
написав конструктор @code{make-vect} и соответствующие селекторы
@code{xcor-vect} и @code{ycor-vect}. В терминах своих селекторов и
конструктора реализуйте процедуры @code{add-vect}, @code{sub-vect} и
@code{scale-vect}, которые выполняют операции сложения, вычитания
векторов и умножения вектора на скаляр:
@ifinfo

@example
(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
(x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
             s * (x, y) = (sx, sy)
@end example
@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
    (x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
    (x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
    s \cdot (x, y) 			& (sx, sy).
\end{array}
$$
@end tex
@end quotation

@quotation
@strong{@anchor{Упражнение 2.47}Упражнение 2.47:}
Вот два варианта конструкторов для рамок:

@lisp
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
@end lisp

К каждому из этих конструкторов добавьте соответствующие селекторы, так,
чтобы получить реализацию рамок.
@end quotation

@comment @subsubheading Painters
@subsubheading Рисовалки

Рисовалка представляется в виде процедуры, которая, получая в качестве
аргумента рамку, рисует определенное изображение, отмасштабированное и
сдвинутое так, чтобы уместиться в эту рамку. Это означает, что если есть
рисовалка @code{p} и рамка @code{f}, то мы можем получить изображение,
порождаемое @code{p}, в @code{f}, позвав @code{p} с @code{f} в качестве
аргумента.

Детали того, как реализуются элементарные рисовалки, зависят от
конкретных характеристик графической системы и типа изображения, которое
надо получить. Например, пусть у нас будет процедура @code{draw-line},
которая рисует на экране отрезок между двумя указанными точками. Тогда
мы можем создавать из списков отрезков рисовалки для изображений,
состоящих из этих отрезков, вроде рисовалки @code{wave} с
рисунка @ref{Рисунок 2.10}, таким образом:@footnote{Процедура
@code{segments->painter} использует представление отрезков прямых,
описанное ниже в упражнении @ref{Упражнение 2.48}. Кроме того, она
использует процедуру @code{for-each}, описанную в
упражнении @ref{Упражнение 2.23}.}

@lisp
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
@end lisp

@noindent
Отрезки даются в координатах по отношению к единичному квадрату. Для
каждого сегмента в списке рисовалка преобразует концы отрезка с помощью
отображения координат рамки и рисует отрезок между точками с
преобразованными координатами.

Представление рисовалок в виде процедур воздвигает в языке построения
изображений мощный барьер абстракции. Мы можем создавать и смешивать
множество типов элементарных рисовалок, в зависимости от имеющихся
возможностей графики. Детали их реализации несущественны. Любая
процедура, если она принимает в качестве аргумента рамку и рисует в ней
что-нибудь должным образом отмасштабированное, может служить
рисовалкой.@footnote{Например, рисовалка @code{rogers} с
рисунка @ref{Рисунок 2.11} была получена из полутонового черно-белого
изображения. Для каждой точки в указанной рамке рисовалка @code{rogers}
определяет точку исходного изображения, которая в нее отображается, и
соответствующим образом ее окрашивает. Разрешая себе иметь различные
типы рисовалок, мы пользуемся идеей абстрактных данных, описанной в
разделе @ref{2.1.3}, где мы говорили, что
представление рациональных чисел может быть каким угодно, пока
соблюдается соответствующее условие. Здесь мы используем то, что
рисовалку можно реализовать как угодно, лишь бы она что-то изображала в
указанной рамке. В разделе @ref{2.1.3}
показывается и то, как реализовать пары в виде процедур. Рисовалки ---
это наш второй пример процедурного представления данных.}

@quotation
@strong{@anchor{Упражнение 2.48}Упражнение 2.48:}
Направленный отрезок на плоскости можно представить в виде
пары векторов: вектор от начала координат до начала отрезка и вектор от
начала координат до конца отрезка. Используйте свое представление
векторов из упражнения @ref{Упражнение 2.46} и определите
представление отрезков с конструктором @code{make-segment} и селекторами
@code{start-segment} и @code{end-segment}.

@end quotation

@quotation
@strong{@anchor{Упражнение 2.49}Упражнение 2.49:}
С помощью @code{segments->painter} определите следующие
элементарные рисовалки:

@enumerate a.

@item
Рисовалку, которая обводит указанную рамку.

@item
Рисовалку, которая рисует <<Х>>, соединяя противоположные концы рамки.

@item
Рисовалку, которая рисует ромб, соединяя между собой середины сторон
рамки.

@item
Рисовалку @code{wave}.

@end enumerate
@end quotation

@comment @subsubheading Transforming and combining painters
@subsubheading Преобразование и комбинирование рисовалок

Операции над рисовалками (@code{flip-vert} или @code{beside}, например)
создают новые рисовалки, которые вызывает исходные рисовалки по
отношению к рамкам, производным от рамок-аргументов. Таким образом,
скажем, @code{flip-vert} не требуется знать, как работает рисовалка,
чтобы перевернуть ее  --- ей нужно только уметь перевернуть рамку вверх
ногами: перевернутая рисовалка просто использует исходную, но в
обращенной рамке.

Операции над рисовалками основываются на процедуре
@code{transform-painter}, которая в качестве аргументов берет рисовалку
и информацию о том, как преобразовать рамку, а возвращает новую
рисовалку. Когда преобразованная рисовалка вызывается по отношению к
какой-либо рамке, она преобразует рамку и вызывает исходную рисовалку по
отношению к ней. Аргументами @code{transform-painter} служат точки
(представленные в виде векторов), указывающие углы новой рамки: будучи
отображенной на рамку, первая точка указывает исходную точку новой
рамки, а две других --- концы краевых векторов. Таким образом,
аргументы, лежащие в пределах единичного квадрата, определяют рамку,
которая содержится внутри исходной рамки.

@lisp
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame
                  new-origin
                  (sub-vect (m corner1) new-origin)
                  (sub-vect (m corner2) new-origin)))))))
@end lisp

@noindent
Вот как перевернуть изображение в рамке вертикально:

@lisp
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   @r{; new @code{origin}}
                     (make-vect 1.0 1.0)   @r{; new end of @code{edge1}}
                     (make-vect 0.0 0.0))) @r{; new end of @code{edge2}}
@end lisp

@noindent
При помощи @code{transform-painter} нам нетрудно будет определять новые
трансформации. Например, можно определить рисовалку, которая рисует
уменьшенную копию исходного изображения в верхней правой четверти рамки:

@lisp
(define (shrink-to-upper-right painter)
  (transform-painter
   painter (make-vect 0.5 0.5)
   (make-vect 1.0 0.5) (make-vect 0.5 1.0)))
@end lisp

@noindent
Вот трансформация, которая поворачивает изображение на 90 градусов
против часовой стрелки:@footnote{@code{Rotate90} представляет собой
чистый поворот только для квадратных рамок, поскольку она еще
растягивает и сплющивает изображение так, чтобы оно уместилось в
повернутой рамке.}

@lisp
(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
@end lisp

@noindent
А эта сжимает изображение по направлению к центру
рамки:@footnote{Ромбовидные изображения на рисунках @ref{Рисунок 2.10}
и @ref{Рисунок 2.11} были получены с помощью @code{squash-inwards},
примененной к @code{wave} и @code{rogers}.}:

@lisp
(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
@end lisp

@noindent
Преобразования рамок являются также основой для определения средств
комбинирования двух или более рисовалок. Например, процедура
@code{beside} берет две рисовалки, трансформирует их так, чтобы они
работали соответственно в левой и правой половинах рамки-аргумента, и
создает новую составную рисовалку. Когда составной рисовалке передается
рамка, она вызывает первую из преобразованных рисовалок над левой
половиной рамки, а вторую над правой половиной:

@lisp
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter
            painter1
            (make-vect 0.0 0.0)
            split-point
            (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter
            painter2
            split-point
            (make-vect 1.0 0.0)
            (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
@end lisp

@noindent
Обратите внимание, как абстракция данных, и особенно представление
рисовалок в виде процедур, облегчает реализацию @code{beside}. Процедуре
@code{beside} не требуется ничего знать о деталях рисовалок-компонент,
кроме того, что каждая из них что-то изобразит в указанной ей рамке.

@quotation
@strong{@anchor{Упражнение 2.50}Упражнение 2.50:}
Определите преобразование @code{flip-horiz}, которое
обращает изображение вокруг горизонтальной оси, а также преобразования,
которые вращают рисовалки против часовой стрелки на 180 и 270 градусов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.51}Упражнение 2.51:}
Определите для рисовалок операцию @code{below}.
@code{Below} принимает в качестве аргументов две рисовалки. Когда
получившейся рисовалке передается рамка, она рисует в нижней ее половине
при помощи первой рисовалки, а в верхней при помощи второй. Определите
@code{below} двумя способами --- один раз аналогично процедуре
@code{beside}, как она приведена выше, а второй раз через @code{beside}
и операции вращения (см. упражнение @ref{Упражнение 2.50}).
@end quotation

@comment @subsubheading Levels of language for robust design
@subsubheading Уровни языка помогают устойчивому проектированию

Язык построения изображений использует некоторые из важнейших введенных
нами идей, относящихся к абстракции процедур и данных. Базовая
абстракция данных, рисовалки, реализуется при помощи процедурного
представления, и благодаря этому наш язык может работать с различными
графическими системами единым образом. Средства комбинирования обладают
свойством замыкания, и это позволяет нам легко возводить сложные
построения. Наконец, все средства абстракции процедур доступны нам для
того, чтобы абстрагировать средства комбинирования рисовалок.

Нам удалось бросить взгляд и еще на одну существеннейшую идею касательно
проектирования языков и программ. Это подход (@newterm{stratified design}),
представление, что сложной системе нужно придавать структуру при помощи
последовательности уровней, которая описывается последовательностью
языков. Каждый из уровней строится путем комбинации частей, которые на
этом уровне рассматриваются как элементарные, и части, которые строятся
на каждом уровне, работают как элементарные на следующем уровне. Язык,
который используется на каждом уровне такого проекта, включает
примитивы, средства комбинирования и абстракции, соответствующие этому
уровню подробности.

Уровневое проектирование пронизывает всю технику построения сложных
систем. Например, при проектировании компьютеров резисторы и транзисторы
сочетаются (и описываются при помощи языка аналоговых схем), и из них
строятся и-, или- элементы и им подобные, служащие основой языка
цифровых схем.@footnote{Один из таких языков описывается в
разделе @ref{3.3.4}.}
Из этих элементов строятся процессоры, шины и системы памяти, которые в
свою очередь служат элементами в построении компьютеров при помощи
языков, подходящих для описания компьютерной архитектуры. Компьютеры,
сочетаясь, дают распределенные системы, которые описываются при помощи
языков описания сетевых взаимодействий, и так далее.

Как миниатюрный пример уровневого подхода, наш язык описания изображений
использует элементарные объекты (элементарные рисовалки), создаваемые
при помощи языка, в котором описываются точки и линии и создаются списки
отрезков для рисовалки @code{segments@/->@/painter} либо градации серого
цвета в рисовалке вроде @code{rogers}. Большей частью наше описание
языка картинок было сосредоточено на комбинировании этих примитивов с
помощью геометрических комбинаторов вроде @code{beside} и @code{below}.
Работали мы и на более высоком уровне, где @code{beside} и @code{below}
рассматривались как примитивы, манипулируемые языком, операции которого,
такие как @code{square-of-four}, фиксируют стандартные схемы сочетания
геометрических комбинаторов.

Уровневое проектирование помогает придать программам (@newterm{robustness}), то
есть повышает вероятность, что небольшое изменение в спецификации
потребует относительно малых изменений в программе. Например,
предположим, что нам нужно изменить картинку, основанную на рисовалке
@code{wave}, которая показана на рисунке @ref{Рисунок 2.9}. Мы можем
работать на самом низком уровне, изменяя конкретный вид элемента
@code{wave}; можем работать на промежуточном уровне и менять то, как
@code{corner-split} воспроизводит @code{wave}; можем на самом высоком
уровне изменять то, как @code{square-limit} расставляет четыре копии по
углам. В общем, каждый уровень такого проекта дает свой словарь для
описания характеристик системы и свой тип возможных изменений.

@quotation
@strong{@anchor{Упражнение 2.52}Упражнение 2.52:}
Измените предел квадрата рисовалки @code{wave}, показанный
на рисунке @ref{Рисунок 2.9}, работая на каждом из вышеописанных
уровней. А именно:

@enumerate a.

@item
Добавьте новые отрезки к элементарной рисовалке @code{wave} из
упражнения @ref{Упражнение 2.49} (например, изобразив улыбку).

@item
Измените шаблон, который порождает @code{corner-split} (например,
используя только одну копию образов @code{up-split} и @code{right-split}
вместо двух).

@item
Измените версию @code{square-limit}, использующую @code{square-of-four},
так, чтобы углы компоновались как-нибудь по-другому. (Например, можно
сделать так, чтобы большой мистер Роджерс выглядывал из каждого угла
квадрата.)

@end enumerate
@end quotation

@comment @section Symbolic Data
@section Символьные данные
@node	2.3, 2.4, 2.2, Глава 2

Все составные объекты данных, которые мы до сих пор использовали,
состояли, в конечном счете, из чисел. В этом разделе мы расширяем
возможности представления нашего языка, разрешая использовать в качестве
данных произвольные символы.

@menu
* 2-3-1::             Кавычки
* 2-3-2::             Пример символьное дифференцирование
* 2-3-3::             Пример представление множеств
* 2-3-4::             Пример деревья кодирования по Хаффману
@end menu

@comment @subsection Quotation
@subsection Кавычки
@node	2.3.1, 2.3.2, 2.3, 2.3

Раз теперь нам можно формировать составные данные, используя символы, мы
можем пользоваться списками вроде

@lisp
(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
@end lisp

@noindent
Списки, содержащие символы, могут выглядеть в точности как выражения
нашего языка:

@lisp
(* (+ 23 45)
   (+ x 9))
(define (fact n)
  (if (= n 1) 1 (* n (fact (- n 1)))))
@end lisp

@noindent
Чтобы работать с символами, нам в языке нужен новый элемент: способность
(@newterm{quote}) объект данных. Допустим, нам хочется построить список
@code{(a b)}. Этого нельзя добиться через @code{(list a b)}, поскольку
это выражение строит список из значений @newterm{values} символов @code{a} и
@code{b}, а не из них самих. Этот вопрос хорошо изучен по отношению к
естественным языкам, где слова и предложения могут рассматриваться либо
как семантические единицы, либо как строки символов (синтаксические
единицы). В естественных языках обычно используют кавычки, чтобы
обозначить, что слово или предложение нужно рассматривать буквально как
строку символов. Например, первая буква <<Джона>> --- разумеется,
<<Д>>. Если мы говорим кому-то <<скажите, как Вас зовут>>, мы ожидаем
услышать имя этого человека. Если же мы говорим кому-то <<скажите ``как
Вас зовут''>>, то мы ожидаем услышать слова <<как Вас зовут>>. Заметьте,
как, для того, чтобы описать, что должен сказать кто-то другой, нам
пришлось использовать кавычки.@footnote{Когда мы разрешаем в языке
кавычки, это разрушает нашу способность говорить о языке в простых
терминах, поскольку становится неверным, что равнозначные выражения
можно подставлять друг вместо друга. Например, три есть два плюс один,
но слово <<три>> не есть слова <<два плюс один>>. Кавычки являются
мощным инструментом, поскольку они дают нам способ строить выражения,
которые работают с другими выражениями (как мы убедимся в
главе @ref{Глава 4},
когда станем писать интерпретатор). Однако как только мы разрешаем в
языке выражения, которые говорят о других выражениях того же языка,
становится очень сложно соблюдать в каком-либо виде принцип <<равное
можно заменить равным>>. Например, если мы знаем, что утренняя и
вечерняя звезда --- одно и то же, то из утверждения <<вечерняя
звезда --- это Венера>> мы можем заключить, что <<утренняя звезда ---
это Венера>>. Однако если нам дано, что <<Джон знает, что вечерняя
звезда --- это Венера>>, мы не можем заключить, что <<Джон знает, что
утренняя звезда --- это Венера>>.}

Чтобы обозначать списки и символы, с которыми нужно обращаться как с
объектами данных, а не как с выражениями, которые нужно вычислить, мы
можем следовать тому же обычаю. Однако наш формат кавычек отличается от
принятого в естественных языках тем, что мы ставим знак кавычки (по
традиции, это символ одинарной кавычки @code{'}) только в начале того
объекта, который надо закавычить. В Scheme это сходит нам с рук,
поскольку для разделения объектов мы полагаемся на пробелы и скобки.
Таким образом, значением одинарной кавычки является требование
закавычить следующий объект.@footnote{Одинарная кавычка отличается от
двойной, которую мы использовали для обозначения строк, выводимых на
печать. В то время как одинарную кавычку можно использовать для
обозначения списков символов, двойная кавычка используется только со
строками, состоящими из печатных знаков. Единственное, для чего такие
строки используются в нашей книге --- это печать.}

Теперь мы можем отличать символы от их значений:

@lisp
(define a 1)
(define b 2)
(list a b)
@i{(1 2)}
(list 'a 'b)
@i{(a b)}
(list 'a b)
@i{(a 2)}
@end lisp

@noindent
Кроме того, кавычки позволяют нам вводить составные объекты, используя
обычное представление для печати списков:@footnote{Строго говоря, то,
как мы используем кавычку, нарушает общее правило, что все сложные
выражения нашего языка должны отмечаться скобками и выглядеть как
списки. Мы можем восстановить эту закономерность, введя особую форму @code{quote},
которая служит тем же целям, что и кавычка. Таким образом, мы можем
печатать @code{(quote a)} вместо @code{'a} и @code{(quote (a b c))}
вместо @code{'(a b c)}. Именно так и работает интерпретатор. Знак
кавычки --- это просто сокращение, означающее, что следующее выражение
нужно завернуть в форму @code{quote} и получить
@math{\hbox{\ttfamily(quote}\;\langle\kern0.06em\hbox{\ttfamily\slshape выражение}\kern0.08em\rangle\hbox{\ttfamily)}}.
Это важно потому, что таким
образом соблюдается принцип, что с любым выражением, которое видит
интерпретатор, можно обращаться как с объектом данных. Например, можно
получить выражение @code{(car '(a b c))}, и это будет то же самое, что и
@code{(car (quote (a b c)))}, вычислив
@code{(list 'car (list 'quote '(a b c)))}.}

@lisp
(car '(a b c))
@i{a}
(cdr '(a b c))
@i{(b c)}
@end lisp

@noindent
Действуя в том же духе, пустой список мы можем получить, вычисляя
@code{'()}, и таким образом избавиться от переменной @code{nil}.

Еще один примитив, который используется при работе с символами --- это
@code{eq?}, который берет в качестве аргументов два символа и проверяет,
совпадают ли они.@footnote{Можно считать, что два символа <<совпадают>>,
если они состоят из одних и тех же печатных знаков в одинаковом порядке.
Такое определение обходит важный вопрос, который мы пока не готовы
обсуждать: значение <<одинаковости>> в языке программирования. К нему мы
вернемся в главе @ref{Глава 3} (раздел @ref{3.1.3}.}
С помощью @code{eq?} можно реализовать полезную процедуру, называемую
@code{memq}. Она принимает два аргумента, символ и список. Если символ
не содержится в списке (то есть, не равен в смысле @code{eq?} ни одному
из элементов списка), то @code{memq} возвращает ложь. В противном случае
она возвращает подсписок списка, начиная с первого вхождения символа:

@lisp
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
@end lisp

@noindent
Например, значение

@lisp
(memq 'apple '(pear banana prune))
@end lisp

@noindent
есть ложь, в то время как значение

@lisp
(memq 'apple '(x (apple sauce) y apple pear))
@end lisp

@noindent
есть @code{(apple pear)}.

@quotation
@strong{@anchor{Упражнение 2.53}Упражнение 2.53:}
Что напечатает интерпретатор в ответ на каждое из следующих выражений?

@lisp
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.54}Упражнение 2.54:}
Предикат @code{equal?} для двух списков возвращает истину,
если они содержат одни и те же элементы в одинаковом порядке. Например,

@lisp
(equal? '(this is a list) '(this is a list))
@end lisp

@noindent
истинно, но

@lisp
(equal? '(this is a list) '(this (is a) list))
@end lisp

@noindent
ложно. Более точно, можно определить @code{equal?} рекурсивно в терминах
базового равенства символов @code{eq?}, сказав, что @code{a} равно
@code{b}, если оба они символы и для них выполняется @code{eq?} либо оба
они списки и при этом верно, что @code{(car a)} равняется в смысле
@code{equal?} @code{(car b)}, а @code{(cdr a)} равняется в смысле
@code{equal?} @code{(cdr b)}. Пользуясь этой идеей, напишите
@code{equal?} в виде процедуры.@footnote{На практике программисты
используют @code{equal?} для сравнения не только символов, но и чисел.
Числа не считаются символами. Вопрос о том, выполняется ли @code{eq?}
для двух чисел, которые равны между собой (в смысле @code{=}), очень
сильно зависит от конкретной реализации. Более правильное определение
@code{equal?} (например, то, которое входит в Scheme как элементарная
процедура) должно содержать условие, что если и @code{a}, и @code{b}
являются числами, то @code{equal?} для них выполняется тогда, когда они
численно равны.}
@end quotation

@quotation
@strong{@anchor{Упражнение 2.55}Упражнение 2.55:}
Ева Лу Атор вводит при работе с интерпретатором выражение

@lisp
(car ''abracadabra)
@end lisp

К ее удивлению, интерпретатор печатает @code{quote}. Объясните.

@end quotation

@comment @subsection Example: Symbolic Differentiation
@subsection Пример: символьное дифференцирование
@node	2.3.2, 2.3.3, 2.3.1, 2.3

Как иллюстрацию к понятию символьной обработки, а также как
дополнительный пример абстракции данных, рассмотрим построение
процедуры, которая производит символьное дифференцирование
алгебраических выражений. Нам хотелось бы, чтобы эта процедура принимала
в качестве аргументов алгебраическое выражение и переменную, и чтобы она
возвращала производную выражения по отношению к этой переменной.
Например, если аргументами к процедуре служат @math{ax^2 + bx + c}
и @math{x}, процедура должна возвращать @math{2ax + b}.
Символьное дифференцирование имеет для Лиспа особое историческое
значение. Оно было одним из побудительных примеров при разработке
компьютерного языка для обработки символов. Более того, оно послужило
началом линии исследований, приведшей к разработке мощных систем для
символической математической работы, которые сейчас все больше
используют прикладные математики и физики.

При разработке программы для символьного дифференцирования мы будем
следовать той же самой стратегии абстракции данных, согласно которой мы
действовали при разработке системы рациональных чисел в
разделе @ref{2.1.1}. А именно, сначала
мы разработаем алгоритм дифференцирования, который работает с
абстрактными объектами, такими как <<суммы>>, <<произведения>> и
<<переменные>>, не обращая внимания на то, как они должны быть
представлены. Только после этого мы обратимся к задаче представления.

@comment @subsubheading The differentiation program with abstract data
@subsubheading Программа дифференцирования с абстрактными данными

Чтобы упростить задачу, мы рассмотрим простую программу символьного
дифференцирования, которая работает с выражениями, построенными только
при помощи операций сложения и умножения с двумя аргументами.
Дифференцировать любое такое выражение можно, применяя следующие правила
редукции:
@ifinfo

@example
dc
-- = 0  for c a constant, or a variable different from x
dx

dx
-- = 1
dx

d(u + v)   du   dv
-------- = -- + --
   dx      dx   dx

d(uv)     / dv \     / du \
----- = u | -- | + v | -- |
 dx       \ dx /     \ dx /
@end example

@end ifinfo
@tex
$$
{{\it dc} \over {\it dx}} 		= 0,
    \quad {\rm for\ } c\ {\rm a\ constant\ or\ a\ variable\ different\ from\ } x,
$$
@end tex
@tex
$$
{{\it dx} \over {\it dx}} 		= 1,
$$
@end tex
@tex
$$
{{\it d\,(u + v\,)} \over {\it dx}} 	= {{\it du} \over {\it dx}} + {{\it dv} \over {\it dx}},
$$
@end tex
@tex
$$
{{\it d\,(uv\,)} \over {\it dx}} 	= u {{\it dv} \over {\it dx}} + v {{\it du} \over {\it dx}}.
$$
@end tex
@noindent
Заметим, что два последних правила по сути своей рекурсивны. То есть,
чтобы получить производную суммы, нам сначала нужно получить производные
слагаемых и их сложить. Каждое из них в свою очередь может быть
выражением, которое требуется разложить на составляющие. Разбивая их на
все более мелкие части, мы в конце концов дойдем до стадии, когда все
части являются либо константами, либо переменными, и их производные
будут равны либо 0, либо 1.

Чтобы воплотить эти правила в виде процедуры, мы позволим себе немного
помечтать, подобно тому, как мы делали при реализации рациональных
чисел. Если бы у нас был способ представления алгебраических выражений,
мы могли бы проверить, является ли выражение суммой, произведением,
константой или переменной. Можно было бы извлекать части выражений.
Например, для суммы мы хотели бы уметь получать первое и второе
слагаемое. Еще нам нужно уметь составлять выражения из частей. Давайте
предположим, что у нас уже есть процедуры, которые реализуют следующие
селекторы, конструкторы и предикаты:

@lisp
(variable? e)            @r{Является ли @code{e} переменной?}
(same-variable? v1 v2)   @r{Является ли @code{v1} and @code{v2} одной и той же переменной?}
(sum? e)                 @r{Является ли @code{e} суммой?}
(addend e)               @r{Первое слагаемое суммы @code{e}.}
(augend e)               @r{Второе слагаемое суммы @code{e}.}
(make-sum a1 a2)         @r{Строит сумму @code{a1} и @code{a2}.}
(product? e)             @r{Является ли @code{e} произведением?}
(multiplier e)           @r{Первый множитель произведения@code{e}.}
(multiplicand e)         @r{Второй множитель произведения @code{e}.}
(make-product m1 m2)     @r{Строит произведение @code{m1} и @code{m2}.}
@end lisp

@noindent
При помощи этих процедур и элементарного предиката @code{number?},
который распознает числа, мы можем выразить правила дифференцирования в
виде следующей процедуры:

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
@end lisp

@noindent
Процедура @code{deriv} заключает в себе весь алгоритм дифференцирования.
Поскольку она выражена в терминах абстрактных данных, она будет
работать, как бы мы ни представили алгебраические выражения, если только
у нас будут соответствующие селекторы и конструкторы. Именно этим
вопросом нам и нужно теперь заняться.

@comment @subsubheading Representing algebraic expressions
@subsubheading Представление алгебраических выражений

Можно представить себе множество способов представления алгебраических
выражений с помощью списковых структур. Например, можно использовать
списки символов, которые отражали бы обычную алгебраическую нотацию, так
что @math{ax + b} представлялось бы как список @code{(a * x + b)}.
Однако естественней всего использовать ту же скобочную префиксную
запись, с помощью которой в Лиспе представляются комбинации; то есть
представлять @math{ax + b} в виде @code{(+ (* a x) b)}.
Тогда наше представление данных для задачи дифференцирования будет следующим:

@itemize @bullet

@item
Переменные --- это символы. Они распознаются элементарным предикатом
@code{symbol?}:

@lisp
(define (variable? x) (symbol? x))
@end lisp

@item
Две переменные одинаковы, если для представляющих их символов
выполняется @code{eq?}:

@lisp
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
@end lisp

@item
Суммы и произведения конструируются как списки:

@lisp
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
@end lisp

@item
Сумма --- это список, первый элемент которого символ @code{+}:

@lisp
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
@end lisp

@item
Первое слагаемое --- это второй элемент списка, представляющего сумму:

@lisp
(define (addend s) (cadr s))
@end lisp

@item
Второе слагаемое --- это третий элемент списка, представляющего сумму:

@lisp
(define (augend s) (caddr s))
@end lisp

@item
Произведение --- это список, первый элемент которого символ @code{*}:

@lisp
(define (product? x) (and (pair? x) (eq? (car x) '*)))
@end lisp

@item
Первый множитель --- это второй элемент списка, представляющего
произведение:

@lisp
(define (multiplier p) (cadr p))
@end lisp

@item
Второй множитель --- это третий элемент списка, представляющего
произведение:

@lisp
(define (multiplicand p) (caddr p))
@end lisp

@end itemize

@noindent
Таким образом, нам осталось только соединить это представление с
алгоритмом, заключенным в процедуре @code{deriv}, и мы получаем
работающую программу символьного дифференцирования. Посмотрим на
некоторые примеры ее поведения:

@lisp
(deriv '(+ x 3) 'x)
@i{(+ 1 0)}
(deriv '(* x y) 'x)
@i{(+ (* x 0) (* 1 y))}
(deriv '(* (* x y) (+ x 3)) 'x)
@i{(+ (* (* x y) (+ 1 0))}
   @i{(* (+ (* x 0) (* 1 y))}
      @i{(+  x 3)))}
@end lisp

@noindent
Ответы, которые выдает программа, правильны; однако их нужно упрощать.
Верно, что
@ifinfo

@example
d(xy)
----- = x * 0 + 1 * y
 dx
@end example

@end ifinfo
@tex
$$ {{\it d\,(xy\,)} \over {\it dx}} = x \cdot 0 + 1 \cdot y, $$
@end tex
@noindent
но нам хотелось бы, чтобы программа знала, что @math{x \cdot 0 = 0},
@math{1 \cdot y = y}, а @math{0 + y = y}. Ответом на второй
пример должно быть просто @math{y}. Как видно из
третьего примера, при усложнении выражений упрощение превращается в
серьезную проблему.

Наши теперешние затруднения очень похожи на те, с которыми мы
столкнулись при реализации рациональных чисел: мы не привели ответы к
простейшей форме. Чтобы произвести приведение рациональных чисел, нам
потребовалось изменить только конструкторы и селекторы в нашей
реализации. Здесь мы можем применить подобную же стратегию. Процедуру
@code{deriv} мы не будем изменять вовсе. Вместо этого мы изменим
@code{make-sum} так, что если оба слагаемых являются числами, она их
сложит и вернет их сумму. Кроме того, если одно из слагаемых равно 0, то
@code{make-sum} вернет другое.

@lisp
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
@end lisp

@noindent
Здесь используется процедура @code{=number?}, которая проверяет, не
равно ли выражение определенному числу:

@lisp
(define (=number? exp num) (and (number? exp) (= exp num)))
@end lisp

@noindent
Подобным же образом мы изменим и @code{make-product}, так. чтобы
встроить в него правила, что нечто, умноженное на 0, есть 0, а
умноженное на 1 равно самому себе:

@lisp
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
@end lisp

@noindent
Вот как эта версия работает на наших трех примерах:

@lisp
(deriv '(+ x 3) 'x)
@i{1}
(deriv '(* x y) 'x)
@i{y}
(deriv '(* (* x y) (+ x 3)) 'x)
@i{(+ (* x y) (* y (+ x 3)))}
@end lisp

@noindent
Хотя это заметное улучшение, третий пример показывает, что нужно многое
еще сделать, прежде чем мы получим программу, приводящую выражения к
форме, которую мы согласимся считать <<простейшей>>. Задача
алгебраического упрощения сложна, среди прочего, еще и потому, что
форма, которая является простейшей для одних целей, может таковой не
являться для других.

@quotation
@strong{@anchor{Упражнение 2.56}Упражнение 2.56:}
Покажите, как расширить простейшую программу
дифференцирования так, чтобы она воспринимала больше разных типов
выражений. Например, реализуйте правило взятия производной
@ifinfo

@example
d(u^n)            du
------ = nu^(n-1) --
  dx              dx
@end example

@end ifinfo
@tex
$$ {{\it d\,(u^n\,)} \over {\it dx}} = nu^{n-1} {{\it du} \over {\it dx}} $$
@end tex
@noindent
добавив еще одну
проверку к программе @code{deriv} и определив соответствующие процедуры
@code{exponentiation?}, @code{base}, @code{exponent} и
@code{make-exponentiation} (обозначать возведение в степень можно
символом @code{*}). Встройте правила, что любое выражение, возведенное в
степень 0, дает 1, а возведенное в степень 1 равно самому себе.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.57}Упражнение 2.57:}
Расширьте программу дифференцирования так, чтобы она
работала с суммами и произведениями любого (больше двух) количества
термов. Тогда последний из приведенных выше примеров мог бы быть записан
как

@lisp
(deriv '(* x y (+ x 3)) 'x)
@end lisp

Попытайтесь сделать это, изменяя только представление сумм и
произведений, не трогая процедуру @code{deriv}. Тогда, например,
процедура @code{addend} будет возвращать первое слагаемое суммы, а
@code{augend} сумму остальных.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.58}Упражнение 2.58:}
Предположим, что нам захотелось изменить программу
дифференцирования так, чтобы она работала с обычной математической
нотацией, где @code{+} и @code{*} не префиксные, а инфиксные операции.
Поскольку программа взятия производных определена в терминах абстрактных
данных, мы можем изменять представление выражений, с которыми она
работает, меняя только предикаты, селекторы и конструкторы, определяющие
представление алгебраических выражений, с которыми должен работать
дифференциатор.

@enumerate a.

@item
Покажите, как это сделать так, чтобы брать производные от выражений,
представленных в инфиксной форме, например
@code{(x + (3 * (x + (y + 2))))}. Для упрощения задачи предположите, что
@code{+} и @code{*} всегда принимают по два аргумента, и что в выражении
расставлены все скобки.

@item
Задача становится существенно сложней, если мы разрешаем стандартную
алгебраическую нотацию, например @code{(x + 3 * (x + y + 2))}, которая
опускает ненужные скобки и предполагает, что умножение выполняется
раньше, чем сложение. Можете ли Вы разработать соответствующие
предикаты, селекторы и конструкторы для этой нотации так, чтобы наша
программа взятия производных продолжала работать?

@end enumerate
@end quotation

@comment @subsection Example: Representing Sets
@subsection Пример: представление множеств
@node	2.3.3, 2.3.4, 2.3.2, 2.3

В предыдущих примерах мы построили представления для двух типов
составных объектов: для рациональных чисел и для алгебраических
выражений. В одном из этих примеров перед нами стоял выбор, упрощать ли
выражение при его конструировании или при обращении; в остальном же
выбор представления наших структур через списки был простым делом. Когда
мы обращаемся к представлению множеств, выбор представления не так
очевиден. Здесь существует несколько возможных представлений, и они
значительно отличаются друг от друга в нескольких аспектах.

Говоря неформально, множество есть просто набор различных объектов.
Чтобы дать ему более точное определение, можно использовать метод
абстракции данных. А именно, мы определяем <<множество>>, указывая
операции, которые можно производить над множествами. Это операции
@code{union-set} (объединение), @code{intersection-set} (пересечение),
@code{element-of-set?} (проверка на принадлежность) и @code{adjoin-set}
(добавление элемента). @code{Element-of-set?} --- это предикат, который
определяет, является ли данный объект элементом множества.
@code{Adjoin-set} принимает как аргументы объект и множество, и
возвращает множество, которое содержит все элементы исходного множества
плюс добавленный элемент. вычисляет объединение двух множеств, то есть
множество, содержащее те элементы, которые присутствуют хотя бы в одном
из аргументов. @code{Intersection-set} вычисляет пересечение двух
множеств, то есть множество, которое содержит только те элементы,
которые присутствуют в обоих аргументах. С точки зрения абстракции
данных, мы имеем право взять любое представление, позволяющее нам
использовать эти операции способом, который согласуется с вышеуказанной
интерпретацией.@footnote{Если нам хочется быть более формальными, мы
можем определить <<соответствие вышеуказанной интерпретации>> как
условие, что операции удовлетворяют некоторому набору правил вроде
следующих:

@noindent
@math{\bullet} Для любого множества @code{S} и любого объекта @code{x},
@code{(element-of-set? x (adjoin-set x S))} истинно (неформально:
<<добавление объекта к множеству дает множество, содержащее этот
объект>>).

@noindent
@math{\bullet} Для любых двух множеств @code{S} и @code{T} и любого объекта @code{x},
@code{(element-of-set? x (union-set S T))} равно
@code{(or (element-of-set? x S) (element-of-set? x T))} (неформально:
<<элементы @code{(union-set S T)} --- это те элементы, которые
принадлежат либо @code{S}, либо @code{T}>>).

@noindent
@math{\bullet} Для любого объекта @code{x}, @code{(element-of-set? x '())} ложно
(неформально: <<ни один объект не принадлежит пустому множеству>>).}

@comment @subsubheading Sets as unordered lists
@subsubheading Множества как неупорядоченные списки

Можно представить множество как список, в котором ни один элемент не
содержится более одного раза. Пустое множество представляется пустым
списком. При таком представлении @code{element-of-set?} подобен
процедуре @code{memq} из раздела @ref{2.3.1}. Она использует
не @code{eq?}, а @code{equal?}, так что элементы множества не обязаны
быть символами:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
@end lisp

@noindent
Используя эту процедуру, мы можем написать @code{adjoin-set}. Если
объект, который требуется добавить, уже принадлежит множеству, мы просто
возвращаем исходное множество. В противном случае мы используем
@code{cons}, чтобы добавить объект к списку. представляющему множество:

@lisp
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
@end lisp

@noindent
Для @code{intersection-set} можно использовать рекурсивную стратегию.
Если мы знаем, как получить пересечение @code{set2} и @code{cdr} от
@code{set1}, нам нужно только понять, надо ли добавить к нему @code{car}
от @code{set1}. Это зависит от того, принадлежит ли @code{(car set1)}
еще и @code{set2}. Получается такая процедура:

\enlargethispage{\baselineskip}

@lisp
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
@end lisp

@noindent
Один из вопросов, которые должны нас заботить при разработке
реализации --- эффективность. Рассмотрим число шагов, которые требуют
наши операции над множествами. Поскольку все они используют
@code{element-of-set?}, скорость этой операции оказывает большое влияние
на скорость реализации в целом. Теперь заметим, что для того, чтобы
проверить, является ли объект элементом множества, процедуре
@code{element-of-set?} может потребоваться просмотреть весь список. (В
худшем случае оказывается, что объекта в списке нет.) Следовательно,
если в множестве @math{n} элементов, @code{element-of-set?} может
затратить до @math{n} шагов. Таким образом, число требуемых шагов растет
как @math{\Theta (n)}. Число шагов, требуемых @code{adjoin-set}, которая
эту операцию использует, также растет как @math{\Theta (n)}. Для
@code{intersection-set}, которая проделывает @code{element-of-set?} для
каждого элемента @code{set1}, число требуемых шагов растет как
произведение размеров исходных множеств, или @math{\Theta (n^2)} для
двух множеств размера @math{n}. То же будет верно и для
@code{union-set}.

@quotation
@strong{@anchor{Упражнение 2.59}Упражнение 2.59:}
Реализуйте операцию @code{union-set} для представления
множеств в виде неупорядоченных списков.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.60}Упражнение 2.60:}
Мы указали, что множество представляется как список без
повторяющихся элементов. Допустим теперь, что мы разрешаем повторяющиеся
элементы. Например, множество @math{\{1, 2, 3\}} могло бы быть
представлено как список @code{(2 3 2 1 3 2 2)}. Разработайте процедуры
@code{element-of-set?}, @code{adjoin-set}, @code{union-@/set} и
@code{intersection-set}, которые бы работали с таким представлением. Как
соотносится эффективность этих операций с эффективностью соответствующих
процедур для представления без повторений? Существуют ли приложения, в
которых Вы бы использовали скорее это представление, чем представление
без повторений?
@end quotation

@comment @subsubheading Sets as ordered lists
@subsubheading Множества как упорядоченные списки

Один из способов ускорить операции над множествами состоит в том, чтобы
изменить представление таким образом, чтобы элементы множества
перечислялись в порядке возрастания. Для этого нам потребуется способ
сравнения объектов, так, чтобы можно было сказать, какой из них больше.
Например, символы мы могли бы сравнивать лексикографически, или же мы
могли бы найти какой-нибудь способ ставить каждому объекту в
соответствие некоторое уникальное число и затем сравнивать объекты путем
сравнения соответствующих чисел. Чтобы упростить обсуждение, мы
рассмотрим только случай, когда элементами множества являются числа, так
что мы сможем сравнивать элементы при помощи @code{>} и @code{<}. Мы
будем представлять множество чисел как список его элементов в
возрастающем порядке. В то время как первая наша реализация позволяла
нам представлять множество @math{\{1, 3, 6, 10\}} путем перечисления его
элементов в произвольном порядке, в новом представлении разрешен только
список @code{(1 3 6 10)}.

Одно из преимуществ упорядочения проявляется в @code{element-of-set?}:
проверяя наличие элемента, нам больше незачем просматривать все
множество. Если мы достигли элемента, который больше того объекта,
который мы ищем, мы можем уже сказать, что искомого в списке нет:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))
@end lisp

@noindent
Сколько шагов мы на этом выигрываем? В худшем случае, объект, который мы
ищем, может быть наибольшим в множестве, так что число шагов то же, что
и для неупорядоченного представления. С другой стороны, если мы ищем
элементы разных размеров, можно ожидать, что иногда мы сможем
останавливаться близко к началу списка, а иногда нам все же потребуется
просмотреть большую его часть. В среднем мы можем ожидать, что
потребуется просмотреть около половины элементов множества. Таким
образом, среднее число требуемых шагов будет примерно @math{n / 2}. Это
все еще рост порядка @math{\Theta (n)}, но это экономит
нам в среднем половину числа шагов по сравнению с предыдущей реализацией.

Более впечатляющее ускорение мы получаем в @code{intersection-set}. При
неупорядоченном представлении эта операция требовала @math{\Theta (n^2)}
шагов, поскольку мы производили полный поиск в @code{set2} для каждого
элемента @code{set1}. Однако при упорядоченном представлении мы можем
воспользоваться более разумным методом. Начнем со сравнения первых
элементов двух множеств, @code{x1} и @code{x2}. Если @code{x1} равно
@code{x2}, мы получаем один элемент пересечения, а остальные элементы
пересечения мы можем получить, пересекая оставшиеся элементы
списков-множеств. Допустим, однако, что @code{x1} меньше, чем @code{x2}.
Поскольку @code{x2} --- наименьший элемент @code{set2}, мы можем
немедленно заключить, что @code{x1} больше нигде в @code{set2} не может
встретиться и, следовательно, не принадлежит пересечению. Следовательно
пересечение двух множеств равно пересечению @code{set2} с @code{cdr} от
@code{set1}. Подобным образом, если @code{x2} меньше, чем @code{x1}, то
пересечение множеств получается путем пересечения @code{set1} с
@code{cdr} от @code{set2}. Вот процедура:

@lisp
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1)
                                          (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
@end lisp

@noindent
Чтобы оценить число шагов, необходимое для этого процесса, заметим, что
на каждом шагу мы сводим задачу нахождения пересечения к вычислению
пересечения меньших множеств --- убирая первый элемент либо из
@code{set1}, либо из @code{set2}, либо из обоих. Таким образом, число
требуемых шагов не больше суммы размеров @code{set1} и @code{set2}, а не
их произведения, как при неупорядоченном представлении. Это рост
@math{\Theta (n)}, а не @math{\Theta (n^2)} --- заметное ускорение,
даже для множеств небольшого размера.

@quotation
@strong{@anchor{Упражнение 2.61}Упражнение 2.61:}
Напишите реализацию @code{adjoin-set} для упорядоченного
представления. По аналогии с @code{element-of-set?} покажите, как
использовать упорядочение, чтобы получить процедуру, которая в среднем
требует только половину числа шагов, которое требуется при
неупорядоченном представлении.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.62}Упражнение 2.62:}
Дайте представление порядка @math{\Theta (n)} для операции
@code{union-set} с представлением в виде упорядоченных списков.
@end quotation

@comment @subsubheading Sets as binary trees
@subsubheading Множества как бинарные деревья

Можно добиться еще лучших результатов, чем при представлении в виде
упорядоченных списков, если расположить элементы множества в виде
дерева. Каждая вершина дерева содержит один элемент множества,
называемый <<входом>> этой вершины, и указатели (возможно, пустые) на
две другие вершины. <<Левый>> указатель указывает на элементы, меньшие,
чем тот, который содержится в вершине, а <<правый>> на элементы,
большие, чем тот, который содержится в вершине. На
рисунке @ref{Рисунок 2.16} показано несколько вариантов представления
множества @math{\{1, 3, 5, 7, 9, 11\}} в виде дерева. Одно и то же
множество может быть представлено в виде дерева несколькими различными
способами. Единственное, чего мы требуем от правильного
представления --- это чтобы все элементы левого поддерева были меньше,
чем вход вершины, а элементы правого поддерева больше.

@float
@quotation
@anchor{Рисунок 2.16}
@ifinfo
@strong{Рисунок 2.16:} Various binary trees that represent the set @math{\{1, 3, 5, 7, 9, 11\}}.

@example
   7          3             5
   /\         /\            /\
  3  9       1  7          3  9
 /\   \         /\        /   /\
1  5  11       5  9      1   7  11
                   \
                   11
@end example
@end ifinfo
@iftex
@sp -0.5
@center @image{fig/chap2/Fig2.16b,70mm,,,.pdf}
@sp 0.2
@quotation
@comment @caption{@strong{Рисунок 2.16:} Various binary trees that represent the set @math{\{1, 3, 5, 7, 9, 11\}}.}
@caption{@strong{Рисунок 2.16:} Различные бинарные деревья, представляющие множество @math{\{1, 3, 5, 7, 9, 11\}}.}
@end quotation
@sp 0.5
@end iftex
@end quotation
@end float

Преимущество древовидного представления следующее. Предположим, мы хотим
проверить, содержится ли в множестве число @math{x}. Начнем с того, что
сравним @math{x} со входом начальной вершины. Если @math{x} меньше его,
то мы уже знаем, что достаточно просмотреть только левое поддерево; если
@math{x} больше, достаточно просмотреть правое поддерево. Если дерево
<<сбалансировано>>, то каждое из поддеревьев будет по размеру примерно
вполовину меньше. Таким образом, за один шаг мы свели задачу поиска в
дереве размера @math{n} к задаче поиска в дереве размера @math{n / 2}.
Поскольку размер дерева уменьшается вдвое на каждом шаге, следует
ожидать, что число шагов, требуемых для поиска в дереве размера
@math{n}, растет как @math{\Theta (\log n)}.@footnote{Уменьшение размера
задачи вдвое на каждом шагу является определяющей характеристикой
логарифмического роста, как мы видели на примере алгоритма быстрого
возведения в степень в разделе @ref{1.2.4} и метода половинного деления в
разделе @ref{1.3.3}.}  Для больших множеств это будет заметным ускорением
по сравнению с предыдущими реализациями.

Деревья мы можем представлять при помощи списков. Каждая вершина будет
списком из трех элементов: вход вершины, левое поддерево и правое
поддерево. Пустой список на месте левого или правого поддерева будет
означать, что в этом месте никакое поддерево не присоединяется. Мы можем
описать это представление при помощи следующих процедур:@footnote{Мы
представляем множества при помощи деревьев, а деревья при помощи
списков --- получается абстракция данных на основе другой абстракции
данных. Процедуры @code{entry}, @code{left-branch}, @code{right-branch}
и @code{make-tree} мы можем рассматривать как способ изолировать
абстракцию <<бинарное дерево>> от конкретного способа, которым мы желаем
представить такое дерево в виде списковой структуры.}

@lisp
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
@end lisp

@noindent
Теперь можно написать процедуру @code{element-of-set?} с использованием
вышеописанной стратегии:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
@end lisp

@noindent
Добавление элемента к множеству реализуется похожим образом и также
требует @math{\Theta (\log n)} шагов. Чтобы добавить объект @code{x}, мы
сравниваем его с входом вершины и определяем, должны ли мы добавить
@code{x} к левой или правой ветви, а добавив @math{x} к соответствующей
ветви, мы соединяем результат с изначальным входом и второй ветвью. Если
@math{x} равен входу, мы просто возвращаем вершину. Если нам требуется
добавить @math{x} к пустому дереву, мы порождаем дерево, которое
содержит @math{x} на входе и пустые левое и правое поддеревья. Вот
процедура:

@lisp
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))
@end lisp

@noindent
Утверждение, что поиск в дереве можно осуществить за логарифмическое
число шагов, основывается на предположении, что дерево
<<сбалансировано>>, то есть что левое и правое его поддеревья содержат
приблизительно одинаковое число элементов, так что каждое поддерево
содержит приблизительно половину элементов своего родителя. Но как нам
добиться того, чтобы те деревья, которые мы строим, были сбалансированы?
Даже если мы начинаем со сбалансированного дерева, добавление элементов
при помощи @code{adjoin-set} может дать несбалансированный результат.
Поскольку позиция нового добавляемого элемента зависит от того, как этот
элемент соотносится с объектами, уже содержащимися в множестве, мы имеем
право ожидать, что если мы будем добавлять элементы <<случайным
образом>>, в среднем дерево будет получаться сбалансированным. Однако
такой гарантии у нас нет. Например, если мы начнем с пустого множества и
будем добавлять по очереди числа от 1 до 7, то получится весьма
несбалансированное дерево, показанное на рисунке @ref{Рисунок 2.17}.
В этом дереве все левые поддеревья пусты, так что нет никакого
преимущества по сравнению с простым упорядоченным списком. Одним из
способов решения этой проблемы было бы определение операции, которая
переводит произвольное дерево в сбалансированное с теми же элементами.
Тогда мы сможем проводить преобразование через каждые несколько операций
@code{adjoin-set}, чтобы поддерживать множество в сбалансированном виде.
Есть и другие способы решения этой задачи. Большая часть из них связана
с разработкой новых структур данных, для которых и поиск, и вставка
могут производиться за @math{\Theta (\log n)} шагов.@footnote{Примерами
таких структур могут служить (@newterm{B-trees}) и (@newterm{red-black trees}).
Существует обширная литература по структурам данных, посвященная этой задаче.
См. @ref{Cormen et al. 1990}.}

@float
@quotation
@anchor{Рисунок 2.17}
@ifinfo
@strong{Рисунок 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.

@example
1
 \
  2
   \
    4
     \
      5
       \
        6
         \
          7
@end example
@end ifinfo
@iftex
@sp -1.0
@center @image{fig/chap2/Fig2.17a,40mm,,,.pdf}
@sp 0.2
@comment @caption{@strong{Рисунок 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.}
@caption{@strong{Рисунок 2.17:} Несбалансированное дерево, порожденное последовательным присоединением элементов от 1 до 7.}
@sp 0.0
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 2.63}Упражнение 2.63:}
Каждая из следующих двух процедур преобразует дерево в список.

@lisp
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
@end lisp

@enumerate a.

@item
Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет,
то как их результаты различаются? Какой результат дают эти две процедуры
для деревьев с рисунка @ref{Рисунок 2.16}?

@item
Одинаков ли порядок роста этих процедур по отношению к числу шагов,
требуемых для преобразования сбалансированного дерева с @math{n}
элементами в список? Если нет, которая из них растет медленнее?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.64}Упражнение 2.64:}
Следующая процедура @code{list->tree} преобразует
упорядоченный список в сбалансированное бинарное дерево. Вспомогательная
процедура @code{partial-tree} принимает в качестве аргументов целое
число @math{n} и список по крайней мере из @math{n} элементов, и строит
сбалансированное дерево из первых @math{n} элементов дерева. Результат,
который возвращает @code{partial-tree}, --- это пара (построенная через
@code{cons}), @code{car} которой есть построенное дерево, а
@code{cdr} --- список элементов, не включенных в дерево.

@lisp
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result
                   (partial-tree
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
@end lisp

@enumerate a.

@item
Дайте краткое описание, как можно более ясно объясняющее работу
@code{partial-tree}. Нарисуйте дерево, которое @code{partial-tree}
строит из списка @code{(1 3 5 7 9 11)}

@item
Каков порядок роста по отношению к числу шагов, которые требуются
процедуре @code{list->tree} для преобразования дерева из @math{n}
элементов?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.65}Упражнение 2.65:}
Используя результаты упражнений @ref{Упражнение 2.63} и
@ref{Упражнение 2.64}, постройте реализации @code{union-set} и
@code{intersection-set} порядка @math{\Theta (n)} для множеств,
реализованных как (сбалансированные) бинарные
деревья.@footnote{Упражнениями @ref{Упражнение 2.63}--@ref{Упражнение 2.65}
мы обязаны Полу Хилфингеру.}
@end quotation

@comment @subsubheading Sets and information retrieval
@subsubheading Множества и поиск информации

Мы рассмотрели способы представления множеств при помощи списков и
увидели, как выбор представления для объектов данных может сильно влиять
на производительность программ, использующих эти данные. Еще одной
причиной нашего внимания к множествам было то, что описанные здесь
методы снова и снова возникают в приложениях, связанных с поиском
данных.

Рассмотрим базу данных, содержащую большое количество записей, например,
сведения о кадрах какой-нибудь компании или о транзакциях в торговой
системе. Как правило, системы управления данными много времени проводят,
занимаясь поиском и модификацией данных в записях; следовательно, им
нужны эффективные методы доступа к записям. Для этого часть каждой
записи выделяется как идентифицирующий (@newterm{key}). Ключом может служить что
угодно, что однозначно определяет запись. В случае записей о кадрах это
может быть номер карточки сотрудника. Для торговой системы это может
быть номер транзакции. Каков бы ни был ключ, когда мы определяем запись
в виде структуры данных, нам нужно указать процедуру выборки ключа,
которая возвращает ключ, связанный с данной записью.

Пусть мы представляем базу данных как множество записей. Чтобы получить
запись с данным ключом, мы используем процедуру @code{lookup}, которая
принимает как аргументы ключ и базу данных и возвращает запись,
содержащую указанный ключ, либо ложь, если такой записи нет.
@code{Lookup} реализуется почти так же, как @code{element-of-set?}.
Например, если множество записей реализуется как неупорядоченный список,
мы могли бы написать

@lisp
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
@end lisp

@noindent
Конечно, существуют лучшие способы представить большие множества, чем в
виде неупорядоченных списков. Системы доступа к информации, в которых
необходим <<произвольный доступ>> к записям, как правило, реализуются с
помощью методов, основанных на деревьях, вроде вышеописанной системы с
бинарными деревьями. При разработке таких систем методология абстракции
данных оказывается весьма полезной. Проектировщик может создать исходную
реализацию с помощью простого, прямолинейного представления вроде
неупорядоченных списков. Для окончательной версии это не подходит, но
такой вариант можно использовать как <<поспешную и небрежную>>
реализацию базы данных, на которой тестируется остальная часть системы.
Позже представление данных можно изменить и сделать более изощренным.
Если доступ к базе данных происходит в терминах абстрактных селекторов и
конструкторов, такое изменение представления данных не потребует никаких
модификаций в остальной системе.

@quotation
@strong{@anchor{Упражнение 2.66}Упражнение 2.66:}
Реализуйте процедуру @code{lookup} для случая, когда
множество записей организовано в виде бинарного дерева, отсортированного
по числовым значениям ключей.
@end quotation

@comment @subsection Example: Huffman Encoding Trees
@subsection Пример: деревья кодирования по Хаффману
@node	2.3.4,  , 2.3.3, 2.3

Этот раздел дает возможность попрактиковаться в использовании списковых
структур и абстракции данных для работы с множествами и деревьями. Они
применяются к методам представления данных как последовательностей из
единиц и нулей (битов). Например, стандартный код ASCII, который
используется для представления текста в компьютерах, кодирует каждый
символ как последовательность из семи бит. Семь бит позволяют нам
обозначить @math{2^7}, то есть 128 различных символов. В общем случае,
если нам требуется различать @math{n} символов, нам потребуется
@math{\log_2 n} бит для каждого символа. Если все наши сообщения
составлены из восьми символов A, B, C, D, E, F, G, и H, мы можем
использовать код с тремя битами для каждого символа, например

@example
A 000    C 010    E 100    G 110
B 001    D 011    F 101    H 111
@end example

@noindent
С таким кодом, сообщение

@example
BACADAEAFABBAAAGAH
@end example

@noindent
кодируется как строка из 54 бит

@example
001000010000011000100000101000001001000000000110000111
@end example

@noindent
Такие коды, как ASCII и наш код от A до H, известны под названием кодов
@emph{с фиксированной длиной} @newterm{fixed-length}, поскольку каждый символ сообщения они
представляют с помощью одного и того же числа битов. Иногда полезно
использовать и коды (@newterm{variable-length}), в которых различные символы могут
представляться различным числом битов. Например, азбука Морзе не для
всех букв алфавита использует одинаковое число точек и тире. В
частности, E, наиболее частая (в английском) буква, представляется с
помощью одной точки. В общем случае, если наши сообщения таковы, что
некоторые символы встречаются очень часто, а некоторые очень редко, то
мы можем кодировать свои данные более эффективно (т. е. с помощью
меньшего числа битов на сообщение), если более частым символам мы
назначим более короткие коды. Рассмотрим следующий код для букв с A по
H:

@example
A 0      C 1010    E 1100    G 1110
B 100    D 1011    F 1101    H 1111
@end example

@noindent
С таким кодом то же самое сообщение преобразуется в строку

@example
100010100101101100011010100100000111001111
@end example

@noindent
В этой строке 42 бита, так что она экономит более 20% места по сравнению
с приведенным выше кодом с фиксированной длиной.

Одна из сложностей при работе с кодом с переменной длиной состоит в том,
чтобы узнать, когда при чтении последовательности единиц и нулей
достигнут конец символа. В азбуке Морзе эта проблема решается при помощи
специального (@newterm{separator code}) (в данном случае паузы) после
последовательности точек и тире для каждой буквы. Другое решение состоит
в том, чтобы построить систему кодирования так, чтобы никакой полный код
символа не совпадал с началом (или ) кода никакого другого символа.
Такой код называется (@newterm{prefix}). В вышеприведенном примере A кодируется 0,
а B 100, так что никакой другой символ не может иметь код, который
начинается на 0 или 100.

В общем случае можно добиться существенной экономии, если использовать
коды с переменной длиной, использующие относительные частоты символов в
подлежащих кодированию сообщениях. Одна из схем такого кодирования
называется кодированием по Хаффману, в честь своего изобретателя, Дэвида
Хаффмана. Код Хаффмана может быть представлен как бинарное дерево, на
листьях которого лежат кодируемые символы. В каждом нетерминальном узле
находится множество символов с тех листьев, которые лежат под данным
узлом. Кроме того, каждому символу на листе дерева присваивается вес
(представляющий собой относительную частоту), а каждый нетерминальный
узел имеет вес, который равняется сумме весов листьев, лежащих под
данным узлом. Веса не используются в процессе кодирования и
декодирования. Ниже мы увидим, как они оказываются полезными при
построении дерева.

Рисунок @ref{Рисунок 2.18} изображает дерево Хаффмана для кода от A
до H, показанного выше. Веса в вершинах дерева указывают, что дерево
строилось для сообщений, где A встречается с относительной частотой 8, B
с относительной частотой 3, а все остальные буквы с относительной
частотой 1.

@float
@quotation
@anchor{Рисунок 2.18}
@ifinfo
@strong{Рисунок 2.18:} A Huffman encoding tree.

@example
           @{A B C D E F G H@} 17
                    *
                   / \
                  /   \
                A 8    * @{B C D E F G H@} 9
            __________/ \_____________
           /                          \
@{B C D@} 5 *                            * @{E F G H@} 4
         / \                       ___/ \___
        /   \                     /         \
      B 3    * @{C D@} 2   @{E F@} 2 *           * @{G H@} 2
            / \                 / \         / \
           /   \               /   \       /   \
         C 1   D 1           E 1   F 1   G 1   H 1
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap2/Fig2.18a,81mm,,,.pdf}
@sp 1.0
@comment @center @caption{@strong{Рисунок 2.18:} A Huffman encoding tree.}
@center @caption{@strong{Рисунок 2.18:} Дерево кодирования по Хаффману.}
@sp 1.0
@end iftex
@end quotation
@end float

Имея дерево Хаффмана, можно найти код любого символа, если начать с
корня и двигаться вниз до тех пор, пока не будет достигнута концевая
вершина, содержащая этот символ. Каждый раз, как мы спускаемся по левой
ветви, мы добавляем 0 к коду, а спускаясь по правой ветви, добавляем 1.
(Мы решаем, по какой ветке двигаться, проверяя, не является ли одна из
веток концевой вершиной, а также содержит ли множество при вершине
символ, который мы ищем.) Например, начиная с корня на картине
@ref{Рисунок 2.18}, мы попадаем в концевую вершину D, сворачивая на
правую дорогу, затем на левую, затем на правую, затем, наконец, снова на
правую ветвь; следовательно, код для D --- 1011.

Чтобы раскодировать последовательность битов при помощи дерева Хаффмана,
мы начинаем с корня и просматриваем один за другим биты в
последовательности, чтобы решить, нужно ли нам спускаться по левой или
по правой ветви. Каждый раз, как мы добираемся до листовой вершины, мы
порождаем новый символ сообщения и возвращаемся к вершине дерева, чтобы
найти следующий символ. Например, пусть нам дано дерево, изображенное на
рисунке, и последовательность 10001010. Начиная от корня, мы идем по
правой ветви (поскольку первый бит в строке 1), затем по левой
(поскольку второй бит 0), затем опять по левой (поскольку и третий бит
0). Здесь мы попадаем в лист, соответствующий B, так что первый символ
декодируемого сообщения --- B. Мы снова начинаем от корня и идем налево,
поскольку следующий бит строки 0. Тут мы попадаем в лист, изображающий
символ A. Мы опять начинаем от корня с остатком строки 1010, двигаемся
направо, налево, направо, налево и приходим в C. Таким образом, все
сообщение было BAC.

@comment @subsubheading Generating Huffman trees
@subsubheading Порождение деревьев Хаффмана

Если нам дан <<алфавит>> символов и их относительные частоты, как мы
можем породить <<наилучший>> код? (Другими словами, какое дерево будет
кодировать сообщения при помощи наименьшего количества битов?) Хаффман
дал алгоритм для решения этой задачи и показал, что получаемый этим
алгоритмом код --- действительно наилучший код с переменной длиной для
сообщений, где относительная частота символов соответствует частотам,
для которых код строился. Здесь мы не будем доказывать оптимальность
кодов Хаффмана, но покажем, как эти коды строятся.@footnote{Обсуждение
математических свойств кодов Хаффмана можно найти в Hamming 1980.}

Алгоритм порождения дерева Хаффмана весьма прост. Идея состоит в том,
чтобы упорядочить дерево так, чтобы символы с наименьшей частотой
оказались дальше всего от корня. Начнем с множества терминальных вершин,
содержащих символы и их частоты, как указано в исходных данных, из
которых нам надо построить дерево. Теперь найдем два листа с наименьшими
весами и сольем их, получая вершину, у которой предыдущие две являются
левым и правым потомками. Вес новой вершины равен сумме весов ее ветвей.
Исключим два листа из исходного множества и заменим их новой вершиной.
Продолжим этот процесс. На каждом шаге будем сливать две вершины с
самыми низкими весами, исключая их из множества и заменяя вершиной, для
которой они являются левой и правой ветвями. Этот процесс заканчивается,
когда остается только одна вершина, которая и является корнем всего
дерева. Вот как было порождено дерево Хаффмана на
рисунке @ref{Рисунок 2.18}:

@example
Исходный набор листьев  @{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (E 1) (F 1) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F@} 2) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F@} 2) (@{G H@} 2)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F G H@} 4)@}
               Слияние  @{(A 8) (@{B C D@} 5) (@{E F G H@} 4)@}
               Слияние  @{(A 8) (@{B C D E F G H@} 9)@}
 Окончательное слияние  @{(@{A B C D E F G H@} 17)@}
@end example

@noindent
Алгоритм не всегда приводит к построению единственно возможного дерева,
поскольку на каждом шаге выбор вершин с наименьшим весом может быть не
единственным. Выбор порядка, в котором будут сливаться две вершины (то
есть, какая из них будет левым, а какая правым поддеревом) также
произволен.

@comment @subsubheading Representing Huffman trees
@subsubheading Представление деревьев Хаффмана

В следующих упражнениях мы будем работать с системой, которая использует
деревья Хаффмана для кодирования и декодирования сообщений и порождает
деревья Хаффмана в соответствии с вышеописанным алгоритмом. Начнем мы с
обсуждения того, как представляются деревья.

Листья дерева представляются в виде списка, состоящего из символа
@code{leaf} (лист), символа, содержащегося в листе, и веса:

@lisp
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
@end lisp

@noindent
Дерево в общем случае будет списком из левой ветви, правой ветви,
множества символов и веса. Множество символов будет просто их списком, а
не каким-то более сложным представлением. Когда мы порождаем дерево
слиянием двух вершин, мы получаем вес дерева как сумму весов этих
вершин, а множество символов как объединение множеств их символов.
Поскольку наши множества представлены в виде списка, мы можем породить
объединение при помощи процедуры @code{append}, определенной нами в
разделе @ref{2.2.1}:

@lisp
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
@end lisp

@noindent
Если мы порождаем дерево таким образом, то у нас будут следующие
селекторы:

@lisp
(define (left-branch  tree) (car  tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
@end lisp

@noindent
Процедуры @code{symbols} и @code{weight} должны вести себя несколько
по-разному в зависимости от того, вызваны они для листа или для дерева
общего вида. Это простые примеры (@newterm{generic procedures}) (процедур,
которые способны работать более, чем с одним типом данных), о которых мы будем
говорить намного более подробно в разделах @ref{2.4} и @ref{2.5}.

\enlargethispage{\baselineskip}

@comment @subsubheading The decoding procedure
@subsubheading Процедура декодирования

Следующая процедура реализует алгоритм декодирования. В качестве
аргументов она принимает список из единиц и нулей, а также дерево Хаффмана.

@lisp
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
@end lisp

@noindent
Процедура @code{decode-1} принимает два аргумента: список остающихся
битов и текущую позицию в дереве. Она двигается <<вниз>> по дереву,
выбирая левую или правую ветвь в зависимости от того, ноль или единица
следующий бит в списке (этот выбор делается в процедуре
@code{choose-branch}). Когда она достигает листа, она возвращает символ
из него как очередной символ сообщения, присоединяя его посредством
@code{cons} к результату декодирования остатка сообщения, начиная от
корня дерева. Обратите внимание на проверку ошибок в конце
@code{choose-branch}, которая заставляет программу протестовать, если во
входных данных обнаруживается что-либо помимо единиц и нулей.

@comment @subsubheading Sets of weighted elements
@subsubheading Множества взвешенных элементов

В нашем представлении деревьев каждая нетерминальная вершина содержит
множество символов, которое мы представили как простой список. Однако
алгоритм порождения дерева, который мы обсуждали выше, требует, чтобы мы
работали еще и с множествами листьев и деревьев, последовательно сливая
два наименьших элемента. Поскольку нам нужно будет раз за разом находить
наименьший элемент множества, удобно для такого множества использовать
упорядоченное представление.

Мы представим множество листьев и деревьев как список элементов,
упорядоченный по весу в возрастающем порядке. Следующая процедура
@code{adjoinset} для построения множеств подобна той, которая описана в
упражнении @ref{Упражнение 2.61}; однако элементы сравниваются по
своим весам, и никогда не бывает так, что добавляемый элемент уже
содержится в множестве.

@lisp
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
@end lisp

@noindent
Следующая процедура принимает список пар вида символ--частота, например
@code{((A 4) (B 2) (C 1) (D 1))}, и порождает исходное упорядоченное
множество листьев, готовое к слиянию по алгоритму Хаффмана:

@lisp
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    @r{; symbol}
                               (cadr pair))  @r{; frequency}
                    (make-leaf-set (cdr pairs))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.67}Упражнение 2.67:}
Пусть нам даны дерево кодирования и пример сообщения:

@lisp
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
@end lisp

Раскодируйте сообщение при помощи процедуры @code{decode}.

@end quotation

@quotation
@strong{@anchor{Упражнение 2.68}Упражнение 2.68:}
Процедура @code{encode} получает в качестве аргументов
сообщение и дерево, и порождает список битов, который представляет
закодированное сообщение.

@lisp
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
@end lisp

@code{encode-symbol} --- процедура, которую Вы должны написать,
возвращает список битов, который кодирует данный символ в соответствии с
заданным деревом. Вы должны спроектировать @code{encode-symbol} так,
чтобы она сообщала об ошибке, если символ вообще не содержится в дереве.
Проверьте свою процедуру, закодировав тот результат, который Вы получили
в упражнении @ref{Упражнение 2.67}, с деревом-примером и проверив,
совпадает ли то, что получаете Вы, с исходным сообщением.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.69}Упражнение 2.69:}
Следующая процедура берет в качестве аргумента список пар
вида символ-частота (где ни один символ не встречается более, чем в
одной паре) и порождает дерево кодирования по Хаффману в соответствии с
алгоритмом Хаффмана.

@lisp
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
@end lisp

Приведенная выше процедура @code{make-leaf-set} преобразует список пар в
упорядоченное множество пар. Вам нужно написать процедуру
@code{successive-merge}, которая при помощи @code{make-code-tree}
сливает наиболее легкие элементы множества, пока не останется только
один элемент, который и представляет собой требуемое дерево Хаффмана.
(Эта процедура устроена немного хитро, но она не такая уж сложная. Если
Вы видите, что строите сложную процедуру, значит, почти наверняка Вы
делаете что-то не то. Можно извлечь немалое преимущество из того, что мы
используем упорядоченное представление для множеств.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.70}Упражнение 2.70:}
Нижеприведенный алфавит из восьми символов с
соответствующими им относительными частотами был разработан, чтобы
эффективно кодировать слова рок-песен 1950-х годов. (Обратите внимание,
что <<символы>> <<алфавита>> не обязаны быть отдельными буквами.)

@example
A    2   GET 2   SHA 3   WAH 1
BOOM 1   JOB 2   NA 16   YIP 9
@end example

При помощи @code{generate-huffman-tree} (упр. @ref{Упражнение 2.69})
породите соответствующее дерево Хаффмана, и с помощью @code{encode}
(упр. @ref{Упражнение 2.68}) закодируйте следующее сообщение:

@example
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
@end example

Сколько битов потребовалось для кодирования? Каково наименьшее число
битов, которое потребовалось бы для кодирования этой песни, если
использовать код с фиксированной длиной для алфавита из восьми символов?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.71}Упражнение 2.71:}
Допустим, у нас есть дерево Хаффмана для алфавита из
@math{n} символов, и относительные частоты символов равны
@math{1, 2, 4, \ldots, 2^{n-1}}. Изобразите дерево для @math{n
= 5}; для @math{n = 10}. Сколько битов в таком дереве (для произвольного
@math{n}) требуется, чтобы закодировать самый частый символ? Самый
редкий символ?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.72}Упражнение 2.72:}
Рассмотрим процедуру кодирования, которую Вы разработали в
упражнении @ref{Упражнение 2.68}. Каков порядок роста в терминах
количества шагов, необходимых для кодирования символа? Не забудьте
включить число шагов, требуемых для поиска символа в каждой следующей
вершине. Ответить на этот вопрос в общем случае сложно. Рассмотрите
особый случай, когда относительные частоты символов таковы, как описано
в упражнении @ref{Упражнение 2.71}, и найдите порядок роста (как
функцию от @math{n}) числа шагов, необходимых, чтобы закодировать самый
частый и самый редкий символ алфавита.
@end quotation

@comment @section Multiple Representations for Abstract Data
@section Множественные представления для абстрактных данных
@node	2.4, 2.5, 2.3, Глава 2

В предыдущих разделах мы описали абстракцию данных, методологию,
позволяющую структурировать системы таким образом, что бо́льшую часть
программы можно специфицировать независимо от решений, которые
принимаются при реализации объектов, обрабатываемых программой.
Например, в разделе @ref{2.1.1} мы
узнали, как отделить задачу проектирования программы, которая пользуется
рациональными числами, от задачи реализации рациональных чисел через
элементарные механизмы построения составных данных в компьютерном языке.
Главная идея состояла в возведении барьера абстракции, --- в данном
случае, селекторов и конструкторов для рациональных чисел
(@code{make-rat}, @code{numer}, @code{denom}), --- который отделяет то,
как рациональные числа используются, от их внутреннего представления
через списковые структуры. Подобный же барьер абстракции отделяет детали
процедур, реализующих рациональную арифметику (@code{add-rat},
@code{sub-rat}, @code{mul-rat} и @code{div-rat}), от <<высокоуровневых>>
процедур, которые используют рациональные числа. Получившаяся программа
имеет структуру, показанную на рис. @ref{Рисунок 2.1}.

Такие барьеры абстракции --- мощное средство управления сложностью
проекта. Изолируя внутренние представления объектов данных, нам удается
разделить задачу построения большой программы на меньшие задачи, которые
можно решать независимо друг от друга. Однако такой тип абстракции
данных еще недостаточно мощен, поскольку не всегда имеет смысл говорить
о <<внутреннем представлении>> объекта данных.

Например, может оказаться более одного удобного представления для
объекта данных, и мы можем захотеть проектировать системы, которые
способны работать с множественными представлениями. В качестве простого
примера, комплексные числа можно представить двумя почти эквивалентными
способами: в декартовой форме (действительная и мнимая часть) и в
полярной форме (модуль и аргумент). Иногда лучше подходит декартова
форма, а иногда полярная. В сущности, вполне возможно представить себе
систему, в которой комплексные числа представляются обоими способами, а
процедуры-операции над комплексным числами способны работать с любым
представлением.

Еще важнее то, что часто программные системы разрабатываются большим
количеством людей в течение долгого времени, в соответствии с
требованиями, которые также со временем меняются. В такой ситуации
просто невозможно заранее всем договориться о выборе представления
данных. Так что в дополнение к барьерам абстракции данных, которые
отделяют представление данных от их использования, нам нужны барьеры
абстракции, которые отделяют друг от друга различные проектные решения и
позволяют различным решениям сосуществовать в рамках одной программы.
Более того, поскольку часто большие программы создаются путем
комбинирования существующих модулей, созданных независимо друг от друга,
нам требуются соглашения, которые позволяли бы программистам добавлять
модули к большим системам (@newterm{additively}), то есть без перепроектирования и
переписывания этих модулей.

В этом разделе мы научимся работать с данными, которые могут быть
представлены в разных частях программы различными способами. Это требует
построения (@newterm{generic procedures}) --- процедур, работающих с данными,
которые могут быть представлены более чем одним способом. Наш основной
метод построения обобщенных процедур будет состоять в том, чтобы
работать в терминах объектов, обладающих (@newterm{type tags}), то есть объектов,
явно включающих информацию о том, как их надо обрабатывать. Кроме того,
мы обсудим (@newterm{data-directed programming}) --- мощную и удобную стратегию
реализации, предназначенную для аддитивной сборки систем с обобщенными
операциями.

Мы начнем с простого примера комплексных чисел. Мы увидим, как метки
типа и стиль, управляемый данными, позволяют нам создать отдельные
декартово и полярное представления комплексных чисел, и при этом
поддерживать понятие абстрактного объекта <<комплексное число>> . Мы
добьемся этого, определив арифметические процедуры для комплексных чисел
(@code{add-complex}, @code{sub-complex}, @code{mul-complex} и
@code{div-complex}) в терминах обобщенных селекторов, которые получают
части комплексного числа независимо от того, как оно представлено.
Получающаяся система работы с комплексными числами, как показано на
рис. @ref{Рисунок 2.19}, содержит два типа барьеров абстракции.
<<Горизонтальные>> барьеры играют ту же роль, что и на
рис. @ref{Рисунок 2.1}. Они отделяют <<высокоуровневые>> операции от
<<низкоуровневых>> представлений. В дополнение к этому, существует еще
<<вертикальный>> барьер, который дает нам возможность отдельно
разрабатывать и добавлять альтернативные представления.

@endpage
@float
@anchor{Рисунок 2.19}
@ifinfo
@quotation
@strong{Рисунок 2.19:} Data-abstraction barriers in the complex-number system.

@example
           Programs that use complex numbers
  +-------------------------------------------------+
--| add-complex sub-complex mul-complex div-complex |--
  +-------------------------------------------------+
              Complex arithmetic package
---------------------------+---------------------------
          Rectangular      |         Polar
        representation     |     representation
---------------------------+---------------------------
    List structure and primitive machine arithmetic
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap2/Fig2.19a,108mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.19:} Data-abstraction barriers in the complex-number system.}
@center @caption{@strong{Рисунок 2.19:} Барьеры абстракции данных в системе работы с комплексными числами.}
@sp 0.8
@end iftex
@end float

В разделе @ref{2.5} мы покажем, как с
помощью меток типа и стиля программирования, управляемого данными,
создать арифметический пакет общего назначения. Такой пакет дает
пользователю процедуры (@code{add}, @code{mul} и т.д.), с помощью
которых можно манипулировать всеми типами <<чисел>>, и если нужно, его
можно легко расширить, когда потребуется новый тип чисел. В
разделе @ref{2.5.3} мы покажем, как
использовать обобщенную арифметику в системе, работающей с символьной
алгеброй.

@menu
* 2-4-1::             Представления комплексных чисел
* 2-4-1::             Помеченные данные
* 2-4-1::             Программирование управляемое данными и аддитивность
@end menu

@comment @subsection Representations for Complex Numbers
@subsection Представления комплексных чисел
@node	2.4.1, 2.4.2, 2.4, 2.4

В качестве простого, хотя и нереалистичного, примера программы,
использующей обобщенные операции, мы разработаем систему, которая
производит арифметические операции над комплексными числами. Начнем мы с
обсуждения двух возможных представлений комплексного числа в виде
упорядоченной пары: декартова форма (действительная и мнимая части) и
полярная форма (модуль и аргумент).@footnote{В реальных вычислительных
системах, как правило, декартова форма предпочтительнее полярной из-за
ошибок округления при преобразованиях между этими двумя формами. Именно
поэтому пример с комплексными числами нереалистичен. Тем не менее, он
служит ясной иллюстрацией строения системы, использующей обобщенные
операции, и хорошим введением в более содержательные системы, которые мы
строим далее по ходу этой главы.} В разделе @ref{2.4.2}
будет показано, как оба представления можно заставить сосуществовать в
рамках одной программы при помощи меток типа и обобщенных операций.

Подобно рациональным числам, комплексные числа естественно представлять
в виде упорядоченных пар. Множество комплексных чисел можно представлять
себе как двумерное пространство с двумя перпендикулярными осями:
<<действительной>> и <<мнимой>> (см. рис. @ref{Рисунок 2.20}). С этой
точки зрения комплексное число @math{z 
= x + iy} (где @math{i^2 = -1}) можно представить как точку на
плоскости, действительная координата которой равна @math{x}, а мнимая
@math{y}. В этом представлении сложение комплексных чисел сводится к
сложению координат:
@ifinfo

@example
Real-part(z_1 + z_2) = Real-part(z_1) + Real-part(z_2)

Imaginary-part(z_1 + z_2) = Imaginary-part(z_1) + Imaginary-part(z_2)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
  \hbox{Real-part} (z_1 + z_2)\; 	&
    \hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \\
  \hbox{Imaginary-part} (z_1 + z_2)\; 	&
    \hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2).
\end{array}
$$
@end tex

@float
@quotation
@anchor{Рисунок 2.20}
@ifinfo
@strong{Рисунок 2.20:} Complex numbers as points in the plane.

@example
 Imaginary
    ^
    |
  y |.........................* z = x + ?y = r e^(?A)
    |                    __-- .
    |                __--     .
    |          r __--         .
    |        __--             .
    |    __-- \               .
    |__--    A |              .
----+----------+-------------------> Real
                              x
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.20,79mm,,,.pdf}
@sp 0.4
@comment @center @caption{@strong{Рисунок 2.20:} Complex numbers as points in the plane.}
@center @caption{@strong{Рисунок 2.20:} Комплексные числа как точки на плоскости.} 
@sp 0.9
@end iftex
@end quotation
@end float

При умножении комплексных чисел естественней думать об их представлении
в полярной форме, в виде модуля и аргумента (@math{r} и @math{A} на рис.
@ref{Рисунок 2.20}). Произведение двух комплексных чисел есть вектор,
получаемый путем растягивания одного комплексного числа на модуль
другого и поворота на его же аргумент:
@ifinfo

@example
Magnitude(z_1 * z_2) = Magnitude(z_1) * Magnitude(z_2)

Angle(z_1 * z_2) = Angle(z_1) + Angle(z_2)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
    \hbox{Magnitude} (z_1 \cdot z_2)\; 	&
        \hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \\
    \hbox{Angle} (z_1 \cdot z_2)\; 		&
        \hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2).
\end{array}
$$
@end tex

@noindent
Таким образом, есть два различных представления для комплексных чисел, и
каждое из них удобнее для какого-то набора операций. Однако с точки
зрения человека, который пишет программу с использованием комплексных
чисел, принцип абстракции данных утверждает, что все операции,
работающие с комплексными числами, должны работать независимо от того,
какую интерпретацию использует компьютер. Например, часто бывает нужно
получить модуль комплексного числа, представленного в декартовых
координатах. Подобным образом, часто полезно уметь определять
действительную часть комплексного числа, представленного в полярных
координатах.

При разработке такой системы мы можем следовать той самой стратегии
абстракции данных, которую мы использовали в пакете работы с
рациональными числами в разделе @ref{2.1.1}. Предположим, что
операции над комплексными числами реализованы в терминах четырех
селекторов: @code{real-part}, @code{imag-part}, @code{magnitude} и
@code{angle}. Предположим еще, что у нас есть две процедуры для
построения комплексных чисел: @code{make-from-real-imag} возвращает
комплексное число с указанными действительной и мнимой частями, а
@code{make-from-mag-ang} возвращает комплексное число с указанными
модулем и аргументом. Эти процедуры обладают такими свойствами, что для
любого комплексного числа @code{z}

@lisp
(make-from-real-imag (real-part z) (imag-part z))
@end lisp

@noindent
и

@lisp
(make-from-mag-ang (magnitude z) (angle z))
@end lisp

@noindent
порождают комплексные числа, равные @code{z}.

Используя такие конструкторы и селекторы, мы можем реализовать
арифметику комплексных чисел через <<абстрактные данные>>, определяемые
этими конструкторами и селекторами, в точности как мы это делали для
рациональных чисел в
разделе @ref{2.1.1}. Как показывают
вышеуказанные формулы, можно складывать и вычитать комплексные числа в
терминах действительной и мнимой части, а умножать и делить в терминах
модуля и аргумента:

@lisp

(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
@end lisp

@noindent
Для того, чтобы придать пакету работы с комплексными числами
окончательный вид, нам осталось выбрать представление и реализовать
конструкторы и селекторы в терминах элементарных чисел и элементарной
списковой структуры. Есть два очевидных способа это сделать: можно
представлять комплексное число как пару в <<декартовой форме>>
(действительная часть, мнимая часть) либо в <<полярной форме>> (модуль,
аргумент). Какой вариант мы выберем?

Чтобы говорить о конкретных вариантах, предположим, что двое
программистов, Бен Битобор и Лиза П. Хакер, независимо друг от друга
разрабатывают представления для системы, работающей с комплексными
числами. Бен решает представлять комплексные числа в декартовой форме.
При таком решении доступ к действительной и мнимой частям комплексного
числа, а также построение его из действительной и мнимой частей
реализуются прямолинейно. Чтобы найти модуль и аргумент, а также чтобы
построить комплексное число с заданными модулем и аргументом, он
использует тригонометрические соотношения
@ifinfo

@example
                      __________
x = r cos A     r = ./ x^2 + y^2

y = r sin A     A = arctan(y,x)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}lr@{{}={}}l}
    x & r \cos A, \qquad 	& r & \sqrt{x^2 + y^2}, \\
    y & r \sin A, \qquad 	& A & \arctan(y, x),
\end{array}
$$
@end tex
@noindent
которые связывают действительную и мнимую части
@math{(x, y)} с модулем и аргументом @math{(r, A)}.@footnote{Функция
взятия арктангенса, которая здесь используется, вычисляется процедурой
Scheme . Она берет два аргумента @math{y} и @math{x} и возвращает угол,
тангенс которого равен @math{y/x}. Знаки аргументов определяют, в каком
квадранте находится угол.} Таким образом, реализация Бена определяется
следующими селекторами и конструкторами:

@lisp
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z))
           (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
@end lisp

@noindent
Напротив, Лиза решает представить комплексные числа в полярной форме.
Для нее доступ к модулю и аргументу тривиален, но для получения
действительной и мнимой части ей приходится использовать
тригонометрические тождества. Вот представление Лизы:

@lisp
(define (real-part z) (* (magnitude z) (cos (angle z))))
(define (imag-part z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))
@end lisp

@noindent
Дисциплина абстракции данных обеспечивает то, что одни и те же
реализации процедур @code{add-complex}, @code{sub-complex},
@code{mul-complex} и @code{div-complex} будут работать как с Беновым
представлением, так и с Лизиным.

@comment @subsection Tagged data
@subsection Помеченные данные
@node	2.4.2, 2.4.3, 2.4.1, 2.4

Можно рассматривать абстракцию данных как применение принципа
<<наименьших обязательств>>. Реализуя систему обработки комплексных
чисел в разделе @ref{2.4.1}, мы
можем использовать либо декартово представление от Бена, либо полярное
от Лизы. Барьер абстракции, который образуют селекторы и конструкторы,
позволяет нам до последнего момента отложить выбор конкретного
представления для наших объектов данных, и таким образом сохранить
максимальную гибкость в проекте нашей системы.

Принцип наименьших обязательств можно довести до еще бо́льших крайностей.
Если нам понадобится, мы можем сохранить неопределенность представления
даже @emph{после} того, как мы спроектировали селекторы и конструкторы,
и использовать @emph{и} представление Бена, @emph{и} представление Лизы.
Однако если оба представления участвуют в одной и той же системе, нам
потребуется какой-нибудь способ отличить данные в полярной форме от
данных в декартовой форме. Иначе, если нас попросят, например, вычислить
@code{magnitude} от пары @math{(3,4)}, мы не будем знать, надо ли
ответить 5 (интерпретируя число в декартовой форме) или 3 (интерпретируя
его в полярной форме). Естественный способ добиться необходимого
различия состоит в том, чтобы использовать (@newterm{type tag}) --- символ
@code{rectangular} или @code{polar} --- как часть каждого комплексного
числа. Тогда, когда нам понадобится что-то делать с комплексным числом,
мы можем при помощи этой метки решить, который селектор требуется
применить.

Чтобы работать с помеченными данными, мы предположим, что у нас есть
процедуры @code{type-tag} и @code{contents}, которые извлекают из
элемента данных метку и собственно содержимое (полярные либо декартовы
координаты, если речь идет о комплексном числе). Кроме того, мы
постулируем процедуру @code{attach-tag}, которая берет метку и
содержимое, и выдает помеченный объект данных. Простейший способ
реализовать эти процедуры --- использовать обыкновенную списковую
структуру:

@lisp
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
@end lisp

@noindent
При помощи этих процедур мы можем определить предикаты
@code{rectangular?} и @code{polar?}, которые распознают, соответственно,
декартово и полярное представление:

@lisp
(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
(define (polar? z) (eq? (type-tag z) 'polar))
@end lisp

@noindent
Теперь, когда у нас имеются метки типов, Бен и Лиза могут переделать
свой код так, чтобы позволить своим разнородным представлениям
сосуществовать в одной и той же системе. Каждый раз, когда Бен создает
комплексное число, он помечает его как декартово. Каждый раз, когда Лиза
создает комплексное число, она помечает его как полярное. В дополнение к
этому, Бен и Лиза должны сделать так, чтобы не было конфликта имен между
названиями их процедур. Один из способов добиться этого --- Бену
добавить слово @code{rectangular} к названиям всех своих процедур
представления данных, а Лизе добавить @code{polar} к своим. Вот
переработанное декартово представление Бена из
раздела @ref{2.4.1}:

@lisp
(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
@end lisp

@noindent
а вот переработанное полярное представление Лизы:

@lisp
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))
(define (make-from-real-imag-polar x y)
  (attach-tag 'polar
              (cons (sqrt (+ (square x) (square y)))
                    (atan y x))))
(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
@end lisp

@noindent
Каждый обобщенный селектор реализуется как процедура, которая проверяет
метку своего аргумента и вызывает подходящую процедуру для обработки
данных нужного типа. Например, для того, чтобы получить действительную
часть комплексного числа, @code{real-part} смотрит на метку и решает,
звать ли Бенову @code{real-part-rectangular} или Лизину
@code{real-part-polar}. В каждом из этих случаев мы пользуемся
процедурой @code{contents}, чтобы извлечь голый, непомеченный элемент
данных и передать его либо в декартову, либо в полярную процедуру:

@lisp
(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type: REAL-PART" z))))
(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type: IMAG-PART" z))))
(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknown type: MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknown type: ANGLE" z))))
@end lisp

@noindent
Для реализации арифметических операций с комплексными числами мы
по-прежнему можем использовать старые процедуры @code{add-complex},
@code{sub-complex}, @code{mul-complex} и @code{div-complex} из
раздела @ref{2.4.1}, поскольку
вызываемые ими селекторы обобщенные и, таким образом, могут работать с
любым из двух представлений. Например, процедура @code{add-complex}
по-прежнему выглядит как

@lisp
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
@end lisp

@noindent
Наконец, нам надо решить, порождать ли комплексные числа в Беновом или
Лизином представлении. Одно из разумных решений состоит в том, чтобы
порождать декартовы числа, когда нам дают действительную и мнимую часть,
и порождать полярные числа, когда нам дают модуль и аргумент:

@lisp
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
@end lisp

@noindent
Структура получившейся системы комплексной арифметики показана на
рисунке @ref{Рисунок 2.21}. Система разбита на три относительно
независимых части: операции арифметики комплексных чисел, полярная
реализация Лизы и декартова реализация Бена. Полярная и декартова
реализации могли быть написаны Беном и Лизой по отдельности, и любую из
них может использовать в качестве внутреннего представления третий
программист, чтобы реализовать процедуры арифметики комплексных чисел в
терминах абстрактного интерфейса конструкторов и селекторов.

@float
@anchor{Рисунок 2.21}
@ifinfo
@quotation
@strong{Рисунок 2.21:} Structure of the generic complex-arithmetic system.

@example
    +-------------------------------------------------+
----| add-complex sub-complex mul-complex div-complex |----
    +-------------------------------------------------+
                Complex arithmetic package
                 +-----------------------+
                 | real-part   imag-part |
-----------------|                       |------------------
                 | magnitude   angle     |
                 +-----------+-----------+
           Rectangular       |          Polar
          representation     |     representation
-----------------------------+------------------------------
       List structure and primitive machine arithmetic
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.21a,108mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 2.21:} Structure of the generic complex-arithmetic system. }@short
@center @caption{@strong{Рисунок 2.21:} Структура обобщенной системы комплексной арифметики.}@short
@sp 0.8
@end iftex
@end float

Поскольку каждый объект данных помечен своим типом, селекторы работают с
данными обобщенным образом. Это означает, что каждый селектор по
определению обладает поведением, которое зависит от того, к какому типу
данных он применяется. Следует обратить внимание на общий механизм
доступа к отдельным представлениям: внутри любой данной реализации
представления (скажем, внутри полярного пакета Лизы) комплексное число
представляется нетипизированной парой (модуль, аргумент). Когда
обобщенный селектор обращается к данным полярного типа, он отрывает
метку и передает содержимое Лизиному коду. И наоборот, когда Лиза строит
число для общего пользования, она помечает его тип, чтобы процедуры
более высокого уровня могли его должным образом распознать. Такая
дисциплина снятия и добавления меток при передаче объектов данных с
уровня на уровень может быть ценной стратегией организации данных и
программ, как мы увидим в
разделе @ref{2.5}.

@comment @subsection Data-Directed Programming and Additivity
@subsection Программирование, управляемое данными, и аддитивность
@node	2.4.3,  , 2.4.2, 2.4

Общая стратегия проверки типа данных и вызова соответствующей процедуры
называется @emph{диспетчеризацией по типу} (@newterm{dispatching on type}). Это
хороший способ добиться модульности при проектировании системы. С другой
стороны, такая реализация диспетчеризации, как в
разделе @ref{2.4.2}, имеет два существенных недостатка.
Один заключается в том, что обобщенные процедуры интерфейса
(@code{real-part}, @code{imag-part}, @code{magnitude} и @code{angle})
обязаны знать про все имеющиеся способы представления. Предположим, к
примеру, что нам хочется ввести в нашу систему комплексных чисел еще
одно представление. Нам нужно будет сопоставить этому представлению тип,
а затем добавить в каждую из обобщенных процедур интерфейса по варианту
для проверки на этот новый тип и вызова селектора, соответствующего его
представлению.

Второй недостаток этого метода диспетчеризации состоит в том, что, хотя
отдельные представления могут проектироваться раздельно, нам нужно
гарантировать, что никакие две процедуры во всей системе не называются
одинаково. Вот почему Бену и Лизе пришлось изменить имена своих
первоначальных процедур из
раздела @ref{2.4.1}.

Оба эти недостатка являются следствием того, что наш метод реализации
обобщенных интерфейсов . Программист, реализующий обобщенные
процедуры-селекторы, должен их переделывать каждый раз, как добавляется
новое представление, а авторы, создающие отдельные представления, должны
изменять свой код, чтобы избежать конфликтов имен. В каждом из этих
случаев изменения, которые требуется внести в код, тривиальны, но их все
равно нужно делать, и отсюда проистекают неудобства и ошибки. Для
системы работы с комплексными числами в ее нынешнем виде это проблема
небольшая, но попробуйте представить, что есть не два, а сотни различных
представлений комплексных чисел. И что есть много обобщенных селекторов,
которые надо поддерживать в интерфейсе абстрактных данных. Представьте
даже, что ни один программист не знает всех интерфейсных процедур всех
реализаций. Проблема эта реальна, и с ней приходится разбираться в
программах вроде систем управления базами данных большого калибра.

Нам нужен способ еще более модуляризовать устройство системы. Это
позволяет метод программирования, который называется (@newterm{data-directed programming}).
Чтобы понять, как работает этот метод, начнем с
наблюдения: каждый раз, когда нам приходится работать с набором
обобщенных операций, общих для множества различных типов, мы, в
сущности, работаем с двумерной таблицей, где по одной оси расположены
возможные операции, а по другой всевозможные типы. Клеткам таблицы
соответствуют процедуры, которые реализуют каждую операцию для каждого
типа ее аргумента. В системе комплексной арифметики из предыдущего
раздела соответствие между именем операции, типом данных и собственно
процедурой было размазано по условным предложениям в обобщенных
процедурах интерфейса. Но ту же самую информацию можно было бы
организовать в виде таблицы, как показано на рис. @ref{Рисунок 2.22}.

Программирование, управляемое данными, --- метод проектирования
программ, позволяющий им напрямую работать с такого рода таблицей.
Механизм, который связывает код комплексных арифметических операций с
двумя пакетами представлений, мы ранее реализовали в виде набора
процедур, которые явно осуществляют диспетчеризацию по типу. Здесь мы
реализуем этот интерфейс через одну процедуру, которая ищет сочетание
имени операции и типа аргумента в таблице, чтобы определить, какую
процедуру требуется применить, а затем применяет ее к содержимому
аргумента. Если мы так сделаем, то, чтобы добавить к системе пакет с
новым представлением, нам не потребуется изменять существующие
процедуры; понадобится только добавить новые клетки в таблицу.

@float
@anchor{Рисунок 2.22}
@ifinfo
@quotation
@strong{Рисунок 2.22:} Table of operations for the complex-number system.

@example
           |               Types
Operations | Polar           | Rectangular
===========+=================+======================
real-part  | real-part-polar | real-part-rectangular
imag-part  | imag-part-polar | imag-part-rectangular
magnitude  | magnitude-polar | magnitude-rectangular
angle      | angle-polar     | angle-rectangular
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.22,102mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.22:} Table of operations for the complex-number system. }@short
@center @caption{@strong{Рисунок 2.22:} Таблица операций в системе комплексных чисел.}@short
@sp 0.8
@end iftex
@end float

Чтобы реализовать этот план, предположим, что у нас есть две процедуры
@code{put} и @code{get}, для манипуляции с таблицей операций и типов:

@itemize @bullet

@item
@math{\hbox{\tt(put}\;\langle}@var{оп}@math{\kern0.1em\rangle\;\langle}@var{тип}@math{\kern0.08em\rangle\;\langle}@var{элемент}@math{\kern0.08em\rangle\hbox{\tt)}} вносит @math{\langle}@var{элемент}@math{\kern0.08em\rangle} в таблицу, в клетку, индексом которой служат операция
@math{\langle}@var{оп}@math{\kern0.1em\rangle} и тип @math{\langle}@var{тип}@math{\kern0.08em\rangle}.

@item
@math{\hbox{\tt(get}\;\langle}@var{оп}@math{\kern0.1em\rangle\;\langle}@var{элемент}@math{\kern0.08em\rangle\hbox{\tt)}} ищет в таблице ячейку с индексом
@math{\langle}@var{оп}@math{\kern0.08em\rangle}, @math{\langle}@var{тип}@math{\kern0.08em\rangle} 
и возвращает ее содержимое. Если ячейки нет, @code{get} возвращает ложь.

@end itemize

Пока что мы предположим, что @code{get} и @code{put} входят в наш язык.
В главе @ref{Глава 3} (раздел @ref{3.3.3}) мы увидим,
как реализовать эти и другие операции для работы с таблицами.

Программирование, управляемое данными, в системе с комплексными числами
можно использовать так: Бен, который разрабатывает декартово
представление, пишет код в точности как он это делал сначала. Он
определяет набор процедур, или (@newterm{package}), и привязывает эти процедуры к
остальной системе, добавляя в таблицу ячейки, которые сообщают системе,
как работать с декартовыми числами. Это происходит при вызове следующей
процедуры:

@lisp
(define (install-rectangular-package)
  @r{;; internal procedures}
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  @r{;; interface to the rest of the system}
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Обратите внимание, что внутренние процедуры --- те самые, которые Бен
писал, когда он в
разделе @ref{2.4.1} работал сам по
себе. Никаких изменений, чтобы связать их с остальной системой, не
требуется. Более того, поскольку определения процедур содержатся внутри
процедуры установки, Бену незачем беспокоиться о конфликтах имен с
другими процедурами вне декартова пакета. Чтобы связать их с остальной
системой, Бен устанавливает свою процедуру @code{real-part} под именем
операции @code{real-part} и типом @code{(rectangular)}, и то же самое он
проделывает с другими селекторами.@footnote{Мы используем список
@code{(rectangular)}, а не символ @code{rectangular}, чтобы
предусмотреть возможность операций с несколькими аргументами, не все из
которых одинакового типа.} Его интерфейс также определяет конструкторы,
которые может использовать внешняя система.@footnote{Тип, под которым
устанавливаются конструкторы, необязательно делать списком, поскольку
конструктор всегда вызывается для того, чтобы породить один объект
определенного типа.} Они совпадают с конструкторами, которые Бен
определяет для себя, но вдобавок прикрепляют метку.

Лизин полярный пакет устроен аналогично:

@lisp
(define (install-polar-package)
  @r{;; internal procedures}
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (* (magnitude z) (cos (angle z))))
  (define (imag-part z) (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  @r{;; interface to the rest of the system}
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Несмотря на то, что Бен и Лиза используют свои исходные процедуры с
совпадающими именами (например, @code{real-part}), эти определения
теперь внутренние для различных процедур (см.
раздел @ref{1.1.8}),
так что никакого конфликта имен не происходит.

Селекторы комплексной арифметики обращаются к таблице посредством общей
процедуры-<<операции>> @code{apply-generic}, которая применяет
обобщенную операцию к набору аргументов. @code{apply-generic} ищет в
таблице ячейку по имени операции и типам аргументов и применяет
найденную процедуру, если она существует:@footnote{@code{apply-generic}
пользуется точечной записью, описанной в
упражнении @ref{Упражнение 2.20}, поскольку различные обобщенные
операции могут принимать различное число аргументов. В
@code{apply-generic} значением @code{op} является первый аргумент вызова
@code{apply-generic}, а значением @code{args} список остальных
аргументов.

Кроме того, @code{apply-generic} пользуется элементарной процедурой
@code{apply}, которая принимает два аргумента: процедуру и список.
@code{Apply} вызывает процедуру, используя элементы списка как
аргументы. Например,

@lisp
(apply + (list 1 2 3 4))
@end lisp

@noindent
возвращает 10.}

@lisp
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types: APPLY-GENERIC"
            (list op type-tags))))))
@end lisp

@noindent
При помощи @code{apply-generic} можно определить обобщенные селекторы
так:

@lisp
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
@end lisp

@noindent
Заметим, что они не изменяются, если в систему добавляется новое
представление.

Кроме того, мы можем из той же таблицы получать конструкторы, которые
будут использоваться программами, внешними по отношению к пакетам, для
изготовления комплексных чисел из действительной и мнимой части либо из
модуля и аргумента. Как и в разделе @ref{2.4.2}, мы
порождаем декартово представление, если нам дают действительную и мнимую
часть, и полярное, если дают модуль и аргумент:

@lisp
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.73}Упражнение 2.73:}
В разделе @ref{2.3.2}
описывается программа, которая осуществляет символьное дифференцирование:

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product
                    (multiplier exp)
                    (deriv (multiplicand exp) var))
                   (make-product
                    (deriv (multiplier exp) var)
                    (multiplicand exp))))
        @math{\langle}@var{more rules can be added here}@math{\rangle}
        (else (error "unknown expression type:
                      DERIV" exp))))
@end lisp

Можно считать, что эта программа осуществляет диспетчеризацию по типу
выражения, которое требуется продифференцировать. В этом случае <<меткой
типа>> элемента данных является символ алгебраической операции
(например, @code{+}), а операция, которую нужно применить --
@code{deriv}. Эту программу можно преобразовать в управляемый данными
стиль, если переписать основную процедуру взятия производной в виде

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp))
               (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
@end lisp

@enumerate a.

@item
Объясните, что происходит в приведенном фрагменте кода. Почему нельзя
включить в операцию выбора, управляемого данными, предикаты
@code{number?} и @code{variable?}?

@item
Напишите процедуры для вычисления производных от суммы и произведения, а
также дополнительный код, чтобы добавить их к таблице, которой
пользуется приведенный фрагмент.

@item
Выберите еще какое-нибудь правило дифференцирования, например для
возведения в степень (упражнение @ref{Упражнение 2.56}), и установите
его в систему.

@item
В этой простой алгебраической системе тип выражения --- это
алгебраическая операция верхнего уровня. Допустим, однако, что мы
индексируем процедуры противоположным образом, так что строка
диспетчеризации в @code{deriv} выглядит как

@lisp
((get (operator exp) 'deriv) (operands exp) var)
@end lisp

@noindent
Какие изменения потребуются в системе дифференцирования?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.74}Упражнение 2.74:}
Insatiable Enterprises, Inc. --- децентрализованная
компания-конгломерат, которая состоит из большого количества независимых
подразделений, раскиданных по всему миру. Недавно вычислительные
мощности компании были связаны умной вычислительной сетью, создающей для
пользователя иллюзию, что он работает с единым компьютером. Президент
компании, когда она в первый раз пытается воспользоваться способностью
системы осуществлять доступ к файлам подразделений, с изумлением и
ужасом обнаруживает, что, несмотря на то, что все эти файлы реализованы
в виде структур данных на Scheme, конкретная структура данных отличается
от подразделения к подразделению. Спешно созывается совещание менеджеров
подразделений, чтобы найти стратегию, которая позволила бы собрать файлы
в единую систему для удовлетворения нужд главного офиса, и одновременно
сохранить существующую автономию подразделений.

Покажите, как такую стратегию можно реализовать при помощи
программирования, управляемого данными. К примеру, предположим, что
сведения о персонале каждого подразделения устроены в виде единого
файла, который содержит набор записей, проиндексированных по имени
служащего. Структура набора данных от подразделения к подразделению
различается. Более того, каждая запись сама по себе --- набор сведений
(в разных подразделениях устроенный по-разному), в котором информация
индексируется метками вроде @code{address} (адрес) или @code{salary}
(зарплата). В частности:

@enumerate a.

@item
Для главного офиса реализуйте процедуру @code{get-record}, которая
получает запись, относящуюся к указанному служащему, из указанного файла
персонала. Процедура должна быть применима к файлу любого подразделения.
Объясните, как должны быть структурированы файлы отдельных
подразделений. В частности, какую информацию о типах нужно хранить?

@item
Для главного офиса реализуйте процедуру @code{get-salary}, которая
возвращает зарплату указанного служащего из файла любого подразделения.
Как должна быть устроена запись, чтобы могла работать эта процедура?

@item
Для главного офиса напишите процедуру @code{find-employee-record}. Она
должна искать в файлах всех подразделений запись указанного служащего и
возвращать эту запись. Предположим, что в качестве аргументов эта
процедура принимает имя служащего и список файлов всех подразделений.

@item
Какие изменения требуется внести в систему, чтобы внести в центральную
систему информацию о новых служащих, когда Insatiable поглощает новую
компанию?

@end enumerate
@end quotation

@comment @subsubheading Message passing
@subsubheading Передача сообщений

Основная идея программирования, управляемого данными, состоит в том,
чтобы работать с обобщенными операциями в программах при помощи явных
манипуляций с таблицами операций и типов, вроде таблицы на
рисунке @ref{Рисунок 2.22}. В стиле программирования, который мы
применяли в разделе @ref{2.4.2}, диспетчеризация по типу
организуется внутри каждой операции, и каждая операция должна сама
заботиться о своей диспетчеризации. Это, в сущности, разбивает таблицу
операций и типов на строки, и каждая обобщенная операция представляет
собой строку таблицы.

Альтернативой такой стратегии реализации будет разбить таблицу по
столбцам и вместо <<умных операций>>, которые диспетчируют по типам
данных, работать с <<умными объектами данных>>, которые диспетчируют по
именам операций. Мы можем этого добиться, если устроим все так, что
объект данных, например комплексное число в декартовом представлении,
будет представляться в виде процедуры, которая в качестве входа
воспринимает имя операции и осуществляет соответствующее ей действие.
При такой организации можно написать @code{make-from-real-imag} в виде

@lisp
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude) (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else (error "Unknown op: MAKE-FROM-REAL-IMAG" op))))
  dispatch)
@end lisp

@noindent
Соответствующая процедура @code{apply-generic}, которая применяет
обобщенную операцию к аргументу, просто скармливает имя операции объекту
данных и заставляет его делать всю работу:@footnote{У такой организации
есть ограничение: она допускает обобщенные процедуры только от одного
аргумента.}

@lisp
(define (apply-generic op arg) (arg op))
@end lisp

@noindent
Обратите внимание, что значение, возвращаемое из
@code{make-from-real-imag}, является процедурой --- это внутренняя
процедура @code{dispatch}. Она вызывается, когда @code{apply-generic}
требует выполнить обобщенную операцию.

Такой стиль программирования называется (@newterm{message passing}). Имя
происходит из представления, что объект данных --- это сущность,
которая получает имя затребованной операции как <<сообщение>>. Мы уже
встречались с примером передачи сообщений в
разделе @ref{2.1.3}, где мы видели, как
@code{cons}, @code{car} и @code{cdr} можно определить безо всяких
объектов данных, с одними только процедурами. Теперь мы видим, что
передача сообщений не математический трюк, а полезный метод организации
систем с обобщенными операциями. В оставшейся части этой главы мы будем
продолжать пользоваться программированием, управляемым данными, а не
передачей сообщений, и рассмотрим обобщенные арифметические операции. Мы
вернемся к передаче сообщений в
главе @ref{Глава 3},
и увидим, что она может служить мощным инструментом для структурирования
моделирующих программ.

@quotation
@strong{@anchor{Упражнение 2.75}Упражнение 2.75:}
Реализуйте в стиле передачи сообщений конструктор
@code{make-from-mag-ang}. Он должен быть аналогичен приведенной выше
процедуре @code{make-from-real-imag}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.76}Упражнение 2.76:}
Когда большая система с обобщенными операциями развивается,
могут потребоваться новые типы объектов данных или новые операции. Для
каждой из трех стратегий --- обобщенные операции с явной
диспетчеризацией, стиль, управляемый данными, и передача сообщений, --
опишите, какие изменения нужно произвести в системе, чтобы добавить
новый тип или новую операцию. Какая организация лучше подходит для
системы, в которую часто добавляются новые типы? Какая для системы, где
часто появляются новые операции?
@end quotation

@comment @section Systems with Generic Operations
@section Системы с обобщенными операциями
@node	2.5,  , 2.4, Глава 2

В предыдущем разделе мы увидели, как проектировать системы, где объекты
данных могут быть представлены более чем одним способом. Основная идея
состоит в том, чтобы связать код, который определяет операции над
данными, и многочисленные реализации данных, при помощи обобщенных
процедур интерфейса. Теперь мы увидим, что ту же самую идею можно
использовать не только для того, чтобы определять обобщенные операции
для нескольких реализаций одного типа, но и для того, чтобы определять
операции, обобщенные относительно нескольких различных типов аргументов.
Мы уже встречались с несколькими различными пакетами арифметических
операций: элементарная арифметика (@code{+}, @code{-}, @code{*},
@code{/}), встроенная в наш язык, арифметика рациональных чисел
(@code{add-rat}, @code{sub-rat}, @code{mul-rat}, @code{div-rat}) из
раздела @ref{2.1.1} и арифметика комплексных чисел, которую мы
реализовали в разделе @ref{2.4.3}. Теперь
мы, используя методы программирования, управляемого данными, создадим
пакет арифметических операций, который включает все уже построенные нами
арифметические пакеты.

@float
@quotation
@ifinfo
@anchor{Рисунок 2.23}
@strong{Рисунок 2.23:} Generic arithmetic system.

@example
                        Programs that use numbers
                           +-----------------+
---------------------------| add sub mul div |-------------------
                           +-----------------+
                        Generic arithmetic package
 +-----------------+   +-------------------------+
 | add-rat sub-rat |   | add-complex sub-complex |   +---------+
-|                 |-+-|                         |-+-| + - * / |-
 | mul-rat div-rat | | | mul-complex div-complex | | +---------+
 +-----------------+ | +-------------------------+ |
      Rational       |     Complex artithmetic     |   Ordinary
     arithmetic      +--------------+--------------+  arithmetic
                     | Rectangular  |     Polar    |
---------------------+--------------+--------------+-------------
             List structure and primitive machine arithmetic
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.23a,111mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 2.23:} Generic arithmetic system.}
@center @caption{@strong{Рисунок 2.23:} Обобщенная арифметическая истема.}
@sp 0.8
@end iftex
@end quotation
@end float

На рисунке @ref{Рисунок 2.23} показана структура системы, которую мы
собираемся построить. Обратите внимание на барьеры абстракции. С точки
зрения человека, работающего с <<числами>>, есть только одна процедура
@code{add}, которая работает, какие бы числа ей ни дали. @code{Add}
является частью обобщенного интерфейса, который позволяет программам,
пользующимся числами, одинаковым образом обращаться к раздельным пакетам
обыкновенной, рациональной и комплексной арифметики. Всякий конкретный
арифметический пакет (например, комплексная арифметика) сам по себе
доступен через обобщенные процедуры (например, @code{add-complex}),
которые связывают пакеты, предназначенные для различных реализаций
(таких, как декартовы и полярные числа). Более того, структура системы
аддитивна, так что можно проектировать отдельные арифметические пакеты
независимо и сочетать их, получая обобщенную арифметическую систему.

@menu
* 2-5-1::             Обобщенные арифметические операции
* 2-5-1::             Сочетание данных различных типов
* 2-5-1::             Пример символьная алгебра
@end menu

@comment @subsection Generic Arithmetic Operations
@subsection Обобщенные арифметические операции
@node	2.5.1, 2.5.2, 2.5, 2.5

Задача проектирования обобщенных арифметических операций аналогична
задаче проектирования обобщенных операций с комплексными числами. К
примеру, нам бы хотелось иметь обобщенную процедуру сложения @code{add},
которая действовала бы как обычное элементарное сложение @code{+} по
отношению к обычным числам, как @code{add-rat} по отношению к
рациональным числам и как @code{add-complex} по отношению к комплексным.
Реализовать @code{add} и прочие обобщенные арифметические операции мы
можем, следуя той же стратегии, которую мы использовали в разделе @ref{2.4.3}
для обобщенных селекторов комплексных чисел. К каждому числу мы прикрепим
метку типа и заставим обобщенную процедуру передавать управление в
нужный пакет в соответствии с типами своих аргументов.

Обобщенные арифметические процедуры определяются следующим образом:

@lisp
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
@end lisp

@noindent
Начнем с установки пакета для работы с числами, то есть элементарными
@newterm{ordinary} числами нашего языка. Мы пометим их символом
@code{scheme-number}. Арифметические операции этого пакета --- это элементарные
арифметические процедуры (так что нет никакой нужды определять
дополнительные процедуры для обработки непомеченных чисел). Поскольку
каждая из них принимает по два аргумента, в таблицу они заносятся с
ключом-списком @code{(scheme-number scheme-number)}:

@lisp
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
@end lisp

@noindent
Пользователи пакета Схемных чисел будут создавать (помеченные)
элементарные числа с помощью процедуры

@lisp
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
@end lisp

@noindent
Теперь, когда каркас обобщенной арифметической системы построен, мы
можем без труда добавлять новые типы чисел. Вот пакет, который реализует
арифметику рациональных чисел. Обратите внимание, что благодаря
аддитивности мы можем без изменений использовать код рациональной
арифметики из раздела @ref{2.1.1} в виде внутренних процедур пакета:

@lisp
(define (install-rational-package)
  @r{;; внутренние процедуры}
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  @r{;; интерфейс к остальной системе}
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
@end lisp

@noindent
Мы можем установить подобный пакет и для комплексных чисел, используя
метку @code{complex}. При создании пакета мы извлекаем из таблицы
операции @code{make-from-real-imag} и @code{make-from-mag-ang},
определенные в декартовом и полярном пакетах. Аддитивность позволяет нам
использовать без изменений в качестве внутренних операций процедуры
@code{add-complex}, @code{sub-complex}, @code{mul-complex} и
@code{div-complex} из
раздела @ref{2.4.1}.

@lisp
(define (install-complex-package)
  @r{;; процедуры, импортируемые из декартова и полярного пакетов}
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  @r{;; внутренние процедуры}
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  @r{;; интерфейс к остальной системе}
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Вне комплексного пакета программы могут создавать комплексные числа либо
из действительной и мнимой части, либо из модуля и аргумента. Обратите
внимание, как нижележащие процедуры, которые были изначально определены
в декартовом и полярном пакете, экспортируются в комплексный пакет, а
оттуда во внешний мир.

@lisp
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
@end lisp

@noindent
Здесь мы имеем двухуровневую систему меток. Типичное комплексное число,
например @math{3+4i} в декартовой форме, будет представлено так, как
показано на рисунке @ref{Рисунок 2.24}. Внешняя метка
(@code{complex}) используется, чтобы отнести число к пакету комплексных
чисел. Внутри комплексного пакета вторая метка (@code{rectangular})
относит число к декартову пакету. В большой и сложной системе может быть
несколько уровней, каждый из которых связан со следующим при помощи
обобщенных операций. Когда объект данных передается <<вниз>>, внешняя
метка, которая используется для отнесения к нужному пакету, отрывается
(при помощи вызова @code{contents}), и следующий уровень меток (если
таковой имеется) становится доступным для дальнейшей диспетчеризации.

@float
@quotation
@anchor{Рисунок 2.24}
@ifinfo
@strong{Рисунок 2.24:} Representation of @math{3 + 4i} in rectangular form.

@example
     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | * |
     +-|-+---+     +-|-+---+     +-|-+-|-+
       |             |             |   |
       V             V             V   V
 +---------+   +-------------+  +---+ +---+
 | complex |   | rectangular |  | 3 | | 4 |
 +---------+   +-------------+  +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap2/Fig2.24c,64mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.24:} Representation of @math{3 + 4i} in rectangular form.}
@center @caption{@strong{Рисунок 2.24:} Представление @math{3 + 4i} в декартовой форме.}
@sp 0.6
@end iftex
@end quotation
@end float

В приведенных пакетах мы использовали @code{add-rat}, @code{add-complex}
и другие арифметические процедуры ровно в таком виде, как они были
написаны с самого начала. Но когда эти определения оказываются внутри
различных процедур установки, отпадает необходимость давать им различные
имена: мы могли бы просто назвать их в обоих пакетах @code{add},
@code{sub}, @code{mul} и @code{div}.

@quotation
@strong{@anchor{Упражнение 2.77}Упражнение 2.77:}
Хьюго Дум пытается вычислить выражение
@code{(magnitude z)}, где @code{z} --- объект, показанный на
рис. @ref{Рисунок 2.24}. К своему удивлению, вместо ответа 5 он
получает сообщение об ошибке от @code{apply-generic}, гласящее, что у
операции @code{magnitude} нет методов для типа @code{(complex)}. Он
показывает результат Лизе П. Хакер. Та заявляет: <<Дело в том, что
селекторы комплексных чисел для чисел с меткой @code{complex} определены
не были, а были только для чисел с меткой @code{polar} и
@code{rectangular}. Все, что требуется, чтобы заставить это
работать --- это добавить к пакету @code{complex} следующее:>>

@lisp
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
@end lisp

Подробно опишите, почему это работает. В качестве примера, проследите
все процедуры, которые вызываются при вычислении @code{(magnitude z)},
где @code{z} --- объект, показанный на рис. @ref{Рисунок 2.24}. В
частности, сколько раз вызывается @code{apply-generic}? На какую
процедуру она диспетчирует в каждом случае?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.78}Упражнение 2.78:}
В пакете @code{scheme-number} внутренние процедуры, в
сущности, ничего не делают, только вызывают элементарные процедуры
@code{+}, @code{-}, и т.д. Прямо использовать примитивы языка не было
возможности, поскольку наша система меток типов требует, чтобы каждый
объект данных был снабжен меткой. Однако на самом деле все реализации
Лиспа имеют систему типов, которую они используют внутри себя.
Элементарные процедуры вроде @code{symbol?} или @code{number?}
определяют, относится ли объект к определенному типу. Измените
определения @code{type-tag}, @code{contents} и @code{attach-tag} из
раздела @ref{2.4.2} так, чтобы наша обобщенная система
использовала внутреннюю систему типов Scheme. То есть, система должна
работать так же, как раньше, но только обычные числа должны быть
представлены просто в виде чисел языка Scheme, а не в виде пары, у
которой первый элемент символ @code{scheme-number}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.79}Упражнение 2.79:}
Определите обобщенный предикат равенства @code{equ?},
который проверяет два числа на равенство, и вставьте его в пакет
обобщенной арифметики. Операция должна работать для обычных чисел,
рациональных и комплексных.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.80}Упражнение 2.80:}
Определите обобщенный предикат @code{=zero?}, который
проверяет, равен ли его аргумент нулю, и вставьте его в пакет обобщенной
арифметики. Предикат должен работать для обычных, рациональных и
комплексных чисел.
@end quotation

@comment @subsection Combining Data of Different Types
@subsection Сочетание данных различных типов
@node	2.5.2, 2.5.3, 2.5.1, 2.5

Мы видели, как можно построить объединенную арифметическую систему,
которая охватывает обыкновенные числа, комплексные числа, рациональные
числа и любые другие типы чисел, которые нам может потребоваться
изобрести, но мы упустили важный момент. Операции, которые мы до сих пор
определили, рассматривают различные типы данных как совершенно
независимые. Таким образом, есть отдельные пакеты для сложения,
например, двух обыкновенных чисел и двух комплексных чисел. Мы до сих
пор не учитывали того, что имеет смысл определять операции, которые
пересекают границы типов, например, сложение комплексного числа с
обычным. Мы затратили немалые усилия, чтобы воздвигнуть барьеры между
частями наших программ, так, чтобы их можно было разрабатывать и
понимать по отдельности. Нам бы хотелось добавить операции со смешанными
типами по возможности аккуратно, так, чтобы мы их могли поддерживать, не
нарушая всерьез границ модулей.

Один из способов управления операциями со смешанными типами состоит в
том, чтобы определить отдельную процедуру для каждого сочетания типов,
для которых операция имеет смысл. Например, мы могли бы расширить пакет
работы с комплексными числами и включить туда процедуру сложения
комплексных чисел с обычными, занося ее в таблицу с меткой
@code{(complex scheme-number)}:@footnote{Придется к тому же написать
почти такую же процедуру для типа @code{(scheme-number complex)}.}

@lisp
@r{;; включается в пакет комплексных чисел}
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
@end lisp

@noindent
Этот метод работает, но он очень громоздок. При такой системе стоимость
введения нового типа не сводится к тому, чтобы построить пакет процедур
для этого типа, но включает еще построение и установку процедур,
осуществляющих операции со смешанными типами. Это запросто может
потребовать больше кода, чем нужно, чтобы определить операции над самим
типом. Кроме того, этот метод подрывает нашу способность сочетать
отдельные пакеты аддитивно, или, по крайней мере, ограничивать степень,
в которой реализация отдельного пакета должна принимать другие пакеты в
расчет. Скажем, в вышеприведенном примере, кажется естественным, чтобы
ответственность за обработку смешанных операций с обычными и
комплексными числами лежала на комплексном пакете. Однако сочетание
рациональных и комплексных чисел может осуществляться комплексным
пакетом, рациональным пакетом, или каким-нибудь третьим, который
пользуется операциями, извлеченными из этих двух. Формулировка ясных
правил разделения ответственности между пакетами может стать непосильной
задачей при разработке систем с многими пакетами и многими смешанными
операциями.

@comment @subsubheading Coercion
@subsubheading Приведение типов

В ситуации общего вида, когда совершенно несвязанные друг с другом
операции применяются к совершенно друг с другом не связанным типам,
явное написание операций со смешанными типами, как бы это ни было
громоздко, --- все, на что мы можем рассчитывать. К счастью, обычно мы
можем воспользоваться дополнительной структурой, которая часто в скрытом
виде присутствует в нашей системе типов. Часто различные типы данных не
совсем независимы, и каким-то образом объекты одного типа можно
рассматривать как объекты другого. Такой процесс называется (@newterm{coercion}).
Например, если нас просят найти некоторую арифметическую комбинацию
обычного числа и комплексного, то мы можем рассматривать обычное число
как такое комплексное, у которого мнимая часть равна нулю. Это сводит
нашу задачу к сочетанию двух комплексных чисел, а с этим может
стандартным способом справиться пакет комплексной арифметики.

В общем случае мы можем реализовать эту идею, проектируя процедуры
приведения типа, которые переводят объект одного типа в эквивалентный
ему объект другого типа. Вот типичная процедура приведения типов,
которая преобразует данное обыкновенное число в комплексное, у которого
есть действительная часть, а мнимая равна нулю:

@lisp
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
@end lisp

@noindent
Мы записываем процедуры приведения типа в специальную таблицу приведения
типов, проиндексированную именами двух типов:

@lisp
(put-coercion 'scheme-number
              'complex
              scheme-number->complex)
@end lisp

@noindent
(Предполагается, что для работы с этой таблицей существуют процедуры
@code{put-coercion} и @code{get-coercion}.) Как правило, часть ячеек
этой таблицы будет пуста, потому что в общем случае невозможно привести
произвольный объект произвольного типа ко всем остальным типам. К
примеру, нет способа привести произвольное комплексное число к
обыкновенному, так что в таблице не появится общая процедура
@code{complex->scheme-number}.

Когда таблица приведения типов построена, мы можем работать с
приведением стандартным образом, приспособив для этого процедуру
@code{apply-generic} из раздела @ref{2.4.3}. Когда
нас просят применить операцию, мы первым делом, как и раньше, проверяем,
не определена ли уже операция для типов аргументов. Если да, мы вызываем
процедуру, найденную в таблице операций и типов. Если нет, мы пробуем
применить приведение типов. Для простоты мы рассматриваем только тот
случай, когда аргументов два.@footnote{Обобщение см. @ref{Упражнение 2.82}.}
Мы проверяем таблицу
преобразования типов и смотрим, можно ли объект первого типа привести ко
второму типу. Если да, осуществляем приведение и снова пробуем операцию.
Если объекты первого типа в общем случае ко второму не приводятся, мы
пробуем приведение в обратном направлении и смотрим, нет ли способа
привести второй аргумент к типу первого. Наконец, если нет никакого
известного способа привести один тип к другому, мы сдаемся. Вот эта
процедура:

@lisp
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else (error "No method for these types"
                                     (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
@end lisp

@noindent
Такая схема приведения типов имеет много преимуществ перед методом
явного определения смешанных операций, как это описано выше. Хотя нам
по-прежнему требуется писать процедуры приведения для связи типов
(возможно, @math{n^2} процедур для системы с @math{n} типами), для
каждой пары типов нам нужно написать только одну процедуру, а не по
процедуре на каждый набор типов и каждую обобщенную
операцию.@footnote{Если мы умные, мы обычно можем обойтись меньше, чем
@math{n^2} процедурами приведения типа. Например, если мы знаем, как из
типа 1 получить тип 2, а из типа 2 тип 3, то можно использовать это
знание для преобразования из 1 в 3. Это может сильно уменьшить
количество процедур, которые надо явно задавать при введении нового типа
в систему. Если нам не страшно ввести в свою систему требуемый уровень
изощренности, мы можем заставить ее искать по <<графу>> отношений между
типами и автоматически порождать все процедуры приведения типов, которые
можно вывести из тех, которые явно заданы.} Здесь мы рассчитываем на
то, что требуемая трансформация типов зависит только от самих типов, и
не зависит от операции, которую требуется применить.

С другой стороны, могут существовать приложения, для которых наша схема
приведения недостаточно обща. Даже когда ни один из объектов, которые
требуется сочетать, не может быть приведен к типу другого, операция
может оказаться применимой, если преобразовать оба объекта к третьему
типу. Чтобы справиться с такой степенью сложности и по-прежнему
сохранить модульность в наших программах, обычно необходимо строить
такие системы, которые еще в большей степени используют структуру в
отношениях между типами, как мы сейчас расскажем.

@comment @subsubheading Hierarchies of types
@subsubheading Иерархии типов

Описанная выше схема приведения типов опиралась на существование
естественных отношений между парами типов. Часто в отношениях типов
между собой существует более <<глобальная>> структура. Предположим,
например, что мы строим обобщенную арифметическую систему, которая
должна работать с целыми, рациональными, действительными и комплексными
числами. В такой системе вполне естественно будет рассматривать целое
число как частный случай рационального, которое в свою очередь является
частным случаем действительного числа, которое опять-таки частный случай
комплексного числа. Здесь мы имеем так называемую (@newterm{hierarchy of types}) в
которой, например, целые числа являются (@newterm{subtype}) рациональных чисел (то
есть всякая операция, которую можно применить к рациональному числу,
применима и к целым). Соответственно, мы говорим, что рациональные числа
являются (@newterm{supertype}) целых. Та конкретная иерархия, с которой мы имеем
дело здесь, имеет очень простой вид, а именно, у каждого типа не более
одного надтипа и не более одного подтипа. Такая структура, называемая
(@newterm{tower}), показана на рис. @ref{Рисунок 2.25}.

@float
@quotation
@anchor{Рисунок 2.25}
@ifinfo
@strong{Рисунок 2.25:} A tower of types.

@example
 complex
   ^
   |
  real
   ^
   |
rational
   ^
   |
integer
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.25,11mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.25:} A tower of types.}
@center @caption{@strong{Рисунок 2.25:} Башня типов.}
@sp 0.0
@end iftex
@end quotation
@end float

Если у нас имеется башня типов, то задача добавления нового типа в
систему сильно упрощается, поскольку требуется указать только то, каким
образом новый тип включается в ближайший надтип сверху и то, каким
образом он является надтипом типа, который находится прямо под ним.
Например, если мы хотим к комплексному числу добавить целое, нам не
нужно специально определять процедуру приведения типа
@code{integer->complex}. Вместо этого мы определяем, как можно перевести
целое число в рациональное, рациональное в действительное, и как
действительное число переводится в комплексное. Потом мы позволяем
системе преобразовать целое число в комплексное через все эти
промежуточные шаги и складываем два комплексных числа.

Можно переопределить процедуру @code{apply-generic} следующим образом:
для каждого типа требуется указать процедуру @code{raise}, которая
<<поднимает>> объекты этого типа на один уровень в башне. В таком
случае, когда системе требуется обработать объекты различных типов, она
может последовательно поднимать объекты более низких типов, пока все
объекты не окажутся на одном и том же уровне башни.
(Упражнения @ref{Упражнение 2.83} и @ref{Упражнение 2.84} касаются
деталей реализации такой стратегии.)

Еще одно преимущество башни состоит в том, что легко реализуется
представление о том, что всякий тип <<наследует>> операции своего
надтипа. Например, если мы не даем особой процедуры для нахождения
действительной части целого числа, мы все равно можем ожидать, что
@code{real-part} будет для них определена в силу того, что целые числа
являются подтипом комплексных. В случае башни мы можем устроить так,
чтобы это происходило само собой, модифицировав @code{apply-generic}.
Если требуемая операция не определена непосредственно для типа данного
объекта, мы поднимаем его до надтипа и пробуем еще раз. Так мы ползем
вверх по башне, преобразуя по пути свой аргумент, пока мы либо не найдем
уровень, на котором требуемую операцию можно произвести, либо не
доберемся до вершины (и в таком случае мы сдаемся).

Еще одно преимущество башни над иерархией более общего типа состоит в
том, что она дает нам простой способ <<опустить>> объект данных до его
простейшего представления. Например, если мы складываем @math{2+3i} с
@math{4-3i}, было бы приятно в качестве ответа получить целое 6, а не
комплексное @math{6+0i}. В упражнении @ref{Упражнение 2.85}
обсуждается способ, которым такую понижающую операцию можно реализовать.
(Сложность в том, что нам нужен общий способ отличить объекты, которые
можно понизить, вроде @math{6+0i}, от тех, которые понизить нельзя,
например @math{6+2i}.)

@float
@quotation
@anchor{Рисунок 2.26}
@ifinfo
@strong{Рисунок 2.26:} Relations among types of geometric figures.

@example
                     polygon
                    /       \
                   /         \
            triangle         quadrilateral
            /     \              /     \
           /       \            /       \
     isosceles   right      trapezoid   kite
     triangle    triangle       |         |
      |     \      |            |         |
      |      \     |            |         |
equilateral   isosceles   parallelogram   |
triangle      right          |       \    |
              triangle       |        \   |
                          rectangle  rhombus
                                \    /
                                 \  /
                                square
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap2/Fig2.26e,96mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 2.26:} Relations among types of geometric figures.}
@center @caption{@strong{Рисунок 2.26:} Отношения между типами геометрических фигур.}
@sp 0.8
@end iftex
@end quotation
@end float

@comment @subsubheading Inadequacies of hierarchies
@subsubheading Неадекватность иерархий

\enlargethispage{\baselineskip}

Если типы данных в нашей системе естественным образом выстраиваются в
башню, это сильно упрощает задачу работы с обобщенными операциями над
различными типами, как мы только что видели. К сожалению, обычно это не
так. На рисунке @ref{Рисунок 2.26} показано более сложное устройство
набора типов, а именно отношения между различными типами геометрических
фигур. Мы видим, что в общем случае у типа может быть более одного
подтипа. Например, и треугольники, и четырехугольники являются
разновидностями многоугольников. В дополнение к этому, у типа может быть
более одного надтипа. Например, равнобедренный прямоугольный треугольник
можно рассматривать и как равнобедренный, и как прямоугольный. Вопрос с
множественными надтипами особенно болезнен, поскольку из-за него
теряется единый способ <<поднять>> тип по иерархии. Нахождение
<<правильного>> надтипа, в котором требуется применить операцию к
объекту, может потребовать долгого поиска по всей сети типов внутри
процедуры вроде @code{apply-generic}. Поскольку в общем случае у типа
несколько подтипов, существует подобная проблема и в сдвиге значения
<<вниз>> по иерархии. Работа с большим количеством связанных типов без
потери модульности при разработке больших систем -- задача очень
трудная, и в этой области сейчас ведется много
исследований.@footnote{Данное утверждение, которое присутствует и в
первом издании этой книги, сейчас столь же верно, как и двенадцать лет
назад. Разработка удобного, достаточно общего способа выражать отношения
между различными типами сущностей (то, что философы называют
<<онтологией>>), оказывается невероятно сложным делом. Основная разница
между той путаницей, которая была десять лет назад, и той, которая есть
сейчас, состоит в том, что теперь множество неадекватных онтологических
теорий оказалось воплощено в массе соответственно неадекватных языков
программирования. Например, львиная доля сложности
объектно-ориентированных языков программирования --- и мелких
невразумительных различий между современными объектно-ориентированными
языками, --- сосредоточена в том, как рассматриваются обобщенные
операции над взаимосвязанными типами. Наше собственное описание
вычислительных объектов в главе @ref{Глава 3}
полностью избегает этих вопросов. Читатели, знакомые с
объектно-ориентированным программированием, заметят, что нам есть, что
сказать в главе 3
о локальном состоянии, но мы ни разу не упоминаем <<классы>> или
<<наследование>>. Мы подозреваем, что на самом деле эти проблемы нельзя
рассматривать только в терминах проектирования языков программирования,
без обращения к работам по представлению знаний и автоматическому
логическому выводу.}

@quotation
@strong{@anchor{Упражнение 2.81}Упражнение 2.81:}
Хьюго Дум заметил, что @code{apply-generic} может пытаться
привести аргументы к типу друг друга даже тогда, когда их типы и так
совпадают. Следовательно, решает он, нам нужно вставить в таблицу
приведения процедуры, которые приводят (@newterm{coerce}) аргументы
каждого типа к нему самому. Например, в дополнение к приведению
@code{scheme-number->complex}, описанному выше, он бы написал еще:

@lisp
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number
              'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
@end lisp

@enumerate a.

@item
Если установлены процедуры приведения типов, написанные Хьюго, что
произойдет, когда @code{apply-generic} будет вызвана с двумя аргументами
типа @code{scheme-number} или двумя аргументами типа @code{complex} для
операции, которая не находится в таблице для этих типов? Допустим,
например, что мы определили обобщенную процедуру возведения в степень:

@lisp
(define (exp x y) (apply-generic 'exp x y))
@end lisp

@noindent
и добавили процедуру возведения в степень в пакет чисел Scheme и ни в
какой другой:

@lisp
@r{;; Следующие строки добавляются в пакет scheme-number}
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y))))
     @r{; using primitive @code{expt}}
@end lisp

@noindent
Что произойдет, если мы позовем @code{exp} с двумя комплексными числами
в качестве аргументов?

@item
Прав ли Хьюго, что нужно что-то сделать с приведением однотипных
аргументов, или @code{apply-generic} и так работает правильно?

@item
Измените @code{apply-generic} так, чтобы она не пыталась применить
приведение, если у обоих аргументов один и тот же тип.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.82}Упражнение 2.82:}
Покажите, как обобщить @code{apply-generic} так, чтобы она
обрабатывала приведение в общем случае с несколькими аргументами. Один
из способов состоит в том, чтобы попытаться сначала привести все
аргументы к типу первого, потом к типу второго, и так далее. Приведите
пример, когда эта стратегия (а также двухаргументная версия, описанная
выше) недостаточно обща. (Подсказка: рассмотрите случай, когда в таблице
есть какие-то подходящие операции со смешанными типами, но обращения к
ним не произойдет.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.83}Упражнение 2.83:}
Предположим, что Вы разрабатываете обобщенную
арифметическую систему для работы с башней типов, показанной на
@ref{Рисунок 2.25}: целые, рациональные, действительные,
комплексные. Для каждого из типов (кроме комплексного), разработайте
процедуру, поднимающую объект на один уровень в башне. Покажите, как
ввести обобщенную операцию @code{raise}, которая будет работать для всех
типов (кроме комплексных чисел).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.84}Упражнение 2.84:}
Используя операцию @code{raise} из
упражнения @ref{Упражнение 2.83}, измените процедуру
@code{apply-generic} так, чтобы она приводила аргументы к одному типу
путем последовательного подъема, как описано в этом разделе. Потребуется
придумать способ проверки, какой из двух типов выше по башне. Сделайте
это способом, <<совместимым>> с остальной системой, так, чтобы не
возникало проблем при добавлении к башне новых типов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.85}Упражнение 2.85:}
В этом разделе упоминался метод <<упрощения>> объекта
данных путем спуска его по башне насколько возможно вниз. Разработайте
процедуру @code{drop}, которая делает это для башни, описанной в
упражнении @ref{Упражнение 2.83}. Ключ к задаче состоит в том, что
надо решить некоторым общим способом, можно ли понизить объект в типе.
Например, комплексное число @math{1.5+0i} можно опустить до @code{real},
комплексное число @math{1+0i} до @code{integer}, а комплексное число
@math{2+3i} никуда понизить нельзя. Вот план того, как определить, можно
ли понизить объект: для начала определите обобщенную операцию
@code{project}, которая <<сталкивает>> объект вниз по башне. Например,
проекция комплексного числа будет состоять в отбрасывании его мнимой
части. Тогда число можно сдвинуть вниз в том случае, если, спроецировав
его, а затем подняв обратно до исходного типа, мы получаем нечто, равное
исходному числу. Покажите как реализовать эту идею в деталях, написав
процедуру @code{drop}, которая опускает объект как можно ниже.
Потребуется разработать различные операции
проекции@footnote{Действительное число можно спроецировать на целое при
помощи примитива , который возвращает целое число, ближайшее к своему
аргументу.} и установить @code{project} в системе в качестве обобщенной
операции. Вам также потребуется обобщенный предикат равенства, подобный
описанному в упражнении @ref{Упражнение 2.79}. Наконец, используя
@code{drop}, перепишите @code{apply-generic} из упражнения
@ref{Упражнение 2.84}, чтобы она <<упрощала>> свои результаты.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.86}Упражнение 2.86:}
Допустим, нам хочется работать с комплексными числами, чьи
действительные и мнимые части, модули и аргументы могут быть
обыкновенными числами, рациональными числами либо любыми другими, какие
нам захочется добавить к системе. Опишите и реализуйте изменения в
системе, которые потребуются, чтобы добавить такую возможность. Вам
придется определить операции вроде @code{sine} (синус) и @code{cosine}
(косинус), обобщенные на обыкновенные и рациональные числа.
@end quotation

@comment @subsection Example: Symbolic Algebra
@subsection Пример: символьная алгебра
@node	2.5.3,  , 2.5.2, 2.5

Обработка символьных алгебраических выражений представляет собой сложный
процесс, который иллюстрирует многие тяжелейшие проблемы, возникающие
при проектировании больших систем. В общем случае, алгебраическое
выражение можно рассматривать как иерархическую структуру, дерево
операций, применяемых к операндам. Мы можем строить алгебраические
выражения, начиная с элементарных объектов, таких, как константы и
переменные, и комбинируя их с помощью алгебраических операций, таких,
как сложение и умножение. Как и в других языках, мы формируем
абстракции, которые позволяют нам именовать составные объекты при помощи
простых терминов. В символьной алгебре типичными абстракциями являются
такие понятия, как линейная комбинация, многочлен, рациональная или
тригонометрическая функция. Мы можем рассматривать их как составные
<<типы>>, которые часто бывают полезны при управлении обработкой
выражений. Например, выражение
@ifinfo

@example
x^2 sin (y^2 + 1) + x cos 2y + cos(y^3 - 2y^2)
@end example

@end ifinfo
@tex
$$ x^2 \sin (y^2 + 1) + x \cos 2y + \cos(y^3 - 2y^2) $$
@end tex
@noindent
можно рассматривать
как многочлен по @math{x} с коэффициентами, которые являются
тригонометрическими функциями многочленов по @math{y}, чьи коэффициенты,
в свою очередь, целые числа.

Здесь мы не будем пытаться разработать полную систему для работы с
алгебраическими выражениями. Такие системы --- очень сложные программы,
использующие глубокие математические знания и элегантные алгоритмы. Мы
собираемся описать только одну простую, но важную часть алгебраических
операций --- арифметику многочленов. Мы проиллюстрируем типы решений,
которые приходится принимать разработчику подобной системы, и то, как
применить идеи абстракции данных и обобщенных операций, чтобы с их
помощью организовать работу.

@comment @subsubheading Arithmetic on polynomials
@subsubheading Арифметика многочленов

Первая задача при разработке системы для проведения арифметических
операций над многочленами --- решить, что именно представляет собой
многочлен. Обычно многочлены определяют по отношению к тем или иным
переменным. Ради простоты, мы ограничимся многочленами только с одной
переменной.@footnote{С другой стороны, мы разрешаем многочлены,
коэффициенты которых сами по себе являются многочленами от других
переменных. По существу, это дает нам такую же выразительную силу, что и
у полной системы со многими переменными, хотя и ведет к проблемам
приведения, как это обсуждается ниже.}. Мы определяем многочлен как
сумму термов, каждый из которых представляет собой либо коэффициент,
либо переменную, возведенную в степень, либо произведение того и
другого. Коэффициент определяется как алгебраическое выражение, не
зависящее от переменной многочлена. Например,
@ifinfo

@example
5x^2 + 3x + 7
@end example

@end ifinfo
@tex
$$ 5x^2 + 3x + 7 $$
@end tex
@noindent
есть простой многочлен с переменной @math{x}, а
@ifinfo

@example
(y^2 + 1)x^3 + (2y)x + 1
@end example

@end ifinfo
@tex
$$ (y^2 + 1)x^3 + (2y)x + 1 $$
@end tex
@noindent
есть многочлен по @math{x}, коэффициенты которого --- многочлены по @math{y}.

Уже здесь мы сталкиваемся с несколькими неудобными деталями. Является ли
первый из приведенных многочленов тем же объектом, что
@math{5y^2 + 3y + 7}? Разумный ответ на этот вопрос таков: <<если мы
рассматриваем многочлен как чисто математическую функцию, то да, но если
как синтаксическую форму, то нет>>. Второй пример алгебраически
эквивалентен многочлену по @math{y}, коэффициенты которого ---
многочлены по @math{x}. Должна ли наша система распознавать это?
Наконец, существуют другие способы представления многочленов ---
например, как произведение линейных множителей, как множество корней
(для многочлена с одной переменной), или как список значений многочлена
в заданном множестве точек.@footnote{В случае многочленов с одной
переменной задание значений многочлена в определенном множестве точек
может быть особенно удачным представлением. Арифметика многочленов
получается чрезвычайно простой. Чтобы получить, скажем, сумму двух
представленных таким образом многочленов, достаточно сложить значения в
соответствующих точках. Чтобы перейти обратно к более привычному
представлению, можно использовать формулу интерполяции Лагранжа, которая
показывает, как восстановить коэффициенты многочлена степени @math{n},
имея его значения в @math{n+1} точке.} Мы можем обойти эти вопросы,
решив, что в нашей системе алгебраических вычислений <<многочлен>> будет
определенной синтаксической формой, а не ее математическим значением.

Теперь пора подумать, как мы будем осуществлять арифметические операции
над многочленами. В нашей упрощенной системе мы рассмотрим только
сложение и умножение. Более того, мы будем настаивать, чтобы два
многочлена, над которыми проводится операция, имели одну и ту же
переменную.

К проектированию системы мы приступим, следуя уже знакомой нам
дисциплине абстракции данных. Мы будем представлять многочлены в виде
структуры данных под названием @newterm{poly}, которая состоит из переменной и набора
термов. Мы предполагаем, что имеются селекторы @code{variable} и
@code{term-list}, которые получают из poly эти данные, и конструктор
@code{make-poly}, который собирает poly из переменной и списка термов.
Переменная будет просто символом, так что для сравнения переменных мы
сможем использовать процедуру из раздела @ref{2.3.2}. Следующие
процедуры определяют сложение и умножение многочленов:

@lisp
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: ADD-POLY" (list p1 p2))))
(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: MUL-POLY" (list p1 p2))))
@end lisp

@noindent
Чтобы включить многочлены в нашу обобщенную арифметическую систему, нам
потребуется снабдить их метками типа. Мы будем пользоваться меткой
@code{polynomial} и вносить соответствующие операции над помеченными
многочленами в таблицу операций. Весь свой код мы включим в процедуру
установки пакета многочленов, подобно пакетам из
раздела @ref{2.5.1}:

@lisp
(define (install-polynomial-package)
  @r{;; внутренние процедуры}
  @r{;; представление poly}
  (define (make-poly variable term-list) (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  @math{\langle}@emph{процедуры @emph{same-variable?} и @emph{variable?} из раздела 2.3.2}@math{\rangle}
  @r{;; представление термов и списков термов}
  @math{\langle}@emph{процедуры @emph{adjoin-term} @dots{} @emph{coeff} из текста ниже}@math{\rangle}
  (define (add-poly p1 p2) @dots{})
  @math{\langle}@emph{процедуры, которыми пользуется @emph{add-poly}}@math{\rangle}
  (define (mul-poly p1 p2) @dots{})
  @math{\langle}@emph{процедуры, которыми пользуется @emph{mul-poly}}@math{\rangle}
  @r{;; интерфейс к остальной системе}
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)
@end lisp

@noindent
Сложение многочленов происходит по термам. Термы одинакового порядка (то
есть имеющие одинаковую степень переменной многочлена) нужно
скомбинировать. Это делается при помощи порождения нового терма того же
порядка, в котором коэффициент является суммой коэффициентов слагаемых.
Термы одного слагаемого, для которых нет соответствия в другом, просто
добавляются к порождаемому многочлену-сумме.

Для того, чтобы работать со списками термов, мы предположим, что имеется
конструктор @code{the-empty-termlist}, который возвращает пустой список
термов, и конструктор @code{adjoin-term}, который добавляет к списку
термов еще один. Кроме того, мы предположим, что имеется предикат
@code{empty-termlist?}, который говорит, пуст ли данный список, селектор
@code{first-term}, который получает из списка термов тот, у которого
наибольший порядок, и селектор @code{rest-terms}, который возвращает все
термы, кроме того, у которого наибольший порядок. Мы предполагаем, что
для работы с термами у нас есть конструктор @code{make-term}, строящий
терм с указанными порядком и коэффициентом, и селекторы @code{order} и
@code{coeff}, которые, соответственно, возвращают порядок и коэффициент
терма. Эти операции позволяют нам рассматривать и термы, и их списки как
абстракции данных, о конкретной реализации которых мы можем позаботиться
отдельно.

Вот процедура, которая строит список термов для суммы двух
многочленов:@footnote{Эта операция очень похожа на процедуру объединения
множеств @code{union-set}, которую мы разработали в
упражнении @ref{Упражнение 2.62}. На самом деле, если мы будем
рассматривать многочлены как множества, упорядоченные по степени
переменной, то программа, которая порождает список термов для суммы,
окажется почти идентична @code{union-set}.}

@lisp
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1))
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
@end lisp

@noindent
Самая важная деталь, которую здесь надо заметить, --- это что для
сложения коэффициентов комбинируемых термов мы использовали обобщенную
процедуру @code{add}. Это влечет глубокие последствия, как мы увидим
ниже.

Чтобы перемножить два списка термов, мы умножаем каждый терм из первого
списка на все термы второго, используя в цикле
@code{mul-term-by-allterms}, которая умножает указанный терм на все
термы указанного списка. Получившиеся списки термов (по одному на каждый
терм в первом списке) накапливаются и образуют сумму. Перемножение двух
термов дает терм, порядок которого равен сумме порядков множителей, а
коэффициент равен произведению коэффициентов множителей:

@lisp
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
@end lisp

@noindent
Вот и все, что нам требуется для сложения и умножения многочленов.
Обратите внимание, что, поскольку мы работаем с термами при помощи
обобщенных процедур @code{add} и @code{mul}, наш пакет работы с
многочленами автоматически оказывается в состоянии обрабатывать любой
тип коэффициента, о котором знает обобщенный арифметический пакет. Если
мы подключим механизм приведения типов, подобный тому, который
обсуждался в разделе @ref{2.5.2}, то
мы автоматически окажемся способны производить операции над многочленами
с коэффициентами различных типов, например
@ifinfo

@example
                         /        2                 \
[3x^2 + (2 + 3i)x + 7] * | x^4 + --- x^2 + (5 + 3i) |
                         \        3                 /
@end example

@end ifinfo
@tex
$$ [3x^2 + (2 + 3i)x + 7] \cdot \! \left[ x^4 + {2\over3} x^2 + (5 + 3i) \right]\!. $$
@end tex
Поскольку мы установили процедуры сложения и умножения многочленов
@code{add-poly} и @code{mul-poly} в обобщенной арифметической системе в
качестве операций @code{add} и @code{mul} для типа @code{polynomial},
наша система оказывается автоматически способна производить операции над
многочленами вроде
@ifinfo

@example
[(y + 1)x^2 + (y^2 + 1)x + (y - 1)] * [(y - 2)x + (y^3 + 7)]
@end example

@end ifinfo
@tex
$$ \Big[(y + 1)x^2 + (y^2 + 1)x + (y - 1)\Big] \cdot \Big[(y - 2)x + (y^3 + 7)\Big]\!. $$
@end tex
Причина этого в том, что, когда система пытается скомбинировать коэффициенты,
она диспетчирует через @code{add} и @code{mul}. Поскольку коэффициенты
сами по себе являются многочленами (по @math{y}), они будут
скомбинированы при помощи @code{add-poly} и @code{mul-poly}. В
результате получается своего рода <<рекурсия, управляемая данными>>,
где, например, вызов @code{mul-poly} приводит к рекурсивным вызовам
@code{mul-poly} для того, чтобы скомбинировать коэффициенты. Если бы
коэффициенты коэффициентов сами по себе были бы многочленами (это может
потребоваться, если надо представить многочлены от трех переменных),
программирование, управляемое данными, позаботится о том, чтобы система
прошла еще через один уровень рекурсивных вызовов, и так далее, на
столько уровней структуры, сколько требуют данные.@footnote{Чтобы все это
работало совершенно гладко, потребуется добавить в нашу систему
обобщенной арифметики возможность привести <<число>> к типу многочлена,
рассматривая его как многочлен степени ноль, коэффициентом которого
является данное число. Это нужно, если мы хотим осуществлять операции
вроде
@ifinfo

@example
[x^2 + (y + 1)x + 5] + [x^2 + 2x + 1]
@end example

@end ifinfo
@tex
$$ [x^2 + (y + 1)x + 5] + [x^2 + 2x + 1], $$
@end tex
@noindent
где требуется сложить коэффициент @math{y+1} с коэффициентом 2.}

@comment @subsubheading Representing term lists
@subsubheading Представление списков термов

Наконец, мы сталкиваемся с задачей реализовать хорошее представление для
списков термов. Список термов, в сущности, есть множество коэффициентов,
проиндексированное порядком терма. Следовательно, любой из методов
представления множеств, описанных в @ref{2.3.3}, годится для этой задачи. С
другой стороны, наши процедуры @code{add-terms} и @code{mul-terms}
всегда обрабатывают списки термов последовательно от наибольшего порядка
к наименьшему, так что мы будем использовать некоторую разновидность
упорядоченного представления.

Как нам устроить структуру данных, которая представляет список термов?
Одно из соображений --- <<плотность>> многочленов, с которыми мы будем
работать. Многочлен называется (@newterm{dense}), если в термах с большинством
порядков у него ненулевые коэффициенты. Если же в нем много нулевых
коэффициентов, он называется (@newterm{sparse}). Например,
@ifinfo

@example
A : x^5 + 2x^4 + 3x^2 - 2x - 5
@end example

@end ifinfo
@tex
$$ A: \quad x^5 + 2x^4 + 3x^2 - 2x - 5 $$
@end tex
@noindent
плотный многочлен, а
@ifinfo

@example
B : x^100 + 2x^2 + 1
@end example

@end ifinfo
@tex
$$ B: \quad x^{100} + 2x^2 + 1 $$
@end tex
@noindent
разреженный.

Списки термов плотных многочленов эффективнее всего представлять в виде
списков коэффициентов. Например, A в приведенном примере удобно
представляется в виде @code{(1 2 0 3 -2 -5)}. Порядок терма в таком
представлении есть длина списка, начинающегося с этого коэффициента,
уменьшенная на 1.@footnote{В этих примерах многочленов мы предполагаем,
что реализовали обобщенную арифметическую систему при помощи механизма
типов, предложенного в упражнении @ref{Упражнение 2.78}. Таким
образом, коэффициенты, которые являются обыкновенными числами, будут
представлены самими числами, а не парами с первым элементом ---
символом @code{scheme-number}.} Для разреженного многочлена вроде B
такое представление будет ужасным: получится громадный список нулей, в
котором изредка попадаются одинокие ненулевые термы. Более разумно
представление разреженного многочлена в виде списка ненулевых термов,
где каждый терм есть список, содержащий порядок терма и коэффициент при
этом порядке. При такой схеме многочлен B эффективно представляется в
виде @code{((100 1) (2 2) (0 1))}. Поскольку большинство операций над
многочленами применяется к разреженным многочленам, мы используем это
представление. Мы предполагаем, что список термов представляется в виде
списка, элементами которого являются термы, упорядоченные от бо́льшего
порядка к меньшему. После того, как решение принято, реализация
селекторов и конструкторов для термов и списков термов не представляет
трудностей:@footnote{Хотя мы предполагаем, что списки термов упорядочены,
мы реализовали @code{adjoin-term} путем простого @code{cons} к
существующему списку термов. Нам это может сойти с рук, пока мы
гарантируем, что процедуры (вроде @code{add-terms}), которые используют
@code{adjoin-term}, всегда вызывают ее с термом бо́льшего порядка, чем
уже есть в списке. Если бы нам не хотелось давать такую гарантию, мы
могли бы реализовать @code{adjoin-term} подобно конструктору
@code{adjoin-set} для представления множеств в виде упорядоченных
списков (упражнение @ref{Упражнение 2.61}).}:

@lisp
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))
(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
@end lisp

@noindent
где @code{=zero?} работает так, как определяется в @ref{Упражнение 2.80}
(см. также ниже @ref{Упражнение 2.87}).

Пользователи многочленного пакета будут создавать (помеченные)
многочлены при помощи процедуры:

@lisp
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.87}Упражнение 2.87:}
Установите @code{=zero? } для многочленов в обобщенный
арифметический пакет. Это позволит @code{adjoin-term} работать с
многочленами, чьи коэффициенты сами по себе многочлены.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.88}Упражнение 2.88:}
Расширьте систему многочленов так, чтобы она включала
вычитание многочленов. (Подсказка: может оказаться полезным определить
обобщенную операцию смены знака.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.89}Упражнение 2.89:}
Определите процедуры, которые реализуют представление в
виде списка термов, описанное выше как подходящее для плотных
многочленов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.90}Упражнение 2.90:}
Допустим, что мы хотим реализовать систему многочленов,
которая эффективна как для плотных, так и для разреженных многочленов.
Один из способов это сделать заключается в том, чтобы разрешить в
системе оба типа представления. Ситуация аналогична примеру с
комплексными числами из раздела @ref{1.4}, где мы
позволили сосуществовать декартову и полярному представлению. Чтобы
добиться этого, нам придется различать виды списков термов и сделать
операции над списками термов обобщенными. Перепроектируйте систему с
многочленами так, чтобы это обобщение было реализовано. Это потребует
большого труда, а не только локальных изменений.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.91}Упражнение 2.91:}
Многочлены с одной переменной можно делить друг на друга,
получая частное и остаток. Например,
@ifinfo

@example
x^5 - 1
------- = x^3 + x, remainder x - 1
x^2 - 1
@end example

@end ifinfo
@tex
$$ {x^5 - 1 \over x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1. $$
@end tex
Деление можно производить в столбик. А именно, разделим старший член
делимого на старший член делителя. В результате получится первый терм
частного. Затем умножим результат на делитель, вычтем получившийся
многочлен из делимого и, рекурсивно деля разность на делитель, получим
оставшуюся часть частного. Останавливаемся, когда порядок делителя
превысит порядок делимого, и объявляем остатком то, что тогда будет
называться делимым. Кроме того, если когда-нибудь делимое окажется
нулем, возвращаем ноль в качестве и частного, и остатка.

Процедуру @code{div-poly} можно разработать, следуя образцу
@code{add-poly} и @code{mul-poly}. Процедура проверяет, одна ли и та же
у многочленов переменная. Если это так, @code{div-poly} откусывает
переменную и передает задачу в @code{div-terms}, которая производит
операцию деления над списками термов. Наконец, @code{div-poly}
прикрепляет переменную к результату, который выдает @code{div-terms}.
Удобно сделать так, чтобы @code{div-terms} выдавала и частное, и остаток
при делении. Она может брать в качестве аргументов два терма и выдавать
список, состоящий из списка термов частного и списка термов остатка.

Закончите следующее определение @code{div-terms}, вставив недостающие
выражения. Используйте ее, чтобы реализовать @code{div-poly}, которая
получает в виде аргументов два экземпляра poly, а выдает список из
poly--частного и poly--остатка.

@smalllisp
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     @math{\langle}@var{рекурсивно вычислить оставшуюся}@math{\rangle} ))
                @math{\langle}@var{сформировать окончательный резальтат}@math{\rangle} ))))))
@end smalllisp
@end quotation

@comment @subsubheading Hierarchies of types in symbolic algebra
@subsubheading Иерархии типов в символьной алгебре

Наша система обработки многочленов показывает, как объекты одного типа
(многочлены) могут на самом деле быть составными сущностями, содержащими
в качестве частей объекты многих различных типов. При определении
обобщенных операций это не составляет никакой реальной сложности. Нужно
только установить соответствующие обобщенные операции для выполнения
необходимых действий над частями составных типов. В сущности, мы видели,
что многочлены образуют своего рода <<рекурсивную абстракцию данных>>, в
том смысле, что части многочленов сами по себе могут быть многочленами.
Наши обобщенные операции и наш стиль программирования, управляемого
данными, могут справиться с такими трудностями без особого труда.

С другой стороны, алгебра многочленов представляет собой систему, в
которой типы данных нельзя естественным образом выстроить в виде башни.
Например, могут существовать многочлены по @math{x}, коэффициенты
которых являются многочленами по @math{y}. Но могут существовать и
многочлены по @math{y}, коэффициенты которых являются многочленами по
@math{x}. Никакой из этих типов не находится <<выше>> другого ни в каком
естественным смысле, и тем не менее элементы этих двух множеств часто
требуется складывать. Для этого существует несколько способов. Одна из
возможностей состоит в том, чтобы преобразовывать один из многочленов к
типу другого путем раскрытия и переупорядочения термов, так, чтобы у
обоих многочленов оказалась одна и та же главная переменная. Можно
навязать данным башнеподобную структуру путем упорядочения переменных,
и, таким образом, всегда преобразовывать любой многочлен к
<<канонической форме>>, где переменная с наибольшим приоритетом всегда
доминирует, а переменные с меньшим оказываются зарыты в коэффициенты.
Такая стратегия работает довольно хорошо, только преобразование может
без особой необходимости <<раздуть>> многочлен, так что его станет
неудобно читать и, возможно, менее эффективно обрабатывать. Для этой
области структура башни определенно не является естественной, как и для
любой другой области, где пользователь может изобретать новые типы
динамически, используя старые в различных комбинирующих формах, таких
как тригонометрические функции, последовательности степеней или
интегралы.

Не должно вызывать удивления то, что управление приведением типов
представляет серьезную проблему при разработке крупных систем
алгебраических манипуляций. Существенная часть сложности таких систем
связана с отношениями между различными типами. В сущности, можно честно
признать, что мы до сих пор не до конца понимаем приведение типов. Мы
даже не до конца осознаем понятие типа данных. Однако то, что мы знаем,
дает нам солидные принципы структурирования и модуляризации, которые
помогают в разработке больших систем.

@quotation
@strong{@anchor{Упражнение 2.92}Упражнение 2.92:}
Использовав упорядочение переменных, расширьте пакет работы
с многочленами так, чтобы сложение и умножение многочленов работало для
многочленов с несколькими переменными. (Это не простая задача!)
@end quotation

@comment @subsubheading Extended exercise: Rational functions
@subsubheading Расширенное упражнение: рациональные функции

Можно расширить обобщенную арифметическую систему и включить в нее
(@newterm{rational functions}). Это <<дроби>>, в которых числитель и знаменатель
являются многочленами, например
@ifinfo

@example
 x + 1
-------
x^3 - 1
@end example

@end ifinfo
@tex
$$ {x + 1 \over x^3 - 1}\,. $$
@end tex
Система должна уметь складывать, вычитать. умножать и делить рациональные
функции, а также осуществлять вычисления вроде
@ifinfo

@example
 x + 1       x      x^3 + 2x^2 + 3x + 1
------- + ------- = -------------------
x^3 - 1   x^2 - 1    x^4 + x^3 - x - 1
@end example

@end ifinfo
@tex
$$ {x + 1 \over x^3 - 1} + {x \over x^2 - 1} =
    {x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}\,. $$
@end tex
@noindent

(здесь сумма упрощена при помощи сокращения общих множителей. Обычное
<<перекрестное умножение>> дало бы многочлен четвертой степени в числителе
и пятой в знаменателе.)

Если мы изменим пакет арифметики рациональных чисел так, чтобы он
использовал обобщенные операции, то он будет делать то, что нам
требуется, за исключением задачи приведения к наименьшему знаменателю.

@quotation
@strong{@anchor{Упражнение 2.93}Упражнение 2.93:}
Модифицируйте пакет арифметики рациональных чисел, заставив
его пользоваться обобщенными операциями, но при этом измените
@code{make-rat}, чтобы она не пыталась сокращать дроби. Проверьте
систему, применив @code{make-rational} к двум многочленам, и получив
рациональную функцию

@lisp
(define p1 (make-polynomial 'x '((2 1) (0 1))))
(define p2 (make-polynomial 'x '((3 1) (0 1))))
(define rf (make-rational p2 p1))
@end lisp

Сложите теперь @code{rf} саму с собой, используя @code{add}. Вы увидите,
что процедура сложения не приводит дроби к наименьшему знаменателю.
@end quotation

@noindent
Приводить дроби многочленов к наименьшему знаменателю мы можем,
используя ту же самую идею, которой мы воспользовались для целых чисел:
изменить @code{make-rat}, чтобы она делила и числитель, и знаменатель на
их наибольший общий делитель. Понятие <<наибольшего общего делителя>>
имеет смысл для многочленов. Более того, вычислять НОД для многочленов
можно с помощью, в сущности, того же алгоритма Евклида, который работает
на целых числах.@footnote{То, что алгоритм Евклида работает для
многочленов, в алгебре формализуется утверждением, что многочлены
образуют структуру, называемую (Euclidean ring). Евклидово кольцо ---
это структура, на которой определены сложение, вычитание и коммутативное
умножение, а также некоторый способ сопоставить каждому элементу кольца
@math{x} <<меру>> --- неотрицательное целое число @math{m(x)},
обладающую следующими свойствами: @math{m(xy) \ge m(x)} для любых
ненулевых @math{x} и @math{y}, а также для любых @math{x} и @math{y}
существует @math{q}, такое, что @math{y = qx + r} и либо @math{r=0},
либо @math{m(r) < m(x)}. С абстрактной точки зрения, это все, что нужно,
чтобы доказать, что алгоритм Евклида работает. В случае целых чисел,
мера @math{m} каждого числа есть его модуль. Для структуры многочленов
мерой служит степень многочлена.} Вот целочисленная версия:

@lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
@end lisp

@noindent
Взяв ее за основу, мы можем проделать очевидные изменения и определить
операцию извлечения НОД, которая работает на списках термов:

@lisp
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
@end lisp

@noindent
где @code{remainder-terms} извлекает компоненту списка, соответствующую
остатку, из списка, который возвращает операция деления списков термов
@code{divterms}, реализованная в упражнении @ref{Упражнение 2.91}.

@quotation
@strong{@anchor{Упражнение 2.94}Упражнение 2.94:}
Используя @code{div-terms}, напишите процедуру
@code{remainder-terms}, и с ее помощью определите @code{gcd-terms}, как
показано выше. Напишите теперь процедуру @code{gcd-polys}, которая
вычисляет НОД двух многочленов. (Процедура должна сообщать об ошибке,
если входные объекты являются многочленами от разных переменных.)
Установите в систему обобщенную операцию @code{greatest-common-divisor},
которая для многочленов сводится к @code{gcd-poly}, а для обыкновенных
чисел к обыкновенному @code{gcd}. В качестве проверки, попробуйте ввести

@lisp
(define p1 (make-polynomial
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
@end lisp

@noindent
и проверьте результат вручную.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.95}Упражнение 2.95:}
Пусть @math{P_1}, @math{P_2} и @math{P_3} -- многочлены

@ifinfo

@example
P_1 : x^2 - 2x + 1

P_2 : 11x^2 + 7

P_3 : 13x + 5
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{{}:}l}
    P_1 	& \quad x^2 - 2x + 1, \\
    P_2 	& \quad 11x^2 + 7, \\
    P_3 	& \quad 13x + 5.
\end{array}
$$
@end tex
Теперь пусть @math{Q_1} будет произведение @math{P_1} и
@math{P_2}, а @math{Q_2} произведение @math{P_1} и @math{P_3}. При
помощи @code{greatest-common-divisor}
(упражнение @ref{Упражнение 2.94}) вычислите НОД @math{Q_1} и
@math{Q_2}. Обратите внимание, что ответ не совпадает с @math{P_1}. Этот
пример вводит в вычисление операции с нецелыми числами, и это создает
сложности для алгоритма вычисления НОД.@footnote{В системах вроде MIT
Scheme получится многочлен, который на самом деле является делителем
@math{Q_1} и @math{Q_2}, но с рациональными коэффициентами. Во многих
других реализациях Scheme, где при делении целых чисел могут получаться
десятичные числа ограниченной точности, может оказаться, что мы не
получим правильного делителя.}. Чтобы понять, что здесь происходит,
попробуйте включить трассировку в @code{gcd-terms} при вычислении НОД
либо проведите деление вручную.
@end quotation

@noindent
Проблему, которую демонстрирует упражнение @ref{Упражнение 2.95},
можно решить, если мы используем следующий вариант алгоритма вычисления
НОД (который работает только для многочленов с целыми коэффициентами).
Прежде, чем проводить деление многочленов при вычислении НОД, мы
умножаем делимое на целую константу, которая выбирается так, чтобы в
процессе деления не возникло никаких дробей. Результат вычисления будет
отличаться от настоящего НОД на целую константу, но при приведении
рациональных функций к наименьшему знаменателю это несущественно; будет
проведено деление и числителя, и знаменателя на НОД, так что константный
множитель сократится.

\enlargethispage{\baselineskip}

Выражаясь более точно, если @math{P} и @math{Q} --- многочлены,
определим @math{O_1} как порядок @math{P} (то есть порядок его старшего
терма), а @math{O_2} как порядок @math{Q}. Пусть @math{c} будет
коэффициент старшего терма @math{Q}. В таком случае, можно показать, что
если мы домножим @math{P} на (@newterm{integerizing factor}) @math{c^{1+O_1-O_2}},
то получившийся многочлен можно будет поделить на @math{Q} алгоритмом
@code{div-terms}, получив результат, в котором не будет никаких дробей.
Операция домножения делимого на такую константу, а затем деления, иногда
называется (@newterm{pseudodivision}) @math{P} на @math{Q}. Остаток такого
деления называется (@newterm{pseudoremainder}).

@quotation
@strong{@anchor{Упражнение 2.96}Упражнение 2.96:}
@enumerate a.

@item
Напишите процедуру @code{pseudoremainder-terms}, которая работает в
точности как @code{remainder-terms}, но только прежде, чем позвать
@code{div-terms}, домножает делимое на множитель целости, описанный
выше. Модифицируйте @code{gcd-terms} так, чтобы она использовала
@code{pseudoremainder-terms}, и убедитесь, что теперь в примере из
упражнения @ref{Упражнение 2.95} @code{greatest-common-divisor} выдает
ответ с целыми коэффициентами.

@item
Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты
@math{P_1}. Измените @code{gcd-terms}, чтобы она убирала общий множитель
из коэффициентов ответа путем деления всех коэффициентов на их
(целочисленный) НОД.

@end enumerate
@end quotation

@noindent
Итак, вот как привести рациональную функцию к наименьшему знаменателю:

@itemize @bullet

@item
Вычислите НОД числителя и знаменателя, используя версию @code{gcd-terms}
из упражнения @ref{Упражнение 2.96}.

@item
Когда Вы получаете НОД, домножьте числитель и знаменатель на множитель
целости, прежде чем делить на НОД, чтобы при делении не получить дробных
коэффициентов. В качестве множителя можно использовать старший
коэффициент НОД, возведенный в степень @math{1 + O_1 - O_2}, где
@math{O_2} -- порядок НОД, а @math{O_1} --- максимум из порядков
числителя и знаменателя. Так Вы добьетесь того, чтобы деление числителя
и знаменателя на НОД не привносило дробей.

@item
В результате этой операции Вы получите числитель и знаменатель с целыми
коэффициентами. Обычно из-за всех множителей целости коэффициенты
окажутся очень большими, стало быть, на последнем шаге следует
избавиться от лишних множителей, вычислив (целый) наибольший общий
делитель числителя и знаменателя и поделив на него все термы.
@end itemize

@endpage
@quotation
@strong{@anchor{Упражнение 2.97}Упражнение 2.97:}
@enumerate a.

@item
Реализуйте этот алгоритм как процедуру @code{reduce-terms}, которая
принимает в качестве аргументов два списка термов @code{n} и @code{d} и
возвращает список из @code{nn} и @code{dd}, которые представляют собой
@code{n} и @code{d}, приведенные к наименьшему знаменателю по
вышеописанному алгоритму. Напишите, кроме того, процедуру
@code{reduce-poly}, подобную @code{add-poly}, которая проверяет, чтобы
два poly имели одну и ту же переменную. Если это так, @code{reduce-poly}
откусывает эту переменную и передает оставшуюся часть задачи в
@code{reduce-terms}, а затем прикрепляет переменную обратно к двум
спискам термов, которые получены из @code{reduce-terms}.

@item
Определите процедуру, аналогичную @code{reduce-terms}, которая делает
то, что делала для целых чисел исходная @code{make-rat}:

@lisp
(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
@end lisp

@noindent
и определите @code{reduce} как обобщенную операцию, которая вызывает
@code{apply-generic} и диспетчирует либо к @code{reduce-poly} (если
аргументы --- многочлены), либо к @code{reduce-integers} (для
аргументов типа @code{scheme-number}). Теперь Вы легко можете заставить
пакет рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от @code{make-rat} звать @code{reduce} прежде, чем сочетать
данные числитель и знаменатель в процессе порождения рационального
числа. Теперь система обрабатывает рациональные выражения и для целых
чисел, и для многочленов. Чтобы проверить программу, попробуйте пример,
который приведен в начале этого расширенного упражнения:

@lisp
(define  p1 (make-polynomial 'x '((1 1) (0  1))))
(define  p2 (make-polynomial 'x '((3 1) (0 -1))))
(define  p3 (make-polynomial 'x '((1 1))))
(define  p4 (make-polynomial 'x '((2 1) (0 -1))))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))
(add rf1 rf2)
@end lisp

Посмотрите, удалось ли Вам получить правильный ответ, правильно
приведенный к наименьшему знаменателю.
@end enumerate
@end quotation

@endpage
@noindent
Вычисление НОД находится в центре всякой системы, работающей с
рациональными числами. Алгоритм, который мы использовали в тексте, хотя
математически он естествен, работает очень медленно. Медлительность эта
проистекает отчасти из большого количества операций деления, а отчасти
из огромного размера промежуточных коэффициентов, которые порождаются в
ходе псевдоделения. Одна из активно разрабатываемых областей в теории
систем алгебраических манипуляций -- построение более быстрых алгоритмов
для вычисления НОД многочленов.@footnote{Изящный и чрезвычайно
эффективный метод вычисления НОД многочленов был открыт Ричардом
Зиппелем (Zippel 1979). Этот метод --- вероятностный алгоритм, подобно
быстрому тесту на простоту числа, описанному в главе @ref{Глава 1}.
Книга Зиппеля (@ref{Zippel 1993}) описывает этот метод, а также другие
способы нахождения НОД многочленов.}
@comment @chapter Modularity, Objects, and State
@chapter Модульность, объекты и состояние
@node    Chapter 3, Chapter 4, Chapter 2, Top

@c @sp 0.5

@quotation
Mεταβάλλον ὰναпαύεται\\
(Изменяясь, оно остается неподвижным)\\
---Heraclitus
@end quotation

@quotation
Plus @,{c}a change, plus c'est la m@^{e}me chose.\\
---Alphonse Karr
@end quotation

@c @sp 1.0

@noindent
\lettrine{В} {предыдущих главах} мы ввели основные элементы, из которых строятся
программы. Мы видели, как элементарные процедуры и элементарные данные,
сочетаясь, образуют составные сущности; мы стали понимать, что без
абстракции нельзя справиться со сложностью больших систем. Однако этих
инструментов недостаточно для разработки программ. Для эффективного
синтеза программ требуются также организационные принципы, которые
помогали бы нам сформулировать общий проект программы. В частности, нам
нужны стратегии для построения больших программ по принципу
(@newterm{modularity}): чтобы программы <<естественным>> образом делились на
логически цельные куски, которые можно разрабатывать и поддерживать
независимо друг от друга.

Существует мощная стратегия разработки, которая особенно хорошо подходит
для построения программ, моделирующих физические системы: воспроизводить
в структуре программы структуру моделируемой системы. Для каждого
объекта в системе мы строим соответствующий ему вычислительный объект.
Для каждого действия в системе определяем в рамках нашей вычислительной
модели символьную операцию. Используя эту стратегию, мы надеемся, что
расширение нашей модели на новые объекты или действия не потребует
стратегических изменений в программе, а позволит обойтись только
добавлением новых символьных аналогов этих объектов или действий. Если
наша организация системы окажется удачной, то для добавления новых
возможностей или отладки старых нам придется работать только с
ограниченной частью системы.

Таким образом, способ, которым мы организуем большую программу, в
значительной степени диктуется нашим восприятием моделируемой системы. В
этой главе мы исследуем две важных организационных стратегии, которые
соответствуют двум достаточно различным взглядам на мир и структуру
систем. Первая из них сосредотачивается на (objects), и большая система
рассматривается как собрание индивидуальных объектов, поведение которых
может меняться со временем. Альтернативная стратегия строится вокруг
(streams) информации в системе, во многом подобно тому, как в
электронике рассматриваются системы обработки сигналов.

Как подход, основанный на объектах, так и подход, основанный на потоках,
высвечивают важные вопросы, касающиеся языков программирования. При
работе с объектами нам приходится думать о том, как вычислительный
объект может изменяться и при этом сохранять свою индивидуальность.
Из-за этого нам придется отказаться от подстановочной модели вычислений
(раздел @ref{1.1.5}) в
пользу более механистичной и в то же время менее привлекательной
теоретически (@newterm{environment model}). Сложности, связанные с объектами, их
изменением и индивидуальностью являются фундаментальным следствием из
потребности ввести понятие времени в вычислительные модели. Эти
сложности только увеличиваются, когда мы добавляем возможность
параллельного выполнения программ. Получить наибольшую отдачу от
потокового подхода удается тогда, когда моделируемое время отделяется от
порядка событий, происходящих в компьютере в процессе вычисления. Мы
достигнем этого при помощи метода, называемого (@newterm{delayed evaluation}).

@menu
* 3-1::              Присваивание и внутреннее состояние объектов::
* 3-2::              Модель вычислений с окружениями::
* 3-3::              Моделирование при помощи изменяемых данных::
* 3-4::              Параллелизм время имеет значение::
* 3-5::              Потоки::
@end menu

@comment @section Assignment and Local State
@section Присваивание и внутреннее состояние объектов
@node	3.1, 3.2, Chapter 3, Chapter 3

Обычно мы считаем, что мир состоит из отдельных объектов, и у каждого из
них есть состояние, которое изменяется со временем. Мы говорим, что
объект <<обладает состоянием>>, если на поведение объекта влияет его
история. Например, банковский счет обладает состоянием потому, что ответ
на вопрос <<Могу ли я снять 100 долларов?>> зависит от истории занесения
и снятия с него денег. Состояние объекта можно описать набором из одной
или более (@newterm{state variables}), которые вместе содержат достаточно
информации, чтобы определить текущее поведение объекта. В простой
банковской системе состояние счета можно охарактеризовать его текущим
балансом, вместо того, чтобы запоминать всю историю транзакций с этим
счетом.

@endpage
Если система состоит из многих объектов, они редко совершенно независимы
друг от друга. Каждый из них может влиять на состояние других при помощи
актов взаимодействия, связывающих переменные состояния одного объекта с
переменными других объектов. На самом деле, взгляд, согласно которому
система состоит из отдельных объектов, полезнее всего в том случае,
когда ее можно разделить на несколько подсистем, в каждой из которых
внутренние связи сильнее, чем связи с другими подсистемами.

Такая точка зрения на систему может служить мощной парадигмой для
организации вычислительных моделей системы. Чтобы такая модель была
модульной, ее требуется разделить на вычислительные объекты,
моделирующие реальные объекты системы. Каждый вычислительный объект
должен содержать собственные (@newterm{local state variables}), описывающие
состояние реального объекта. Поскольку объекты в моделируемой системе
меняются со временем, переменные состояния соответствующих
вычислительных объектов также должны изменяться. Если мы решаем, что
поток времени в системе будет моделироваться временем, проходящим в
компьютере, то нам требуется способ строить вычислительные объекты,
поведение которых меняется по мере выполнения программы. В частности,
если нам хочется моделировать переменные состояния обыкновенными
символическими именами в языке программирования, в языке должен иметься
(@newterm{assignment operator}), который позволял бы изменять значение,
связанное с именем.

@menu
* 3-1-1::            Внутренние переменные состояния::
* 3-1-2::            Преимущества присваивания::
* 3-1-3::            Издержки связанные с введением присваивания::
@end menu

@comment @subsection Local State Variables
@subsection Внутренние переменные состояния
@node	3.1.1, 3.1.2, 3.1, 3.1

Чтобы показать, что мы имеем в виду, говоря о вычислительном объекте,
состояние которого меняется со временем, давайте промоделируем ситуацию
снятия денег с банковского счета. Воспользуемся для этого процедурой
@code{withdraw}, которая в качестве аргумента принимает сумму, которую
требуется снять. Если на счету имеется достаточно средств, чтобы
осуществить операцию, то @code{withdraw} возвращает баланс, остающийся
после снятия. В противном случае @code{withdraw} возвращает сообщение
<<Недостаточно денег на счете>>. Например, если вначале на счету
содержится 100 долларов, мы получим следующую последовательность
результатов:

@lisp
(withdraw 25)
@i{75}
(withdraw 25)
@i{50}
(withdraw 60)
@i{"Insufficient funds"}
(withdraw 15)
@i{35}
@end lisp

@noindent
Обратите внимание, что выражение @code{(withdraw 25)}, будучи вычислено
дважды, дает различные результаты. Это новый тип поведения для
процедуры. До сих пор все наши процедуры можно было рассматривать как
описания способов вычисления математических функций. Вызов процедуры
вычислял значение функции для данных аргументов, и два вызова одной и
той же процедуры с одинаковыми аргументами всегда приводили к
одинаковому результату.@footnote{На самом деле это не совсем правда. Одно
исключение --- генератор случайных чисел из
раздела @ref{1.2.6}.
Второе связано с таблицами операций и типов, которые мы ввели в
разделе @ref{2.4.3},
где значения двух вызовов @code{get} с одними и теми же аргументами
зависели от того, какие были в промежутке между ними вызовы @code{put}.
С другой стороны, пока мы не ввели присваивание, мы лишены возможности
самим создавать такие процедуры.}

При реализации @code{withdraw} мы используем переменную @code{balance},
которая показывает остаток денег на счете, и определяем @code{withdraw}
в виде процедуры, которая обращается к этой переменной. Процедура
@code{withdraw} проверяет, что значение @code{balance} не меньше, чем
значение аргумента @code{amount}. Если это так, @code{withdraw}
уменьшает значение @code{balance} на @code{amount} и возвращает новое
значение @code{balance}. В противном случае она возвращает сообщение
<<Недостаточно денег на счете>>. Вот определения @code{balance} и
@code{withdraw}:

@lisp
(define balance 100)
(define (withdraw amount)
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
@end lisp

@noindent
Значение переменной @code{balance} уменьшается, когда мы выполняем
выражение

@lisp
(set! balance (- balance amount))
@end lisp

@noindent
Здесь используется особая форма , синтаксис которой выглядит так:

@lisp
(set! @math{\langle}@var{имя}@math{\rangle} @math{\langle}@var{новое-значение}@math{\rangle})
@end lisp

@noindent
Здесь @math{\langle}@var{имя}@math{\kern0.04em\rangle}  --- символ, а
@math{\langle}@var{новое-значение}@math{\kern0.04em\rangle} -- произвольное
выражение. @code{set!} заменяет значение
@math{\langle}@var{имени}@math{\kern0.04em\rangle} на результат, полученный при
вычислении @math{\langle}@var{нового-значения}@math{\kern0.04em\rangle}.
В данном случае, мы изменяем @code{balance} так, что его новое значение будет
результатом вычитания @code{amount} из предыдущего значения
@code{balance}.@footnote{Значение выражения @code{set!} зависит от
реализации. @code{set!} нужно использовать только ради эффекта, который
оно оказывает, а не ради значения, которое оно возвращает.

Имя @code{set!} отражает соглашение, принятое в Scheme: операциям,
которые изменяют значения переменных (или структуры данных, как мы
увидим в разделе @ref{3.3}) даются имена с
восклицательным знаком на конце. Это напоминает соглашение называть
предикаты именами, которые оканчиваются на вопросительный знак.}

Кроме того, @code{withdraw} использует особую форму , когда проверка
@code{if} выдает истину, и требуется вычислить два выражения: сначала
уменьшить @code{balance}, а затем вернуть его значение. В общем случае
вычисление выражения

@lisp
(begin @math{\langle}@var{выражение}@math{_{\mono{1}}\rangle} @math{\langle}@var{выражение}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{выражение}@math{_{\monoit{k}}\rangle})
@end lisp

@noindent
приводит к последовательному вычислению выражений от
@math{\langle\kern0.06em}@var{выражения}@math{_1\rangle} до
@math{\langle\kern0.06em}@var{выражения}@math{_k\rangle}, и
значение последнего выражения
@math{\langle\kern0.06em}@var{выражения}@math{_k\rangle}
возвращается в качестве значения всей формы @code{begin}.@footnote{Неявно
мы уже использовали в своих программах @code{begin}, поскольку в Scheme
тело процедуры может быть последовательностью выражений. Кроме того, в
каждом подвыражении @code{cond} следствие может состоять не из одного
выражения, а из нескольких.}

Хотя процедура @code{withdraw} и работает так, как мы того хотели,
переменная @code{balance} представляет собой проблему. @code{balance},
как она описана выше, является переменной, определенной в глобальном
окружении, и любая процедура может прочитать или изменить ее значение.
Намного лучше было бы, если бы @code{balance} можно было сделать
внутренней переменной для @code{withdraw}, так, чтобы только
@code{withdraw} имела доступ к ней напрямую, а любая другая
процедура --- только посредством вызовов @code{withdraw}. Так можно
будет более точно смоделировать представление о @code{balance} как о
внутренней переменной состояния, с помощью которой @code{withdraw}
следит за состоянием счета.

Сделать @code{balance} внутренней по отношению к @code{withdraw} мы
можем, переписав определение следующим образом:

@lisp
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
@end lisp

@noindent
Здесь мы, используя @code{let}, создаем окружение с внутренней
переменной @code{balance}, которой вначале присваивается значение 100.
Внутри этого локального окружения мы при помощи @code{lambda} определяем
процедуру, которая берет в качестве аргумента @code{amount} и действует
так же, как наша старая процедура @code{withdraw}. Эта процедура ---
возвращаемая как результат выражения @code{let}, --- и есть
@code{new-withdraw}. Она ведет себя в точности так же, как, как
@code{withdraw}, но ее переменная @code{balance} недоступна для всех
остальных процедур.@footnote{По терминологии, принятой при описании
языков программирования, переменная @code{balance}
@emph{инкапсулируется} (is encapsulated) внутри процедуры
@code{new-withdraw}. Инкапсуляция отражает общий принцип проектирования
систем, известный как (@newterm{the hiding principle}): систему можно сделать
более модульной и надежной, если защищать ее части друг от друга; то
есть, разрешать доступ к информации только тем частям системы, которым
<<необходимо это знать>>.}

@code{set!} в сочетании с локальными переменными --- общая стратегия
программирования, которую мы будем использовать для построения
вычислительных объектов, обладающих внутренним состоянием. К сожалению,
при использовании этой стратегии возникает серьезная проблема: когда мы
только вводили понятие процедуры, мы ввели также подстановочную модель
вычислений (раздел @ref{1.1.5})
для того, чтобы объяснить, что означает применение процедуры к
аргументам. Мы сказали, что оно должно интерпретироваться как вычисление
тела процедуры, в котором формальные параметры заменяются на свои
значения. К сожалению, как только мы вводим в язык присваивание,
подстановка перестает быть адекватной моделью применения процедуры.
(Почему это так, мы поймем в разделе @ref{3.1.3}.) В
результате, с технической точки зрения мы сейчас не умеем объяснить,
почему процедура @code{new-withdraw} ведет себя именно так, как описано
выше. Чтобы действительно понять процедуры, подобные
@code{new-withdraw}, нам придется разработать новую модель применения
процедуры. В разделе @ref{3.2} мы
введем такую модель, попутно объяснив @code{set!} и локальные
переменные. Однако сначала мы рассмотрим некоторые вариации на тему,
заданную @code{new-withdraw}.

Следующая процедура, @code{make-withdraw}, создает <<обработчики снятия
денег со счетов>>. Формальный параметр @code{balance}, передаваемый в
@code{make-withdraw}, указывает начальную сумму денег на
счету.@footnote{В отличие от предыдущей процедуры @code{new-withdraw},
здесь нам необязательно использовать @code{let}, чтобы сделать
@code{balance} локальной переменной, поскольку формальные параметры и
так локальны. Это станет яснее после обсуждения модели вычисления с
окружениями в разделе @ref{3.2}.  (См. также @ref{3.10})}

@lisp
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете")))
@end lisp

@noindent
При помощи @code{make-withdraw} можно следующим образом создать два
объекта @code{W1} и @code{W2}:

@lisp
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
@i{50}
(W2 70)
@i{30}
(W2 40)
@i{"Недостаточно денег на счете"}
(W1 40)
@i{10}
@end lisp

@noindent
Обратите внимание, что @code{W1} и @code{W2} --- полностью независимые
объекты, каждый со своей локальной переменной @code{balance}. Снятие
денег с одного счета не влияет на другой.

Мы можем создавать объекты, которые будут разрешать не только снятие
денег, но и их занесение на счет, и таким образом можно смоделировать
простые банковские счета. Вот процедура, которая возвращает
объект-<<банковский счет>> с указанным начальным балансом:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  dispatch)
@end lisp

@noindent
Каждый вызов @code{make-account} создает окружение с локальной
переменной состояния @code{balance}. Внутри этого окружения
@code{make-account} определяет процедуры @code{deposit} и
@code{withdraw}, которые обращаются к @code{balance}, а также
дополнительную процедуру @code{dispatch}, которая принимает
<<сообщение>> в качестве ввода, и возвращает одну из двух локальных
процедур. Сама процедура @code{dispatch} возвращается как значение,
которое представляет объект-банковский счет. Это не что иное, как стиль
программирования с (@newterm{message passing}), который мы видели в
разделе @ref{2.4.3},
но только здесь мы его используем в сочетании с возможностью изменять
локальные переменные.

@code{make-account} можно использовать следующим образом:

@lisp
(define acc (make-account 100))
((acc 'withdraw) 50)
@i{50}
((acc 'withdraw) 60)
@i{"Недостаточно денег на счете"}
((acc 'deposit) 40)
@i{90}
((acc 'withdraw) 60)
@i{30}
@end lisp

@noindent
Каждый вызов @code{acc} возвращает локально определенную процедуру
@code{deposit} или @code{withdraw}, которая затем применяется к
указанной сумме. Точно так же, как это было с @code{make-withdraw},
второй вызов @code{make-account}

@lisp
(define acc2 (make-account 100))
@end lisp

@noindent
создает совершенно отдельный объект-счет, который поддерживает свою
собственную переменную @code{balance}.

@quotation
@strong{@anchor{Упражнение 3.1}Упражнение 3.1:}
Накопитель (@newterm{accumulator}) --- это процедура, которая
вызывается с одним численным аргументом и собирает свои аргументы в
сумму. При каждом вызове накопитель возвращает сумму, которую успел
накопить. Напишите процедуру @code{make-accumulator}, порождающую
накопители, каждый из которых поддерживает свою отдельную сумму. Входной
параметр @code{make-accumulator} должен указывать начальное значение
суммы; например,

@lisp
(define A (make-accumulator 5))
(A 10)
@i{15}
(A 10)
@i{25}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.2}Упражнение 3.2:}
При тестировании программ удобно иметь возможность
подсчитывать, сколько раз за время вычислений была вызвана та или иная
процедура. Напишите процедуру @code{make-monitored}, принимающую в
качестве параметра процедуру @code{f}, которая сама по себе принимает
один входной параметр. Результат, возвращаемый
@code{make-monitored} --- третья процедура, назовем ее @code{mf},
которая подсчитывает, сколько раз она была вызвана, при помощи
внутреннего счетчика. Если на входе @code{mf} получает специальный
символ @code{how-many-calls?}, она возвращает значение счетчика. Если же
на вход подается специальный символ @code{reset-count}, @code{mf}
обнуляет счетчик. Для любого другого параметра @code{mf} возвращает
результат вызова @code{f} с этим параметром и увеличивает счетчик.
Например, можно было бы сделать отслеживаемую версию процедуры
@code{sqrt}:

@lisp
(define s (make-monitored sqrt))
(s 100)
@i{10}
(s 'how-many-calls?)
@i{1}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.3}Упражнение 3.3:}
Измените процедуру @code{make-account} так, чтобы она
создавала счета, защищенные паролем. А именно, @code{make-account}
должна в качестве дополнительного аргумента принимать символ, например

@lisp
(define acc (make-account 100 'secret-password))
@end lisp

Получившийся объект-счет должен обрабатывать запросы, только если они
сопровождаются паролем, с которым счет был создан, а в противном случае
он должен жаловаться:

@lisp
((acc 'secret-password 'withdraw) 40)
@i{60}
((acc 'some-other-password 'deposit) 50)
@i{"Incorrect password"}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.4}Упражнение 3.4:}
Модифицируйте процедуру @code{make-account} из
упражнения @ref{}, добавив еще одну локальную переменную,
так, чтобы, если происходит более семи попыток доступа подряд с неверным
паролем, вызывалась процедура @code{call-the-cops} (вызвать полицию).

@comment @subsection The Benefits of Introducing Assignment
@subsection Преимущества присваивания
@node	3.1.2, 3.1.3, 3.1.1, 3.1

Как нам предстоит увидеть, введение присваивания в наш язык
программирования ведет к множеству сложных концептуальных проблем. Тем
не менее, представление о системе как о наборе объектов, имеющих
внутреннее состояние, --- мощное средство для обеспечения модульности
проекта. В качестве примера рассмотрим строение процедуры @code{rand},
которая, будучи вызванной, каждый раз возвращает случайное целое число.

Вовсе не так просто определить, что значит <<случайное>>. Вероятно,
имеется в виду, что последовательные обращения к @code{rand} должны
порождать последовательность чисел, которая обладает статистическими
свойствами равномерного распределения. Здесь мы не будем обсуждать
способы порождения подобных последовательностей. Вместо этого
предположим, что у нас есть процедура @code{rand-update}, которая
обладает следующим свойством: если мы начинаем с некоторого данного
числа @math{x_1} и строим последовательность

@lisp
@math{x_2} = (rand-update @math{x_1})
@math{x_3} = (rand-update @math{x_2})
@end lisp

@noindent
то последовательность величин @math{x_1}, @math{x_2}, @math{x_3}, @dots{}
будет обладать требуемыми математическими свойствами.@footnote{Один из
распространенных способов реализации @code{rand-update} состоит в том,
чтобы положить новое значение @math{x} равным
@math{ax+b} по модулю @math{m}, где @math{a}, @math{b} и @math{m} --- соответствующим образом
подобранные целые числа. Глава 3 книги Knuth 1981 содержит подробное
обсуждение методов порождения последовательностей случайных чисел и
обеспечения их статистических свойств. Обратите внимание, что
@code{rand-update} вычисляет математическую функцию: если ей дважды дать
один и тот же вход, она вернет одинаковый результат. Таким образом,
последовательность чисел, порождаемая @code{rand-update}, никоим образом
не <<случайна>>, если мы настаиваем на том, что в последовательности
<<случайных>> чисел следующее число не должно иметь никакого отношения к
предыдущему. Отношение между <<настоящей>> случайностью и так
называемыми (@newterm{pseudo-random}) последовательностями, которые порождаются
путем однозначно определенных вычислений и тем не менее обладают нужными
статистическими свойствами, --- непростой вопрос, связанный со сложными
проблемами математики и философии. Для прояснения этих вопросов много
сделали Колмогоров, Соломонофф и Хайтин; обсуждение можно найти в
Chaitin 1975.}

Мы можем реализовать @code{rand} как процедуру с внутренней переменной
состояния @code{x}, которая инициализируется некоторым заранее заданным
значением @code{random-init}. Каждый вызов @code{rand} вычисляет
@code{rand-update} от текущего значения @code{x}, возвращает это
значение как случайное число, и, кроме того, сохраняет его как новое
значение @code{x}.

@lisp
(define rand (let ((x random-init))
               (lambda ()
                 (set! x (rand-update x))
                 x)))
@end lisp

@noindent
Разумеется, ту же последовательность случайных чисел мы могли бы
получить без использования присваивания, просто напрямую вызывая
@code{rand-update}. Однако это означало бы, что всякая часть программы,
которая использует случайные числа, должна явно запоминать текущее
значение @code{x}, чтобы передать его как аргумент @code{rand-update}.
Чтобы понять, насколько это было бы неприятно, рассмотрим использование
случайных чисел для реализации т.н. (@newterm{Monte Carlo simulation}).

Метод Монте-Карло состоит в том, чтобы случайным образом выбирать
тестовые точки из большого множества и затем делать выводы на основании
вероятностей, оцениваемых по результатам тестов. Например, можно
получить приближенное значение @math{\pi}, используя тот факт, что для
двух случайно выбранных целых чисел вероятность отсутствия общих
множителей (то есть, вероятность того, что их наибольший общий делитель
будет равен 1) составляет @math{6/\pi^2}.@footnote{Эта теорема доказана
Э. Чезаро. Обсуждение и доказательство можно найти в разделе 4.5.2
книги Knuth 1981.}. Чтобы получить приближенное значение @math{\pi}, мы
производим большое количество тестов. В каждом тесте мы случайным
образом выбираем два числа и проверяем, не равен ли их НОД единице. Доля
тестов, которые проходят, дает нам приближение к @math{6/\pi^2}, и
отсюда мы получаем приближенное значение @math{\pi}.

В центре нашей программы находится процедура @code{monte-carlo}, которая
в качестве аргументов принимает количество попыток тестирования, а также
сам тест --- процедуру без аргументов, возвращающую при каждом вызове
либо истину, либо ложь. @code{monte-carlo} запускает тест указанное
количество раз и возвращает число, обозначающее долю попыток, в которых
тест вернул истинное значение.

@lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
   (= (gcd (rand) (rand)) 1))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1)
                 (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1)
                 trials-passed))))
  (iter trials 0))
@end lisp

@noindent
Теперь попробуем осуществить то же вычисление, используя
@code{rand-update} вместо @code{rand}, как нам пришлось бы поступить,
если бы у нас не было присваивания для моделирования локального
состояния:

@lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))
(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
@end lisp

@noindent
Хотя программа по-прежнему проста, в ней обнаруживается несколько
болезненных нарушений принципа модульности. В первой версии программы
нам удалось, используя @code{rand}, выразить метод Монте-Карло напрямую
как обобщенную процедуру @code{monte-carlo}, которая в качестве
аргумента принимает произвольную процедуру @code{experiment}. Во втором
варианте программы, где у генератора случайных чисел нет локального
состояния, @code{random-gcd-test} приходится непосредственно возиться со
случайными числами @code{x1} и @code{x2} и передавать в итеративном
цикле @code{x2} в качестве нового входа @code{rand-update}. Из-за того,
что обработка случайных чисел происходит явно, структура накопления
результатов тестов начинает зависеть от того, что наш тест использует
именно два случайных числа, тогда как для других тестов Монте-Карло
может потребоваться, скажем, одно или три. Даже процедура верхнего
уровня @code{estimate-pi} вынуждена заботиться о том, чтобы предоставить
начальное значение случайного числа. Поскольку внутренности генератора
случайных чисел просачиваются наружу в другие части программы, задача
изолировать идею метода Монте-Карло так, чтобы применять ее затем к
другим задачам, осложняется. В первом варианте программы присваивание
инкапсулирует состояние генератора случайных чисел внутри @code{rand},
так что состояние генератора остается независимым от остальной программы.

Общее явление, наблюдаемое на примере с методом Монте-Карло, таково: с
точки зрения одной части сложного процесса кажется, что другие части
изменяются со временем. Они обладают скрытым локальным состоянием. Если
мы хотим, чтобы структура программ, которые мы пишем, отражала такое
разделение на части, мы создаем вычислительные объекты (например,
банковские счета или генераторы случайных чисел), поведение которых
изменяется со временем. Состояние мы моделируем при помощи локальных
переменных, а изменение состояния --- при помощи присваивания этим
переменным.

Здесь возникает соблазн закрыть обсуждение и сказать, что, введя
присваивание и метод сокрытия состояния в локальных переменных, мы
обретаем способность структурировать системы более модульным образом,
чем если бы нам пришлось всем состоянием манипулировать явно, с
передачей дополнительных параметров. К сожалению, как мы увидим, все не
так просто.

@quotation
@strong{@anchor{Упражнение 3.5}Упражнение 3.5:}
@emph{Интегрирование методом Монте-Карло} (@newterm{Monte Carlo integration}) --- способ приближенного вычисления определенных
интегралов при помощи моделирования методом Монте-Карло. Рассмотрим
задачу вычисления площади фигуры, описываемой предикатом @math{P(x,y)},
который истинен для точек @math{(x,y)}, принадлежащих фигуре, и ложен
для точек вне фигуры. Например, область, содержащаяся в круге с радиусом
3 и центром в точке @math{(5,7)}, описывается предикатом, проверяющим
@math{(x-5)^2 + (y-7)^2 \le 3^2}. Чтобы оценить площадь фигуры,
описываемой таким предикатом, для начала выберем прямоугольник, который
содержит нашу фигуру. Например, прямоугольник с углами @math{(2,4)} и
@math{(8,10)}, расположенными по диагонали, содержит вышеописанный круг.
Нужный нам интеграл --- площадь той части прямоугольника, которая лежит
внутри фигуры. Мы можем оценить интеграл, случайным образом выбирая
точки @math{(x,y)}, лежащие внутри прямоугольника, и проверяя для каждой
точки @math{P(x,y)}, чтобы определить, лежит ли точка внутри фигуры.
Если мы проверим много точек, доля тех, которые окажутся внутри области,
даст нам приближенное значение отношения площадей фигуры и
прямоугольника. Таким образом, домножив это значение на площадь
прямоугольника, мы получим приближенное значение интеграла.

Реализуйте интегрирование методом Монте-Карло в виде процедуры
@code{estimate-integral}, которая в качестве аргументов принимает
предикат @code{P}, верхнюю и нижнюю границы прямоугольника @code{x1},
@code{x2}, @code{y1} и @code{y2}, а также число проверок, которые мы
должны осуществить, чтобы оценить отношение площадей. Ваша процедура
должна использовать ту же самую процедуру @code{monte-carlo}, которая
выше использовалась для оценки значения @math{\pi}. Оцените @math{\pi}
при помощи @code{estimate-integral}, измерив площадь единичного круга.

Вам может пригодиться процедура, которая выдает число, случайно
выбранное внутри данного отрезка. Нижеприведенная процедура
@code{random-in-range} решает эту задачу, используя процедуру
@code{random}, введенную в разделе @ref{1.2.6},
которая возвращает неотрицательное число меньше своего
аргумента.@footnote{В MIT Scheme есть такая процедура. Если @code{random}
на вход дается точное целое число (как в разделе @ref{1.2.6}),
она возвращает точное целое число, но если ей дать десятичную дробь (как
в этом примере), она и возвращает десятичную дробь.}

@lisp
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.6}Упражнение 3.6:}
Полезно иметь возможность сбросить генератор случайных чисел,
чтобы получить последовательность, которая начинается с некоторого
числа. Постройте новую процедуру @code{rand}, которая вызывается с
аргументом. Этот аргумент должен быть либо символом @code{generate},
либо символом @code{reset}. Процедура работает так:
@code{(rand 'generate)} порождает новое случайное число;
@code{((rand 'reset)}@math{\;\langle}@var{новое-значение}@math{\kern0.11em\rangle}@code{)}
сбрасывает внутреннюю переменную состояния в указанное
@math{\langle}@var{новое-значение}@math{\kern0.08em\rangle}. Таким образом,
сбрасывая значения, можно получать повторяющиеся последовательности. Эта
возможность очень полезна при тестировании и отладке программ,
использующих случайные числа.
@end quotation

@comment @subsection The Costs of Introducing Assignment
@subsection Издержки, связанные с введением присваивания
@node	3.1.3,  , 3.1.2, 3.1
Как мы только что видели, операция @code{set!} позволяет моделировать
объекты, обладающие внутренним состоянием. Однако за это преимущество
приходится платить. Наш язык программирования нельзя больше описывать
при помощи подстановочной модели применения процедур, которую мы ввели в
разделе @ref{1.1.5}.
Хуже того, не существует простой модели с <<приятными>> математическими
свойствами, которая бы адекватно описывала работу с объектами и
присваивание в языках программирования.

Пока мы не применяем присваивание, два вычисления одной и той же
процедуры с одними и теми же аргументами всегда дают одинаковый
результат. Стало быть, можно считать, что процедуры вычисляют
математические функции. Соответственно, программирование, в котором
присваивание не используется (как у нас в первых двух главах этой
книги), известно как (@newterm{functional programming}).

Чтобы понять, как присваивание усложняет ситуацию, рассмотрим упрощенную
версию @code{make-withdraw} из раздела @ref{3.1.1}, которая не проверяет,
достаточно ли на счете денег:

@lisp
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
(define W (make-simplified-withdraw 25))
(W 20)
@i{5}
(W 10)
@i{-5}
@end lisp

@noindent
Сравним эту процедуру со следующей процедурой @code{make-decrementer},
которая не использует @code{set!}:

@lisp
(define (make-decrementer balance)
  (lambda (amount)
    (- balance amount)))
@end lisp

@noindent
@code{make-decrementer} возвращает процедуру, которая вычитает свой
аргумент из определенного числа @code{balance}, но при последовательных
вызовах ее действие не накапливается, как при использовании
@code{make-simplified-withdraw}:

@lisp
(define d (make-decrementer 25))
(d 20)
@i{5}
(d 10)
@i{15}
@end lisp

@noindent
Мы можем объяснить, как работает @code{make-decrementer}, при помощи
подстановочной модели. Например, рассмотрим, как вычисляется выражение

@lisp
((make-decrementer 25) 20)
@end lisp

@noindent
Сначала мы упрощаем операторную часть комбинации, подставляя в теле
@code{make-decrementer} вместо @code{balance} 25. Выражение сводится к

@lisp
((lambda (amount) (- 25 amount)) 20)
@end lisp

@noindent
Теперь мы применяем оператор к операнду, подставляя 20 вместо
@code{amount} в теле @code{lambda}-выражения:

@lisp
(- 25 20)
@end lisp

@noindent
Окончательный результат равен 5.

Посмотрим, однако, что произойдет, если мы попробуем применить подобный
подстановочный анализ к @code{make-simplified-withdraw}:

@lisp
((make-simplified-withdraw 25) 20)
@end lisp

@noindent
Сначала мы упрощаем оператор, подставляя вместо @code{balance} 25 в теле
@code{makesimplified-withdraw}. Таким образом, наше выражение сводится
к.@footnote{Мы не производим подстановку вхождения @code{balance} в
выражение @code{set!}, поскольку @math{\langle}@var{имя}@math{\kern0.08em\rangle} 
в @code{set!} не вычисляется. Если бы мы провели подстановку, получилось
бы @code{(set! 25 (- 25 amount))}, а это не имеет никакого смысла.}

@lisp
((lambda (amount) (set! balance (- 25 amount)) 25) 20)
@end lisp

@noindent
Теперь мы применяем оператор к операнду, подставляя в теле
@code{lambda}-выражения 20 вместо @code{amount}:

@lisp
(set! balance (- 25 20)) 25
@end lisp

@noindent
Если бы мы следовали подстановочной модели, нам пришлось бы сказать, что
вычисление процедуры состоит в том, чтобы сначала присвоить переменной
@code{balance} значение 5, а затем в качестве значения вернуть 25. Но
это дает неверный ответ. Чтобы получить правильный ответ, нам пришлось
бы как-то отличить первое вхождение @code{balance} (до того, как
сработает @code{set!}) от второго (после выполнения @code{set!}).
Подстановочная модель на это не способна.

Проблема здесь состоит в том, что подстановка предполагает, что символы
в нашем языке --- просто имена для значений. Но как только мы вводим
@code{set!} и представление, что значение переменной может изменяться,
переменная уже не может быть всего лишь именем. Теперь переменная
некоторым образом соответствует месту, в котором может храниться
значение, и значение это может меняться. В разделе @ref{3.2} мы увидим, как в
нашей модели вычислений роль этого <<места>> играют окружения.

@comment @subsubheading Sameness and change
@subsubheading Тождественность и изменение

Проблема, которая здесь встает, глубже, чем просто поломка определенной
модели вычислений. Как только мы вводим в наши вычислительные модели
понятие изменения, многие другие понятия, которые до сих пор были ясны,
становятся сомнительными. Рассмотрим вопрос, что значит, что две вещи
суть <<одно и то же>>.

Допустим, мы два раза зовем @code{make-decrementer} с одним и тем же
аргументом, и получаем две процедуры:

@lisp
(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))
@end lisp

@noindent
Являются ли @code{D1} и @code{D2} одним и тем же объектом? Можно
сказать, что да, поскольку @code{D1} и @code{D2} обладают одинаковым
поведением --- каждая из этих процедур вычитает свой аргумент из 25. В
сущности, в любом вычислении можно подставить @code{D1} вместо
@code{D2}, и результат не изменится.

Напротив, рассмотрим два вызова @code{make-simplified-withdraw}:

@lisp
(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))
@end lisp

@noindent
Являются ли @code{W1} и @code{W2} одним и тем же? Нет, конечно, потому
что вызовы @code{W1} и @code{W2} приводят к различным результатам, как
показывает следующая последовательность вычислений:

@lisp
(W1 20)
@i{5}
(W1 20)
@i{-15}
(W2 20)
@i{5}
@end lisp

@noindent
Хотя @code{W1} и @code{W2} <<равны друг другу>> в том смысле, что оба
они созданы вычислением одного и того же выражения
@code{(make-simplified-withdraw 25)}, неверно, что в любом выражении
можно заменить @code{W1} на @code{W2}, не повлияв при этом на результат
его вычисления.

Язык, соблюдающий правило, что в любом выражении <<одинаковое можно
подставить вместо одинакового>>, не меняя его значения, называется
(@newterm{referentially transparent}). Если мы включаем в свой компьютерный язык
@code{set!}, его референциальная прозрачность нарушается. Становится
сложно определить, где можно упростить выражение, подставив вместо него
равносильное. Следовательно, рассуждать о программах, в которых
используется присваивание, оказывается гораздо сложнее.

С потерей референциальной прозрачности становится сложно формально
описать понятие о том, что два объекта -- один и тот же объект. На самом
деле, смысл выражения <<то же самое>> в реальном мире, который наши
программы моделируют, сам по себе недостаточно ясен. В общем случае, мы
можем проверить, являются ли два как будто бы одинаковых объекта одним и
тем же, только изменяя один из них и наблюдая, изменился ли таким же
образом и другой. Но как мы можем узнать, <<изменился>> ли объект?
Только рассмотрев один и тот же объект дважды и проверив, не различается
ли некоторое его свойство между двумя наблюдениями. Таким образом, мы не
можем определить <<изменение>>, не имея заранее понятия
<<идентичности>>, а идентичность мы не можем определить, не рассмотрев
результаты изменений.

В качестве примера того, как эти вопросы возникают в программировании,
рассмотрим ситуацию, где у Петра и у Павла есть по банковскому счету в
100 долларов. Здесь не все равно, смоделируем мы это через

@lisp
(define peter-acc (make-account 100))
(define paul-acc (make-account 100))
@end lisp

@noindent
или

@lisp
(define peter-acc (make-account 100))
(define paul-acc peter-acc)
@end lisp

@noindent
В первом случае, два счета различны. Действия, которые производит Петр,
не меняют счет Павла, и наоборот. Однако во втором случае мы сказали,
что @code{paul-acc} --- это @emph{та же самая вещь}, что и
@code{peter-acc}. Теперь у Петра и у Павла есть совместный банковский
счет, и если Петр возьмет сколько-то с @code{peter-acc}, то у Павла на
@code{paul-acc} будет меньше денег. При построении вычислительных
моделей сходство между этими двумя несовпадающими ситуациями может
привести к путанице. В частности, в случае с совместным счетом может
особенно мешать то, что у одного объекта (банковского счета) есть два
имени (@code{peter-acc} и @code{paul-acc}); если мы ищем в программе все
места, где может меняться @code{paul-acc}, надо смотреть еще и где
меняется @code{peter-acc}.@footnote{Когда у вычислительного объекта
имеется несколько имён, эти имена называются (aliasing). Ситуация с
совместным банковским счетом --- простой пример псевдонимов. В
разделе @ref{3.3} мы увидим значительно
более сложные примеры, скажем, <<различные>> составные структуры с
общими частями. Если мы забудем, что <<побочным эффектом>> в результате
изменения одного объекта может стать изменение <<другого>> объекта,
поскольку <<разные>> объекты --- на самом деле один и тот же под
разными псевдонимами, то могут возникнуть ошибки. Эти так называемые
(side-effect bugs) настолько трудно обнаруживать и анализировать, что
некоторые исследователи выступали с предложениями не допускать в языках
программирования побочные эффекты и псевдонимы (@ref{Lampson et al. 1981};
@ref{Morris et al. 1980}).}

В связи с этими замечаниями обратите внимание на то, что если бы Петр и
Павел могли только проверять свой платежный баланс, но не менять его, то
вопрос <<один ли у них счет?>> не имел бы смысла. В общем случае, если
мы никогда не меняем объекты данных, то можно считать, что каждый объект
представляет собой в точности совокупность своих частей. Например,
рациональное число определяется своим числителем и знаменателем. Однако
при наличии изменений такой взгляд становится ошибочным, поскольку
теперь у каждого объекта есть <<индивидуальность>>, которая отличается
от тех частей, из которых он состоит. Банковский счет останется <<тем же
самым>> счетом, даже если мы снимем с него часть денег; и наоборот,
можно иметь два разных счета с одинаковым состоянием. Такие
сложности --- следствие не нашего языка программирования, а нашего
восприятия банковского счета как объекта. Скажем, рациональное число мы
обычно не рассматриваем как изменяемый объект со своей
индивидуальностью, у которого можно было бы изменить числитель и
по-прежнему иметь дело с <<тем же>> числом.

@comment @subsubheading Pitfalls of imperative programming
@subsubheading Ловушки императивного программирования

В противоположность функциональному программированию, стиль
программирования, при котором активно используется присваивание,
называется (@newterm{imperative programming}). Кроме того, что возникают сложности
с вычислительными моделями, программы, написанные в императивном стиле,
подвержены таким ошибкам, которые в функциональных программах не
возникают. Вспомним, к примеру, итеративную программу для вычисления
факториала из
раздела @ref{1.2.1}:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
@end lisp

@noindent
Вместо того, чтобы передавать аргументы во внутреннем итеративном цикле,
мы могли бы написать процедуру в более императивном стиле с
использованием присваивания для обновления значений переменных
@code{product} и @code{counter}:

@lisp
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))
@end lisp

@noindent
Результаты, выдаваемые программой, при этом не меняются, но возникает
маленькая ловушка. Как определить порядок присваиваний? В имеющемся виде
программа корректна. Однако если бы мы записали присваивания в обратном
порядке:

@lisp
(set! counter (+ counter 1))
(set! product (* counter product))
@end lisp

@noindent
--- получился бы другой, неверный результат. Вообще, программирование с
использованием присваивания заставляет нас тщательно следить за порядком
присваиваний, так, чтобы в каждом использовалась правильная версия
значения переменных, которые меняются. В функциональных программах такие
сложности просто не возникают.@footnote{Поэтому странно и смешно, что
вводные курсы программирования часто читаются в глубоко императивном
стиле. Может быть, сказываются остатки распространенного в 60-е и 70-е
годы представления, что программы, которые вызывают процедуры,
непременно будут менее эффективны, чем те, которые производят
присваивания. (@ref{Steele 1977} развенчивает этот аргумент.) С другой
стороны, возможно, считается, что новичкам легче представить пошаговое
присваивание, чем вызов процедуры. Так или иначе, программистам часто
приходится заботиться о вопросе <<присвоить сначала эту переменную или
ту?>>, а это усложняет программирование и затемняет важные идеи.}

Сложность императивных программ еще увеличивается, если мы начинаем
рассматривать приложения, где одновременно выполняется несколько
процессов. К этому мы еще вернемся в разделе @ref{3.4}. Однако сначала
мы обратимся к задаче построения вычислительной модели для выражений,
содержащих присваивание, а также изучим, как использовать объекты с
локальным состоянием при проектировании моделирующих программ.

@quotation
@strong{@anchor{Упражнение 3.7}Упражнение 3.7:}
Рассмотрим объекты-банковские счета, создаваемые процедурой
@code{make-account}, и снабженные паролями, как это описано в
упражнении @ref{Упражнение 3.3}. Предположим, что наша банковская
система требует от нас умения порождать совместные счета. Напишите
процедуру @code{make-joint}, которая это делает. @code{make-joint}
должна принимать три аргумента. Первый из них --- защищенный паролем
счет. Второй обязан совпадать с паролем, с которым этот счет был создан,
иначе @code{make-joint} откажется работать. Третий аргумент --- новый
пароль. Например, если банковский счет @code{peter-account} был создан с
паролем @code{open-sesame}, то

@lisp
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
@end lisp

@noindent
позволит нам проводить операции с @code{peter-account}, используя имя
@code{paul-acc} и пароль @code{rosebud}. Вам может потребоваться
переработать решение упражнения @ref{Упражнение 3.3}, чтобы добавить
эту новую возможность.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.8}Упражнение 3.8:} Когда в разделе @ref{1.1.3} мы
определяли модель вычислений, мы сказали, что первым шагом при
вычислении выражения является вычисление его подвыражений. Однако мы
нигде не указали порядок, в котором проходит вычисление подвыражений
(слева направо или справа налево). Когда мы вводим присваивание,
порядок, в котором вычисляются аргументы процедуры, может повлиять на
результат. Определите простую процедуру @code{f}, так, чтобы вычисление

@lisp
(+ (f 0) (f 1))
@end lisp

возвращало 0, если аргументы @code{+} вычисляются
слева направо, и 1, если они вычисляются справа налево.
@end quotation

@comment @section The Environment Model of Evaluation
@section Модель вычислений с окружениями
@node	3.2, 3.3, 3.1, Chapter 3


Когда в @ref{Глава 1} мы вводили понятие составной процедуры, то для того,
чтобы определить, что значит применение процедуры к аргументам, мы пользовались
подстановочной моделью вычислений (@ref{1.1.5}):

@itemize @bullet

@item
Чтобы применить составную процедуру к аргументам, нужно вычислить тело
процедуры, подставив вместо каждого формального параметра
соответствующий ему аргумент.

@end itemize

@noindent
Как только мы вводим в язык программирования присваивание, это
определение перестает быть адекватным. А именно, в @ref{3.1.3} указывалось,
что в присутствии присваивания переменную уже нельзя рассматривать
просто как имя для значения. Переменная должна каким-то образом
обозначать <<место>>, где значение может храниться. В нашей новой модели
вычислений такие места будут находиться в структурах, которые мы
называем (@newterm{environments}).

Окружение представляет собой последовательность (@newterm{frames}). Каждый кадр
есть (возможно, пустая) таблица (@newterm{bindings}), которые сопоставляют имена
переменных соответствующим значениям. (Каждый кадр должен содержать не
более одного связывания для каждой данной переменной.) Кроме того, в
каждом кадре имеется указатель на (@newterm{enclosing environment}), кроме тех
случаев, когда в рамках текущего обсуждения окружение считается
(@newterm{global}). (@newterm{value of a variable}) по отношению к данному окружению есть
значение, которое находится в связывании для этой переменной в первом
кадре окружения, содержащем такое связывание. Если в последовательности
кадров ни один не указывает значения для данной переменной, говорят, что
переменная (@newterm{unbound}) в окружении.

На рисунке @ref{Рисунок 3.1} изображена простая структура окружений,
которая состоит из трех кадров, помеченных числами I, II и III. На этой
диаграмме A, B, C и D --- указатели на окружения. C и D указывают на
одно и то же окружение. В кадре II связываются переменные @code{z} и
@code{x}, а в кадре I переменные @code{y} и @code{x}. В окружении D
переменная @code{x} имеет значение 3. В окружении B значение переменной
@code{x} также равно 3. Это определяется следующим образом: мы
рассматриваем первый кадр в последовательности (кадр III) и не находим
там связывания для переменной @code{x}, так что мы переходим к
объемлющему окружению D и находим связывание в кадре I. С другой
стороны, в окружении A значение переменной @code{x} равно 7, поскольку
первый кадр окружения (кадр II) содержит связывание @code{x} со
значением 7. По отношению к окружению A говорится, что связывание
@code{x} со значением 7 в кадре II (@newterm{shadows}) связывание @code{x} со
значением 3 в кадре I.

@float
@quotation
@anchor{Рисунок 3.1}
@ifinfo
@strong{Рисунок 3.1:} A simple environment structure.

@example
           +--------+
           |      I |
           | x: 3   |
           | y: 5   |
           +--------+
              ^  ^
              |  |
            C |  | D
+---------+   |  |   +----------+
|      II |   |  |   |      III |
| z: 6    +---+  +---+ m: 1     |
| x: 7    |          | y: 2     |
+---------+          +----------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.1,48mm,,,.pdf}
@sp 0.4
@comment @center @caption{@strong{Рисунок 3.1:} A simple environment structure.}
@center @caption{@strong{Рисунок 3.1:} Простой пример структуры окружений.}
@sp 0.7
@end iftex
@end quotation
@end float

Окружение играет важную роль в процессе вычисления, поскольку оно
определяет контекст, в котором выражение должно вычисляться. В самом
деле, можно сказать, что выражения языка программирования сами по себе
не имеют значения. Выражение приобретает значение только по отношению к
окружению, в контексте которого оно вычисляется. Даже интерпретация
столь простого выражения, как @code{(+ 1 1)}, зависит от нашего
понимания, что мы работаем в контексте, где @code{+} является символом
сложения. Таким образом, в нашей модели мы всегда будем говорить о
вычислении выражения относительно некоторого окружения. При описании
взаимодействия с интерпретатором мы будем предполагать, что существует
глобальное окружение, состоящее из одного кадра (без объемлющего
окружения), и что глобальное окружение содержит значения для символов,
обозначающих элементарные процедуры. Например, информация о том, что
@code{+} служит символом сложения, выражается как утверждение, что в
глобальном окружении символ @code{+} связан с элементарной процедурой
сложения.

@menu
* 3-2-1::            Правила вычисления
* 3-2-2::            Применение простых процедур
* 3-2-3::            Кадры как хранилище внутреннего состояния
* 3-2-4::            Внутренние определения
@end menu

@comment @subsection The Rules for Evaluation
@subsection Правила вычисления
@node	3.2.1, 3.2.2, 3.2, 3.2

Общее описание того, как интерпретатор вычисляет комбинацию, остается
таким же, как оно было введено в
@ref{1.1.3}:

@itemize @bullet

@item
Для того, чтобы вычислить комбинацию, нужно:

@end itemize

@enumerate 1

@item
Вычислить подвыражения комбинации.@footnote{Присваивание вносит одну
тонкость в шаг 1 правила вычисления. Как показано в
упражнении @ref{Упражнение 3.8}, присваивание позволяет нам писать
выражения, которые имеют различные значения в зависимости от того, в
каком порядке вычисляются подвыражения комбинации. Таким образом, чтобы
быть точными, мы должны были бы указать порядок вычислений на шаге 1
(например, слева направо или справа налево). Однако этот порядок всегда
должен рассматриваться как деталь реализации, и писать программы,
которые зависят от порядка вычисления аргументов, не следует. К примеру,
продвинутый компилятор может оптимизировать программу, изменяя порядок,
в котором вычисляются подвыражения.}

@item
Применить значение выражения-оператора к значениям выражений-операндов.

@end enumerate

@noindent
Модель вычисления с окружениями заменяет подстановочную модель,
по-своему определяя, что значит применить составную процедуру к
аргументам.

В модели вычисления с окружениями процедура всегда представляется в виде
пары, состоящей из кода и указателя на некое окружение. Процедура
создается единственным способом: вычислением @code{lambda}-выражения.
Такое вычисление дает в качестве результата процедуру, код которой
берется из тела @code{lambda}-выражения, а окружение совпадает с
окружением, в котором было вычислено выражение, чьим значением является
процедура. Например, рассмотрим определение процедуры

@lisp
(define (square x)
  (* x x))
@end lisp

@noindent
которое вычисляется в глобальном окружении. Синтаксис определения
процедуры --- всего лишь синтаксический сахар для подразумеваемой
@code{lambda}. С тем же успехом можно было написать выражение

@lisp
(define square
  (lambda (x) (* x x)))
@end lisp

@noindent
которое вычисляет @code{(lambda (x) (* x x))} и связывает символ
@code{square} с полученным значением, все это в глобальном окружении.

параметры: @code{x}

тело: @code{(* x x)}

Рис. @ref{Рисунок 3.2} показывает результат вычисления
@code{lambda}-выражения. Объект-процедура представляет собой пару, код
которой указывает, что процедура принимает один формальный параметр, а
именно @code{x}, а тело ее @code{(* x x)}. Окружение процедуры --- это
указатель на глобальное окружение, поскольку именно в нем вычислялось
@code{lambda}-выражение, при помощи которого процедура была порождена. К
глобальному кадру добавилось новое связывание, которое сопоставляет
процедурный объект символу @code{square}. В общем случае @code{define}
создает определения, добавляя новые связывания в кадры.

@float
@quotation
@anchor{Рисунок 3.2}
@ifinfo
@strong{Рисунок 3.2:} Environment structure produced by
evaluating @code{(define (square x) (* x x))} in the global environment.

@example
           +----------------------+
           | other variables      |
global --->|                      |
env        | square: --+          |
           +-----------|----------+
                       |       ^
(define (square x)     |       |
  (* x x))             V       |
                   .---.---.   |
                   | O | O-+---+
                   `-|-^---'
                     |
                     V
                   parameters: x
                   body: (* x x)
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.2b,49mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 3.2:} Environment structure produced by evaluating @* @code{(define (square x) (* x x))} in the global environment.}
@center @caption{@strong{Рисунок 3.2:} Структура окружений, порождаемая вычислением @code{(define (square x) (* x x))} в глобальном окружении.}
@sp 0.8
@end iftex
@end quotation
@end float

Теперь, когда мы рассмотрели, как процедуры создаются, мы можем описать,
как они применяются. Модель с окружениями говорит: чтобы применить
процедуру к аргументам, создайте новое окружение, которое содержит кадр,
связывающий параметры со значениями аргументов. Объемлющим окружением
для нового кадра служит окружение, на которое указывает процедура.
Теперь требуется выполнить тело процедуры в этом новом окружении.

Чтобы проиллюстрировать, как работает это новое правило, на
рис. @ref{Рисунок 3.3} показана структура окружений, создаваемая при
вычислении выражения @code{(square 5)} в глобальном окружении, если
@code{square} --- процедура, порожденная на рисунке @ref{Рисунок 3.2}.
Применение процедуры приводит к созданию нового окружения, которое на
рисунке обозначено как E1, и это окружение начинается с кадра, в котором
@code{x}, формальный параметр процедуры, связан с аргументом 5.
Указатель, который ведет из этого кадра вверх, показывает, что
объемлющим для этого окружения является глобальное. Глобальное окружение
выбирается потому, что именно на него ссылается процедурный объект
@code{square}. Внутри E1 мы вычисляем тело процедуры, @code{(* x x)}.
Поскольку значение @code{x} в E1 равно 5, результатом будет
@code{(* 5 5)}, или 25.

@float
@quotation
@anchor{Рисунок 3.3}
@ifinfo
@strong{Рисунок 3.3:} Environment created by evaluating
@code{(square 5)} in the global environment.

@example
          +------------------------------------+
          | other variables                    |
global -->|                                    |
env       | square: --+                        |
          +-----------|---------------------+--+
                      |       ^             ^
(square 5)            |       |             |
                      V       |             |
                  .---.---.   |         +---+--+
                  | O | O-+---+   E1 -->| x: 5 |
                  `-|-^---'             +------+
                    |
                    V
                  parameters: x
                  body: (* x x)
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.3b,78mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 3.3:} Environment created by evaluating @code{(square 5)} in the global environment.}
@center @caption{@strong{Рисунок 3.3:} Окружение, создаваемое при вычислении @code{(square 5)} в глобальном окружении.}
@sp 0.7
@end iftex
@end quotation
@end float

параметры: @code{x}

тело: @code{(* x x)}

Модель вычисления с окружениями можно вкратце описать двумя правилами:

@itemize @bullet

@item
Процедурный объект применяется к набору аргументов при помощи создания
кадра, связывания формальных параметров процедуры с аргументами вызова,
и, наконец, вычисления тела процедуры в контексте этого свежесозданного
окружения. В качестве объемлющего окружения новый кадр имеет окружение,
содержащееся в применяемом процедурном объекте.

@item
Процедура создается при вычислении @code{lambda}-выражения по отношению
к некоторому окружению. Получающийся процедурный объект есть пара,
состоящая из текста @code{lambda}-выражения и указателя на окружение, в
котором процедура была создана.

@end itemize

@noindent
Кроме того, мы указываем, что когда символ определяется при помощи
@code{define}, в текущем кадре окружения создается связывание, и символу
присваивается указанное значение.@footnote{Если в текущем кадре уже
имелось связывание для указанной переменной, то это связывание
изменяется. Это правило удобно, поскольку позволяет переопределять
символы; однако оно означает, что при помощи @code{define} можно
изменять значение символов, а это влечет за собой все проблемы,
связанные с присваиванием, без явного использования @code{set!}. По этой
причине некоторые предпочитают, чтобы переопределение существующего
символа вызывало предупреждение или сообщение об ошибке.} Наконец, мы
описываем поведение @code{set!}, операции, из-за которой нам,
собственно, и пришлось ввести модель с окружениями. Вычисление выражения
@code{(set!}@math{\;\langle}@var{переменная}@math{\kern0.08em\rangle}@math{\;\langle}@var{значение}@math{\kern0.08em\rangle}@code{)} в
некотором окружении заставляет интерпретатор найти связывание переменной
в окружении и изменить это связывание так, чтобы оно указывало на новое
значение. А именно, нужно найти первый кадр окружения, в котором
содержится связывание для переменной, и изменить этот кадр. Если
переменная в окружении не связана, @code{set!} сигнализирует об ошибке.

Все эти правила вычисления, хотя они значительно сложнее, чем в
подстановочной модели, достаточно просты. Более того, модель вычислений,
несмотря на свою абстрактность, дает правильное описание того, как
интерпретатор вычисляет выражения. В @ref{Глава 4} мы
увидим, как эта модель может служить основой для реализации работающего
интерпретатора. В последующих разделах анализ нескольких примеров
программ раскрывает некоторые детали этой модели.

@comment @subsection Applying Simple Procedures
@subsection Применение простых процедур
@node	3.2.2, 3.2.3, 3.2.1, 3.2

Когда в @ref{1.1.5} мы
описывали подстановочную модель, мы показали, как вычисление комбинации
@code{(f 5)} дает результат 136, если даны следующие определения:

@lisp
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
@end lisp

@noindent
Теперь мы можем проанализировать тот же самый пример, используя модель с
окружениями. На рисунке @ref{Рисунок 3.4} изображены три процедурных
объекта, созданные вычислением в глобальном окружении определений
@code{f}, @code{square}, и @code{sum-of-squares}. Каждый процедурный
объект состоит из куска кода и указателя на глобальное окружение.

@float
@c @quotation
@anchor{Рисунок 3.4}
@ifinfo
@strong{Рисунок 3.4:} Procedure objects in the global frame.

@example
          +--------------------------------------------+
          | sum-of-squares:                            |
global -->| square:                                    |
env       | f: --+                                     |
          +------|--------------+--------------+-------+
                 |     ^        |     ^        |     ^
                 |     |        |     |        |     |
                 V     |        V     |        V     |
             .---.---. |    .---.---. |    .---.---. |
             | O | O-+-+    | O | O-+-+    | O | O-+-+
             `-|-^---'      `-|-^---'      `-|-^---'
               |              |              |
               V              V              V
   parameters: a          parameters: x  parameters: x, y
   body: (sum-of-squares  body: (* x x)  body: (+ (square x)
           (+ a 1)                                (square y))
           (* a 2))
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.4a,106mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 3.4:} Procedure objects in the global frame.}
@center @caption{@strong{Рисунок 3.4:} Процедурные объекты в глобальном кадре окружения.}
@sp 0.7
@end iftex
@c @end quotation
@end float

На рисунке @ref{Рисунок 3.5} мы видим структуру окружений, созданную
вычислением выражения @code{(f 5)}. Вызов @code{f} создает новое
окружение E1, начинающееся с кадра, в котором @code{a}, формальный
параметр @code{f}, связывается с аргументом 5. В окружении E1 мы
вычисляем тело @code{f}:

@lisp
(sum-of-squares (+ a 1) (* a 2))
@end lisp

@noindent
To evaluate this combination, we first evaluate the subexpressions.  The first
Для вычисления этой комбинации сначала мы вычисляем подвыражения.
Значение первого подвыражения, @code{sum-of-squares} --- процедурный
объект. (Обратите внимание, как мы находим этот объект: сначала мы
просматриваем первый кадр E1, который не содержит связывания для
переменной @code{sum-of-squares}. Затем мы переходим в объемлющее
окружение, а именно глобальное, и там находим связывание, которое
показано на рис. @ref{Рисунок 3.4}.) В оставшихся двух подвыражениях
элементарные операции @code{+} и @code{*} применяются при вычислении
комбинаций @code{(+ a 1)} и @code{(* a 2)}, и дают, соответственно,
результаты 6 и 10.

\enlargethispage{\baselineskip}

Теперь мы применяем процедурный объект @code{sum-of-squares} к
аргументам 6 и 10. При этом создается новое окружение E2, в котором
формальные параметры @code{x} и @code{y} связываются со значениями
аргументов. Внутри E2 мы вычисляем комбинацию
@code{(+ (square x) (square y))}. Для этого нам требуется вычислить
@code{(square x)}, причем значение @code{square} мы находим в глобальном
окружении, а @code{x} равен 6. Мы опять создаем новое окружение, E3, где
@code{x} связан со значением 6, и где мы вычисляем тело @code{square},
то есть @code{(* x x)}. Кроме того, как часть вычисления
@code{sum-of-squares}, нам нужно вычислить подвыражение
@code{(square y)}, где @code{y} равен 10. Этот второй вызов
@code{square} создает еще одно окружение E4, в котором @code{x},
формальный параметр @code{square}, связан со значением 10. Внутри E4 нам
нужно вычислить @code{(* x x)}.

@float
@c @quotation
@anchor{Рисунок 3.5}
@ifinfo
@strong{Рисунок 3.5:} Environments created by evaluating
@code{(f 5)} using the procedures in @ref{Рисунок 3.4}.

@example
          +-----------------------------------------------------+
global -->|                                                     |
env       +-----------------------------------------------------+
            ^              ^                ^               ^
(f 5)       |              |                |               |
        +------+       +-------+        +------+        +-------+
  E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
        |      |       | y: 10 |        |      |        |       |
        +------+       +-------+        +------+        +-------+
   (sum-of-squares   (+ (square x)       (* x x)         (* x x)
     (+ a 1)            (square u))
     (+ a 2))
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.5a,100mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 3.5:} Environments created by evaluating @code{(f 5)} using the procedures in @ref{Рисунок 3.4}.}
@caption{@strong{Рисунок 3.5:} Окружения, созданные при вычислении @code{(f 5)} с использованием процедур, изображенных на рис. @ref{Рисунок 3.4}}
@sp 0.9
@end iftex
@c @end quotation
@end float

Важно заметить, что каждый вызов @code{square} создает новое окружение с
новым связыванием для @code{x}. Теперь мы видим, как разделение кадров
служит для того, чтобы разные локальные переменные по имени @code{x} не
смешивались. Заметим, кроме того, что все кадры, созданные процедурой
@code{square}, указывают на глобальное окружение, поскольку указатель
именно на это окружение содержится в процедурном объекте @code{square}.

После того, как подвыражения вычисляются, они возвращают значения.
Значения, порожденные двумя вызовами @code{square}, складываются в
@code{sum-of-squares}, и этот результат возвращается процедурой
@code{f}. Поскольку сейчас наше внимание сосредоточено на структурах
окружений, мы не будем здесь разбираться, как значения передаются от
вызова к вызову; однако на самом деле это важная часть процесса
вычисления, и мы детально рассмотрим ее в
@ref{Глава 5}.

@quotation
@strong{@anchor{Упражнение 3.9}Упражнение 3.9:}
В @ref{1.2.1} мы с помощью подстановочной модели анализировали две процедуры
вычисления факториала, рекурсивную

@lisp
(define (factorial n)
  (if (= n 1) 1 (* n (factorial (- n 1)))))
@end lisp

@noindent
и итеративную

@lisp
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
@end lisp

Продемонстрируйте, какие структуры окружений возникнут при вычислении
@code{(factorial 6)} с каждой из версий процедуры
@code{factorial}.@footnote{Модель с окружениями неспособна
проиллюстрировать утверждение из @ref{1.2.1},
что интерпретатор может, используя хвостовую рекурсию, вычислять
процедуры, подобные @code{fact-iter}, в фиксированном объеме памяти. Мы
рассмотрим хвостовую рекурсию, когда будем изучать управляющую структуру
интерпретатора в @ref{5.4}.}
@end quotation

@comment @subsection Frames as the Repository of Local State
@subsection Кадры как хранилище внутреннего состояния
@node	3.2.3, 3.2.4, 3.2.2, 3.2

Теперь мы можем обратиться к модели с окружениями и рассмотреть, как
можно с помощью процедур и присваивания представлять объекты, обладающие
внутренним состоянием. В качестве примера возьмем <<обработчик снятия
денег со счета>> из @ref{3.1.1}, который создается вызовом процедуры

@lisp
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
@end lisp

@noindent
Опишем вычисление

@lisp
(define W1 (make-withdraw 100))
@end lisp

@noindent
за которым следует

@lisp
(W1 50)
@i{50}
@end lisp

@noindent
На рисунке @ref{Рисунок 3.6} показан результат определения
@code{make-withdraw} в глобальном окружении. Получается процедурный
объект, который содержит ссылку на глобальное окружение. До сих пор мы
не видим особых отличий от тех примеров, которые мы уже рассмотрели,
кроме того, что тело процедуры само по себе является @code{lambda}-выражением.

@float
@anchor{Рисунок 3.6}
@ifinfo
@quotation
@strong{Рисунок 3.6:} Result of defining @code{make-withdraw} in the global environment.

@example
          +---------------------------+
global -->| make-withdraw: --+        |
env       +------------------|--------+
                             |      ^
                             V      |
                         .---.---.  |
                         | O | O-+--+
                         `-|-^---'
                           |
                           V
         parameters: balance
         body: (lambda (amount)
                 (if (>= balance amount)
                     (begin (set! balance
                                  (- balance amount))
                            balance)
                     "Insufficient funds"))
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.6b,91mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 3.6:} Result of defining @code{make-withdraw} in the global environment.}
@center @caption{@strong{Рисунок 3.6:} Результат определения @code{make-withdraw} в глобальном окружении.}
@sp 0.8
@end iftex
@end float

@float
@c @quotation
@anchor{Рисунок 3.7}
@ifinfo
@strong{Рисунок 3.7:} Result of evaluating @code{(define W1 (make-withdraw 100))}.

@example
          +-----------------------------------------------+
          | make-withdraw: -----------------------+       |
global -->|                                       |       |
          | W1: --+                               |       |
          +-------|-------------------------------|-------+
                  |                ^              |     ^
                  |                |              V     |
                  |        +-------+------+   .---.---. |
                  |  E1 -->| balance: 100 |   | O | O-+-+
                  |        +--------------+   `-|-^---'
                  V                ^            |
              .---.---.            |            V
            +-+-O | O-+------------+    parameters: balance
            | `---^---'                 body: ...
            V
    parameters: amount
    body: (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds")
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap3/Fig3.7a,100mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 3.7:} Result of evaluating @code{(define W1 (make-withdraw 100))}. }@short
@center @caption{@strong{Рисунок 3.7:} Результат вычисления @code{(define W1 (make-withdraw 100))}.}
@sp 0.9
@end iftex
@c @end quotation
@end float

Интересная часть вычисления начинается тогда, когда мы применяем
процедуру @code{make-withdraw} к аргументу:

@lisp
(define W1 (make-withdraw 100))
@end lisp

@noindent
Сначала, как обычно, мы создаем окружение E1, где формальный параметр
@code{balance} связан с аргументом 100. Внутри этого окружения мы
вычисляем тело @code{make-withdraw}, а именно @code{lambda}-выражение.
При этом создается новый процедурный объект, код которого определяется
@code{lambda}-выражением, а окружение равно E1, окружению, в котором
вычисляется @code{lambda} при создании процедуры. Полученный процедурный
объект возвращается в качестве значения процедуры @code{make-withdraw}.
Это значение присваивается переменной @code{W1} в глобальном окружении,
поскольку выражение @code{define} вычисляется именно в нем. Получившаяся
структура окружений изображена на рисунке @ref{Рисунок 3.7}.

@float
@c @quotation
@anchor{Рисунок 3.8}
@ifinfo
@strong{Рисунок 3.8:} Environments created by applying the procedure object @code{W1}.

@example
          +---------------------------------------------------+
          | make-withdraw: ...                                |
global -->|                                                   |
env       | W1: --+                                           |
          +-------|-------------------------------------------+
                  |               ^
                  |               |
                  |       +-------+------+ Here is the balance
                  | E1 -->| balance: 100 | that will be changed
                  |       +--------------+ by the set!.
                  V               ^   ^
              .---.---.           |   +----+
              | O | O-+-----------+        |
              `-|-^---'             +------+-----+
                |                   | amount: 50 |
                V                   +------------+
      parameters: amount   (if (>= balance amount)
      body: ...                (begin (set! balance
                                            (- balance amount))
                                      balance)
                               "Insufficient funds")
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.8c,99mm,,,.pdf}
@sp 0.2
@comment @center @caption{@strong{Рисунок 3.8:} Environments created by applying the procedure object @code{W1}. }@short
@center @caption{@strong{Рисунок 3.8:} Окружения, создаваемые при применении процедурного объекта @code{W1}.}
@sp 0.7
@end iftex
@c @end quotation
@end float

\enlargethispage{\baselineskip}

Теперь можно проанализировать, что происходит, когда @code{W1}
применяется к аргументу:

@lisp
(W1 50)
@i{50}
@end lisp

Для начала мы конструируем кадр, в котором @code{amount}, формальный
параметр @code{W1}, связывается со значением 50. Здесь крайне важно
заметить, что у этого кадра в качестве объемлющего окружения выступает
не глобальное окружение, а E1, поскольку именно на него указывает
процедурный объект @code{W1}. В этом новом окружении мы вычисляем тело
процедуры:

@lisp
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
@end lisp

@noindent
Получается структура окружений, изображенная на
рисунке @ref{Рисунок 3.8}. Вычисляемое выражение обращается к
переменным @code{amount} и @code{balance}. @code{Amount} находится в
первом кадре окружения, а @code{balance} мы найдем, проследовав по
указателю на объемлющее окружение E1.

@float
@quotation
@anchor{Рисунок 3.9}
@ifinfo
@strong{Рисунок 3.9:} Environments after the call to @code{W1}.

@example
           +------------------------------------+
           | make-withdraw: ...                 |
global --->|                                    |
env        | W1: --+                            |
           +-------|----------------------------+
                   |                   ^
                   |                   |
                   |            +------+------+
                   |     E1 --->| balance: 50 |
                   |            +-------------+
                   V                   ^
               .---.---.               |
               | O | O-+---------------+
               `-|-^---'
                 |
                 V
          parameters: amount
          body: ...
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap3/Fig3.9a,96mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.9:} Environments after the call to @code{W1}.}
@center @caption{@strong{Рисунок 3.9:} Окружения после вызова @code{W1}.}
@sp 1.0
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

Когда выполняется @code{set!}, связывание переменной @code{balance} в E1
изменяется. После завершения вызова @code{W1} значение @code{balance}
равно 50, а @code{W1} по-прежнему указывает на кадр, который содержит
переменную @code{balance}. Кадр, содержащий @code{amount} (тот, в
котором мы выполняли код, изменяющий @code{balance}), больше не нужен,
поскольку создавший его вызов процедуры закончен, и никаких указателей
на этот кадр из других частей окружения нет. В следующий раз, когда мы
позовем @code{W1}, создастся новый кадр, в котором будет связана
переменная @code{amount}, и для которого объемлющим окружением снова
будет E1. Мы видим, что E1 служит <<местом>>, в котором хранится
локальная переменная окружения для процедурного объекта @code{W1}. На
рисунке @ref{Рисунок 3.9} изображена ситуация после вызова @code{W1}.

Рассмотрим, что произойдет, когда мы создадим другой объект для <<снятия
денег>>, вызвав @code{make-withdraw} второй раз:

@lisp
(define W2 (make-withdraw 100))
@end lisp

@float
@c @quotation
@anchor{Рисунок 3.10}
@ifinfo
@strong{Рисунок 3.10:} Using @code{(define W2 (make-withdraw 100))} to create a second object.

@example
         +-------------------------------------------------+
         | make-withdraw: ...                              |
global ->| W2: ---------------------------+                |
env      | W1: --+                        |                |
         +-------|------------------------|----------------+
                 |              ^         |              ^
                 |              |         |              |
                 |       +------+------+  |       +------+-------+
                 |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                 |       +-------------+  |       +--------------+
                 V              ^         V              ^
             .---.---.          |     .---.---.          |
             | O | O-+----------+     | O | O-+----------+
             `-|-^---'                `-|-^---'
               | +----------------------+
               V V
        parameters: amount
        body: ...
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap3/Fig3.10a,108mm,,,.pdf}
@sp 0.7
@comment @caption{@strong{Рисунок 3.10:} Using @code{(define W2 (make-withdraw 100))} to create a second object.}
@caption{@strong{Рисунок 3.10:} Создание второго объекта при помощи @code{(define W2 (make-withdraw 100))}}
@sp 1.0
@end iftex
@c @end quotation
@end float

При этом получается структура окружений, изображенная на
рисунке @ref{Рисунок 3.10}. Мы видим, что @code{W2} --- процедурный
объект, то есть пара, содержащая код и окружение. Окружение E2 для
@code{W2} было создано во время вызова @code{make-withdraw}. Оно
содержит кадр со своим собственным связыванием переменной
@code{balance}. С другой стороны, код у @code{W1} и @code{W2} один и тот
же: это код, определяемый @code{lambda}-выражением в теле
@code{make-withdraw}.@footnote{Разделяют ли @code{W1} и @code{W2} общий
физический код, хранимый в компьютере, или каждый из них хранит
собственную копию кода --- это деталь реализации. В интерпретаторе,
который мы создадим в @ref{Глава 4},
код будет общим.} Отсюда мы видим, почему @code{W1} и @code{W2} ведут
себя как независимые объекты. Вызовы @code{W1} работают с переменной
состояния @code{balance}, которая хранится в E1, а вызовы @code{W2} с
переменной @code{balance}, хранящейся в E2. Таким образом, изменения
внутреннего состояния одного объекта не действуют на другой.

@quotation
@strong{@anchor{Упражнение 3.10}Упражнение 3.10:}
В процедуре @code{make-withdraw} локальная переменная
@code{balance} создается в виде параметра @code{make-withdraw}. Можно
было бы создать локальную переменную и явно, используя @code{let}, а
именно:

@lisp
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
@end lisp

Напомним, что в @ref{1.3.2} говорится, что @code{let} всего лишь
синтаксический сахар для вызова процедуры:

@lisp
(let ((@math{\langle}@var{var}@math{\rangle} @math{\langle}@var{exp}@math{\rangle})) @math{\langle}@var{body}@math{\rangle})
@end lisp

@noindent
интерпретируется как альтернативный синтаксис для

@lisp
((lambda (@math{\langle}@var{var}@math{\rangle}) @math{\langle}@var{body}@math{\rangle}) @math{\langle}@var{exp}@math{\rangle})
@end lisp

С помощью модели с окружениями проанализируйте альтернативную версию
@code{makewithraw}. Нарисуйте картинки, подобные приведенным в этом
разделе, для выражений

@lisp
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
@end lisp

Покажите, что две версии @code{make-withdraw} создают объекты с
одинаковым поведением. Как различаются структуры окружений в двух
версиях?
@end quotation

@comment @subsection Internal Definitions
@subsection Внутренние определения
@node	3.2.4,  , 3.2.3, 3.2

В @ref{1.1.8} мы познакомились с идеей, что процедуры могут содержать внутренние
определения, в результате чего возникает блочная структура, как,
например, в следующей процедуре вычисления квадратного корня:

@lisp
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
@end lisp

@noindent
Теперь с помощью модели с окружениями мы можем увидеть, почему эти
внутренние определения работают так, как должны. На
рисунке @ref{Рисунок 3.11} изображен момент во время вычисления
выражения @code{(sqrt 2)}, когда внутренняя процедура
@code{good-enough?} вызвана в первый раз со значением @code{guess},
равным 1.

Рассмотрим структуру окружения. Символ @code{sqrt} в глобальном
окружении связан с процедурным объектом, ассоциированное окружение
которого --- глобальное окружение. Когда мы вызвали процедуру
@code{sqrt}, появилось окружение E1, зависимое от глобального, в котором
параметр @code{x} связан со значением 2. Затем мы вычислили тело
@code{sqrt} внутри E1. Поскольку первое выражение в теле @code{sqrt}
есть

@lisp
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
@end lisp

@noindent
вычисление этого выражения привело к определению процедуры
@code{good-enough?} в окружении E1. Выражаясь более точно, к первому
кадру E1 был добавлен символ @code{good-enough?}, связанный с
процедурным объектом, ассоциированным окружением которого является E1.
Подобным образом в качестве процедур внутри E1 были определены
@code{improve} и @code{sqrt-iter}. Краткости ради на
рис. @ref{Рисунок 3.11} показан только процедурный объект,
соответствующий @code{good-enough?}.

@float
@c @quotation
@anchor{Рисунок 3.11}
@ifinfo
@strong{Рисунок 3.11:} @code{sqrt} procedure with internal definitions.

@example
          +--------------------------------------------------+
global -->| sqrt: --+                                        |
env       |         |                                        |
          +---------|----------------------------------------+
                    V       ^                   ^
                .---.---.   |                   |
     +----------+-O | O-+---+        +----------+------------+
     |          `---^---'            | x: 2                  |
     V                         E1 -->| good-enough?: -+      |
parameters: x                        | improve: ...   |      |
body: (define good-enough? ...)      | sqrt-iter: ... |      |
      (define improve ...)           +----------------|------+
      (define sqrt-iter ...)          ^  ^            |     ^
      (sqrt-iter 1.0)                 |  |            V     |
                            +---------++ |        .---.---. |
                      E2 -->| guess: 1 | |        | O | O-+-+
                            +----------+ |        `-|-^---'
                      call to sqrt-iter  |          |
                                         |          V
                               +---------++    parameters: guess
                         E3 -->| guess: 1 |    body: (< (abs ...)
                               +----------+             ...)
                         call to good-enough?
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap3/Fig3.11a,107mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.11:} @code{sqrt} procedure with internal definitions.}
@center @caption{@strong{Рисунок 3.11:} Процедура @code{sqrt} с внутренними определениями.}
@sp 0.7
@end iftex
@c @end quotation
@end float

После того, как были определены внутренние процедуры, мы вычислили
выражение @code{(sqrt-iter 1.0)}, по-прежнему в окружении E1. То есть,
процедурный объект, связанный в E1 с именем @code{sqrt-iter}, был вызван
с аргументом 1. При этом появилось окружение E2, в котором @code{guess},
параметр @code{sqrt-iter}, связан со значением 1. В свою очередь,
@code{sqrt-iter} вызвала @code{good-enough?} со значением @code{guess}
(из E2) в качестве аргумента. Получилось еще одно окружение, E3, в
котором @code{guess} (параметр @code{good-enough?}) связан со значением
1. Несмотря на то, что и @code{sqrt-iter}, и @code{good-enough?} имеют
по параметру с одинаковым именем @code{guess}, это две различные
переменные, расположенные в разных кадрах. Кроме того, и E2, и E3 в
качестве объемлющего окружения имеют E1, поскольку как @code{sqrt-iter},
так и @code{good-enough?} в качестве окружения содержат указатель на E1.
Одним из следствий этого является то, что символ @code{x} в теле
@code{good-enough?} обозначает связывание @code{x}, в окружении E1, а
точнее, то значение @code{x}, с которым была вызвана исходная процедура
@code{sqrt}.

Таким образом, модель вычислений с окружениями объясняет две ключевых
особенности, которые делают внутренние определения процедур полезным
способом модуляризации программ:

@itemize @bullet

@item
Имена внутренних процедур не путаются с именами, внешними по отношению к
охватывающей процедуре, поскольку локальные имена процедур будут
связываться в кадре, который процедура создает при своем запуске, а не в
глобальном окружении.

@item
Внутренние процедуры могут обращаться к аргументам охватывающих
процедур, просто используя имена параметров как свободные переменные.
Это происходит потому, что тело внутренней процедуры выполняется в
окружении, подчиненном окружению, где вычисляется объемлющая процедура.

@end itemize

@quotation
@strong{@anchor{Упражнение 3.11}Упражнение 3.11:}
В @ref{3.2.3}
мы видели, как модель с окружениями описывает поведение процедур,
обладающих внутренним состоянием. Теперь мы рассмотрели, как работают
локальные определения. Типичная процедура с передачей сообщений
пользуется и тем, и другим. Рассмотрим процедуру моделирования
банковского счета из @ref{3.1.1}:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else
           (error "Unknown request: MAKE-ACCOUNT"
                  m))))
  dispatch)
@end lisp

Покажите, какая структура окружений создается последовательностью
действий

@lisp
(define acc (make-account 50))
((acc 'deposit) 40)
@i{90}
((acc 'withdraw) 60)
@i{30}
@end lisp

Где хранится внутреннее состояние @code{acc}? Предположим, что мы
определяем еще один счет

@lisp
(define acc2 (make-account 100))
@end lisp

Каким образом удается не смешивать внутренние состояния двух счетов?
Какие части структуры окружений общие у @code{acc} и @code{acc2}?
@end quotation

@comment @section Modeling with Mutable Data
@section Моделирование при помощи изменяемых данных
@node	3.3, 3.4, 3.2, Chapter 3

В @ref{Глава 2}
составные данные использовались как средство построения вычислительных
объектов, состоящих из нескольких частей, с целью моделирования объектов
реального мира, обладающих несколькими свойствами. В этой главе мы ввели
дисциплину абстракции данных, согласно которой структуры данных
описываются в терминах конструкторов, которые создают объекты данных, и
селекторов, которые обеспечивают доступ к частям составных объектов.
Однако теперь мы знаем, что есть еще один аспект работы с данными,
который остался незатронутым в
@ref{Глава 2}.
Желание моделировать системы, которые состоят из объектов, обладающих
изменяющимся состоянием, вызывает потребность не только создавать
составные объекты данных и иметь доступ к их частям, но и изменять их.
Чтобы моделировать объекты с изменяющимся состоянием, мы будем
проектировать абстракции данных, которые, помимо конструкторов и
селекторов, включают (@newterm{mutators}), модифицирующие объекты данных.
Например, моделирование банковской системы требует от нас способности
изменять балансы счетов. Таким образом, структура данных, изображающая
банковский счет, может обладать операцией

@lisp
(set-balance! @math{\langle}@var{account}@math{\rangle} @math{\langle}@var{new-value}@math{\rangle})
@end lisp

@noindent
которая присваивает балансу указанного счета указанное значение. Объекты
данных, для которых определены мутаторы, называются (@newterm{mutable data objects}).

В @ref{Глава 2}
в качестве универсального <<клея>> для построения составных данных мы
ввели пары. Этот раздел мы начинаем с определения мутаторов для пар,
так, чтобы пары могли служить строительным материалом для построения
изменяемых объектов данных. Мутаторы значительно увеличивают
выразительную силу пар и позволяют нам строить структуры данных помимо
последовательностей и деревьев, с которыми мы имели дело в
@ref{2.2}.
Кроме того, мы строим несколько примеров моделей, где сложные системы
представляются в виде множества объектов, обладающих внутренним
состоянием.

@menu
* 3-3-1::            Изменяемая списковая структура
* 3-3-2::            Представление очередей
* 3-3-3::            Представление таблиц
* 3-3-4::            Имитация цифровых схем
* 3-3-5::            Распространение ограничений
@end menu

@comment @subsection Mutable List Structure
@subsection Изменяемая списковая структура
@node	3.3.1, 3.3.2, 3.3, 3.3

Базовые операции над парами --- @code{cons}, @code{car} и @code{cdr} ---
можно использовать для построения списковой структуры и для извлечения
частей списковой структуры, однако изменять списковую структуру они не
позволяют. То же верно и для операций со списками, которые мы до сих пор
использовали, таких, как @code{append} и @code{list}, поскольку эти
последние можно определить в терминах @code{cons}, @code{car} и
@code{cdr}. Для модификации списковых структур нам нужны новые операции.

Элементарные мутаторы для пар называются @code{set-car!} и
@code{set-cdr!}. @code{set-car!} принимает два аргумента, первый из
которых обязан быть парой. Он модифицирует эту пару, подставляя вместо
указателя @code{car} указатель на свой второй
аргумент.@footnote{Значения, которые возвращают @code{set-car!} и
@code{set-cdr!}, зависят от реализации. Подобно @code{set!}, эти
операции должны использоваться исключительно ради своего побочного
эффекта.}

В качестве примера предположим, что переменная @code{x} имеет значением
список @code{((a b) c d)}, а переменная @code{y} список @code{(e f)},
как показано на рисунке @ref{Рисунок 3.12}. Вычисление выражения
@code{(set-car! x y)} изменяет пару, с которой связана переменная
@code{x}, заменяя ее @code{car} на значение @code{y}. Результат этой
операции показан на рисунке @ref{Рисунок 3.13}. Структура @code{x}
изменилась, и теперь ее можно записать как @code{((e f) c d)}. Пары
представляющие список @code{(a b)}, на которые указывал замененный
указатель, теперь отделены от исходной структуры.@footnote{Здесь мы
видим, как операции изменения данных могут создавать <<мусор>>, который
не является частью никакой доступной структуры. В @ref{5.3.2}
мы увидим, что системы управления памятью Лиспа включают (garbage
collector), который находит и освобождает память, используемую ненужными
парами.}

Сравните рисунок @ref{Рисунок 3.13}, на котором представлен результат
выполнения @code{(define z (cons y (cdr x)))}, где @code{x} и @code{y} имеют
исходные значения с рисунком @ref{Рисунок 3.12}. Здесь переменная
@code{z} оказывается связана с новой парой, созданной операцией
@code{cons}; список, который является значением @code{x}, не меняется.

@float[tp]
@quotation
@anchor{Рисунок 3.12}
@ifinfo
@strong{Рисунок 3.12:} Lists @code{x}: @code{((a b) c d)} and @code{y}: @code{(e f)}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       +---------->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | a |         | b |
                   +---+         +---+
                   +---+---+     +---+---+
              y -->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.12b,72mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.12:} Lists @code{x}: @code{((a b) c d)} and @code{y}: @code{(e f)}.}
@center @caption{@strong{Рисунок 3.12:} Списки @code{x}: @code{((a b) c d)} и @code{y}: @code{(e f)}.}
@sp 0.7
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

@float[bp]
@quotation
@anchor{Рисунок 3.13}
@ifinfo
@strong{Рисунок 3.13:} Effect of @code{(set-car! x y)} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       |           | * | *-+---->| * | / |
       |           +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.13b,72mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.13:} Effect of @code{(set-car! x y)} on the lists in @ref{Рисунок 3.12}. }@short
@center @caption{@strong{Рисунок 3.13:} Результат применения @code{(set-car! x y)} к спискам, изображенным на рис. @ref{Рисунок 3.12}.}
@sp 0.7
@end iftex
@end quotation
@end float

@float[tp]
@quotation
@anchor{Рисунок 3.14}
@ifinfo
@strong{Рисунок 3.14:} Effect of @code{(define z (cons y (cdr x)))} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+ +-->+-|-+---+     +-|-+---+
       |       |     V             V
       |       |   +---+         +---+
       |       |   | c |         | d |
       |       |   +---+         +---+
       |       |   +---+---+     +---+---+
       +-------+-->| * | *-+---->| * | / |
               |   +-|-+---+     +-|-+---+
     +---+---+ |     V             V
z -->| * | *-+-+   +---+         +---+
     +-|-+---+     | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.14b,72mm,,,.pdf}
@sp 0.7
@comment @caption{@strong{Рисунок 3.14:} Effect of @code{(define z (cons y (cdr x)))} on the lists in @ref{Рисунок 3.12}.}
@caption{@strong{Рисунок 3.14:} Результат применения @code{(define z (cons y (cdr x)))} к спискам, показанным на рис. @ref{Рисунок 3.12}.}
@sp 0.0
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

@float[bp]
@quotation
@anchor{Рисунок 3.15}
@ifinfo
@strong{Рисунок 3.15:} Effect of @code{(set-cdr! x y)} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | * |     | * | *-+---->| * | / |
     +-|-+-|-+     +-|-+---+     +-|-+---+
       |   |         V             V
       |   |       +---+         +---+
       |   |       | c |         | d |
       |   |       +---+         +---+
       |   |       +---+---+     +---+---+
       +---+------>| * | *-+---->| * | / |
           |       +-|-+---+     +-|-+---+
           |         V             V
           |       +---+         +---+
           |       | a |         | b |
           |       +---+         +---+
           +------>+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.15b,72mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.15:} Effect of @code{(set-cdr! x y)} on the lists in @ref{Рисунок 3.12}. }@short
@center @caption{@strong{Рисунок 3.15:} Результат применения @code{(set-cdr! x y)} к спискам с @ref{Рисунок 3.12}.}
@sp 0.7
@end iftex
@end quotation
@end float

Операция @code{set-cdr!} подобна @code{set-car!}. Единственная разница
состоит в том, что заменяется не указатель @code{car}, а указатель
@code{cdr}. Результат применения @code{(set-cdr! x y)} к спискам,
изображенным на рис. @ref{Рисунок 3.12}, показан на
рис. @ref{Рисунок 3.15}. Здесь указатель @code{cdr} в составе
@code{x} заменился указателем на @code{(e f)}. Кроме того, список
@code{(c d)}, который был @code{cdr}-ом @code{x}, оказывается отделенным
от структуры.

@code{Cons} создает новую списковую структуру, порождая новые пары, а
@code{set-car!} и @code{set-cdr!} изменяют существующие. В сущности, мы
могли бы реализовать @code{cons} при помощи этих двух мутаторов и
процедуры @code{get-new-pair}, которая возвращает новую пару, не
являющуюся частью никакой существующей списковой структуры. Мы порождаем
новую пару, присваиваем ее указателям @code{car} и @code{cdr} нужные
значения, и возвращаем новую пару в качестве результата
@code{cons}.@footnote{@code{get-new-pair} --- одна из операций, которые
требуется предоставить как часть системы управления памятью в рамках
реализации Лиспа. Мы рассмотрим эти вопросы в
@ref{5.3.1}.}

@lisp
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.12}Упражнение 3.12:}
В @ref{2.2.1} была
введена следующая процедура для добавления одного списка к другому:

@lisp
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
@end lisp

@code{append} порождает новый список, по очереди наращивая элементы
@code{x} в начало @code{y}. Процедура @code{append!} подобна
@code{append}, но только она является не конструктором, а мутатором. Она
склеивает списки вместе, изменяя последнюю пару @code{x} так, что ее
@code{cdr} становится равным @code{y}. (Вызов @code{append!} с пустым
@code{x} является ошибкой.)

@lisp
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
@end lisp

Здесь @code{last-pair} --- процедура, которая возвращает последнюю пару
своего аргумента:

@lisp
(define (last-pair x)
  (if (null? (cdr x)) x (last-pair (cdr x))))
@end lisp

Рассмотрим последовательность действий

@lisp
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
@i{(a b c d)}
(cdr x)
@math{\langle}@var{ответ}@math{\rangle}
(define w (append! x y))
w
@i{(a b c d)}
(cdr x)
@math{\langle}@var{ответ}@math{\rangle}
@end lisp

Каковы будут пропущенные @math{\langle}@var{ответы}@math{\rangle}?
Объясните, нарисовав стрелочные диаграммы.

@quotation
@strong{@anchor{Упражнение 3.13}Упражнение 3.13:}
Рассмотрим следующую процедуру @code{make-cycle}, которая
пользуется @code{last-pair} из упражнения @ref{Упражнение 3.12}:

@lisp
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
@end lisp

Нарисуйте стрелочную диаграмму, которая изображает структуру @code{z},
созданную таким кодом:

@lisp
(define z (make-cycle (list 'a 'b 'c)))
@end lisp

Что случится, если мы попробуем вычислить @code{(last-pair z)}?

@quotation
@strong{@anchor{Упражнение 3.14}Упражнение 3.14:}
Следующая процедура, хотя и сложна для понимания, вполне может оказаться полезной:

@lisp
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
@end lisp

@code{loop} пользуется <<временной>> переменной @code{temp}, чтобы
сохранить старое значение @code{cdr} пары @code{x}, поскольку
@code{set-cdr!} на следующей строке его разрушает. Объясните, что за
задачу выполняет @code{mystery}. Предположим, что переменная @code{v}
определена выражением @code{(define v (list 'a 'b 'c 'd)}. Нарисуйте
диаграмму, которая изображает список, являющийся значением @code{v}.
Допустим, что теперь мы выполняем @code{(define w (mystery v))}.
Нарисуйте стрелочные диаграммы, которые показывают структуры @code{v} и
@code{w} после вычисления этого выражения. Что будет напечатано в
качестве значений @code{v} и @code{w}?
@end quotation

@comment @subsubheading Sharing and identity
@subsubheading Разделение данных и их идентичность
В @ref{3.1.3} мы упоминали
теоретические вопросы <<идентичности>> и <<изменения>>, которые
возникают с появлением присваивания. Эти вопросы начинают иметь
практическое значение тогда, когда отдельные пары (@newterm{are shared}) между
различными объектами данных. Рассмотрим, например, структуру, которая
создается таким кодом:

@lisp
(define x (list 'a 'b))
(define z1 (cons x x))
@end lisp

@noindent
Как показано на рис. @ref{Рисунок 3.16}, @code{z1} представляет собой
пару, в которой @code{car} и @code{cdr} указывают на одну и ту же пару
@code{x}. Разделение @code{x} между @code{car} и @code{cdr} пары
@code{z1} возникает оттого, что @code{cons} реализован простейшим
способом. В общем случае построение списков с помощью @code{cons}
приводит к возникновению сложносвязанной сети пар, в которой многие пары
разделяются между многими различными структурами.

В противоположность @ref{Рисунок 3.16}, @ref{Рисунок 3.17} показывает
структуру, которая порождается кодом

@lisp
(define z2 (cons (list 'a 'b) (list 'a 'b)))
@end lisp

@noindent
В этой структуре пары двух списков @code{(a b)} различны, притом, что
сами символы разделяются.@footnote{Пары различаются потому, что каждый
вызов @code{cons} порождает новую пару. Символы разделяются; в Scheme
существует только один символ для каждого данного имени. Поскольку
Scheme не дает возможности изменять символ, это разделение невозможно
заметить. Заметим, кроме того, что именно разделение позволяет нам
сравнивать символы при помощи @code{eq?}, который просто проверяет
равенство указателей.}

@float
@quotation
@anchor{Рисунок 3.16}
@ifinfo
@strong{Рисунок 3.16:} The list @code{z1} formed by @code{(cons x x)}.

@example
      +---+---+
z1 -->| * | * |
      +-|-+-|-+
        V   V
      +---+---+     +---+---+
 x -->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+
        V             V
      +---+         +---+
      | a |         | b |
      +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap3/Fig3.16b,46mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.16:} The list @code{z1} formed by @code{(cons x x)}.}
@center @caption{@strong{Рисунок 3.16:} Список @code{z1}, порождаемый выражением @code{(cons x x)}.}
@sp 0.7
@end iftex
@end quotation
@end float

@float
@anchor{Рисунок 3.17}
@ifinfo
@quotation
@strong{Рисунок 3.17:} The list @code{z2} formed by @code{(cons (list 'a 'b) (list 'a 'b))}.

@example
      +---+---+     +---+---+     +---+---+
z2 -->| * | *-+---->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+     +-|-+---+
        |             V             V
        |           +---+         +---+
        |           | a |         | b |
        |           +---+         +---+
        |             ^             ^
        |             |             |
        |           +-|-+---+     +-|-+---+
        +---------->| * | *-+---->| * | / |
                    +---+---+     +---+---+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.17b,71mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.17:} The list @code{z2} formed by @code{(cons (list 'a 'b) (list 'a 'b))}.}
@center @caption{@strong{Рисунок 3.17:} Список z2, порождаемый выражением @code{(cons (list 'a 'b) (list 'a 'b))}.}
@sp 1.0
@end iftex
@end float

Если мы рассматриваем @code{z1} и @code{z2} как списки, они представляют
<<один и тот же>> список @code{((a b) a b)}. Вообще говоря, разделение
данных невозможно заметить, если мы работаем со списками только при
помощи операций @code{cons}, @code{car} и @code{cdr}. Однако если мы
вводим мутаторы, работающие со списковой структурой, разделение данных
начинает иметь значение. Как пример случая, когда разделение влияет на
результат, рассмотрим следующую процедуру, которая изменяет @code{car}
структуры, к которой она применяется:

@lisp
(define (set-to-wow! x) (set-car! (car x) 'wow) x)
@end lisp

@noindent
Несмотря на то, что @code{z1} и @code{z2} имеют <<одинаковую>>
структуру, применение к ним процедуры @code{set-to-wow!} дает различные
результаты. В случае с @code{z1} изменение @code{car} влияет и на
@code{cdr}, поскольку здесь @code{car} и @code{cdr} --- это одна и та же
пара. В случае с @code{z2}, @code{car} и @code{cdr} различны, так что
@code{set-to-wow!} изменяет только @code{car}:

@lisp
z1
@i{((a b) a b)}
(set-to-wow! z1)
@i{((wow b) wow b)}
z2
@i{((a b) a b)}
(set-to-wow! z2)
@i{((wow b) a b)}
@end lisp

@noindent
Один из способов распознать разделение данных в списковых структурах ---
это воспользоваться предикатом @code{eq?}, который мы ввели в
@ref{} как метод проверки двух символов
на равенство. В более общем случае @code{(eq? x y)} проверяет, являются
ли @code{x} и @code{y} одним объектом (то есть, равны ли @code{x} и
@code{y} друг другу как указатели). Так что, если @code{z1} и @code{z2}
определены как на рисунках @ref{Рисунок 3.16},
@code{(eq? (car z1) (cdr z1))} будет истинно, а
@code{(eq? (car z2) (cdr z2))} ложно.

Как будет видно в последующих разделах, с помощью разделения данных мы
значительно расширим репертуар структур данных, которые могут быть
представлены через пары. С другой стороны, разделение сопряжено с
риском, поскольку изменения в одних структурах могут затрагивать и
другие структуры, разделяющие те части, которые подвергаются изменению.
Операции изменения @code{set-car!} и @code{set-cdr!} нужно использовать
осторожно; если у нас нет точного понимания, какие из наших объектов
разделяют данные, изменение может привести к неожиданным
результатам.@footnote{Тонкости работы с разделением изменяемых данных
отражают сложности с понятием <<идентичности>> и <<изменения>>, о
которых мы говорили в @ref{3.1.3}. Там мы
отметили, что введение в наш язык понятия изменения требует, чтобы у
составного объекта была <<индивидуальность>>, которая представляет собой
нечто отличное от частей, из которых он состоит. В Лиспе мы считаем, что
именно эта <<индивидуальность>> проверяется предикатом @code{eq?}, то
есть сравнением указателей. Поскольку в большинстве реализаций Лиспа
указатель --- это, в сущности, адрес в памяти, мы <<решаем проблему>>
определения индивидуальности объектов, постановив, что <<сам>> объект
данных есть информация, хранимая в некотором наборе ячеек памяти
компьютера. Для простых лисповских программ этого достаточно, но такой
метод не способен разрешить общий вопрос <<идентичности>> в
вычислительных моделях.}

@quotation
@strong{@anchor{Упражнение 3.15}Упражнение 3.15:}
Нарисуйте стрелочные диаграммы, объясняющие, как
@code{set-to-wow!} действует на структуры @code{z1} и @code{z2} из этого
раздела.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.16}Упражнение 3.16:}
Бен Битобор решил написать процедуру для подсчета числа пар
в любой списковой структуре. <<Это легко, --- думает он. --- Число пар в
любой структуре есть число пар в @code{car} плюс число пар в @code{cdr}
плюс один на текущую пару>>. И он пишет следующую процедуру:

@lisp
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
@end lisp

Покажите, что эта процедура ошибочна. В частности, нарисуйте диаграммы,
представляющие списковые структуры ровно из трех пар, для которых Бенова
процедура вернет 3; вернет 4; вернет 7; вообще никогда не завершится.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.17}Упражнение 3.17:}
Напишите правильную версию процедуры @code{count-pairs} из
упражнения @ref{Упражнение 3.16}, которая возвращает число различных
пар в любой структуре. (Подсказка: просматривайте структуру, поддерживая
при этом вспомогательную структуру, следящую за тем, какие пары уже были
посчитаны.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.18}Упражнение 3.18:}
Напишите процедуру, которая рассматривает список и
определяет, содержится ли в нем цикл, то есть, не войдет ли программа,
которая попытается добраться до конца списка, продвигаясь по полям
@code{cdr}, в бесконечный цикл. Такие списки порождались в
упражнении @ref{Упражнение 3.13}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.19}Упражнение 3.19:}
Переделайте упражнение @ref{Упражнение 3.18}, используя
фиксированное количество памяти. (Тут нужна достаточно хитрая идея.)
@end quotation

@comment @subsubheading Mutation is just assignment
@subsubheading Изменение как присваивание

Когда мы вводили понятие составных данных, в @ref{2.1.3} мы
заметили, что пары можно представить при помощи одних только процедур:

@lisp
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
@end lisp

@noindent
То же наблюдение верно и для изменяемых данных. Изменяемые объекты
данных можно реализовать при помощи процедур и внутреннего состояния.
Например, можно расширить приведенную реализацию пар, так, чтобы
@code{set-car!} и @code{set-cdr!} обрабатывались по аналогии с
реализацией банковских счетов через @code{make-account} из @ref{3.1.1}:

@lisp
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else
           (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value)
  ((z 'set-car!) new-value) z)
(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value) z)
@end lisp

@noindent
Теоретически, чтобы описать поведение изменяемых данных, не требуется
ничего, кроме присваивания. Как только мы вводим в наш язык @code{set!},
мы сталкиваемся со всеми проблемами, не только собственно присваивания,
но и вообще изменяемых данных.@footnote{С другой стороны, с точки зрения
реализации, присваивание требует модификации окружения, которое само по
себе является изменяемой структурой данных. Таким образом, присваивание
и изменяемость данных обладают равной мощностью: каждое из них можно
реализовать при помощи другого.}

@quotation
@strong{@anchor{Упражнение 3.20}Упражнение 3.20:}
Нарисуйте диаграммы окружений, изображающие выполнение последовательности выражений

@lisp
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
@i{17}
@end lisp

@noindent
с помощью вышеприведенной процедурной реализации пар. (Ср. с
упражнением @ref{Упражнение 3.11}.)
@end quotation

@endpage
@comment @subsection Representing Queues
@subsection Представление очередей
@node	3.3.2, 3.3.3, 3.3.1, 3.3

Мутаторы @code{set-car!} и @code{set-cdr!} позволяют нам строить из пар
такие структуры, какие мы не смогли бы создать только при помощи
@code{cons}, @code{car} и @code{cdr}. В этом разделе будет показано, как
представить структуру данных, которая называется очередь. В
@ref{3.3.3} мы увидим, как реализовать структуру, называемую таблицей.

@float
@quotation
@anchor{Рисунок 3.18}
@ifinfo
@strong{Рисунок 3.18:} Queue operations.

@example
Операция                 Результат
(define q (make-queue))
(insert-queue! q 'a)     a
(insert-queue! q 'b)     a b
(delete-queue! q)        b
(insert-queue! q 'c)     b c
(insert-queue! q 'd)     b c d
(delete-queue! q)        c d
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.18a,70mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 3.18:} Queue operations.}
@center @caption{@strong{Рисунок 3.18:} Операции над очередью.}
@sp 0.9
@end iftex
@end quotation
@end float

(@newterm{queue}) представляет собой последовательность, в которую можно добавлять
элементы с одного конца (он называется (@newterm{rear)}) и убирать с другого (он
называется (@newterm{front)}). На рисунке @ref{Рисунок 3.18} изображено, как в
изначально пустую очередь добавляются элементы @code{a} и @code{b}.
Затем @code{a} убирается из очереди, в нее добавляются @code{c} и
@code{d}, потом удаляется @code{b}. Поскольку элементы удаляются всегда
в том же порядке, в котором они были добавлены, иногда очередь называют
буфером (@newterm{FIFO}) (англ. first in, first out --- первым вошел, первым
вышел).

С точки зрения абстракции данных, можно считать, что очередь
определяется следующим набором операций:

@itemize @bullet

@item
конструктор @code{(make-queue)} возвращает пустую очередь (очередь, в
которой нет ни одного элемента).

@item
два селектора:
@code{(empty-queue? @math{\langle}@var{очередь}@math{\rangle})}
проверяет, пуста ли очередь.

@code{(front-queue @math{\langle}@var{очередь}@math{\rangle})}
возвращает объект, находящийся в голове очереди. Если очередь пуста,
он сообщает об ошибке. Очередь не модифицируется.

@item
Два мутатора:
@code{(insert-queue! @math{\langle}@var{очередь}@math{\rangle} @math{\langle}@var{элемант}@math{\rangle})}
вставляет элемент в хвост очереди и возвращает в качестве значения
измененную очередь; @code{(delete-queue! @math{\langle}@var{очередь}@math{\rangle})} удаляет
элемент в голове очереди и возвращает в качестве значения измененную
очередь. Если перед уничтожением элемента очередь оказывается пустой,
выводится  об ошибке.

@end itemize

@noindent
Поскольку очередь есть последовательность элементов, ее, разумеется,
можно было бы представить как обыкновенный список; головой очереди был
бы @code{car} этого списка, вставка элемента в очередь сводилась бы к
добавлению нового элемента в конец списка, а уничтожение элемента из
очереди состояло бы просто во взятии @code{cdr} списка. Однако такая
реализация неэффективна, поскольку для вставки элемента нам пришлось бы
просматривать весь список до конца. Поскольку единственный доступный нам
метод просмотра списка --- это последовательное применение @code{cdr},
такой просмотр требует @math{\Theta(n)} шагов для очереди с @code{n}
членами. Простое видоизменение спискового представления преодолевает
этот недостаток, позволяя нам реализовать операции с очередью так, чтобы
все они требовали @math{\Theta(1)} шагов; то есть, чтобы число шагов
алгоритма не зависело от длины очереди.

Сложность со списковым представлением возникает из-за необходимости
искать конец списка. Искать приходится потому, что, хотя стандартный
способ представления списка в виде цепочки пар дает нам указатель на
начало списка, легкодоступного указателя на конец он не дает.
Модификация, обходящая этот недостаток, состоит в том, чтобы
представлять очередь в виде списка, и держать еще дополнительный
указатель на его последнюю пару. В таком случае, когда требуется
вставить элемент, мы можем просто посмотреть на этот указатель и
избежать за счет этого просмотра всего списка.

Очередь, таким образом, представляется в виде пары указателей,
@code{front-ptr} и @code{rear-ptr}, которые обозначают, соответственно,
первую и последнюю пару обыкновенного списка. Поскольку нам хочется,
чтобы очередь была объектом с собственной индивидуальностью, соединить
эти два указателя можно с помощью @code{cons}, так что собственно
очередь будет результатом @code{cons} двух указателей. Такое
представление показано на рис. @ref{Рисунок 3.19}.

@float
@anchor{Рисунок 3.19}
@ifinfo
@quotation
@strong{Рисунок 3.19:} Implementation of a queue as a list with front and rear pointers.

@example
       +---+---+
  q -->| * | *-+-------------------+
       +-|-+---+                   |
         |                         |
         | front-ptr               | rear-ptr
         V                         V
     +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V
     +---+        +---+        +---+
     | a |        | b |        | c |
     +---+        +---+        +---+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.19b,69mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.19:} Implementation of a queue as a list with front and rear pointers.}
@center @caption{@strong{Рисунок 3.19:} Реализация очереди в виде списка с указателями на начало и конец.}
@sp 0.9
@end iftex
@end float

Во время определения операций над очередью мы пользуемся следующими
процедурами, которые позволяют нам читать и записывать указатели на
начало и конец очереди:

@lisp
(define (front-ptr queue) (car queue))
(define (rear-ptr  queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr!  queue item)
  (set-cdr! queue item))
@end lisp

@noindent
Теперь можно реализовать сами операции над очередью. Очередь будет
считаться пустой, если ее головной указатель указывает на пустой список:

@lisp
(define (empty-queue? queue)
  (null? (front-ptr queue)))
@end lisp

@noindent
Конструктор @code{make-queue} возвращает в качестве исходно пустой
очереди пару, в которой и @code{car}, и @code{cdr} являются пустыми
списками:

@lisp
(define (make-queue) (cons '() '()))
@end lisp

При обращении к элементу в голове очереди мы возвращаем @code{car} пары,
на которую указывает головной указатель:

@lisp
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
@end lisp

@float
@quotation
@anchor{Рисунок 3.20}
@ifinfo
@strong{Рисунок 3.20:} Result of using @code{(insert-queue! q 'd)} on the queue of @ref{Рисунок 3.19}.

@example
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         |                                      |
         | front-ptr                            | rear-ptr
         V                                      V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.20b,88mm,,,.pdf}
@sp 0.7
@comment @caption{@strong{Рисунок 3.20:} Result of using @code{(insert-queue! q 'd)} on the queue of @ref{Рисунок 3.19}.}
@caption{@strong{Рисунок 3.20:} Результат применения @code{(insert-queue! q 'd)} к очереди с рисунка @ref{Рисунок 3.19}}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Чтобы вставить элемент в конец очереди, мы используем метод, результат
которого показан на рисунке @ref{Рисунок 3.20}. Первым делом мы
создаем новую пару, @code{car} которой содержит вставляемый элемент, а
@code{cdr} --- пустой список. Если очередь была пуста, мы перенаправляем
на эту пару и головной, и хвостовой указатели. В противном случае, мы
изменяем последнюю пару очереди так, чтобы следующей была новая пара, и
хвостовой указатель тоже перенаправляем на нее же.

@lisp
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
@end lisp

@float
@quotation
@anchor{Рисунок 3.21}
@ifinfo
@strong{Рисунок 3.21:} Result of using @code{(delete-queue!  q)} on the queue of @ref{Рисунок 3.20}.

@example
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         +------------+                         |
            front-ptr |                         | rear-ptr
                      V                         V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.21b,88mm,,,.pdf}
@sp 0.6
@comment @caption{@strong{Рисунок 3.21:} Result of using @code{(delete-queue!  q)} on the queue of @ref{Рисунок 3.20}.}
@caption{@strong{Рисунок 3.21:}  Результат применения @code{(delete-queue!  q)} к очереди с рис. @ref{Рисунок 3.20}.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Чтобы уничтожить элемент в голове очереди, мы просто переставляем
головной указатель на второй элемент очереди, а его можно найти в
@code{cdr} первого элемента (см. @ref{Рисунок 3.21}):@footnote{В
случае, если первый элемент --- одновременно и последний, после его
уничтожения головной указатель окажется пустым списком, и это будет
означать, что очередь пуста; нам незачем заботиться о хвостовом
указателе, который по-прежнему будет указывать на уничтоженный элемент,
поскольку @code{empty-queue?} смотрит только на голову.}

@lisp
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else (set-front-ptr! queue (cdr (front-ptr queue)))
              queue)))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.21}Упражнение 3.21:}
Бен Битобор решает протестировать вышеописанную реализацию.
Он вводит процедуры в интерпретаторе Лиспа и тестирует их:

@lisp
(define q1 (make-queue))
(insert-queue! q1 'a)
@i{((a) a)}
(insert-queue! q1 'b)
@i{((a b) b)}
(delete-queue! q1)
@i{((b) b)}
(delete-queue! q1)
@i{(() b)}
@end lisp

<<Ничего не работает! --- жалуется он. --- Ответ интерпретатора
показывает, что последний элемент попадает в очередь два раза. А когда я
оба элемента уничтожаю, второе @code{b} по-прежнему там сидит, так что
очередь не становится пустой, хотя должна бы>>. Ева Лу Атор говорит, что
Бен просто не понимает, что происходит. <<Дело не в том, что элементы
два раза оказываются в очереди, --- объясняет она. --- Дело в том, что
стандартная лисповская печаталка не знает, как устроено представление
очереди. Если ты хочешь, чтобы очередь правильно печаталась, придется
написать специальную процедуру распечатки очередей>>. Объясните, что
имеет в виду Ева Лу. В частности, объясните, почему в примерах Бена на
печать выдается именно такой результат. Определите процедуру
@code{print-queue}, которая берет на входе очередь и выводит на печать
последовательность ее элементов.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.22}Упражнение 3.22:}
Вместо того, чтобы представлять очередь как пару
указателей, можно построить ее в виде процедуры с внутренним состоянием.
Это состояние будет включать указатели на начало и конец обыкновенного
списка. Таким образом, @code{make-queue} будет иметь вид

@lisp
(define (make-queue)
  (let ((front-ptr @dots{} )
        (rear-ptr @dots{} ))
    @math{\langle}@var{definitions of internal procedures}@math{\rangle}
    (define (dispatch m) @dots{})
    dispatch))
@end lisp

Закончите определение @code{make-queue} и реализуйте операции над
очередями с помощью этого представления.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.23}Упражнение 3.23:}
(@newterm{deque}), (double-ended queue, <<двусторонняя очередь>>)
представляет собой последовательность, элементы в которой могут
добавляться и уничтожаться как с головы, так и с хвоста. На деках
определены такие операции: конструктор @code{make-deque}, предикат
@code{empty-deque?}, селекторы @code{front-deque} и @code{rear-deque}, и
мутаторы @code{front-insert-deque!}, @code{rear-insert-deque!},
@code{front-delete-deque!} и @code{rear-delete-deque!}. Покажите, как
представить дек при помощи пар, и напишите реализацию
операций.@footnote{Осторожно, не заставьте ненароком интерпретатор
печатать циклическую структуру (см. упр. @ref{Упражнение 3.13}).}
Все операции должны выполняться за @math{\Theta(1)} шагов.
@end quotation

@comment @subsection Representing Tables
@subsection Представление таблиц
@node	3.3.3, 3.3.4, 3.3.2, 3.3

Когда в @ref{Глава 2} мы изучали различные способы представления множеств, то в
@ref{2.3.3} была упомянута задача поддержания таблицы с идентифицирующими ключами.
При реализации программирования, управляемого данными, в @ref{2.4.3},
активно использовались двумерные таблицы, в которых информация заносится
и ищется с использованием двух ключей. Теперь мы увидим, как такие
таблицы можно строить при помощи изменяемых списковых структур.

@float
@quotation
@anchor{Рисунок 3.22}
@ifinfo
@strong{Рисунок 3.22:} A table represented as a headed list.

@example
 +---+---+    +---+---+    +---+---+    +---+---+
 | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
 +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
   |            |            |            |
   V            V            V            V
+---------+   +---+---+   +---+---+   +---+---+
| *table* |   | * | * |   | * | * |   | * | * |
+---------+   +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                |   |       |   |       |   |
                V   V       V   V       V   V
             +---+ +---+ +---+ +---+ +---+ +---+
             | a | | 1 | | b | | 2 | | c | | 3 |
             +---+ +---+ +---+ +---+ +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.22c,81mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.22:} A table represented as a headed list.}
@center @caption{@strong{Рисунок 3.22:} Таблица, представленная в виде списка с заголовком.}
@sp 0.9
@end iftex
@end quotation
@end float

Сначала рассмотрим одномерную таблицу, где каждый элемент хранится под
отдельным ключом. Ее мы реализуем как список записей, каждая из которых
представляет собой пару, состоящую из ключа и связанного с ним значения.
Пары связаны вместе в список при помощи цепочки пар, в каждой из которых
@code{car} указывают на одну из записей. Эти связующие пары называются
(@newterm{backbone}) таблицы. Для того, чтобы у нас было место, которое мы будем
изменять при добавлении новой записи, таблицу мы строим как
(@newterm{headed list}). У такого списка есть в начале специальная хребтовая
пара, в которой хранится фиктивная <<запись>> --- в данном случае произвольно
выбранный символ @code{*table*}. На рисунке @ref{Рисунок 3.22}
изображена стрелочная диаграмма для таблицы

@lisp
a:  1
b:  2
c:  3
@end lisp

@noindent
Информацию из таблицы можно извлекать при помощи процедуры
@code{lookup}, которая получает ключ в качестве аргумента, а возвращает
связанное с ним значение (либо ложь, если в таблице с этим ключом
никакого значения не связано). @code{Lookup} определена при помощи
операции @code{assoc}, которая требует в виде аргументов ключ и список
записей. Обратите внимание, что @code{assoc} не видит фиктивной записи.
@code{Assoc} возвращает запись, которая содержит в @code{car} искомый
ключ.@footnote{Поскольку @code{assoc} пользуется @code{equal?}, в
качестве ключей она может распознавать символы, числа и списковые
структуры.} Затем @code{lookup} проверяет, что запись, возвращенная
@code{assoc}, не есть ложь, и возвращает значение (то есть @code{cdr})
записи.

@lisp
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
@end lisp

@noindent
Чтобы вставить в таблицу значение под данным ключом, сначала мы с
помощью @code{assoc} проверяем, нет ли уже в таблице записи с этим
ключом. Если нет, мы формируем новую запись, <<с@code{cons}ивая>> ключ
со значением, и вставляем ее в начало списка записей таблицы, после
фиктивной записи. Если же в таблице уже была запись с этим ключом, мы
переставляем @code{cdr} записи на указанное новое значение. Заголовок
таблицы используется как неподвижное место, которое мы можем изменять
при порождении новой записи.@footnote{Таким образом, первая хребтовая
пара является объектом, который представляет <<саму>> таблицу; то есть,
указатель на таблицу --- это указатель на эту пару. Таблица всегда
начинается с одной и той же хребтовой пары. Будь это устроено иначе,
пришлось бы возвращать из @code{insert!} новое начало таблицы в том
случае, когда создается новая запись.}

@lisp
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
@end lisp

@noindent
Для того, чтобы создать таблицу, мы просто порождаем список, содержащий
символ @code{*table*}:

@lisp
(define (make-table)
  (list '*table*))
@end lisp

@comment @subsubheading Two-dimensional tables
@subsubheading Двумерные таблицы

@noindent
В двумерной таблице каждое значение индексируется двумя ключами. Такую
таблицу мы можем построить как одномерную таблицу, в которой каждый ключ
определяет подтаблицу. На рисунке @ref{Рисунок 3.23} изображена
стрелочная диаграмма для таблицы

@example
math:    +:  43        letters:    a:  97
         -:  45                    b:  98
         *:  42
@end example

@noindent
содержащей две подтаблицы (подтаблицам не требуется специального
заголовочного символа, поскольку для этой цели служит ключ,
идентифицирующий подтаблицу).

Когда мы ищем в таблице элемент, сначала при помощи первого ключа мы
находим нужную подтаблицу. Затем при помощи второго ключа мы определяем
запись внутри подтаблицы.

@lisp
(define (lookup key-1 key-2 table)
  (let ((subtable
         (assoc key-1 (cdr table))))
    (if subtable
        (let ((record
               (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
@end lisp

@float
@c @quotation
@anchor{Рисунок 3.23}
@ifinfo
@strong{Рисунок 3.23:} A two-dimensional table.

@example
table
  |
  V
+---+---+   +---+---+   +---+---+
| * | *-+-->| * | *-+-->| * | / |
+-|-+---+   +-|-+---+   +-|-+---+
  V           |           V
+-------+     |         +---+---+   +---+---+   +---+---+
|*table*|     |         | * | *-+-->| * | *-+-->| * | / |
+-------+     |         +-|-+---+   +-|-+---+   +-|-+---+
              |           V           V           V
              |       +-------+     +---+---+   +---+---+
              |       |letters|     | * | * |   | * | * |
              |       +-------+     +-|-+-|-+   +-|-+-|-+
              |                       V   V       V   V
              |                    +---+ +---+ +---+ +---+
              |                    | a | | 97| | b | | 98|
              |                    +---+ +---+ +---+ +---+
              V
            +---+---+   +---+---+   +---+---+   +---+---+
            | * | *-+-->| * | *-+-->| * | *-+-->| * | / |
            +-|-+---+   +-|-+---+   +-|-+---+   +-|-+---+
              V           V           V           V
          +------+      +---+---+   +---+---+   +---+---+
          | math |      | * | * |   | * | * |   | * | * |
          +------+      +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                          V   V       V   V       V   V
                       +---+ +---+ +---+ +---+ +---+ +---+
                       | + | | 43| | - | | 45| | * | | 42|
                       +---+ +---+ +---+ +---+ +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.23a,103mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.23:} A two-dimensional table.}
@center @caption{@strong{Рисунок 3.23:} Двумерная таблица.}
@sp 0.9
@end iftex
@c @end quotation
@end float

Чтобы вставить в таблицу новый элемент под двумя ключами, мы при помощи
@code{assoc} проверяем, соответствует ли какая-нибудь подтаблица первому
ключу. Если нет, строим новую подтаблицу, содержащую единственную запись
(@code{key-2}, @code{value}), и заносим ее в таблицу под первым ключом.
Если для первого ключа уже существует подтаблица, мы вставляем новую
запись в эту подтаблицу, используя вышеописанный метод вставки для
одномерных таблиц:

@lisp
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
@end lisp

@comment @subsubheading Creating local tables
@subsubheading Создание локальных таблиц

Операции @code{lookup} и @code{insert!}, которые мы определили,
принимают таблицу в качестве аргумента. Это позволяет писать программы,
которые обращаются более, чем к одной таблице. Другой способ работы с
множественными таблицами заключается в том, чтобы иметь для каждой из
них свои отдельные процедуры @code{lookup} и @code{insert!}. Мы можем
этого добиться, представив таблицу в процедурном виде, как объект,
который поддерживает внутреннюю таблицу как часть своего локального
состояния. Когда ему посылают соответствующее сообщение, этот
<<табличный объект>> выдает процедуру, с помощью которой можно работать
с его внутренним состоянием. Вот генератор двумерных таблиц,
представленных таким способом:

@lisp
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))
@end lisp

@noindent
Использование @code{make-table} позволяет нам реализовать операции @code{get}
и @code{put} из @ref{2.4.3}, так:

@lisp
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
@end lisp

@noindent
@code{get} в качестве аргументов берет два ключа, а @code{put} два ключа
и значение. Обе операции обращаются к одной и той же локальной таблице,
которая инкапсулируется в объекте, созданном посредством вызова
@code{make-table}.

@quotation
@strong{@anchor{Упражнение 3.24}Упражнение 3.24:}
В реализациях таблиц в этом разделе ключи всегда
проверяются на равенство с помощью @code{equal?} (который, в свою
очередь, зовется из @code{assoc}). Это не всегда то, что нужно.
Например, можно представить себе таблицу с числовыми ключами, где не
требуется точного совпадения с числом, которое мы ищем, а нужно только
совпадение с определенной допустимой ошибкой. Постройте конструктор
таблиц @code{make-table}, который в качестве аргумента принимает
процедуру @code{same-key?} для проверки равенства ключей.
@code{make-table} должна возвращать процедуру @code{dispatch}. через
которую можно добраться до процедур @code{lookup} и @code{insert!}
локальной таблицы.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.25}Упражнение 3.25:}
Обобщая случаи одно- и двумерных таблиц, покажите, как
можно реализовать таблицу, в которой элементы хранятся с произвольным
количеством ключей и различные значения могут храниться с различным
количеством ключей. Процедуры @code{lookup} и @code{insert!} должны
принимать на входе список ключей, с которыми требуется обратиться к
таблице.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.26}Упражнение 3.26:}
При поиске в таблице, как она реализована выше, приходится
просматривать список записей. В сущности, это представление с
неупорядоченным списком из @ref{2.3.3}.
Для больших таблиц может оказаться эффективнее организовать таблицу
иначе. Опишите реализацию таблицы, в которой записи (ключ, значение)
организованы в виде бинарного дерева, в предположении, что ключи можно
каким-то образом упорядочить (например, численно или по алфавиту). (Ср.
с упражнением @ref{Упражнение 2.66} из @ref{Глава 2}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.27}Упражнение 3.27:}
(@newterm{memoization}) (называемая также (@newterm{tabulation)}) --- прием,
который позволяет процедуре записывать в локальной таблице единожды
вычисленные значения. Такой прием может сильно повысить
производительность программы. Мемоизированная процедура поддерживает
таблицу, где сохраняются результаты предыдущих вызовов, а в качестве
ключей используются аргументы, относительно которых эти результаты были
получены. Когда от мемоизированной процедуры требуют вычислить значение,
сначала она проверят в таблице, нет ли там уже нужного значения, и если
да, то она просто возвращает это значение. Если нет, то она вычисляет
значение обычным способом и заносит его в таблицу. В качестве примера
мемоизации, вспомним экспоненциальный процесс вычисления чисел Фибоначчи
из @ref{1.2.2}:

@lisp
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
@end lisp

Мемоизированная версия той же самой процедуры выглядит так:

@lisp
(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))
@end lisp

@noindent
а процедура @code{memoize} определяется так:

@lisp
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
@end lisp

Нарисуйте диаграмму окружений, анализирующую вычисление
@code{(memo-fib 3)}. Объясните, почему @code{memo-fib} вычисляет
@math{n}-е число Фибоначчи за число шагов, пропорциональное @math{n}.
Стала бы схема работать, если бы мы определили @code{memo-fib} просто
как @code{(memoize fib)}?
@end quotation

@comment @subsection A Simulator for Digital Circuits
@subsection Имитация цифровых схем
@node	3.3.4, 3.3.5, 3.3.3, 3.3

Проектирование сложных цифровых систем, таких, как компьютеры, является
важной отраслью инженерной деятельности. Цифровые системы строятся путем
соединения простых элементов. Хотя поведение этих составляющих элементов
примитивно, сети, из них собранные, могут обладать весьма сложным
поведением. Компьютерная имитация проектируемых электронных схем служит
важным инструментом для инженеров-специалистов по цифровым системам. В
этом разделе мы спроектируем систему для имитационного моделирования
цифровых схем. Система эта будет служить примером программ особого вида,
называемых (@newterm{event-driven simulation}), в которых действия (<<события>>)
вызывают другие события, которые происходят спустя некоторое время и при
этом в свою очередь вызывают события, и так далее.

Наша вычислительная модель цифровой схемы будет состоять из объектов,
соответствующих элементарным компонентам, из которых строится схема.
Имеются (@newterm{wires}), несущие (@newterm{digital signals}). В каждый данный момент
цифровой сигнал может иметь только одно из двух возможных значений, 0
или 1. Кроме того, имеются различные виды (@newterm{function boxes}), которые
соединяют провода, несущие входные сигналы, с выходными проводами. Такие
элементы порождают выходные сигналы, вычисляя их на основе входных
сигналов. Выходной сигнал задерживается на время, зависящее от типа
функционального элемента. Например, (@newterm{inverter}) --- элементарный
функциональный элемент, который обращает свой входной сигнал. Если
входной сигнал инвертора становится 0, то на одну инверторную задержку
позже сигнал на выходе станет равен 1. Если входной сигнал станет 1, то
на инверторную задержку позже на выходе появится 0. Инвертор
символически изображен на @ref{Рисунок 3.24}. (@newterm{and-gate}), также
показанный на @ref{Рисунок 3.24}, имеет два входа и один выход.
Он обеспечивает на выходе сигнал, равный (@newterm{logical and}) от входов. Это
означает, что если оба входных сигнала становятся равными 1, то одну
И-задержку спустя И-элемент заставит свой выходной сигнал стать 1; в
противном случае на выходе будет 0.
(or-gate) представляет собой подобный же элементарный функциональный
элемент, который обеспечивает на выходе сигнал, равный (logical or)
своих входов. А именно, выходной сигнал станет равен 1, если хотя бы
один из входных сигналов окажется 1; в противном случае на выходе будет
0.

@float
@quotation
@anchor{Рисунок 3.24}
@ifinfo
@strong{Рисунок 3.24:} Primitive functions in the digital logic simulator.

@example
               __          ___
  |\        --|  \       --\  \
--| >o--      |   )--       )  >--
  |/        --|__/       --/__/

инвертор   И-элемент    ИЛИ-элемент
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap3/Fig3.24b,74mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 3.24:} Primitive functions in the digital logic simulator. }@short
@center @caption{@strong{Рисунок 3.24:} Элементарные функциональные элементы в имитаторе цифровых схем.}
@sp 0.7
@end iftex
@end quotation
@end float

Соединяя элементарные функции, можно получать более сложные. Для этого
надо подсоединять выходы одних функциональных элементов ко входам
других. Например, схема (@newterm{half-adder}) на рис. @ref{Рисунок 3.25}
состоит из ИЛИ-элемента, двух И-элементов и инвертора. Полусумматор
получает два входа, A и B, и имеет два выхода, S и C. S становится 1,
когда ровно один из сигналов A и B равен 1, а C тогда, когда и A, и B
равны 1. Из схемы можно видеть, что по причине задержек выходные сигналы
могут генерироваться в разное время. Отсюда происходят многие сложности
в проектировании цифровых схем.

@float
@quotation
@anchor{Рисунок 3.25}
@ifinfo
@strong{Рисунок 3.25:} A half-adder circuit.

@example
    +--------------------------------------+
    |         ____                         |
A --------*---\   \ D               ___    |
    |     |    >   >---------------|   \   |
    |  +--|---/___/                |    )----- S
    |  |  |              |\  E  +--|___/   |
    |  |  |           +--| >o---+          |
    |  |  |    ___    |  |/                |
    |  |  +---|   \   |                    |
    |  |      |    )--*----------------------- C
B -----*------|___/                        |
    |                                      |
    +--------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.25c,72mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.25:} A half-adder circuit.}
@center @caption{@strong{Рисунок 3.25:} Полусумматор.}
@sp 1.2
@end iftex
@end quotation
@end float

Теперь мы построим программу для имитации цифровых логических схем,
которые мы хотим изучать. Программа будет строить вычислительные
объекты, моделирующие провода, которые <<содержат>> сигналы.
Функциональные элементы будут моделироваться процедурами, которые
обеспечивают нужное отношение между сигналами.

Одним из базовых элементов нашей имитации будет процедура
@code{make-wire}, которая порождает провода. Например, мы можем создать
шесть проводов так:

@lisp
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
@end lisp

@noindent
Мы подсоединяем функциональный элемент к проводу во время вызова
процедуры, которая создает данный вид элемента. Аргументами порождающей
процедуры служат провода, подсоединяемые к элементу. Например, если мы
умеем создавать И-элементы, ИЛИ-элементы и инверторы, мы можем собрать
полусумматор, изображенный на рисунке @ref{Рисунок 3.25}:

@lisp
(or-gate a b d)
@i{ok}
(and-gate a b c)
@i{ok}
(inverter c e)
@i{ok}
(and-gate d e s)
@i{ok}
@end lisp

@noindent
Даже лучше того, можно присвоить этой операции имя, определив процедуру
@code{half-adder}, конструирующую схему, используя четыре внешних
провода, которые нужно подсоединить к полусумматору:

@lisp
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
@end lisp

@noindent
Преимущество этого определения в том, что теперь мы можем использовать
@code{half-adder} как строительный блок при создании более сложных схем.
Например, на рисунке @ref{Рисунок 3.26} изображен (@newterm{full-adder}),
состоящий из двух полусумматоров и ИЛИ-элемента.@footnote{Сумматор ---
основной элемент схем, используемых для сложения двоичных чисел. Здесь A
и B --- биты на соответствующих позициях двух складываемых чисел, а
@math{\rm C_{in}} --- бит переноса из позиции на одну правее. Схема
генерирует SUM, бит суммы для соответствующей позиции, и
@math{\rm C_{out}}, бит переноса для распространения налево.}
Сумматор можно сконструировать так:

@lisp
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
@end lisp

@float
@quotation
@anchor{Рисунок 3.26}
@ifinfo
@strong{Рисунок 3.26:} A full-adder circuit.

@example
    +----------------------------------+
    |              +-------+           |
A -----------------+ half- +-------------- SUM
    |  +-------+   | adder |   ____    |
B -----+ half- +---+       +---\   \   |
    |  | adder |   +-------+    >or >----- Cout
C -----+       +---------------/___/   |
    |  +-------+                       |
    +----------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.26a,74mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.26:} A full-adder circuit.}
@center @caption{@strong{Рисунок 3.26:} Сумматор.}
@sp 1.2
@end iftex
@end quotation
@end float

@noindent
Определив @code{full-adder} как процедуру, мы можем ее использовать как
строительный блок для еще более сложных схем. (См., например,
упражнение @ref{Упражнение 3.30}.)

В сущности, наша имитация дает инструмент, с помощью которого строится
язык описания схем. Принимая общую точку зрения на языки, с которой мы
приступили к изучению Лиспа в @ref{1.1},
можно сказать, что элементарные функциональные элементы являются
примитивами языка, связывание их проводами представляет собой средство
комбинирования, а определение шаблонных схем в виде процедур служит
средством абстракции.

@comment @subsubheading Primitive function boxes
@subsubheading Элементарные функциональные элементы.

Элементарные функциональные элементы изображают <<силы>>, через
посредство которых изменение сигнала в одном проводе влечет изменение
сигнала в других проводах. Для построения функциональных элементов мы
будем пользоваться следующими операциями над проводами:

@itemize @bullet

@item @code{(get-signal @math{\langle}@var{провод}@math{\rangle})} возвращает текущее значение
сигнала в проводе.

@item @code{(set-signal!}@math{\;\;\langle\kern0.08em\hbox{\ttfamily\slshape провод}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape новое-значение}\kern0.08em\rangle}@code{)}
@noindentyy
заменяет значение сигнала в проводе на указанное.

@item @code{(add-action! @math{\langle}@var{провод}@math{\rangle} @math{\langle}@var{процедура без аргументов}@math{\rangle})}
@noindent
указывает, чтобы процедура-аргумент вызывалась каждый раз, когда
сигнальный провод изменяет значение. Такие процедуры служат передаточным
механизмом, с помощью которого изменение значения сигнала в одном
проводе передается другим проводам.

@end itemize

@noindent
В дополнение, мы будем пользоваться процедурой @code{after-delay}, которая
принимает значение задержки и процедуру. Она выполняет процедуру после истечения задержки.

При помощи этих процедур можно определить элементарные функции цифровой
логики. Чтобы соединить вход с выходом через инвертор, мы используем
@code{add-action!} и ассоциируем со входным проводом процедуру, которая
будет вызываться всякий раз, когда сигнал на входе элемента изменит
значение. Процедура вычисляет @code{logical-not} (логическое отрицание)
входного сигнала, а затем, переждав @code{inverter-delay}, устанавливает
выходной сигнал в новое значение:

@lisp
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input) 'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
@end lisp

@noindent
И-элемент устроен немного сложнее. Процедура-действие должна вызываться,
когда меняется любое из значений на входе. Она при этом через процедуру,
подобную @code{logical-not}, вычисляет @code{logical-and} (логическое И)
значений сигналов на входных проводах, и затем требует, чтобы изменение
значения выходного провода произошло спустя задержку длиной в
@code{and-gate-delay}.

@lisp
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay
       and-gate-delay
       (lambda () (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
@end lisp

@quotation
@strong{@anchor{Упражнение 3.28}Упражнение 3.28:}
Определите ИЛИ-элемент как элементарный функциональный
блок. Ваш конструктор @code{or-gate} должен быть подобен
@code{and-gate}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.29}Упражнение 3.29:}
Еще один способ создать ИЛИ-элемент --- это собрать его как
составной блок из И-элементов и инверторов. Определите процедуру
@code{or-gate}, которая это осуществляет. Как время задержки
ИЛИ-элемента выражается через @code{and-gate-delay} и
@code{inverter-delay}?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.30}Упражнение 3.30:}
На рисунке @ref{Упражнение 3.27} изображен (ripple-carry
adder), полученный выстраиванием в ряд @math{n} сумматоров. Это
простейшая форма параллельного сумматора для сложения двух
@math{n}-битных двоичных чисел. На входе мы имеем 
@math{A_1}, @math{A_2}, @math{A_3}, @dots{}, @math{A_n} и
@math{B_1}, @math{B_2}, @math{B_3}, @dots{}, @math{B_n} --- два двоичных
числа, подлежащих сложению (каждый из @math{A_k} и @math{B_n} имеет значение
либо 0, либо 1). Схема порождает
@math{S_1}, @math{S_2}, @math{S_3}, @dots{}, @math{S_n} --- первые @math{n} бит суммы, и @math{C} -- бит
переноса после суммы. Напишите процедуру @code{riple-carry-adder},
которая бы моделировала эту схему. Процедура должна в качестве
аргументов принимать три списка по @math{n} проводов в каждом
(@math{A_k}, @math{B_k} и @math{S_k}), а также дополнительный провод @math{C}.
Главный недостаток каскадных сумматоров в том, что приходится ждать, пока
сигнал распространится. Какова задержка, требуемая для получения полного
вывода @math{n}-битного каскадного сумматора, выраженная в зависимости от
задержек И-, ИЛИ-элементов и инверторов?
@end quotation

@float
@quotation
@anchor{Рисунок 3.27}
@ifinfo
@strong{Рисунок 3.27:} A ripple-carry adder for @math{n}-bit numbers.

@example
   :                                              :   :
   : A_1 B_1   C_1   A_2 B_2   C_2   A_3 B_3   C_3:   : A_n B_n C_n=0
   :  |   |   +---+   |   |   +---+   |   |   +-----  :  |   |   +-
   |  |   |   |   |   |   |   |   |   |   |   |   :   :  |   |   |
   : ++---+---++  |  ++---+---++  |  ++---+---++  :   : ++---+---++
   : |   FA    |  |  |   FA    |  |  |   FA    |  :   : |   FA    |
   : +--+---+--+  |  +--+---+--+  |  +--+---+--+  :   : +--+---+--+
   :    |   |     |     |   |     |     |   |     :   :    |   |
C ------+   |     +-----+   |     +-----+   |     :  ------+   |
   :        |       C_1     |       C_2     |     :   :C_(n-1) |
   :        |               |               |     :   :        |
           S_1             S_2             S_3                S_n
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.27a,96mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 3.27:} A ripple-carry adder for @math{n}-bit numbers.}
@center @caption{@strong{Рисунок 3.27:} Каскадный сумматор для @math{n}-битных чисел.}
@sp 0.3
@end iftex
@end quotation
@end float

@comment @subsubheading Representing wires
@subsubheading Представление проводов

Провод в нашей имитации будет вычислительным объектом с двумя
внутренними переменными состояния: значение сигнала @code{signal-value}
(вначале равное 0) и набор процедур-действий @code{action-procedures},
подлежащих исполнению, когда сигнал изменяется. Мы реализуем провод в
стиле с передачей сообщений, как набор локальных процедур плюс процедура
диспетчеризации, которая выбирает требуемую внутреннюю операцию. Точно
так же мы строили объект-банковский счет в @ref{3.1.1}.

@lisp
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation: WIRE" m))))
    dispatch))
@end lisp

@noindent
Внутренняя процедура @code{set-my-signal!} проверяет, отличается ли
новое значение сигнала в проводе от старого. Если да, то она запускает
все процедуры-действия при помощи процедуры @code{call-each}, которая по
очереди вызывает элементы списка безаргументных процедур:

@lisp
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))
@end lisp

@noindent
Внутренняя процедура @code{accept-action-procedure!} добавляет
процедуру-аргумент к списку действий, а затем один раз запускает новую
процедуру. (См. упражнение @ref{Упражнение 3.31}.)

Располагая вышеописанной процедурой @code{dispatch}, мы можем написать
следующие процедуры для доступа к внутренним операциям над
проводами:@footnote{@anchor{Сноска 27} Эти процедуры --- всего лишь
синтаксический сахар, который позволяет нам работать с внутренними
процедурами объектов, используя обычный синтаксис процедурного вызова.
Поразительно, что мы так просто можем менять местами роли процедур и
данных. Например, когда мы пишем @code{(wire 'get-signal)}, мы
представляем себе провод @code{wire} как процедуру, вызываемую с
сообщением @code{get-signal} на входе. С другой стороны, запись
@code{(get-signal wire)} поощряет нас думать о @code{wire} как об
объекте данных, который поступает на вход процедуре @code{get-signal}.
Истина состоит в том, что в языке, где с процедурами можно работать как
с объектами, никакого фундаментального различия между <<процедурами>> и
<<данными>> не существует, и мы имеем право выбирать такой
синтаксический сахар, который позволит программировать в удобном для нас
стиле.}

@lisp
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
@end lisp

@noindent
Провода, которые содержат меняющиеся со временем сигналы и могут
подсоединяться к одному объекту за другим, --- типичный образец
изменяющихся объектов. Мы смоделировали их в виде процедур с внутренними
переменными состояния, которые изменяются присваиванием. При создании
нового провода создается новый набор переменных состояния (в выражении
@code{let} внутри @code{make-wire}), а также порождается и возвращается
новая процедура @code{dispatch}, которая захватывает окружение с новыми
переменными состояния.

Провода разделяются между различными устройствами, к ним
подсоединенными. Таким образом, изменение, произведенное при
взаимодействии с одним устройством, скажется на всех других устройствах,
связанных с этим проводом. Провод передает изменение своим соседям,
вызывая процедуры-действия, зарегистрированные в нем в момент
установления соединения.

@comment @subsubheading The agenda
@subsubheading План действий

Теперь для завершения модели нам остается только написать
@code{after-delay}. Здесь идея состоит в том, чтобы организовать
структуру данных под названием (@newterm{agenda}), где будет храниться
расписание того, что нам надо сделать. Для планов действий определены следующие
операции:

@itemize @bullet

@item
@code{(make-agenda)} возвращает новый пустой план действий.

@item
@code{(empty-agenda? @math{\langle}@var{план-действий}@math{\rangle})} истинно, если план
пуст.

@item
@code{(first-agenda-item @math{\langle}@var{план-действий}@math{\rangle})} возвращает первый
элемент плана.

@code{(remove-first-agenda-item! @math{\langle}@var{план-действий}@math{\rangle})}
модифицирует план, убирая из него первый элемент.

@item
@code{(add-to-agenda! @math{\langle}@var{время}@math{\rangle} @math{\langle}@var{действие}@math{\rangle} @math{\langle}@var{план-действий}@math{\rangle})}
модифицирует план, добавляя указанную процедуру-действие, которую нужно
запустить в указанное время.

@item
@code{(current-time @math{\langle}@var{план-действий}@math{\rangle})}
возвращает текущее время модели.

@end itemize

@noindent
Экземпляр плана, которым мы будем пользоваться, будет обозначаться
@code{the-agenda}. Процедура @code{after-delay} добавляет новый элемент
в план @code{the-agenda}:

@lisp
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
@end lisp

@noindent
Имитация управляется процедурой @code{propagate}, которая работает с
@code{the-agenda}, по очереди выполняя процедуры, содержащиеся в плане.
В общем случае, при работе модели в план добавляются новые элементы, а
@code{propagate} продолжает работу, пока план не становится пустым:

@lisp
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
@end lisp

@comment @subsubheading A sample simulation
@subsubheading Пример работы модели

Следующая процедура, которая навешивает на провод <<тестер>>, показывает
имитационную модель в действии. Тестер говорит проводу, что, каждый раз,
когда сигнал изменяет значение, нужно напечатать новое значение сигнала,
а также текущее время и имя провода:

@lisp
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name) (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
@end lisp

@noindent
Сначала мы инициализируем план действий и указываем задержки для
элементарных функциональных элементов:

@lisp
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
@end lisp

@noindent
Затем мы создаем четыре провода и к двум из них подсоединяем тестеры:

@lisp
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
@i{sum 0  New-value = 0}

(probe 'carry carry)
@i{carry 0  New-value = 0}
@end lisp

@noindent
Затем мы связываем провода, образуя схему полусумматора (как на рис.
@ref{Рисунок 3.25}), устанавливаем сигнал на входе @code{input-1} в 1,
и запускаем модель:

@lisp
(half-adder input-1 input-2 sum carry)
@i{ok}
@end lisp

@lisp
(set-signal! input-1 1)
@i{done}
@end lisp

@lisp
(propagate)
@i{sum 8  New-value = 1}
@i{done}
@end lisp

@noindent
Сигнал @code{sum} становится 1 в момент времени 8. Мы находимся в 8
единицах от начала работы модели. В этот момент мы можем установить
сигнал на входе @code{input-2} в 1 и дать изменению распространиться:

@lisp
(set-signal! input-2 1)
@i{done}
@end lisp

@lisp
(propagate)
@i{carry 11  New-value = 1}
@i{sum 16  New-value = 0}
@i{done}
@end lisp

@noindent
Сигнал @code{carry} становится равным 1 в момент 11, а @code{sum}
становится 0 в момент 16.

@quotation
@strong{@anchor{Упражнение 3.31}Упражнение 3.31:}
Внутренняя процедура @code{accept-action-procedure!},
определенная в @code{make-wire}, требует, чтобы в момент, когда
процедура-действие добавляется к проводу, она немедленно исполнялась.
Объясните, зачем требуется такая инициализация. В частности, проследите
работу процедуры @code{half-adder} из этого текста и скажите, как
отличалась бы реакция системы, если бы @code{accept-action-procedure!}
была определена как

@lisp
(define (accept-action-procedure! proc)
  (set! action-procedures
        (cons proc action-procedures)))
@end lisp
@end quotation

@comment @subsubheading Implementing the agenda
@subsubheading Реализация плана действий

Наконец, мы описываем детали структуры данных плана действий, которая
хранит процедуры, предназначенные для исполнения в будущем.

План состоит из (@newterm{time segments}). Каждый временной отрезок является
парой, состоящей из числа (значения времени) и очереди
(см. @ref{Упражнение 3.32}), которая содержит процедуры,
предназначенные к исполнению в этот временной отрезок.

@lisp
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
@end lisp

@noindent
Мы будем работать с очередями временных отрезков при помощи операций,
описанных в @ref{3.3.2}.

Сам по себе план действий является одномерной таблицей временных
отрезков. От таблиц, описанных в @ref{3.3.3}, он отличается тем, что
сегменты отсортированы в порядке возрастания времени. В дополнение к
этому мы храним (@newterm{current time}) (т. е. время последнего исполненного
действия) в голове плана. Свежесозданный план не содержит временных
отрезков, а его текущее время равно 0:@footnote{Подобно таблицам из
@ref{3.3.3}, план действий --- это список
с заголовком, но, поскольку в заголовке хранится время, не нужно
дополнительного заголовка-пустышки (вроде символа @code{table*}, которым
мы пользовались в таблицах).}

@lisp
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
@end lisp

@noindent
План пуст, если в нем нет ни одного временного отрезка:

@lisp
(define (empty-agenda? agenda)
  (null? (segments agenda)))
@end lisp

@noindent
Для того, чтобы добавить в план новое действие, прежде всего мы
проверяем, не пуст ли он. Если пуст, мы создаем для действия новый
отрезок и вставляем его в план. Иначе мы просматриваем план, глядя на
времена отрезков. Если мы находим отрезок с назначенным временем, мы
добавляем действие к соответствующей очереди. Если же мы обнаруживаем
время, большее, чем назначенное, мы вставляем новый отрезок перед
текущим. Если мы доходим до конца плана, мы вставляем новый отрезок в
конец.

@lisp
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
@end lisp

@noindent
Процедура, которая убирает из плана первый элемент, уничтожает элемент в
начале очереди первого отрезка времени. Если в результате отрезок
становится пустым, мы изымаем его из списка отрезков:@footnote{Обратите
внимание, что в этой процедуре выражение @code{if} не имеет
@math{\langle}@var{альтернативы}@math{\kern0.08em\rangle}. Такие <<односторонние
предложения @code{if}>> используются, когда требуется решить, нужно ли
какое-то действие, а не выбрать одно из двух выражений. Если предикат
ложен, а @math{\langle}@var{альтернатива}@math{\kern0.08em\rangle} отсутствует,
значение предложения @code{if} не определено.}

@lisp
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
@end lisp

@noindent
Первый элемент плана находится в начале очереди в первом временном
отрезке. Каждый раз, когда мы обращаемся к такому элементу, мы обновляем
текущее время.@footnote{Таким образом, текущее время всегда будет
совпадать с временем последнего обработанного действия. Благодаря тому,
что это время хранится в голове плана, оно всегда доступно, даже если
соответствующий отрезок времени был уничтожен.}

@lisp
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty: FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda
                           (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.32}Упражнение 3.32:}
Процедуры, предназначенные к выполнению в каждом временном
отрезке, хранятся в виде очереди. Таким образом, процедуры для каждого
отрезка вызываются в том же порядке, в котором они были добавлены к
плану (первый пришел, первый ушел). Объясните, почему требуется
использовать именно такой порядок. В частности, проследите поведение
И-элемента, входы которого меняются с 0 на 1 и с 1 на 0 одновременно и
скажите, как отличалось бы поведение, если бы мы хранили процедуры
отрезка в обыкновенном списке, добавляя и убирая их только с головы
(последний пришел, первый ушел).
@end quotation

@comment @subsection Propagation of Constraints
@subsection Распространение ограничений
@node	3.3.5,  , 3.3.4, 3.3

Традиционно компьютерные программы организованы как однонаправленные
вычисления, выполняющие вычисления над указанными аргументами и
получающие указанные значения. С другой стороны, часто системы
приходится моделировать в виде отношений между величинами. Например,
математическая модель механической структуры может включать информацию,
что деформация @math{d} металлического стержня связана уравнением
@math{dAE = FL} с приложенной к нему силой @math{F}, его длиной
@math{L}, поперечным сечением @math{A} и модулем упругости @math{E}.
Такое уравнение не является однонаправленным. Имея любые четыре
величины, мы можем вычислить пятую. Однако при переводе уравнения на
традиционный компьютерный язык нам придется выбрать величину, которая
вычисляется на основе остальных четырех, так что процедура для
вычисления площади @math{A} не может быть использована для вычисления
деформации @math{d}, хотя вычисление @math{A} и @math{d} основаны на
одном и том же уравнении.@footnote{Распространение ограничений появилось
в системе SKETCHPAD Айвена Сазерленда (Sutherland 1963), невероятно
опередившей свое время. Изящная система распространения ограничений,
основанная на языке Smalltalk, была разработана Аланом Борнингом
(Borning 1977) в исследовательском центре компании Xerox в Пало Альто.
Сассман, Столлман и Стил применили распространение ограничений к анализу
электрических цепей (Sussman and Stallman 1975; Sussman and Steele
1980). TK!Solver (Konopasek and Jayaraman 1984) представляет собой
богатую среду моделирования, основанную на ограничениях.}

В этом разделе мы набросаем эскиз языка, который позволит нам работать в
терминах самих отношений. Минимальными составляющими этого языка будут
служить (@newterm{primitive constraints}), которые говорят, что между величинами
существуют определенные связи. Например, @code{(adder a b c)} означает,
что величины @math{a}, @math{b} и @math{c} должны быть связаны
уравнением @math{a + b = c}, @code{(multiplier x y z)} выражает
ограничение @math{xy =
z}, а @code{(constant 3.14 x)} говорит, что значение @math{x} обязано
равняться 3.14.

Наш язык предоставляет средства комбинирования элементарных ограничений,
чтобы с их помощью выражать более сложные отношения. Сочетания образуют
(@newterm{constraint networks}), в которых ограничения связаны (@newterm{connectors}).
Соединитель --- это объект, который <<содержит>> значение, способное
участвовать в одном или нескольких ограничениях. К примеру, мы знаем,
что связь между температурами по Цельсию и по Фаренгейту выглядит как
@math{9 C = 5 (F - 32)} Такое ограничение можно изобразить в виде сети,
состоящей из элементарных ограничений --- сумматора, умножителей и
констант (рисунок @ref{Рисунок 3.28}). На этом рисунке слева мы видим
блок умножителя с тремя выводами, обозначенными @math{m1}, @math{m2} и
@math{p}. Вывод @math{m1} присоединен к соединителю @math{C}, который
будет хранить температуру по Цельсию. Вывод @math{m2} присоединен к
соединителю @math{w}, который, кроме того, связан с блоком-константой,
содержащим 9. Вывод @math{p}, про который блок-умножитель говорит, что
он должен быть произведением @math{m1} и @math{m2}, связан с выводом
@math{p} другого блока-умножителя, чей вывод @math{m2} связан с
константой 5, а @math{m1} присоединен к одному из слагаемых суммы.

@float
@anchor{Рисунок 3.28}
@ifinfo
@quotation
@strong{Рисунок 3.28:} The relation @math{9C = 5(F - 32)} expressed as a constraint network.

@example
       +---------+     +---------+   v   +---------+
C -----+ m1      |  u  |      m1 +-------+ a1      |
       |    *  p +-----+ p  *    |       |    *  s +---- F
    +--+ m2      |     |      m2 +--+ +--+ a2      |
    |  +---------+     +---------+  | |  +---------+
  w |                              x| |y
    |    +-----+        +-----+     | |     +-----+
    +----+  9  |        |  5  +-----+ +-----+  32 |
         +-----+        +-----+             +-----+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.28,87mm,,,.pdf}
@sp 0.4
@comment @center @caption{@strong{Рисунок 3.28:} The relation @math{9C = 5(F - 32)} expressed as a constraint network.}
@center @caption{@strong{Рисунок 3.28:} Уравнение @math{9C = 5(F - 32)}, выраженное в виде сети ограничений.}
@sp 0.7
@end iftex
@end float

Вычисления в такой сети происходят следующим образом: когда соединителю
дается значение (пользователем либо блоком-ограничением, с которым он
связан), соединитель пробуждает все связанные с ним ограничения (кроме
того, которое само его пробудило), и сообщает им, что у него появилось
значение. Каждый пробужденный блок-ограничение опрашивает свои выводы,
чтобы определить, достаточно ли у него информации, чтобы найти значение
для какого-нибудь еще соединителя. Если да, блок присваивает соединителю
значение, и тогда уже он пробуждает связанные с ним ограничения, и так
далее. Например, при преобразовании между градусами Цельсия и
Фаренгейта, значения @math{w}, @math{x} и @math{y} сразу устанавливаются
блоками-константами соответственно в 9, 5 и 32. Соединители пробуждают
умножители и сумматор, которые убеждаются, что у них не хватает
информации, чтобы продолжить. Если пользователь (или какая-то другая
часть сети) установит значение @math{C} в 25, пробудится левый
умножитель, и сделает @math{u} равным @math{25 \cdot 9 = 225}. Затем
@math{u} разбудит второй умножитель, который присвоит @math{v} значение
45, а @math{v} разбудит сумматор, и тот сделает значение @math{F} равным
77.

@comment @subsubheading Using the constraint system
@subsubheading Использование системы ограничений

Чтобы при помощи системы ограничений провести вышеописанное вычисление,
сначала мы порождаем два соединителя, @code{C} и @code{F}, вызовами
конструктора @code{make-connector}, и связываем @code{C} и @code{F} в
требуемую нам сеть:

@lisp
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
@i{ok}
@end lisp

@noindent
Процедура, создающая сеть, определяется так:

@lisp
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
@end lisp

@noindent
Эта процедура порождает внутренние соединители @code{u}, @code{v},
@code{w}, @code{x} и @code{y}, а затем связывает их, как показано на
рис. @ref{Рисунок 3.28}, при помощи элементарных ограничений
@code{adder}, @code{multiplier} и @code{constant}. Как и при
моделировании цифровых схем в @ref{3.3.4}, способность
выражать комбинации базовых элементов в виде процедур автоматически
сообщает нашему языку средство абстракции для составных объектов.

Чтобы наблюдать сеть в действии, мы подсоединим тестеры к соединителям
@code{C} и @code{F} при помощи процедуры @code{probe}, подобной той,
которая следила за сигналами в проводах в @ref{3.3.4}. Установка
тестера на соединителе ведет к тому, что каждый раз, когда он получает
значение, печатается сообщение:

@lisp
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
@end lisp

@noindent
Затем мы присваиваем значение 25 соединителю @code{C}. (Третий аргумент
процедуры @code{set-value!} сообщает @code{C}, что директива исходит от
пользователя.)

@lisp
(set-value! C 25 'user)
@i{Probe: Celsius temp = 25}
@i{Probe: Fahrenheit temp = 77}
@i{done}
@end lisp

@noindent
Тестер на @code{C} просыпается и печатает значение. Кроме того, @code{C}
распространяет значение по сети, как описано выше. В результате @code{F}
становится равным 77, и тестер на @code{F} об этом сообщает.

Теперь можно попробовать присвоить @code{F} новое значение, скажем, 212:

@lisp
(set-value! F 212 'user)
@i{Error! Contradiction (77 212)}
@end lisp

@noindent
Соединитель жалуется, что обнаружил противоречие: его значение равно 77,
а при этом кто-то пытается установить его в 212. Если мы и вправду хотим
снова воспользоваться сетью с новыми значениями, можно попросить
@code{C} забыть свое старое значение:

@lisp
(forget-value! C 'user)
@i{Probe: Celsius temp = ?}
@i{Probe: Fahrenheit temp = ?}
@i{done}
@end lisp

@noindent
@code{С} видит, что @code{user}, который изначально присвоил ему
значение, отменяет его, так что @code{C} соглашается потерять значение,
как показывает тестер, и информирует об этом остальную сеть. Эта
информация в конце концов добирается до @code{F}, и у @code{F} уже не
остается причин считать, что его значение равно 77. Так что @code{F}
тоже теряет значение, и тестер это отображает.

Теперь, когда у @code{F} больше нет значения, мы можем установить его в
212:

@lisp
(set-value! F 212 'user)
@i{Probe: Fahrenheit temp = 212}
@i{Probe: Celsius temp = 100}
@i{done}
@end lisp

@noindent
Это новое значение, распространяясь по сети, заставляет @code{C}
получить значение 100, и тестер на @code{C} это регистрирует. Заметим,
что одна и та же сеть используется и для того, чтобы на основе @code{F}
получить @code{C} и для того, чтобы на основе @code{C} получить
@code{F}. Эта ненаправленность вычислений является отличительной чертой
систем, основанных на ограничениях.

@comment @subsubheading Implementing the constraint system
@subsubheading Реализация системы ограничений

Система ограничений реализована на основе процедурных объектов с
внутренним состоянием, очень похоже на модель цифровых схем из
@ref{3.3.4}. Хотя базовые
объекты системы с ограничениями несколько более сложны, система в целом
проще за счет того, что незачем заботиться о планах действий и
логических задержках.

Базовые операции над соединителями таковы:

@itemize @bullet

@item
@code{(has-value? @math{\langle}@var{соединитель}@math{\rangle})}
сообщает, есть ли у соединителя значение.

@item
@code{(get-value @math{\langle}@var{соединитель}@math{\rangle})}
возвращает текущее значение соединителя.

@item
@code{(set-value! @math{\langle}@var{соединитель}@math{\rangle} 
@math{\langle}@var{новое-знач}@math{\rangle} 
@math{\langle}@var{информант}@math{\rangle})} сообщает соединителю, что
информант требует установить в нем новое значение.

@item
@code{(forget-value! @math{\langle}@var{соединитель}@math{\rangle} 
@math{\langle}@var{отказник}@math{\rangle})} сообщает соединителю, что
отказник просит его забыть значение.

@item
@code{(connect @math{\langle}@var{соединитель}@math{\rangle}
@math{\langle}@var{новое-ограничение}@math{\rangle})} говорит соединителю, что
он участвует в новом ограничении.

@end itemize

@noindent
Соединители общаются с ограничениями при помощи процедур
@code{inform-about-value}, которая говорит ограничению, что у
соединителя есть значение, и @code{inform-about-no-value}, которая
сообщает ограничению, что соединитель утратил значение.

@code{adder} порождает ограничение-сумматор между
соединителями-слагаемыми @code{a1} и @code{a2} и соединителем-суммой
@code{sum}. Сумматор реализован в виде процедуры с внутренним состоянием
(процедура @code{me}):

@lisp
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
@end lisp

@noindent
@code{adder} связывает новый сумматор с указанными соединителями и
возвращает его в качестве значения. Процедура @code{me}, которая
представляет сумматор, работает как диспетчер для внутренних процедур.
Для доступа к диспетчеру используются следующие <<синтаксические
интерфейсы>> (см. примечание @ref{Сноска 27} в
@ref{3.3.4}):

@lisp
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
@end lisp

@noindent
Внутренняя процедура сумматора @code{process-new-value} вызывается,
когда сумматору сообщают, что один из его соединителей получил значение.
Сумматор проверяет, имеют ли значения одновременно @code{a1} и
@code{a2}. Если да, то он говорит @code{sum}, чтобы тот установил
значение в сумму двух слагаемых. Аргумент @code{informant} процедуры
@code{set-value!} равен @code{me}, то есть самому объекту-сумматору.
Если неверно, что и @code{a1} и @code{a2} имеют значения, то сумматор
проверяет, имеют ли одновременно значения @code{a1} и @code{sum}. Если
да, то он устанавливает @code{a2} в их разность. Наконец, если значения
есть у @code{a2} и @code{sum}, это дает сумматору достаточно информации,
чтобы установить @code{a1}. Если сумматору сообщают, что один из
соединителей потерял значение, то он просит все свои соединители
избавиться от значений. (На самом деле будут отброшены только значения,
установленные самим сумматором.) Затем он зовет
@code{process-new-value}. Смысл этого последнего шага в том, что один
или более соединителей по-прежнему могут обладать значением (то есть, у
соединителя могло быть значение, не установленное сумматором), и эти
значения может быть необходимо распространить через сумматор.

Умножитель очень похож на сумматор. Он устанавливает свой вывод
@code{product} в 0, если хотя бы один множитель равен 0, даже в том
случае, когда второй множитель неизвестен.

@lisp
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product)
                          (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product)
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: MULTIPLIER"
                       request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
@end lisp

@noindent
Конструктор @code{constant} просто устанавливает значение указанного
соединителя. Сообщение @code{I-have-a-value} либо
@code{I-lost-my-value}, посланные блоку-константе, приводят к ошибке.

@lisp
(define (constant value connector)
  (define (me request)
    (error "Unknown request: CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
@end lisp

@noindent
Наконец, тестер печатает сообщение о присваивании или потере значения в
указанном соединителе:

@lisp
(define (probe name connector)
  (define (print-probe value)
    (newline) (display "Probe: ") (display name)
    (display " = ") (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value) (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: PROBE" request))))
  (connect connector me)
  me)
@end lisp

@comment @subsubheading Representing connectors
@subsubheading Представление соединителей

Соединитель представляется в виде процедурного объекта с внутренними
переменными состояния: @code{value}, значение соединителя;
@code{informant}, объект, который установил значение соединителя; и
@code{constraints}, множество ограничений, в которых участвует
соединитель.

@lisp
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "unknown operation: connector"
                         request))))
    me))
@end lisp

@noindent
Внутренняя процедура соединителя @code{set-my-value} зовется, когда
поступает требование установить значение соединителя. Если у соединителя
нет текущего значения, он его устанавливает и запоминает ограничение,
которое потребовало установки значения, в переменной
@code{informant}.@footnote{@code{Setter} может и не быть ограничением. В
примере с температурой мы использовали символ @code{user} в качестве
значения @code{setter}.} Затем соединитель оповещает все связанные с
ним ограничения, кроме того, которое потребовало установить значение.
Это проделывается с помощью следующего итератора, который применяет
указанную процедуру ко всем элементам списка, кроме одного.

@lisp
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
@end lisp

@noindent
Если от соединителя требуют забыть значение, он запускает внутреннюю
процедуру @code{forget-my-value}, которая первым делом убеждается, что
запрос исходит от того же самого объекта, который значение установил.
Если это так, соединитель оповещает связанные с ним ограничения о потере
значения.

Внутренняя процедура @code{connect} добавляет указанное ограничение к
списку ограничений, если его там еще нет. Затем, если у соединителя есть
значение, он сообщает об этом ограничению.

Процедура соединителя @code{me} служит диспетчером для остальных
внутренних процедур, а кроме того, представляет соединитель как объект.
Следующие процедуры предоставляют синтаксический интерфейс к диспетчеру:

@lisp
(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.33}Упражнение 3.33:}
С помощью элементарных ограничений сумматор, умножитель и
константа, определите процедуру @code{averager} (усреднитель), которая
принимает три соединителя @code{a}, @code{b} и @code{c}, и обеспечивает
условие, что значение @code{c} равно среднему арифметическому значений
@code{a} и @code{b}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.34}Упражнение 3.34:}
Хьюго Дум хочет построить квадратор, блок-ограничение с
двумя выводами, такое, что значение соединителя @code{b} на втором
выводе всегда будет равно квадрату значения соединителя @code{a} на
первом выводе. Он предлагает следующее простое устройство на основе
умножителя:

@lisp
(define (squarer a b)
  (multiplier a a b))
@end lisp

В такой идее есть существенная ошибка. Объясните ее.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.35}Упражнение 3.35:}
Бен Битобор объясняет Хьюго, что один из способов избежать
неприятностей в упражнении @ref{Упражнение 3.34} --- определить
квадратор как новое элементарное ограничение. Заполните недостающие
части в Беновой схеме процедуры, реализующей такое ограничение:

@lisp
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER"
                   (get-value b))
            @math{\langle}@var{alternative1}@math{\rangle})
        @math{\langle}@var{alternative2}@math{\rangle}))
  (define (process-forget-value) @math{\langle}@var{body1}@math{\rangle})
  (define (me request) @math{\langle}@var{body2}@math{\rangle})
  @math{\langle}@var{rest of definition}@math{\rangle}
  me)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.36}Упражнение 3.36:}
Допустим, что мы выполняем следующую последовательность
действий в глобальном окружении:

@lisp
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
@end lisp

В какой-то момент при вычислении @code{set-value!} будет выполнено
следующее выражение из внутренней процедуры соединителя:

@lisp
(for-each-except
  setter inform-about-value constraints)
@end lisp

Нарисуйте диаграмму, изображающую окружение, в котором выполняется
указанное выражение.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.37}Упражнение 3.37:}
Процедура @code{celsius-fahrenheit-converter} выглядит
громоздко по сравнению со стилем определения в формате выражения:

@lisp
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
@end lisp

Здесь @code{c+}, @code{c*} и т. п. --- <<ограничительные>> версии
арифметических операций. Например, @code{c+} берет в виде аргументов два
соединителя, и возвращает соединитель, который связан с ними
ограничением-сумматором:

@lisp
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
@end lisp

Определите аналогичные процедуры для @code{c-}, @code{c*}, @code{c/} и
@code{cv} (константа), так, чтобы можно было определять составные
ограничения, как в вышеприведенном примере.@footnote{Представление в виде
выражений удобно, потому что при этом отпадает необходимость давать
имена промежуточным выражениям в вычислении. Наша исходная формулировка
языка ограничений громоздка по той же причине, по которой многие языки
оказываются громоздкими при работе с составными данными. Например, если
нам нужно вычислить произведение @math{(a+b) \cdot (c+d)}, где переменные представляют вектора, мы можем работать в
<<императивном>> стиле, с процедурами, которые присваивают значения
указанным векторным аргументам, но сами не возвращают вектора как
значения:

@sp -0.8
@smallexample
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
@end smallexample
@sp -0.8

@noindent
С другой стороны, мы можем работать с выражениями, используя процедуры,
которые возвращают вектора как значения, и таким образом избежать
прямого упоминания @code{temp1} и @code{temp2}:

@sp -0.8
@smallexample
(define answer (v-prod (v-sum a b) (v-sum c d)))
@end smallexample
@sp -0.8

@noindent
Поскольку Лисп позволяет возвращать составные объекты как результаты
процедур, мы можем преобразовать свой императивный язык ограничений в
язык на основе выражений, как показано в этом упражнении. В языках, где
средства работы с составными объектами бедны, как в Алголе, Бейсике и
Паскале (если явно не использовать паскалевские переменные-указатели),
обычно при решении таких задач программист ограничен императивным
стилем. Поскольку формат выражений предпочтителен, можно спросить, есть
ли причина строить систему императивно, как мы поступили в этом разделе.
Одна из причин состоит в том, что язык ограничений, не ориентированный
на выражения, дает нам возможность работать не только с
объектами-соединителями, но и с объектами-ограничениями (например,
значением, порождаемым процедурой @code{adder}). Это будет полезно, если
мы захотим расширить систему новыми операциями, которые работают с
ограничениями напрямую, а не только косвенным образом через операции над
соединителями. Хотя реализовать работу с выражениями на основе
императивной реализации просто, сделать обратное значительно труднее.}
@end quotation

@comment @section Concurrency: Time Is of the Essence
@section Параллелизм: время имеет значение
@node	3.4, 3.5, 3.3, Chapter 3

Мы убедились в мощности вычислительных объектов с внутренним состоянием
в качестве инструмента моделирования. Однако, как было сказано в
@ref{3.1.3}, за эту
мощность приходится платить потерей референциальной прозрачности,
которая ведет в дебри вопросов об идентичности и изменении, и
необходимостью замены подстановочной модели вычислений на более сложную
модель с окружениями.

Главная проблема, стоящая за сложностями состояния, идентичности и
изменения, состоит в том, что, введя присваивание, мы вынуждены внести в
свои вычислительные модели понятие (@newterm{time}). До того, как появилось
присваивание, наши программы от времени не зависели --- в том смысле,
что всякое выражение, обладающее значением, всегда имело одно и то же
значение. Вспомним, однако, пример со снятием денег со счета и
просмотром получившегося баланса из начала
@ref{3.1.1}:

@lisp
(withdraw 25)
@i{75}
(withdraw 25)
@i{50}
@end lisp

@noindent
Здесь последовательное вычисление одного и того же выражения приводит к
различным результатам. Такое поведение возникает из-за того, что
выполнение предложений присваивания (в данном случае присваивания
переменной @code{balance}) отмечает (@newterm{moments in time}), когда значения
меняются. Результат вычисления выражения зависит не только от самого
выражения, но и от того, происходит ли вычисление до или после таких
моментов. Построение моделей в терминах вычислительных объектов с
внутренним состоянием заставляет нас рассматривать время как
существенное для программирования понятие.

Можно пойти еще дальше в структурировании наших вычислительных объектов,
чтобы точнее отразить наше восприятие физического мира. Объекты мира
изменяются не последовательно один за другим. Мы воспринимаем их как
действующие (@newterm{concurrently}) --- все вместе. Так что зачастую бывает
естественно моделировать системы как сообщества вычислительных
процессов, работающих параллельно. Точно так же, как можно сделать
программы модульными, организуя их в виде объектов с раздельным
внутренним состоянием, часто имеет смысл разделять вычислительные модели
на части, вычисляющиеся раздельно и одновременно. Даже если на самом
деле предполагается выполнять программы на последовательном компьютере,
практика написания программ так, как будто вычисление будет
параллельным, заставляет программиста избегать несущественных временны́х
ограничений, и таким образом повышает модульность программ.

Параллельное вычисление не только делает программы модульнее, оно к тому
же может дать выигрыш в скорости перед последовательным.
Последовательные компьютеры выполняют только одну операцию за раз, так
что время, необходимое для решения задачи, пропорционально общему
количеству выполняемых операций.@footnote{На самом деле большинство
процессоров выполняют несколько операций за раз, используя стратегию,
называемую (@newterm{pipelining}) Хотя этот метод значительно повышает степень
использования аппаратных ресурсов, он используется только для ускорения
выполнения последовательного потока вычислений, сохраняя поведение
последовательной программы.} Однако если возможно разбить задачу на
части, которые относительно независимы друг от друга и должны общаться
между собой редко, может оказаться возможным раздать эти куски отдельным
вычисляющим процессорам и получить выигрыш, пропорциональный числу
имеющихся процессоров.

К несчастью, проблемы, связанные с присваиванием, становятся только
тяжелее в присутствии параллелизма. Связано ли это с тем, что
параллельно работает мир, или компьютер, но явление одновременных
вычислений привносит дополнительную сложность в наше понимание времени.

@menu
* 3-4-1::            Природа времени в параллельных системах
* 3-4-2::            Механизмы управления параллелизмом
@end menu

@comment @subsection The Nature of Time in Concurrent Systems
@subsection Природа времени в параллельных системах
@node	3.4.1, 3.4.2, 3.4, 3.4

На первый взгляд, время --- вещь простая. Это порядок, накладываемый на
события.@footnote{Граффити на одной стене в Кембридже: <<Время --- это
устройство для того, чтобы случалось не все сразу>>.} Для всяких двух
событий @math{A} и @math{B}, либо @math{A} случается раньше @math{B},
либо @math{A} и @math{B} происходят одновременно, либо @math{A}
случается позже @math{B}. Например, возвращаясь к примеру с банковским
счетом, пусть Петр берет с общего счета 10 долларов, а Павел 25, притом,
что сначала на счету 100 долларов. На счету останется 65 долларов. В
зависимости от порядка двух событий, последовательность балансов на
счету будет либо @math{\$100 \to \$90 \to \$65}, либо
@math{\$100 \to \$75 \to \$65}. В компьютерной реализации банковской
системы эта изменяющаяся последовательность балансов может
моделироваться через последовательные присваивания переменной
@code{balance}.

Однако в некоторых ситуациях такой взгляд может вести к проблемам.
Допустим, что Петр и Павел, и еще другие люди помимо них, имеют доступ к
совместному банковскому счету через сеть банкоматов, разбросанных по
всему миру. Последовательность значений баланса будет критическим
образом зависеть от точной хронологии доступа и деталей коммуникации
между машинами.

Неопределенность порядка событий может приводить к серьезным проблемам в
проектировании компьютерных систем. Например, предположим, что действия
Петра и Павла реализованы как два отдельных процесса с общей переменной
@code{balance}, и что каждый процесс определяется процедурой из
@ref{3.1.1}:

@lisp
(define (withdraw amount)
  (if (>= balance amount)
      (begin
        (set! balance (- balance amount))
        balance)
      "Insufficient funds"))
@end lisp

@noindent
Если два процесса работают одновременно, то Петр может проверить баланс
и попытаться снять разрешенную сумму. Однако за промежуток времени между
моментами, когда Петр проверяет баланс, и когда он завершает снятие
денег, Павел может снять какую-то сумму и сделать результат Петровой
проверки несостоятельным.

И это еще не самое худшее. Рассмотрим выражение

@lisp
(set! balance (- balance amount))
@end lisp

@noindent
которое выполняется во время каждого снятия денег. Выполнение происходит
в три шага: (1) считывание значения переменной @code{balance}; (2)
вычисление нового значения баланса; (3) присвоение переменной
@code{balance} этого нового значения. Если процессы Петра и Павла
выполняют это предложение параллельно, то в двух процессах снятия денег
порядок чтения переменной @code{balance} и присваивания могут
чередоваться.

@float[tp]
@anchor{Рисунок 3.29}
@ifinfo
@strong{Рисунок 3.29:} Timing diagram showing how interleaving the order of events
in two banking withdrawals can lead to an incorrect final balance.

@example
 |           Peter              Bank              Paul
 |                              ____
 |                             /    \
 |             .--------------| $100 |-------------.
 |             |               \____/              |
 |             V                                   V
 |  .----------------------.            .----------------------.
 |  | Access balance: $100 |            | Access balance: $100 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   V
 |  .----------------------.            .----------------------.
 |  | new value: 100-10=90 |            | new value: 100-25=75 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   |
 |  .----------------------.                       |
 |  | set! balance to $90  |                       |
 |  `----------+-----------'    ____               |
 |             |               /    \              |
 |             `------------->| $ 90 |             V
 |                             \____/   .----------------------.
 |                                      | new value: 100-25=75 |
 |                              ____    `----------+-----------'
 |                             /    \              |
 |                            | $ 90 |<------------'
 V                             \____/
time
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.29b,109mm,,,.pdf}
@sp 0.8
@noindent
@comment @caption{@strong{Рисунок 3.29:} Timing diagram showing how interleaving the order of events in two banking withdrawals can lead to an incorrect final balance.}
@caption{@strong{Рисунок 3.29:} Временная диаграмма, показывающая, как чередование действий при двух операциях со счетом может привести к неправильному балансу.}
@sp 1.2
@end iftex
@end float

Временна́я диаграмма на рисунке @ref{Рисунок 3.29} показывает порядок
событий, при котором @code{balance} сначала равен 100. Петр берет 10,
Павел 25, и однако в итоге @code{balance} оказывается равен 75. Как
показано на диаграмме, причина аномалии состоит в том, что у Павла
присваивание переменной значения 75 основано на предположении, что
значение @code{balance}, которое надо уменьшить, равно 100. Однако это
предположение стало неверным, когда Петр сделал @code{balance} равным
90. Для банковской системы это катастрофическая ошибка, так как не
сохраняется общее количество денег в системе. До транзакций общая сумма
была 100 долларов. После же у Петра оказывается 10 долларов, у Павла 25,
и у банка 75.@footnote{Еще худшая ошибка могла бы случиться, если бы две
операции @code{set!} попытались одновременно изменить баланс. В
результате содержимое памяти могло бы стать случайной комбинацией
данных, записанных двумя процессами. В большинство компьютеров встроена
блокировка элементарных операций записи в память, которая предохраняет
от такого одновременного доступа. Однако даже такой, казалось бы,
простой метод защиты придает дополнительную сложность проектированию
многопроцессорных компьютеров, где требуются сложные протоколы (cache
coherence), чтобы у разных процессоров были непротиворечивые точки
зрения на содержимое памяти, при том, что данные могут дублироваться
(<<кэшироваться>>) в разных процессорах, чтобы увеличить скорость
доступа к памяти.}

Общее явление, иллюстрируемое здесь, состоит в том, что различные
процессы могут разделять одну и ту же переменную состояния. Сложность
возникает оттого, что с этой переменной в одно и то же время может
пытаться работать более одного процесса. В примере с банковским счетом
во время каждой транзакции клиент должен иметь возможность действовать
так, как будто остальных клиентов не существует. Когда клиент изменяет
баланс, исходя из его предыдущего значения, ему надо обеспечить гарантии
того, что прямо перед моментом изменения баланс все еще соответствует
его, клиента, предoставлениям.

@endpage
@comment @subsubheading Correct behavior of concurrent programs
@subsubheading Правильное поведение параллельных программ

Вышеприведенный пример демонстрирует типичную неочевидную ошибку,
которая может возникнуть в параллельной программе. Сложность здесь
восходит к присваиванию переменным, разделяемым между различными
процессами. Мы уже знаем, что при работе с @code{set!} требуется
осторожность, потому что результаты вычислений зависят от порядка, в
котором происходят присваивания.@footnote{Программа подсчета факториала
из @ref{3.1.3} демонстрирует это в рамках одного последовательного процесса.}
При наличии параллелизма нужно быть острожным вдвойне, поскольку не всегда
можно управлять порядком, в котором присваивания происходят в разных
процессах. Если несколько таких изменений могут происходить одновременно
(как в случае с двумя вкладчиками, имеющими доступ к общему счету), нам
требуется способ обеспечить правильную работу системы. Например, в
случае со снятием денег с общего счета, мы должны сделать так, чтобы
общее количество денег оставалось неизменным. Чтобы заставить
параллельные программы работать корректно, иногда требуется наложить
некоторые ограничения на одновременное исполнение.

Одно из возможных ограничений на параллелизм может состоять в том, что
никакие две операции, способные изменить разделяемые переменные
состояния, не могут исполняться одновременно. Это очень серьезное
ограничение. Для распределенной банковской системы это означало бы, что
проектировщик системы должен сделать так, что в каждый момент происходит
не более одной транзакции. Это требование чрезмерно консервативное и
ведет к неэффективности. На рисунке @ref{Рисунок 3.30} показан случай
с совместным счетом Петра и Павла, причем у Павла есть еще и собственный
счет. Диаграмма показывает две операции снятия денег с совместного счета
(одну проводит Петр, одну Павел), а также занесение Павлом денег на
личный счет.@footnote{По столбцам: содержимое кошелька Петра, общий счет
(в Банке 1), кошелек Павла и личный счет Павла (в Банке 2), до и после
каждого снятия (W) и занесения денег на счет (D). Петр берет 10 долларов
из Банка 1; Павел кладет 5 долларов в Банк 2, затем берет 25 долларов из
Банка 1.} Два снятия денег с одного счета не должны происходить
одновременно (поскольку оба работают с одним счетом), и Павел не может
одновременно снять деньги и занести их в банк (поскольку и та, и другая
операция касаются кошелька Павла). Однако не должно быть препятствий,
мешающих Павлу заносить деньги на личный счет в то время, как Петр берет
деньги с общего счета.

@float
@quotation
@anchor{Рисунок 3.30}
@ifinfo
@strong{Рисунок 3.30:} Concurrent deposits and withdrawals from a joint account
in Bank1 and a private account in Bank2.

@example
 |    Peter          Bank1          Paul           Bank2
 |    ____           ____           ____           ____
 |   /    \         /    \         /    \         /    \
 |  |  $7  |--. .--| $100 |       |  $5  |--. .--| $300 |
 |   \____/   V V   \____/         \____/   V V   \____/
 |           +---+                         +---+
 |           | W |                         | D |
 |    ____   ++-++   ____           ____   ++-++   ____
 |   /    \   | |   /    \         /    \   | |   /    \
 |  | $17  |<-' `->| $90  |--. .--|  $0  |<-' `->| $305 |
 |   \____/         \____/   V V   \____/         \____/
 |                          +---+
 |                          | W |
 |    ____           ____   ++-++   ____           ____
 |   /    \         /    \   | |   /    \         /    \
 |  | $17  |       | $65  |<-' `->| $25  |       | $305 |
 |   \____/         \____/         \____/         \____/
 V
time
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.30b,94mm,,,.pdf}
@sp 0.7
@comment @caption{@strong{Рисунок 3.30:} Concurrent deposits and withdrawals from a joint @w{account} in Bank1 and a private account in Bank2.}
@caption{@strong{Рисунок 3.30:} Одновременные операции при работе с совместным счетом в Банке~1 и личным счетом в Банке~2.}
@sp 1.0
@end iftex
@end quotation
@end float

Менее драконовское ограничение на параллелизм могло бы состоять в том,
чтобы параллельная система выдавала такие же результаты, как если бы
процессы происходили последовательно. У этого ограничения две важных
стороны. Во-первых, от процессов на самом деле не требуется
последовательного исполнения, а только результаты, совпадающие с теми,
которые @emph{получались бы}, если бы они работали один за другим. В
примере на рис. @ref{Рисунок 3.30}, проектировщик банковской системы
спокойно может разрешить одновременное занесение денег Павлом и снятие
их Петром, поскольку общий результат будет таков, как будто бы они шли
последовательно. Во-вторых, у параллельной программы может быть более
одного <<правильного>> результата, потому что мы требуем только, чтобы
он совпадал с результатом при @emph{каком-нибудь} последовательном
порядке. Например, предположим, что общий счет Петра и Павла вначале
равен 100 долларам, Петр кладет на него 40 долларов, а Павел снимает
половину имеющихся там денег. При этом последовательное исполнение может
привести к значению на счету либо в 70, либо в 90 долларов
(см. @ref{Упражнение 3.38}).@footnote{@anchor{Сноска 39} Более
формально это утверждение можно выразить, сказав, что поведение
параллельных программ --- (nondeterministic). То есть, они описываются
не функциями с одним значением, а функциями, чьи результаты являются
множествами возможных значений. В @ref{4.3}
мы рассмотрим язык для выражения недетерминистских вычислений.}

Можно найти и еще более слабые требования для корректного выполнения
параллельных программ. Программа, имитирующая диффузию (например, поток
тепла в объекте), может состоять из большого числа процессов, каждый из
которых изображает маленький участок пространства, и которые параллельно
обновляют свои значения. Каждый процесс в цикле изменяет свое значение
на среднее между своим собственным значением и значениями соседей. Этот
алгоритм сходится к правильному ответу независимо от порядка, в котором
выполняются операции; нет никакой нужды в ограничениях на параллельное
использование разделяемых значений.

@quotation
@strong{@anchor{Упражнение 3.38}Упражнение 3.38:}
Пусть Петр, Павел и Мария имеют общий счет, на котором
вначале лежит 100 долларов. Петр кладет на счет 10 долларов,
одновременно с этим Павел берет 20, а Мария берет половину денег со
счета. При этом они выполняют следующие операции:

@lisp
Peter: (set! balance (+ balance 10))
Paul:  (set! balance (- balance 20))
Mary:  (set! balance (- balance (/ balance 2)))
@end lisp

@enumerate a.

@item
Перечислите возможные значения @code{balance} после завершения операций,
предполагая, что банковская система требует от транзакций исполняться
последовательно в каком-то порядке.

@item
Назовите какие-нибудь другие значения, которые могли бы получиться, если
бы система разрешала операциям чередоваться. Нарисуйте временные
диаграммы, подобные рис. @ref{Рисунок 3.29}, чтобы объяснить, как
возникают такие результаты.

@end enumerate
@end quotation

@comment @subsection Mechanisms for Controlling Concurrency
@subsection Механизмы управления параллелизмом
@node	3.4.2,  , 3.4.1, 3.4

Мы убедились, что сложность работы с параллельными процессами происходит
из необходимости учитывать порядок чередования событий в различных
процессах. Предположим, к примеру, что у нас есть два процесса, один с
упорядоченными событиями @math{(a, b, c)}, а другой с упорядоченными
событиями @math{(x, y, z)}. Если эти два процесса исполняются
параллельно, без каких-либо дополнительных ограничений на чередование
событий, то возможно 20 различных порядков событий, соблюдающих
упорядочение их внутри каждого из процессов:

@example
(a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)  (x,a,y,z,b,c)
(a,b,x,c,y,z)  (a,x,b,y,z,c)  (x,a,b,y,c,z)  (x,y,a,b,c,z)
(a,b,x,y,c,z)  (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
(a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)  (x,y,a,z,b,c)
(a,x,b,c,y,z)  (a,x,y,z,b,c)  (x,a,y,b,z,c)  (x,y,z,a,b,c)
@end example

@noindent
При разработке этой системы нам как программистам пришлось
бы рассматривать результаты каждого из этих 20 упорядочений и проверять,
что каждое из них допустимо. С ростом числа процессов и событий такой
подход быстро становится нереалистичным.

Более практичный подход к проектированию параллельных систем состоит в
том, чтобы придумать общие механизмы, которые бы ограничивали
чередование событий в параллельных процессах и тем самым давали нам
уверенность, что поведение программы верно. Для этой цели было
разработано большое количество механизмов. В этом разделе мы опишем один
из них --- (@newterm{serializer}).

@comment @subsubheading Serializing access to shared state
@subsubheading Сериализация доступа к разделяемой памяти

Идея сериализации заключается в следующем: процессы выполняются
параллельно, но при этом существуют определенные группы процедур,
которые не могут выполняться одновременно. Выражаясь точнее,
сериализация порождает выделенные множества процедур, такие, что в
каждом сериализованном множестве в любой момент может происходить
выполнение только одной процедуры из множества. Если какая-то процедура
из множества уже выполняется, то процесс, который пытается выполнить
любую процедуру из множества, будет приостановлен до тех пор, пока не
закончится текущее вычисление процедуры.

С помощью сериализации можно управлять доступом к разделяемым
переменным. Например, если мы хотим присвоить разделяемой переменной
значение, зависящее от ее текущего значения, мы помещаем доступ к
прежнему значению и присваивание нового в одну процедуру. Затем мы
помещаем все такие процедуры в один сериализатор и тем самым добиваемся
того, что никакая другая процедура, которая присваивает значения этой
переменной, не может выполняться одновременно с нашей. Это гарантирует
нам, что значение переменной не может измениться в промежутке между
доступом к ней и соответствующим ему присваиванием.

@comment @subsubheading Serializers in Scheme
@subsubheading Сериализаторы в Scheme

Чтобы сделать это описание более конкретным, предположим, что мы
расширили язык Scheme, добавив в него процедуру @code{parallel-execute}:

@lisp
(parallel-execute @math{\langle}@var{p}@math{_{\mono{1}}\rangle} @math{\langle}@var{p}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{p}@math{_{\monoit{k}}\rangle})
@end lisp

Каждый из @math{\langle p \rangle} должен быть
процедурой без аргументов. @code{parallel-execute} создает для каждого
@math{\langle p \rangle} отдельный процесс, который выполняет
@math{\langle p \rangle} (с пустым набором аргументов). Все эти процессы выполняются
параллельно.@footnote{@code{parallel-execute} не входит в стандартную
Scheme, но такая процедура может быть реализована в MIT Scheme. В нашей
реализации новые процессы выполняются параллельно еще и с исходным
Scheme-процессом. Кроме того, в нашей реализации значение, которое
возвращает @code{parallel-execute}, представляет собой специальный
управляющий объект, с помощью которого можно остановить все
новосозданные процессы.}

Чтобы продемонстрировать, как эта процедура используется, рассмотрим

@lisp
(define x 10)
(parallel-execute
 (lambda () (set! x (* x x)))
 (lambda () (set! x (+ x 1))))
@end lisp

@noindent
Здесь создаются два параллельных процесса --- @math{P_1}, который
присваивает @code{x} значение @code{x} умножить на @code{x}, и
@math{P_2}, который увеличивает @code{x} на единицу. После того, как
вычисление закончено, @code{x} может иметь одно из пяти значений, в
зависимости от чередования событий в @math{P_1} и @math{P_2}:

@lisp
101: @r{@math{P_1} делает @code{x} равным 100, затем @math{P_2} его
увеличивает.}

121: @r{@math{P_2} увеличивает @code{x}, делая его равным 11, затем
@math{P_1} присваивает ему значение @code{x} умножить на @code{x}.}

110: @r{@math{P_2} изменяет @code{x} с 10 на 11 в промежутке между двумя
обращениями к @code{x} из @math{P_1} во время вычисления @code{(* x x)}.}

11: @r{@math{P_2} читает @code{x}, затем @math{P_1} присваивает ему
значение 100, затем @math{P_1} пишет @code{x}}

100: @r{@math{P_1} читает @code{x} (дважды), затем @math{P_2} присваивает
ему значение 11, затем @math{P_1} записывает значение @code{x}.}
@end lisp

@noindent
Мы можем ограничить параллелизм, используя сериализованные процедуры,
которые создаются (@newterm{serializers}). Сериализаторы порождаются процедурой
@code{make-serializer}, реализация которой дана ниже. Сериализатор
принимает в качестве аргумента процедуру, и возвращает сериализованную
процедуру с таким же поведением. Все вызовы сериализатора порождают
сериализованные процедуры, принадлежащие одному множеству.

Таким образом, в отличие от предыдущего примера, выполнение

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute
 (s (lambda () (set! x (* x x))))
 (s (lambda () (set! x (+ x 1)))))
@end lisp

@noindent
может иметь только два результата, 101 и 121. Остальные возможности
отбрасываются, поскольку выполнение @math{P_1} и @math{P_2} не может
чередоваться.

Ниже приведена версия процедуры @code{make-account} из @ref{3.1.1},
в которой помещение денег на счет и снятие их со счета сериализованы:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
    dispatch))
@end lisp

@noindent
В такой реализации два процесса не могут параллельно помещать деньги на
счет или снимать их. Таким образом устраняется источник ошибки,
показанной на рис. @ref{Рисунок 3.29}, где Петр изменяет баланс на
счете в промежутке между моментами, когда Павел считывает значение
баланса, и когда он производит присваивание. С другой стороны, у каждого
счета свой собственный сериализатор, так что операции с различными
счетами могут происходить параллельно.

@quotation
@strong{@anchor{Упражнение 3.39}Упражнение 3.39:}
Какие из пяти возможных исходов параллельного выполнения
сохраняются, если мы сериализуем выполнение таким образом:

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.40}Упражнение 3.40:}
Укажите все возможные значения @code{x} при выполнении

@lisp
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
@end lisp

Какие из них сохраняются, если вместо этого мы выполняем сериализованные
процедуры:

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.41}Упражнение 3.41:}
Бен Битобор считает, что лучше было бы реализовать
банковский счет таким образом (измененная строка отмечена комментарием):

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance
                     (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected
               (lambda () balance)))) @r{; serialized}
            (else
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
@end lisp

@noindent
поскольку несериализованный доступ к банковскому счету может привести к
неправильному поведению. Вы согласны? Существует ли сценарий, который
демонстрирует обоснованность беспокойства Бена?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.42}Упражнение 3.42:}
Бен Битобор говорит, что слишком расточительно в ответ на
каждое сообщение @code{withdraw} и @code{deposit} создавать по новой
сериализованной процедуре. Он говорит, что можно изменить
@code{make-account} так, чтобы все вызовы @code{protected} происходили
вне процедуры @code{dispatch}. Таким образом, счет будет возвращать одну
и ту же сериализованную процедуру (созданную тогда же, когда и сам счет)
каждый раз, когда у него просят процедуру снятия денег:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else
               (error "Unknown request: MAKE-ACCOUNT"
                      m))))
      dispatch)))
@end lisp

Безопасно ли такое изменение? В частности, есть ли разница в том, в
каком порядке может происходить параллельное выполнение в этих двух
версиях @code{make-account}?
@end quotation

@comment @subsubheading Complexity of using multiple shared resources
@subsubheading Сложности при использовании множественных разделяемых ресурсов

Сериализаторы предоставляют нам мощную абстракцию, которая позволяет
изолировать сложности выполнения параллельных программ, так что мы
получаем возможность работать с ними аккуратно (и, будем надеяться, без
ошибок). Однако, хотя при работе только с одним разделяемым ресурсом
(например, с одним банковским счетом) использовать сериализаторы
относительно просто, при наличии множественных разделяемых ресурсов
параллельное программирование может быть предательски сложным.

Чтобы проиллюстрировать одну из ряда трудностей, которые могут
возникнуть, предположим, что нам требуется поменять местами балансы на
двух банковских счетах. Мы читаем каждый счет, чтобы узнать баланс,
вычисляем разницу между балансами, снимаем ее с одного счета и кладем на
другой. Это можно реализовать следующим образом:@footnote{Мы упростили
@code{exchange}, пользуясь тем, что наше сообщение @code{deposit} может
принимать отрицательные суммы. (Для банковской системы это серьезная
ошибка!)}

@lisp
(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
@end lisp

@noindent
Эта процедура работает правильно в том случае, когда только один процесс
пытается осуществить обмен. Допустим, однако, что Петр и Павел имеют
доступ к совместным счетам @math{a1}, @math{a2} и @math{a3}, и что Петр
меняет местами @math{a1} и @math{a2}, а Павел в то же время обменивает
@math{a1} и @math{a3}. Даже если снятие и занесение денег на отдельные
счета сериализованы (как в процедуре @code{make-account} из предыдущего
раздела), @code{exchange} может привести к неверным результатам.
Например, может оказаться, что Петр посчитает разницу между @math{a1} и
@math{a2}, но Павел изменит баланс на @math{a1} прежде, чем Петр
закончит обмен.@footnote{Если балансы на счетах вначале равны 10, 20 и 30
долларам, то после любого количества параллельных обменов балансы должны
по прежнему быть 10, 20 и 30, в каком-то порядке. Сериализации доступа к
отдельным счетам недостаточно, чтобы это гарантировать.
См. @ref{Упражнение 3.43}.} Чтобы добиться правильного
поведения, мы должны устроить так, чтобы процедура @code{exchange}
блокировала всякий параллельный доступ к счетам на все время обмена.

Один из способов этого достичь --- сериализовать всю процедуру
@code{exchange} сериализаторами обоих счетов. Ради этого мы откроем
доступ к сериализаторам счетов. Обратите внимание, что, раскрывая
сериализатор, мы намеренно ломаем модульное построение
объекта-банковского счета. Следующая версия процедуры
@code{make-account} идентична исходной версии из @ref{}, за исключением
того, что имеется сериализатор для защиты переменной баланса, и он
экспортируется через передачу сообщений:

@lisp
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
@end lisp

\enlargethispage{\baselineskip}

@noindent
С помощью этой версии мы можем выполнять сериализованное занесение и
снятие денег. Заметим, однако, что, в отличие от предыдущей версии
сериализованного счета, теперь каждый пользователь объектов-банковских
счетов должен явным образом управлять сериализацией, например,
так:@footnote{В @ref{Упражнение 3.45} рассматривается
вопрос, почему занесение и снятие денег теперь не сериализуются счетом
автоматически.}

@lisp
(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
@end lisp

@noindent
Экспорт сериализатора дает нам достаточно гибкости, чтобы реализовать
сериализованную программу обмена. Мы просто-напросто сериализуем
исходную процедуру @code{exchange} сериализаторами обоих счетов:

@lisp
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.43}Упражнение 3.43:}
Предположим, что значения баланса на трех счетах вначале
равны 10, 20 и 30 долларам, и что несколько процессов занимаются обменом
значений баланса. Покажите, что если эти процессы выполняются
последовательно, то после любого количества обменов значения баланса
по-прежнему будут равны 10, 20 и 30 долларам, в каком-то порядке.
Нарисуйте временную диаграмму вроде той, которая изображена на
рис. @ref{Рисунок 3.29}, и покажите, что указанное условие может
нарушаться, если работает первая версия процедуры обмена из этого
раздела. Покажите, с другой стороны, что даже с первой программой
@code{exchange} общая сумма балансов на счетах сохранится. Нарисуйте
временную диаграмму, показывающую, что если бы мы не сериализовали
транзакции по отдельным счетам, это условие тоже могло бы нарушаться.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.44}Упражнение 3.44:}
Рассмотрим задачу переноса денег с одного счета на другой.
Бен Битобор утверждает, что ее можно решить с помощью следующей
процедуры, даже в тех случаях, когда много людей одновременно перемещают
деньги между различными счетами, если использовать при этом какой-то
механизм, сериализующий операции занесения на счет и снятия со счета,
например, версию @code{make-account} из нашего текста.

@lisp
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
@end lisp

Хьюго Дум считает, что с этой версией возникнут проблемы и что нужно
использовать более сложный подход, вроде того, который требуется при
решении задачи обмена. Прав ли он? Если нет, то в чем состоит
существенная разница между задачей перевода денег и задачей обмена
счетов? (Нужно предположить, что значение баланса на @code{from-account}
по крайней мере равно @code{amount}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.45}Упражнение 3.45:}
Хьюго Дум полагает, что теперь, когда операции снятия денег
со счета и занесения их на счет перестали сериализовываться
автоматически, система банковских счетов стала неоправданно сложной и
работать с ней правильным образом чересчур трудно. Он предлагает сделать
так, чтобы @code{make-account-and-serializer} экспортировал сериализатор
(для использования в процедурах вроде @code{serialized-exchange}), и
вдобавок сам использовал его для сериализации простых операций со
счетом, как это делал @code{make-account}. Он предлагает переопределить
объект-счет так:

@smalllisp
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount)) balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
@end smalllisp

Then deposits are handled as with the original @code{make-account}:

@lisp
(define (deposit account amount)
  ((account 'deposit) amount))
@end lisp

Объясните, в чем Хьюго ошибается. В частности, рассмотрите, что
происходит при вызове @code{serialized-exchange}.
@end quotation

@comment @subsubheading Implementing serializers
@subsubheading Реализация сериализаторов

Мы реализуем сериализаторы на основе более примитивного механизма
синхронизации, называемого (@newterm{mutex}). Мьютекс --- это объект, который
поддерживает две операции: его можно (@newterm{acquire}), и его можно (@newterm{release}).
Когда мьютекс захвачен, никакая другая операция захвата того же самого
мьютекса произойти не может, пока его не освободят.@footnote{Название
<<мьютекс>> происходит от английского <<взаимное исключение>>. Общая
проблема построения механизма, который позволил бы параллельным
процессам безопасно разделять ресурсы, называется проблемой взаимного
исключения. Наши мьютексы являются простым вариантом механизма
(@newterm{semaphores}) (см. упражнение @ref{Упражнение 3.47}), которые впервые
появились в Системе Мультипрограммирования THE, разработанной в
Эйндховенском Техническом Университете и названной по первым буквам
голландского названия этого учебного заведения (Dijkstra 1968a).
Операции захвата и освобождения изначально назывались P и V, от
голландских глаголов @emph{passeren} (пройти) и @emph{vrijgeven}
(освободить), употребляемых по отношению к семафорам на железных
дорогах. Классическое описание Дейкстры (Dijkstra 1968b) было одним из
первых ясных изложений вопросов управления параллелизмом, и там было
показано, как решаются при помощи семафоров различные задачи.} В нашей
реализации каждый сериализатор содержит по мьютексу. Получая процедуру
@code{p}, сериализатор возвращает процедуру, которая захватывает
мьютекс, выполняет @code{p}, и затем освобождает мьютекс. Благодаря
этому, только одна из процедур, порожденных сериализатором, может
исполняться в каждый момент времени. Именно такого поведения мы и хотели
добиться от сериализации.

@lisp
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
@end lisp

@noindent
Мьютекс --- изменяемый объект (здесь мы используем одноэлементный
список, который будем называть (@newterm{cell)}), способный хранить значение
истина или ложь. Когда значение ложно, мьютекс можно захватывать. Когда
значение истинно, мьютекс недоступен, и процесс, который попытается его
захватить, вынужден будет ждать.

Конструктор мьютекса @code{make-mutex} для начала присваивает
содержимому ячейки значение ложь. Для захвата мьютекса мы проверяем
значение ячейки. Если мьютекс доступен, мы делаем значение истинным и
идем дальше. Если нет, мы входим в цикл ожидания, все время пытаясь
захватить мьютекс, пока он не окажется свободным.@footnote{В большинстве
систем разделения времени процессы, блокированные на мьютексе, не тратят
время в <<занятом ожидании>>, как это описано здесь. Вместо этого
система назначает на исполнение другой процесс, пока первый ждет, а
когда мьютекс освобождается, она будит заблокированный процесс.} Чтобы
освободить мьютекс, мы присваиваем значению ячейки ложь.

@lisp
(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) @r{; retry}
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell) (set-car! cell false))
@end lisp

@noindent
@code{test-and-set!} проверяет ячейку и возвращает результат проверки.
Помимо того, если значение было ложным, @code{test-and-set!}
устанавливает значение в истину, прежде чем вернуть ложь. Мы можем
описать это поведение так:

@lisp
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))
@end lisp

@noindent
Однако эта реализация @code{test-and-set!}, как она есть, не годится.
Здесь есть важная тонкость, и именно здесь управление параллелизмом
становится частью системы: операция @code{test-and-set!} должна
производиться (atomically). Это значит, что мы должны гарантировать, что
когда процесс протестировал ячейку и убедился, что ее значение ложь,
значение будет установлено в истину прежде, чем какой-либо еще процесс
успеет проверить ячейку. Если мы такую гарантию не обеспечим, мьютекс
может сломаться таким же образом, как банковский счет на @ref{Рисунок 3.29}.)

Реализация @code{test-and-set!} зависит от того, как наша система на
самом деле управляет параллельными процессами. Например, мы можем
выполнять параллельные процессы на последовательном процессоре при
помощи механизма разделения времени, который перебирает процессы по
очереди, дает каждому из них выполняться в течение небольшого промежутка
времени, а затем прерывает его и переходит к следующему процессу. В
таком случае @code{test-and-set!} может запрещать смену процесса в
момент между проверкой и присваиванием.@footnote{В MIT Scheme на
однопроцессорной системе можно реализовать @code{test-and-set!}
следующим образом:

@smalllisp
(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
@end smalllisp

@noindent
@code{without-interrupts} запрещает прерывания по таймеру, пока
выполняется его процедурный аргумент.} С другой стороны, в
многопроцессорных компьютерах бывают команды, которые обеспечивают
атомарные операции прямо на уровне аппаратуры.@footnote{Есть много
вариантов таких команд --- включая проверку-и-установку,
проверку-и-сброс, обмен, сравнение-и-обмен, загрузку с резервированием и
условную запись, --- и их форма должна точно соответствовать интерфейсу
между процессором и памятью в данной машине. Один из возникающих
вопросов состоит в том, что происходит, когда два процесса пытаются
получить один и тот же ресурс в точности одновременно при помощи такой
команды. Тут требуется какой-то механизм, принимающий решение, который
из процессов получает управление. Такой механизм называется (arbiter).
Обычно арбитры представляют собой аппаратные устройства. К сожалению,
можно доказать, что нельзя построить справедливого арбитра, работающего
в 100% случаев, если не позволять арбитру принимать решение
неопределенно долгое время. Сущность этого явления была открыта
французским философом XIV века Жаном Буриданом в комментарии к @i{De
caelo} Аристотеля. Буридан указал, что идеально разумная собака,
помещенная между двумя одинаково привлекательными кусками еды, должна
умереть от голода, поскольку она не сможет решить, к какому куску идти в
первую очередь.}

@quotation
@strong{@anchor{Упражнение 3.46}Упражнение 3.46:}
Допустим, что мы реализуем @code{test-and-set} в виде
обыкновенной процедуры, как показано в тексте, не пытаясь сделать ее
атомарной. Нарисуйте временную диаграмму, подобную диаграмме на
рис. @ref{Рисунок 3.29}, и покажите, как реализация мьютекса может
ошибиться и позволить двум процессам одновременно захватить мьютекс.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.47}Упражнение 3.47:}
Семафор (размера @math{n}) представляет собой обобщение
мьютекса. Подобно мьютексу, семафор поддерживает операции захвата и
освобождения, но захватить его одновременно могут до @math{n} процессов.
Прочие процессы, которые попытаются захватить семафор, должны будут
ждать освобождения. Дайте реализацию семафоров

@enumerate a.

@item
в терминах мьютексов.

@item
в терминах атомарных операций @code{test-and-set!}.

@end enumerate
@end quotation

@comment @subsubheading Deadlock
@subsubheading Тупик

Теперь, когда мы рассмотрели, как реализуются сериализаторы, мы
убеждаемся, что с обменом счетов по-прежнему связаны проблемы, даже с
вышеописанной процедурой @code{serialized-exchange}. Допустим, что Петр
хочет обменять @math{a1} и @math{a2}, а Павел в то же время пытается
обменять @math{a2} и @math{a1}. Допустим, что процесс Петра доходит до
некоторой точки внутри сериализованной процедуры, защищающей @math{a1},
и сразу вслед за этим процесс Павла входит в сериализованную процедуру,
защищающую @math{a2}. Теперь Петр не может двигаться дальше (ему надо
войти в сериализованную процедуру для @math{a2}), пока Павел не выйдет
из сериализованной процедуры для @math{a2}. Точно так же Павел не может
двигаться дальше, пока Петр не выйдет из сериализованной процедуры для
@math{a1}. Оба процесса замирают навеки в ожидании друг друга. Такая
ситуация называется (deadlock). В любой системе, которая предоставляет
доступ к множественным разделяемым ресурсам, существует опасность
тупика.

В этой ситуации можно избежать тупика, если присвоить каждому счету
уникальный идентификационный номер, и переписать
@code{serialized-exchange} так, чтобы процесс всегда пытался сначала
войти в процедуру, которая защищает счет с наименьшим номером. Хотя для
задачи обмена это решение работает хорошо, бывают и другие ситуации, в
которых требуются более развитые методы избежания тупиков, или где
тупика нельзя избежать в принципе.  (См. @ref{Упражнение 3.48} и
@ref{Упражнение 3.49}.)@footnote{Общий метод избежания тупиков путем
нумерации разделяемых ресурсов и захвата их по порядку придумал
Хейвендер (Havender 1968). В ситуациях, где тупика нельзя избежать,
нужны меры по (deadlock recovery), когда от процессов требуется
<<откатиться>> из тупикового состояния и повторить попытку. Механизмы
выхода из тупика широко используются в системах управления базами
данных. Эта тема детально рассматривается у Грея и Рейтера (Gray and
Reuter 1993).}

@quotation
@strong{@anchor{Упражнение 3.48}Упражнение 3.48:}
Подробно объясните, почему метод избежания тупиков,
описанный выше (т. е. счета нумеруются, и каждый процесс сначала
пытается захватить счет с меньшим номером), в самом деле позволяет
избежать тупика в задаче обмена балансов. Перепишите
@code{serialized-exchange} с использованием этой идеи. (Придется также
изменить @code{make-account}, так, чтобы каждый счет создавался вместе с
номером, и чтобы этот номер можно было считать, послав соответствующее
сообщение.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.49}Упражнение 3.49:}
Опишите сценарий, в котором вышеописанный механизм
избежания тупиков не работает. (Подсказка: в задаче обмена счетов каждый
процесс заранее знает, к каким счетам ему нужен будет доступ.
Рассмотрите ситуацию, в которой процессу нужно сначала получить доступ к
каким-то разделяемым ресурсам, прежде чем он сможет определить, какие
ресурсы ему потребуются дополнительно.)
@end quotation

@comment @subsubheading Concurrency, time, and communication
@subsubheading Параллелизм, время и взаимодействие

Мы видели, что для программирования параллельных систем, когда различные
процессы имеют доступ к разделяемому состоянию, необходимо управление
порядком событий, и мы видели, как можно добиться нужного порядка с
помощью надлежащего использования сериализаторов. Однако проблемы
параллелизма лежат глубже, поскольку, с фундаментальной точки зрения, не
всегда ясно, что имеется в виду под <<разделяемым состоянием>>.

Механизмы вроде @code{test-and-set!} требуют, чтобы процессы в
произвольные моменты времени имели доступ к глобальному разделяемому
флагу. На современных высокоскоростных процессорах это реализуется
сложно и неэффективно, поскольку, благодаря средствам оптимизации вроде
конвейеров и кэширования памяти, содержимое памяти не обязательно должно
в каждый момент находиться в непротиворечивом состоянии. Из-за этого в
современных многопроцессорных системах идея сериализаторов вытесняется
новыми подходами к управлению параллелизмом.@footnote{Один из подходов,
альтернативных сериализации, называется (@newterm{barrier synchronization}).
Программист позволяет параллельным процессам выполняться как угодно, но
устанавливает определенные точки синхронизации (<<барьеры>>), так что ни
один процесс не может продолжаться, пока все они не достигли барьера.
Современные процессоры обладают машинными командами, которые позволяют
программистам устанавливать точки синхронизации там, где требуется иметь
непротиворечивое состояние. Например, в Power PC
имеются две предназначенные для этого команды: SYNC и EIEIO (Enforced
In-Order Execution of Input-Output, Гарантированно Последовательное
Исполнение Ввода-Вывода).}

Кроме того, проблемы с разделяемым состоянием возникают в больших
распределенных системах. Например, рассмотрим распределенную банковскую
систему, в которой отдельные местные банки поддерживают собственные
значения баланса счетов и время от времени сравнивают их со значениями,
хранимыми в других местах. В такой системе значение <<баланс счета>> не
будет определенным ни в какой момент, кроме как сразу после
синхронизации. Если Петр вносит деньги на счет, который он делит с
Павлом, когда мы должны считать, что баланс изменился, --- когда
меняется баланс в местном банке или только после синхронизации? А если
Павел обращается к счету через другую ветвь системы, какие ограничения
нужно наложить на банковскую систему, чтобы ее поведение считалось
<<правильным>>? Единственное, что может иметь значение для определения
<<правильности>>, --- это поведение, которое Павел и Петр наблюдают по
отдельности, и состояние счета сразу после синхронизации. Вопросы о
<<настоящем>> значении баланса или порядке событий между синхронизациями
могут не иметь значения или даже смысла.@footnote{Такая точка зрения
может казаться странной, но при этом существуют системы, которые именно
так и работают. Изменения на счетах, связанных с кредитными картами,
например, обычно поддерживаются отдельно в каждой стране, а изменения в
различных странах согласовываются время от времени. Таким образом,
баланс на счете может быть различным в различных странах.}

Общее в этих проблемах то, что синхронизация различных процессов,
установление общего состояния и управление порядком событий требуют
взаимодействия процессов. В сущности, любое понятие времени при
управлении параллельными процессами должно быть прочно привязано к
взаимодействию процессов.@footnote{Для распределенных систем эта точка
зрения исследовалась Лэмпортом (Lamport 1978). Он показал, как при
помощи взаимодействия установить <<глобальные часы>>, через которые
можно управлять порядком событий в распределенных системах.} Любопытно,
что похожая связь между временем и обменом информацией возникает в
теории относительности, где скорость света (самого быстрого сигнала,
который можно использовать для синхронизации событий) служит
универсальной константой, связывающей пространство и время. Сложности, с
которыми мы сталкиваемся при работе с временем и состоянием в
вычислительных моделях, могут на самом деле отражать фундаментальную
сложность физического мира.

@comment @section Streams
@section Потоки
@node 3.5,  , 3.4, Chapter 3

Теперь у нас есть ясное понимание того, как присваивание может служить
инструментом моделирования, а также понятие о сложности проблем,
связанных с ним. Пора задать вопрос, нельзя ли организовать работу иначе
и избежать части этих проблем. В этом разделе мы исследуем
альтернативный подход к моделированию состояния, основанный на
структурах данных, называемых (@newterm{streams}). Как нам предстоит убедиться,
потоки могут смягчить некоторые трудности в моделировании состояния.

Давайте сделаем шаг назад и рассмотрим еще раз, откуда происходят эти
сложности. Пытаясь моделировать явления реального мира, мы приняли
несколько, казалось бы, разумных решений: мы моделировали объекты
внешнего мира, обладающие состоянием, при помощи вычислительных объектов
с внутренними переменными. Мы отождествили течение времени в мире с
течением времени в компьютере. Мы имитировали на компьютере изменение
состояния моделируемых объектов при помощи присваивания внутренним
переменным объектов-моделей.

Возможен ли другой подход? Можно ли избежать отождествления времени в
компьютере с временем в моделируемом мире? Должны ли мы заставить модель
изменяться во времени, чтобы смоделировать явления изменяющегося мира?
Давайте подумаем об этом в терминах математических функций. Можно
описать изменение во времени величины @math{x} с помощью функции
@math{x(t)}, где время выступает как аргумент. Если мы сосредотачиваем
внимание на @math{x} момент за моментом, мы думаем об изменяющейся
величине. Однако если мы обращаем внимание на всю хронологию значений,
мы не подчеркиваем изменение --- функция сама по себе не
изменяется.@footnote{Физики иногда принимают эту точку зрения, вводя
<<мировые линии>> частиц в рассуждениях о движении. Кроме того, мы уже
упоминали (в @ref{2.2.3}),
что это естественный ход мысли при рассужднениях о системах обработки
сигналов. Мы рассмотрим приложение потоков к обработке сигналов в
@ref{3.5.3}.}

Если время измеряется дискретными интервалами, мы можем смоделировать
функцию времени как последовательность (возможно, бесконечную). В этом
разделе мы увидим, как моделировать изменение в виде
последовательностей, которые представляют картины изменения во времени
систем, подвергаемых моделированию. С этой целью мы вводим новую
структуру данных, называемую (@newterm{stream}). С абстрактной точки зрения, поток
--- это просто последовательность. Однако, как мы увидим, прямое
представление потоков в виде списков (как в @ref{2.2.1}) не
полностью раскрывает мощь работы с потоками. В качестве альтернативы мы
введем метод (@newterm{delayed evaluation}), который позволит нам представлять
очень большие (даже бесконечные) последовательности в виде потоков.

Работа с потоками позволяет моделировать системы, обладающие состоянием,
совершенно не используя присваивание и изменяемые данные. Отсюда есть
важные следствия, как теоретические, так и практические, поскольку мы
приобретаем возможность строить модели, лишенные недостатков, связанных
с присваиванием. С другой стороны, парадигма потоков вызывает свои
собственные трудности, и вопрос, какой из методов моделирования ведет к
построению более модульных и легко поддерживаемых систем, остается
открытым.

@menu
* 3-5-1::            Потоки как задержанные списки
* 3-5-2::            Бесконечные потоки
* 3-5-3::            Использование парадигмы потоков
* 3-5-4::            Потоки и задержанное вычисление
* 3-5-5::            Модульность функциональных программ и модульность
                     объектов
@end menu

@comment @subsection Streams Are Delayed Lists
@subsection Потоки как задержанные списки
@node	3.5.1, 3.5.2, 3.5, 3.5

Как мы видели в @ref{2.2.3},
последовательности можно использовать как стандартные интерфейсы для
комбинирования программных модулей. Мы сформулировали мощные абстракции
для работы с последовательностями, такие как @code{map}, @code{filter} и
@code{accumulate}, с помощью которых можно описать широкий класс
действий одновременно коротко и изящно.

К сожалению, если представлять последовательности в виде списков, за это
изящество приходится расплачиваться чрезвычайной неэффективностью как с
точки зрения времени, так и с точки зрения объема памяти, который
требуется нашим вычислениям. Когда мы представляем операции над
последовательностями в виде трансформаций списков, программам приходится
на каждом шагу строить и копировать структуры данных (которые могут быть
громадными).

Чтобы понять, почему это так, сравним две программы для вычисления суммы
всех простых чисел на интервале. Первая программа написана в стандартном
итеративном стиле:@footnote{Мы предполагаем, что у нас имеется предикат
@code{prime?} (например, из @ref{1.2.6}), который проверяет, является ли
число простым.}

@lisp
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count)
             (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
@end lisp

@noindent
Вторая программа производит то же самое вычисление с помощью операций
над последовательностями из @ref{2.2.3}:

@lisp
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime?
                      (enumerate-interval a b))))
@end lisp

@noindent
Во время вычисления первая программа должна хранить только накапливаемую
сумму. Напротив, фильтр во второй программе не может начать тестировать,
пока @code{enumerate-interval} не создала полного списка чисел на
интервале. Фильтр порождает еще один список, который, в свою очередь,
передается @code{accumulate}, прежде, чем он сожмется в сумму. Первой
программе не требуется такого количества промежуточной памяти, --- мы
можем считать, что она просто проходит интервал снизу вверх, добавляя к
сумме каждое простое число, которое ей встретится.

Неэффективность использования списков становится болезненно очевидной,
если мы воспользуемся парадигмой последовательностей для вычисления
второго простого числа в интервале от 1000 до 1 000 000 при помощи
следующего выражения:

@lisp
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
@end lisp

@noindent
Это выражение находит второе простое число, однако на это затрачивается
возмутительное количество вычислительных ресурсов. Мы строим список из
почти миллиона целых чисел, фильтруем этот список, проверяя каждый его
элемент на простоту, а затем почти весь результат игнорируем. При более
традиционном программистском подходе мы бы чередовали перечисление и
фильтрацию, и остановились бы по достижении второго простого числа.

Потоки представляют собой прием, который дает возможность работать с
последовательностями и при этом ничего не терять на представлении
последовательностей в виде списков. Потоки сочетают лучшее из обоих
подходов: мы можем изящно формулировать программы в терминах операций с
последовательностями и при этом сохранять эффективность пошагового
вычисления. Основная идея состоит в том, чтобы строить список только
частично и передавать частично построенный список программе,
потребляющей поток. Если потребитель запросит доступ к той части потока,
которая еще не сконструирована, поток автоматически достроит ровно такую
часть себя самого, какая нужна, и сохранит таким образом иллюзию, что он
существует целиком. Другими словами, хотя программы будут писаться так,
как будто обрабатываются полные последовательности, мы так спроектируем
реализацию потоков, что построение потока будет автоматически и
незаметно для пользователя чередоваться с его использованием.

На первый взгляд, потоки --- это просто списки, у которых процедуры
работы с ними переименованы. Имеется конструктор, @code{cons-stream}, и
два селектора, @code{stream-car} и @code{stream-cdr}, причем выполняются
уравнения

@lisp
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
@end lisp

@noindent
Имеется специальный объект, @code{the-empty-stream}, который не может
быть результатом никакой операции @code{cons-stream}, и который можно
распознать процедурой @code{stream-null?}.@footnote{В реализации MIT
@code{the-empty-stream} совпадает с пустым списком @code{'()}, а
процедура @code{stream-null?} совпадает с @code{null?}.} Таким образом,
можно создавать и использовать потоки, точно так же, как списки, для
представления составных данных, организованных в виде последовательности.
В частности, можно построить потоковые аналоги операций со списками из
@ref{Глава 2},
таких, как @code{list-ref}, @code{map} и @code{for-each}:@footnote{Здесь
у Вас должно возникнуть беспокойство. То, что мы определяем столь
сходные процедуры для потоков и списков, показывает, что мы упускаем
некую глубинную абстракцию. К сожалению, чтобы использовать эту
абстракцию, нам нужно более точное управление процессом вычисления, чем
у нас сейчас есть. Мы подробнее обсудим этот вопрос в конце @ref{3.4.5}.
В @ref{4.2} мы разработаем среду, в которой списки и потоки объединяются.}

@lisp
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
@end lisp

@noindent
С помощью @code{stream-for-each} потоки можно печатать:

@lisp
(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))
@end lisp

@noindent
Чтобы заставить реализацию потоков автоматически и незаметно чередовать
построение потока с его использованием, мы сделаем так, чтобы @code{cdr}
потока вычислялся тогда, когда к нему обращается процедура
@code{stream-cdr}, а не тогда, когда поток создается процедурой
@code{cons-stream}. Такое проектное решение заставляет вспомнить
обсуждение рациональных чисел в @ref{2.1.2}, где мы
увидели, что можно приводить рациональные числа к наименьшему
знаменателю либо во время создания числа, либо во время обращения к
нему. Две реализации рациональных чисел предоставляют одну и ту же
абстракцию, однако наш выбор влияет на эффективность работы. Существует
подобная связь и между потоками и обычными списками. В качестве
абстракции данных потоки не отличаются от списков. Разница состоит в
том, когда вычисляются их элементы. В обычных списках и @code{car}, и
@code{cdr} вычисляются во время построения. У потоков @code{cdr}
вычисляется при обращении.

Наша реализация потоков основана на особой форме под названием
@code{delay}. Выполнение не вычисляет
@code{(delay @math{\langle}@var{выражение}@math{\rangle})},
а вместо этого возвращает так называемый (@newterm{delayed object}).
Мы можем считать, что это <<обещание>>
вычислить @code{выражение} когда-нибудь в будущем. В качестве пары к
@code{delay} имеется процедура @code{force}, которая берет задержанный
объект в качестве аргумента и вычисляет его --- фактически, заставляя
@code{delay} выполнить обещание. Ниже мы увидим, как можно реализовать
@code{delay} и @code{force}, но сначала давайте посмотрим, как с их
помощью строить потоки.

@code{cons-stream} --- это особая форма, такая, что

@lisp
(cons-stream @math{\langle}@var{a}@math{\rangle} @math{\langle}@var{b}@math{\rangle})
@end lisp

@noindent
эквивалентно

@lisp
(cons @math{\langle}@var{a}@math{\rangle} (delay @math{\langle}@var{b}@math{\rangle}))
@end lisp

@noindent
Это означает, что мы строим потоки при помощи пар. Однако вместо того,
чтобы поместить значение остатка потока в @code{cdr} пары, мы кладем
туда обещание вычислить остаток, если нас об этом попросят. Теперь можно
определить @code{stream-car} и @code{stream-cdr} как процедуры:

@lisp
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
@end lisp

@noindent
@code{stream-car} возвращает @code{car} пары. @code{stream-cdr} берет
@code{cdr} пары и вычисляет хранящееся там задержанное выражение, чтобы
получить остаток потока.@footnote{В отличие от @code{stream-car} и
@code{stream-cdr}, которые можно определить в виде процедур,
@code{cons-stream} обязан быть особой формой. Если бы он был процедурой,
то, согласно нашей модели вычислений, выполнение
@code{(cons-stream @math{\langle} a @math{\rangle} @math{\langle} b @math{\rangle})} автоматически
приводило бы к вычислению @emph{@math{\langle}b@math{\rangle}}, а именно
этого мы и не хотим. По этой же причине @code{delay} должен быть особой
формой, хотя @code{force} может оставаться обычной процедурой.}

@comment @subsubheading The stream implementation in action
@subsubheading Реализация потоков в действии

Чтобы посмотреть, как ведет себя эта реализация, давайте проанализируем
<<возмутительное>> вычисление с простыми числами, переформулированное
через потоки:

@lisp
(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval
                  10000 1000000))))
@end lisp

@noindent
Мы увидим, что теперь вычисления происходят эффективно.

Вначале зовется процедура @code{stream-enumerate-interval} с аргументами
1,000 и 1,000,000. @code{Stream-enumerate-interval} --- это потоковый
аналог процедуры @code{enumerate-interval} (@ref{2.2.3}):

@lisp
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
@end lisp

@noindent
и, таким образом, результат, возвращаемый
@code{stream-enumerate-interval}, сформированный @code{cons-stream}
внутри нее, равен@footnote{Показанные здесь числа на самом деле не
появляются в возвращаемом выражении. Возвращается исходное выражение
вместе с окружением, в котором переменным присвоены соответствующие
значения. Например, там, где напечатано число 10001, стоит
@code{(+ low 1)}, и переменная @code{low} связана со значением 10,000.}

@lisp
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
@end lisp

@noindent
А именно, @code{stream-enumerate-interval} возвращает поток,
представленный в виде пары, @code{car} которой равен 10,000, а @code{cdr}
является обещанием вычислить остаток интервала, когда попросят. Теперь
этот поток отфильтровывается на предмет поиска простых чисел с помощью
потокового аналога процедуры @code{filter} (@ref{2.2.3}):

@lisp
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter
                       pred
                       (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
@end lisp

@noindent
@code{stream-filter} проверяет @code{stream-car} потока (то есть
@code{car} пары, то есть 10000). Поскольку это не простое число,
@code{stream-filter} смотрит на @code{stream-cdr} своего входного
потока. Вызов @code{stream-cdr} приводит к вычислению задержанного
вызова @code{stream-enumerate-interval}, возвращающего

@lisp
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
@end lisp

@noindent
Теперь @code{stream-filter} смотрит на @code{stream-car} этого потока,
10,001, видит, что и это не простое число, снова зовет @code{stream-cdr}
и так далее, пока @code{stream-enumerate-interval} не выдаст простое
число 10007. Тогда @code{stream-filter}, в соответствии со своим
определением, вернет

@lisp
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
@end lisp

@noindent
что в данном случае равняется

@lisp
(cons 10007
      (delay (stream-filter
              prime?
              (cons 10008
                    (delay (stream-enumerate-interval
                            10009
                            1000000))))))
@end lisp

@noindent
Теперь этот результат передается в @code{stream-cdr} из нашего исходного
выражения. При этом вызывается задержанный @code{stream-filter},
который, в свою очередь, вынуждает задержанные вызовы
@code{stream-enumerate-interval}, пока не доберется до следующего
простого числа, а именно 10,009. Наконец, результат, передаваемый в
@code{stream-car} нашего исходного выражения, равен

@lisp
(cons 10009
      (delay (stream-filter
              prime?
              (cons 10010
                    (delay (stream-enumerate-interval
                            10011
                            1000000))))))
@end lisp

@noindent
@code{stream-car} возвращает 10,009, и вычисление закончено. На простоту
было проверено ровно столько чисел, сколько было необходимо, чтобы найти
второе простое число на интервале, и сам интервал был перебран только до
того места, которое было нужно фильтру простых чисел.

В общем, мы можем считать задержанные вычисления программированием,
<<управляемым потребностями>>, в котором каждый шаг вычислений в
потоковом процессе активизируется лишь настолько, насколько это нужно
для следующего шага. Таким образом, нам удалось отделить реальный
порядок событий при вычислении от внешней структуры процедур. Мы пишем
процедуры так, как будто потоки существуют <<все целиком>>, а на самом
деле вычисление происходит пошагово, как и при программировании в
традиционном стиле.

@comment @subsubheading Implementing @code{delay} and @code{force}
@subsubheading Реализация @code{delay} и @code{force}

@code{delay} и @code{force} могут казаться таинственными операциями, но
на самом деле их реализация весьма проста. @code{delay} должно упаковать
выражение так, чтобы потом его можно было выполнить по требованию, и мы
добиваемся этого, просто рассматривая выражение как тело процедуры.
Можно сделать @code{delay} особой формой, такой, чтобы

@lisp
(delay @math{\langle}@var{выражение}@math{\rangle})
@end lisp

@noindent
было синтаксическим сахаром для

@lisp
(lambda () @math{\langle}@var{выражение}@math{\rangle})
@end lisp

@noindent
@code{force} просто вызывает (безаргументную) процедуру, порожденную
@code{delay}, так что она может быть реализована как процедура

@lisp
(define (force delayed-object) (delayed-object))
@end lisp

@noindent
При такой реализации и @code{force} работают согласно описанию, однако к
ней можно добавить важную оптимизацию. Во многих приложениях мы
вынуждаем один и тот же задержанный объект по многу раз. В рекурсивных
программах с использованием потоков это может привести к существенной
неэффективности (см. упражнение @ref{Упражнение 3.57}). Решение
состоит в том, чтобы строить задержанные объекты так, чтобы при первом
вынуждении они сохраняли вычисленное значение. Последующие обращения
будут просто возвращать сохраненное значение без повторения вычислений.
Другими словами, мы реализуем @code{delay} как особого рода
мемоизированную процедуру, подобную описанным в
упражнении @ref{Упражнение 3.27}. Один из способов этого добиться ---
использовать следующую процедуру, которая принимает процедуру (без
аргументов) и возвращает ее мемоизированную версию. При первом вызове
мемоизированная процедура сохраняет результат. При последующих вызовах
она просто его возвращает.

@lisp
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
@end lisp

@noindent
Теперь можно определить @code{delay} таким образом, что
@code{(delay @math{\langle}@var{выражение}@math{\rangle})} равносильно

@lisp
(memo-proc (lambda () @math{\langle}@var{exp}@math{\rangle}))
@end lisp

@noindent
а определение @code{force} не меняется.@footnote{Есть много возможных
реализаций потоков помимо описанной в этом разделе. Задержанное
вычисление, ключевой элемент, который делает потоки практически
полезными, было частью метода передачи параметров @emph{по имени} (by
name) в языке Алгол-60. Использование этого механизма для реализации
потоков впервые было описано Ландином (Landin 1965). Задержанное
вычисление для потоков ввели в Лисп Фридман и Уайз (Friedman and Wise
1976). В их реализации @code{cons} всегда задерживает вычисление своих
аргументов, так что списки автоматически ведут себя как потоки.
Мемоизирующая оптимизация известна также как (@newterm{call-by-need}).
В сообществе программистов на Алголе задержанные объекты из нашей первой
реализации назывались бы (@newterm{call-by-name thunks}), а
оптимизированный вариант (@newterm{call-by-need thunks}).}

@quotation
@strong{@anchor{Упражнение 3.50}Упражнение 3.50:}
Закончите следующее определение, которое обобщает процедуру
@code{stream-map}, чтобы она позволяла использовать процедуры от
нескольких аргументов, подобно @code{map} из @ref{2.2.1}, сноска @ref{Сноска 2.12}.

@lisp
(define (stream-map proc . argstreams)
  (if (@math{\langle}??@math{\rangle} (car argstreams))
      the-empty-stream
      (@math{\langle}??@math{\rangle}
       (apply proc (map @math{\langle}??@math{\rangle} argstreams))
       (apply stream-map
              (cons proc (map @math{\langle}??@math{\rangle} argstreams))))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.51}Упражнение 3.51:}
Чтобы внимательнее изучить задержанные вычисления, мы
воспользуемся следующей процедурой, которая печатает свой аргумент, а
затем возвращает его:

@lisp
(define (show x)
  (display-line x)
  x)
@end lisp

Что печатает интерпретатор в ответ на каждое выражение из следующей
последовательности?@footnote{Упражнения типа @ref{Упражнение 3.51} и
@ref{Упражнение 3.52} помогают понять, как работает @code{delay}. С
другой стороны, смешение задержанного вычисления с печатью --- или, хуже
того, с присваиванием, --- ужасно запутывает, и преподаватели, читающие
курсы по языкам программирования, часто пытают студентов
экзаменационными вопросами вроде упражнений из этого раздела. Незачем и
говорить, что писать программы, зависящие от таких тонкостей, ---
показатель чрезвычайно плохого стиля. Отчасти мощность потокового
программирования в том и заключается, что можно игнорировать порядок, в
котором на самом деле происходят события в программах. К сожалению,
ровно этого мы и не можем себе позволить в присутствии присваивания,
заставляющего нас думать о времени и изменении.}

@lisp
(define x
  (stream-map show
              (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.52}Упражнение 3.52:}
Рассмотрим последовательность выражений

@lisp
(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
(stream-ref y 7)
(display-stream z)
@end lisp

Каково значение @code{sum} после вычисления каждого из этих выражений?
Что печатается при вычислении выражений @code{stream-ref} и
@code{display-stream}? Изменился бы этот результат, если бы мы
реализовали @code{(delay @math{\langle}@var{выражение}@math{\rangle})}
просто как @code{(lambda () @math{\langle}@var{выражение}@math{\rangle})},
не применяя оптимизацию через @code{memo-proc}? Объясните свой ответ.
@end quotation

@comment @subsection Infinite Streams
@subsection Бесконечные потоки
@node	3.5.2, 3.5.3, 3.5.1, 3.5

Мы видели, как можно поддерживать иллюзию работы с потоками как с
цельными объектами, хотя на самом деле мы вычисляем только ту часть
потока, к которой нам требуется доступ. Этот метод можно использовать,
чтобы эффективно представлять последовательности в виде потоков, даже
если эти последовательности весьма длинны. Еще удивительнее то, что при
помощи потоков можно представлять последовательности бесконечной длины.
Рассмотрим, например, следующее определение потока положительных целых
чисел:

@lisp
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
@end lisp

@noindent
Такая запись имеет смысл, потому что описывает @code{integers} как пару,
у которой @code{car} равен 1, а @code{cdr} является обещанием породить
целые числа, начиная с 2. Такой поток бесконечен, но в любой данный
момент мы можем работать только с конечной его частью. Таким образом,
наши программы никогда не узнают, что целиком бесконечного потока не
существует.

При помощи @code{integers} можно определять другие бесконечные потоки,
например, поток чисел, не делящихся на 7:

@lisp
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
@end lisp

@noindent
Теперь мы можем искать числа, не делящиеся на 7, просто обращаясь к
элементам этого потока:

@lisp
(stream-ref no-sevens 100)
@i{117}
@end lisp

@noindent
По аналогии с @code{integers}, можно определить бесконечный поток чисел
Фибоначчи:

@lisp
(define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
(define fibs (fibgen 0 1))
@end lisp

@noindent
@code{fibs} представляет собой пару, @code{car} которой равен 0, а
@code{cdr} является обещанием вычислить @code{(fibgen 1 1)}. Когда мы
выполняем это задержанное @code{(fibgen 1 1)}, оно порождает пару, где
@code{car} равен 1, а в @code{cdr} лежит обещание вычислить
@code{(fibgen 1 2)}, и так далее.

Чтобы продемонстрировать пример более интересного потока, можно обобщить
@code{no-sevens} и построить бесконечный поток простых чисел, используя
метод, известный как (@newterm{sieve of Eratosthenes}).@footnote{Эратосфен,
греческий философ третьего века до н. э. из Александрии, знаменит тем,
что он дал первую верную оценку длины окружности Земли, которую он
вычислил, наблюдая тени, отбрасываемые в полдень летнего солнцестояния.
Метод решета Эратосфена, несмотря на свою древность, лежал в основе
специальных аппаратных устройств-<<решет>>, которые до недавних пор были
самыми мощными устройствами для поиска простых чисел. Однако начиная с
70-х годов такие устройства были вытеснены развитием вероятностных
методик, обсуждаемых в @ref{1.2.6}.}
Сначала мы строим поток чисел, начиная с 2, первого простого числа. Для
того, чтобы найти остальные простые числа, мы фильтруем кратные двойки
из потока остальных чисел. Получается поток, который начинается с 3,
следующего простого числа. Теперь из остатка потока мы фильтруем числа,
кратные 3. Получается поток, начинающийся с 5, следующего простого, и
так далее. Другими словами, мы строим простые числа с помощью
просеивающего процесса, описываемого так: чтобы просеять поток @math{S},
нужно сформировать поток, в котором первый элемент совпадает с первым
элементом @math{S}, а остаток получается фильтрацией множителей первого
элемента из оставшейся части @math{S} и просеивания того, что получится.
Такой процесс нетрудно описать в терминах операций над потоками:

@lisp
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))
@end lisp

@noindent
Теперь, чтобы найти определенное простое число, надо только попросить:

@lisp
(stream-ref primes 50)
@i{233}
@end lisp

@noindent
Интересно представить себе систему обработки сигналов, соответствующую
@code{sieve}, показанную на <<хендерсоновской диаграмме>> на
@ref{Рисунок 3.31}.@footnote{Мы назвали этот способ
изображения потоков в честь Питера Хендерсона, который первым показал
нам диаграммы такого вида как способ рассуждений об обработке потоков.
Сплошные линии представляют потоки передаваемых сигналов. Прерывистая
линия от @code{car} к @code{cons} и @code{filter} указывает, что здесь
передается не поток, а единичное значение.} Входной поток попадает в
<<рас@code{cons}ер>>, который отделяет первый элемент потока от его
хвоста. При помощи первого элемента строится фильтр на делимость, и
через него пропускается остаток входного потока, а выход запускается в
еще один элемент @code{sieve}. Затем исходный первый элемент сочетается
при помощи @code{cons} с выходом внутреннего @code{sieve}, и получается
выходной поток. Таким образом, не только входной поток бесконечен, но и
обработчик сигналов также бесконечен, поскольку одно решето содержит в
себе другое.

@float
@c @quotation
@anchor{Рисунок 3.31}
@ifinfo
@strong{Рисунок 3.31:} The prime sieve viewed as a signal-processing system.

@example
  +---------------------------------------------------------------+
  | sieve                                                         |
  |                                                               |
  |        __/|                                        |\__       |
  |     __/car|........................................|   \__    |
  |   _/      |           :                            |      \_  |
----><_       |           V                            |  cons _>---->
  |    \__    |    +------------+    +------------+    |    __/   |
  |       \cdr|--->| filter:    |    | sieve      |--->| __/      |
  |          \|    |            |--->|            |    |/         |
  |                | not        |    |            |               |
  |                | divisible? |    |            |               |
  |                +------------+    +------------+               |
  +---------------------------------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.31,111mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 3.31:} The prime sieve viewed as a signal-processing system.}
@center @caption{@strong{Рисунок 3.31:} Решето для поиска простых чисел в виде системы обработки сигналов.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@comment @subsubheading Defining streams implicitly
@subsubheading Неявное определение потоков

Потоки @code{integers} и @code{fibs} были определены при помощи
<<порождающих>> процедур, которые явным образом вычисляют элементы
потока один за другим. Однако можно определять потоки неявно, пользуясь
задержанным вычислением. Например, следующее выражение определяет
@code{ones} как бесконечный поток, состоящий из одних единиц:

@lisp
(define ones (cons-stream 1 ones))
@end lisp

@noindent
Это выражение работает примерно так же, как рекурсивная процедура:
@code{ones} является парой, чей @code{car} есть 1, а @code{cdr}
представляет собой обещание вычислить @code{ones}. Обращение к
@code{cdr} дает нам снова 1 и обещание вычислить @code{ones}, и так далее.

Можно делать и более интересные вещи с помощью операций вроде
@code{add-streams}, которая порождает поэлементную сумму двух данных
потоков:@footnote{Здесь используется обобщенная версия @code{stream-map}
из упражнения @ref{Упражнение 3.50}.}

@lisp
(define (add-streams s1 s2) (stream-map + s1 s2))
@end lisp

@noindent
Теперь можно определить поток целых чисел следующим образом:

@lisp
(define integers
  (cons-stream 1 (add-streams ones integers)))
@end lisp

@noindent
Здесь @code{integers} определяются как поток, в котором первый элемент
1, а остаток равен сумме @code{ones} и @code{integers}. Таким образом,
второй элемент @code{integers} равен 1 плюс первый элемент
@code{integers}, то есть 2; третий элемент равен 1 плюс второй элемент
@code{integers}, то есть 3, и так далее. Это определение работает
потому, что в любой момент сгенерировано достаточно элементов потока
@code{integers}, чтобы мы могли обратиться к ним в определении и
породить следующий элемент.

В том же стиле можно определить числа Фибоначчи:

@lisp
(define fibs
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
@end lisp

@noindent
Это определение говорит, что @code{fibs} есть поток, начинающийся с 0 и
1, такой, что остаток потока порождается сложением @code{fibs} с собой
самим, сдвинутым на одну позицию:

@lisp
      1  1  2  3  5  8   13  21  @dots{}  =  @code{(stream-cdr fibs)}
      0  1  1  2  3  5   8   13  @dots{}  =  @code{fibs}
0  1  1  2  3  5  8  13  21  34  @dots{}  =  @code{fibs}
@end lisp

@noindent
Еще одна полезная процедура для подобных определений потоков ---
@code{scale-stream}. Она умножает каждый элемент потока на данную
константу:

@lisp
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream))
@end lisp

@noindent
Например,

@lisp
(define double (cons-stream 1 (scale-stream double 2)))
@end lisp

@noindent
порождает поток степеней двойки: 1, 2, 4, 8, 16, 32 @dots{}

Можно дать альтернативное определение потока простых чисел, начав с
потока целых чисел, и фильтруя его через проверку на простоту. Вначале
нам потребуется первое простое число, 2:

@lisp
(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
@end lisp

@noindent
Это определение не столь тривиально, как кажется, поскольку мы будем
проверять число @math{n} на простоту, проверяя, делится ли @math{n} на
простые числа (а не на все целые), меньшие или равные @math{\sqrt{n}}:

@lisp
(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
@end lisp

@noindent
Это рекурсивное определение, поскольку @code{primes} определяются
посредством предиката @code{prime?}, а он сам использует поток
@code{primes}. Работает эта процедура потому, что в любой момент имеется
достаточно элементов потока @code{primes} для проверки на простоту
следующего требуемого числа. А именно, при проверке @code{n} либо
оказывается не простым (а в таком случае имеется уже сгенерированное
простое число, на которое оно делится), либо оно простое (а в таком
случае, имеется уже сгенерированное простое число --- то есть, простое
число меньше @math{n}, --- большее @math{\sqrt{n}}.@footnote{Это тонкая
деталь, которая основана на том, что @math{p_{n+1} \le p_{n}^2} (Здесь
@math{p_k} обозначает @math{k}-е простое число.) Такие оценки достаточно
трудно доказать. Античное доказательство Евклида показывает, что имеется
бесконечное количество простых чисел, и что
@math{p_{n+1} \le p_1 p_2 \cdots p_n + 1}. Никакого существенно лучшего
результата не было найдено до 1851 года, когда русский математик
П. Л. Чебышев доказал, что для всех @math{n}, @math{p_{n+1} \le 2p_n}.
Предположение, что это так, было высказано в 1845 году и известно как
(Bertrand's hypothesis). Доказательство можно найти в разделе 22.3 в
книге Hardy and Wright 1960.}

@quotation
@strong{@anchor{Упражнение 3.53}Упражнение 3.53:}
Не запуская программу, опишите элементы потока, порождаемого

@lisp
(define s (cons-stream 1 (add-streams s s)))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.54}Упражнение 3.54:}
Определите процедуру @code{mul-streams}, аналогичную
@code{add-streams}, которая порождает поэлементное произведение двух
входных потоков. С помощью нее и потока @code{integers} закончите
следующее определение потока, @math{n}-й элемент которого (начиная с 0)
равен факториалу @math{n+1}:

@lisp
(define factorials
  (cons-stream 1 (mul-streams @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp
@c @noindent
@c @code{(define factorials (cons-stream 1 (mul-streams}@math{\kern0.7ex\langle}@code{?}@math{\rangle}@math{\kern0.7ex\langle}@code{?}@math{\rangle}@code{)))}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.55}Упражнение 3.55:}
Определите процедуру @code{partial-sums}, которая в
качестве аргумента берет поток @math{S}, а возвращает поток, элементы
которого равны @math{S_0, S_0 + S_1, S_0 + S_1 + S_2, \ldots}. Например,
@code{(partial-sums integers)} должно давать поток 1, 3, 6, 10, 15 @dots{}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.56}Упражнение 3.56:}
Существует знаменитая задача, впервые сформулированная
Р. Хэммингом: породить в возрастающем порядке и без повторений все
положительные целые числа, у которых нет других простых делителей, кроме
2, 3 и 5. Очевидное решение состоит в том, чтобы перебирать все
натуральные числа по очереди и проверять, есть ли у них простые
множители помимо 2, 3 и 5. Однако эта процедура весьма неэффективна,
поскольку чем больше числа, тем меньшая их доля соответствует условию.
Применим альтернативный подход: назовем искомый поток чисел @code{S} и
обратим внимание на следующие факты:

@itemize @bullet

@item
@code{S} начинается с 1.

@item
Элементы @code{(scale-stream S 2)} также принадлежат @code{S}

@item
То же верно и для @code{(scale-stream S 3)} и @code{(scale-stream S 5)}.

@item
Других элементов @code{S} нет.

@end itemize

Теперь требуется только соединить элементы из этих источников. Для этого
мы определяем процедуру @code{merge}, которая сливает два упорядоченных
потока в один упорядоченный поток, убирая при этом повторения:

@lisp
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream
                   s2car
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))
@end lisp

Тогда требуемый поток можно получить с помощью @code{merge} таким
образом:

@lisp
(define S (cons-stream 1 (merge @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp

Заполните пропуски в местах, обозначенных знаком @math{\langle}??@math{\kern0.08em\rangle}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.57}Упражнение 3.57:}
Сколько сложений происходит при вычислении @math{n}-го
числа Фибоначчи, в случае, когда мы используем определение @math{fibs}
через процедуру @code{add-streams}? Покажите, что число сложений выросло
бы экспоненциально, если бы мы реализовали
@code{(delay @math{\langle}@var{выражение}@math{\rangle})} просто как
@code{(lambda () @math{\langle}@var{выражение}@math{\rangle})}, без
оптимизации через процедуру @code{memo-proc} из @ref{3.5.1}.@footnote{Это
упражнение показывает, как близко связан вызов по необходимости с обычной
мемоизацией, описанной в @ref{Упражнение 3.27}. В этом
упражнении мы при помощи присваивания явным образом создавали локальную
таблицу. Наша оптимизация с вызовом по необходимости, в сущности,
автоматически создает такую же таблицу, сохраняя значения в уже
размороженных частях потока.}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.58}Упражнение 3.58:}
Дайте интерпретацию потоку, порождаемому следующей процедурой:

@lisp
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
@end lisp

(Элементарная процедура @code{quotient} возвращает целую часть частного
двух целых чисел.) Каковы последовательные элементы потока, порожденного
выражением @code{(expand 1 7 10)}? Что дает вычисление @code{(expand 3 8 10)}?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.59}Упражнение 3.59:} В @ref{2.5.3} мы
увидели, как реализовать систему арифметики многочленов, используя
представление многочленов в виде списка термов. Подобным же образом
можно работать со (@newterm{power series}), например
@ifinfo

@example
               x^2     x^3       x^4
e^x = 1 + x + ----- + ----- + --------- + ...
                2     3 * 2   4 * 3 * 2

             x^2       x^4
cos x = 1 - ----- + --------- - ...
              2     4 * 3 * 2

             x^3         x^5
sin x = x - ----- + ------------- - ...
            3 * 2   5 * 4 * 3 * 2
@end example

@end ifinfo
@tex
$$
e^x = 1 + x + \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} + \dots,
$$
@end tex
@tex
$$
\cos x = 1 - \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} - \dots,
$$
@end tex
@tex
$$
\sin x = x - \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^5}{5 \cdot 4 \cdot 3 \cdot 2} - \dots
$$
@end tex
@noindent
представленными в виде бесконечных потоков. Будем
представлять последовательность
@math{a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots} как поток, элементами
которого являются коэффициенты @math{a_0, a_1, a_2, a_3 \ldots}

@enumerate a.

@item
Интеграл последовательности
@math{a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots} есть последовательность
@ifinfo

@example
             1             1             1
c + a_0 x + --- a_1 x^2 + --- a_2 x^3 + --- a_3 x^4 + ...
             2             3             4
@end example

@end ifinfo
@tex
$$ c + a_0 x + {1\over2} a_1 x^2 + {1\over3} a_2 x^3 + {1\over4} a_3 x^4 + \dots, $$
@end tex
@noindent
где @math{c} --- произвольная константа. Определите процедуру
@code{integrate-series}, которая на входе принимает поток
@math{a_0, a_1, a_2,\ldots}, представляющую степенной ряд, и возвращает
поток @math{a_0}, @math{{1\over2}a_1}, @math{{1\over3}a_2}, @dots{}
коэффициентов при неконстантных членах интеграла последовательности.
(Поскольку в результате отсутствует постоянный член, он не представляет
собой степенной ряд; при использовании @code{integrate-series} мы через
@code{cons} будем присоединять к началу соответствующую константу.)

@item
Функция @math{x \mapsto e^x} равна своей собственной производной. Отсюда
следует, что @math{e^x} и интеграл @math{e^x} суть одна и та же
последовательность, с точностью до постоянного члена, который равен
@math{e^0 = 1}. Соответственно, можно породить последовательность для
@math{e^x} через

@lisp
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
@end lisp

Покажите, как породить последовательности для синуса и косинуса,
опираясь на то, что производная синуса равна косинусу, а производная
косинуса равна минус синусу:

@lisp
(define cosine-series (cons-stream 1 @math{\langle}??@math{\rangle}))
(define sine-series (cons-stream 0 @math{\langle}??@math{\rangle}))
@end lisp
@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 3.60}Упражнение 3.60:}
Если степенной ряд представляется в виде потока своих
коэффициентов, как в упражнении @ref{Упражнение 3.59}, то сумма
последовательностей реализуется посредством @code{add-streams}.
Завершите определение следующей процедуры для перемножения
последовательностей:

@lisp
(define (mul-series s1 s2)
  (cons-stream @math{\langle}??@math{\rangle} (add-streams @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp

Можете проверить свою процедуру, убедившись, что
@math{\sin^2 x + \cos^2 x = 1} с помощью последовательностей из
@ref{Упражнение 3.59}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.61}Упражнение 3.61:} Пусть @math{S} будет
степенным рядом (упражнение @ref{Упражнение 3.59}) с постоянным членом 1.
Предположим, что мы хотим найти степенной ряд @math{1/S}, то есть такой ряд
@math{X}, что @math{S \cdot X = 1}. Запишем @math{S = 1 + S_R}, где
@math{S_R} --- часть @math{S} после постоянного члена. Тогда мы можем
решить уравнение для @math{X} так:
@ifinfo

@example
        S * X = 1
(1 + S_R) * X = 1
  X + S_R * X = 1
            X = 1 - S_R * X
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
            S \cdot X 	& 1, \\
    (1 + S_R) \cdot X 	& 1, \\
      X + S_R \cdot X 	& 1, \\
                    X 	& 1 - S_R \cdot X.
\end{array}
$$
@end tex
Другими словами, @math{X} есть степенной ряд с постоянным
членом 1, чьи члены с более высокими степенями определяются как минус
произведение @math{S_R} и @math{X}. Воспользовавшись этим, напишите
процедуру @code{invert-unit-series}, которая вычисляет @math{1/S} для
степенного ряда @math{S} с постоянным членом 1. Вам потребуется
@code{mul-series} из упражнения @ref{Упражнение 3.60}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.62}Упражнение 3.62:}
При помощи результатов упражнений @ref{Упражнение 3.60} и
@ref{Упражнение 3.61} определите процедуру @code{div-series}, которая
делит один степенной ряд на другой. @code{Div-series} должна работать
для любых двух рядов, при условии, что ряд в знаменателе начинается с
ненулевого постоянного члена. (Если в знаменателе постоянный член равен
нулю, @code{div-series} должна сообщать об ошибке.) Покажите, как при
помощи @code{div-series} и результата упражнения @ref{Упражнение 3.59}
получить степенной ряд для тангенса.
@end quotation

@endpage
@comment @subsection Exploiting the Stream Paradigm
@subsection Использование парадигмы потоков
@node	3.5.3, 3.5.4, 3.5.2, 3.5

Потоки с задержкой вычисления могут служить мощным инструментом
моделирования. Они дают многие из преимуществ, обычно предоставляемых
внутренним состоянием и присваиванием. Более того, они избегают
некоторых из теоретических неудобств, связанных с введением присваивания
в язык программирования.

Потоковый метод может изменять взгляд на вещи, так как он позволяет
строить системы с другими границами модулей, не такими, как в системах,
основанных на присваивании переменным состояния. Например, можно
сосредоточивать внимание на всей временной последовательности (или
сигнале), а не на значении переменных состояния в отдельные моменты.
Оказывается удобно сочетать и сравнивать параметры состояния в различные
моменты времени.

@comment @subsubheading Formulating iterations as stream processes
@subsubheading Итерация как потоковый процесс

В @ref{1.21}
мы ввели понятие итеративного процесса, по мере исполнения изменяющего
переменные состояния. Теперь мы узнали, что можно представлять состояние
в виде <<вневременного>> потока значений, а не набора обновляемых
переменных. Давайте примем этот взгляд и заново рассмотрим процедуру
поиска квадратного корня из @ref{1.1.7}.
Напомним, что идея процедуры состояла в том, чтобы порождать
последовательность все лучших и лучших приближений к квадратному корню
@math{x}, снова и снова применяя процедуру улучшения гипотезы:

@lisp
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
@end lisp

@noindent
В исходной процедуре @code{sqrt} эти гипотезы были последовательными
значениями переменной состояния. Вместо этого можно породить бесконечный
поток гипотез, в голове которого стоит начальная гипотеза
1:@footnote{Внутреннюю переменную @code{guesses} нельзя связать с помощью
@code{let}, поскольку значение @code{guesses} зависит от нее самой. В
упражнении @ref{Упражнение 3.63} рассматривается вопрос, зачем здесь
нужна внутренняя переменная.}

@lisp
(define (sqrt-stream x)
  (define guesses
    (cons-stream
     1.0
     (stream-map (lambda (guess) (sqrt-improve guess x))
                 guesses)))
  guesses)

(display-stream (sqrt-stream 2))
@i{1.}
@i{1.5}
@i{1.4166666666666665}
@i{1.4142156862745097}
@i{1.4142135623746899}
@dots{}
@end lisp

@noindent
Можно порождать все больше элементов потока, получая все лучшие
приближения. Если нужно, можно написать процедуру, которая бы порождала
гипотезы до тех пор, пока ответ не окажется достаточно хорош.
(См. @ref{Упражнение 3.64}.)

Еще один итеративный процесс, который можно рассматривать подобным
образом --- аппроксимация числа @math{\pi}, основанная на
знакочередующемся ряде, упомянутом в @ref{Section 1.3.1}:
@ifinfo

@example
[pi]        1     1     1
---- = 1 - --- + --- - --- + ...
  4         3     5     7
@end example

@end ifinfo
@tex
$$ {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots. $$
@end tex
Сначала мы порождаем поток элементов ряда (числа, обратные нечетным
натуральным, с чередующимся знаком). Затем мы берем поток сумм все
большего количества элементов (при помощи процедуры @code{partial-sums}
из упражнения @ref{Упражнение 3.55}) и домножаем результат на 4:

@lisp
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

(display-stream pi-stream)
@i{4.}
@i{2.666666666666667}
@i{3.466666666666667}
@i{2.8952380952380956}
@i{3.3396825396825403}
@i{2.9760461760461765}
@i{3.2837384837384844}
@i{3.017071817071818}
@dots{}
@end lisp

@noindent
Получается поток все более точных приближений к @math{\pi}, но сходятся
эти приближения довольно медленно. Восемь членов последовательности
поместили @math{\pi} между 3.284 и 3.017.

Пока что подход с потоком состояний не слишком отличается от потока с
переменными состояния. Однако потоки дают нам возможность проделывать
некоторые интересные трюки. Например, поток можно преобразовать с
помощью (@newterm{sequence accelerator}), преобразующего последовательность
приближений в новую последовательность, которая сходится к тому же
значению, что и исходная, но быстрее.

Один такой ускоритель, открытый швейцарским математиком восемнадцатого
века Леонардом Эйлером, хорошо работает с последовательностями частичных
сумм знакочередующихся рядов (рядов, знаки элементов которых
чередуются). По методу Эйлера, если @math{S_n} есть @math{n}-й член
исходного ряда, то ускоренная последовательность имеет элементы
@ifinfo

@example
             (S_(n+1) - S_n)^2
S_(n+1) - ------------------------
          S_(n-1) - 2S_n + S_(n+1)
@end example

@end ifinfo
@tex
$$ S_{n+1} - {(S_{n+1} - S_n)^2 \over S_{n-1} - 2S_n + S_{n+1}}\,. $$
@end tex
Таким образом, если исходная
последовательность представлена как поток значений, преобразованная
последовательность дается процедурой

@lisp
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))     @r{; @math{S_{n-1}}}
        (s1 (stream-ref s 1))     @r{; @math{S_n}}
        (s2 (stream-ref s 2)))    @r{; @math{S_{n+1}}}
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
@end lisp

@noindent
Можно продемонстрировать ускорение Эйлера на нашей последовательности
приближений к @math{\pi}:

@lisp
(display-stream (euler-transform pi-stream))
@i{3.166666666666667}
@i{3.1333333333333337}
@i{3.1452380952380956}
@i{3.13968253968254}
@i{3.1427128427128435}
@i{3.1408813408813416}
@i{3.142071817071818}
@i{3.1412548236077655}
@dots{}
@end lisp

@noindent
Более того, можно ускорить ускоренную последовательность, рекурсивно
ускорить результат, и так далее. То есть, можно создать поток потоков
(структуру, которую мы будем называть (@newterm{tableau)}), в котором
каждый поток есть результат преобразования предыдущего:

@lisp
(define (make-tableau transform s)
  (cons-stream s (make-tableau transform (transform s))))
@end lisp

@noindent
Табло имеет вид
@ifinfo

@example
s_00   s_01   s_02   s_03   s_04   ...
       s_10   s_11   s_12   s_13   ...
              s_20   s_21   s_22   ...
                            ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ s_{00} $ 	&  $ s_{01} $ 	&  $ s_{02} $ 	&  $ s_{03} $ 	&  $ s_{04} $ 	&  $ \dots $ \cr
		&  $ s_{10} $ 	&  $ s_{11} $ 	&  $ s_{12} $ 	&  $ s_{13} $ 	&  $ \dots $ \cr
		& 		&  $ s_{20} $ 	&  $ s_{21} $ 	&  $ s_{22} $ 	&  $ \dots $ \cr
		& 		& 		&  $ \dots $ 	& 		&  \cr }
} $$
@end tex
Наконец, можно построить последовательность, членами
которой будут первые элементы каждой строки табло:

@lisp
(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))
@end lisp

@noindent
Можно показать, как работает такое <<сверхускорение>> на
последовательности приближений к @math{\pi}:

@lisp
(display-stream
 (accelerated-sequence euler-transform pi-stream))
@i{4.}
@i{3.166666666666667}
@i{3.142105263157895}
@i{3.141599357319005}
@i{3.1415927140337785}
@i{3.1415926539752927}
@i{3.1415926535911765}
@i{3.141592653589778}
@dots{}
@end lisp

@noindent
Результат впечатляет. Восемь членов последовательности дают нам верное
значение @math{\pi} с точностью до 14 десятичных знаков. Если бы у нас
была только исходная последовательность приближений к @math{\pi}, то
пришлось бы вычислить порядка @math{10^{13}} ее элементов (то есть
довести последовательность до такого места, где ее элементы становятся
меньше @math{10^{-13}}), чтобы добиться такой точности!

Все эти методы ускорения можно было бы реализовать и без помощи потоков.
Однако формулировка в терминах потоков обладает особым удобством и
изяществом, поскольку мы имеем доступ ко всей последовательности
состояний в виде структуры данных, с которой можно работать при помощи
единого набора операций.

@quotation
@strong{@anchor{Упражнение 3.63}Упражнение 3.63:}
Хьюго Дум спрашивает, почему нельзя было написать
@code{sqrt-stream} более простым способом, без внутренней переменной
@code{guesses}:

@lisp
(define (sqrt-stream x)
  (cons-stream 1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    (sqrt-stream x))))
@end lisp

Лиза П. Хакер отвечает, что эта версия процедуры значительно менее
эффективна, поскольку производит избыточные вычисления. Объясните Лизин
ответ. Сохранилось бы отличие в эффективности, если бы реализация
@code{delay} использовала только
@code{(lambda () @math{\langle}@var{выражение}@math{\rangle})}, без
оптимизации через @code{memo-proc} (см. @ref{3.5.1})?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.64}Упражнение 3.64:}
Напишите процедуру , которая в качестве аргумента принимает
поток и число (погрешность). Она должна просматривать поток, пока не
найдется два элемента подряд, различающихся меньше, чем на погрешность,
и возвращать второй из этих элементов. При помощи этой процедуры можно
будет вычислять квадратные корни с заданной точностью так:

@lisp
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.65}Упражнение 3.65:}
С помощью ряда
@ifinfo

@example
            1     1     1
ln 2 = 1 - --- + --- - --- + ...
            2     3     4
@end example

@end ifinfo
@tex
$$ \ln 2 = 1 - {1\over2} + {1\over3} - {1\over4} + \dots $$
@end tex
@noindent
породите три последовательности приближений к натуральному логарифму 2,
так же, как мы выше сделали это для @math{\pi}. Как быстро сходятся эти
последовательности?
@end quotation

@comment @subsubheading Infinite streams of pairs
@subsubheading Бесконечные потоки пар

В @ref{2.2.3} мы видели, как парадигма работы с последовательностями
рассматривает вложенные циклы традиционной парадигмы в виде процессов,
определенных на последовательности пар. Если мы обобщим этот метод на
бесконечные потоки, то сможем писать программы, которые трудно воспроизвести
с помощью обычных циклов, поскольку <<цикл>> охватывает бесконечное множество.

Например, пусть нам хочется обобщить процедуру @code{sum-of-primes} из
@ref{2.2.3} так, чтобы получился поток из @emph{всех} пар натуральных чисел
@math{(i,j)}, таких, что @math{i \le j} и @math{i+j} простое. Если
@code{int-pairs} есть последовательность всех пар натуральных чисел
@math{(i,j)}, где @math{i \leq j}, то необходимый нам поток
таков:@footnote{Как и в @ref{2.2.3}, мы представляем пару натуральных
чисел в виде списка, а не лисповской пары.}

@lisp
(stream-filter
 (lambda (pair) (prime? (+ (car pair) (cadr pair))))
 int-pairs)
@end lisp

@noindent
Задача, следовательно, состоит в том, чтобы породить поток @code{int-pairs}.
В более общем случае допустим, что у нас есть два потока @math{S = (S_i)}
и @math{T = (T_j)}, и представим себе бесконечную матрицу
@ifinfo

@example
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
(S_1, T_0)  (S_1, T_1)  (S_1, T_2)  ...
(S_2, T_0)  (S_2, T_1)  (S_2, T_2)  ...
   ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

    $ (S_0, T_0) $ & $ (S_0, T_1) $ & $ (S_0, T_2) $ & $ \dots $ \cr
    $ (S_1, T_0) $ & $ (S_1, T_1) $ & $ (S_1, T_2) $ & $ \dots $ \cr
    $ (S_2, T_0) $ & $ (S_2, T_1) $ & $ (S_2, T_2) $ & $ \dots $ \cr
    $ \dots $ & & & \cr }
} $$
@end tex
Нам хочется породить поток, который содержит все пары из
этой матрицы, лежащие на диагонали или выше, а именно пары
@ifinfo

@example
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
            (S_1, T_1)  (S_1, T_2)  ...
                        (S_2, T_2)  ...
                                    ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
        & $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
        & 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
        & 			& 			& $ \dots $ \cr }
} $$
@end tex
@noindent
(Если мы возьмем и @math{S}, и @math{T} равными потоку
натуральных чисел, то получим как раз необходимый нам поток
@code{int-pairs}.)

Назовем общий поток пар @code{(pairs S T)}, и будем считать, что он
состоит из трех частей: пары @math{(S_0, T_0)}, остатка пар в первом
ряду, и всех остальных пар:@footnote{В упражнении @ref{Упражнение 3.68}
объясняется, почему мы выбрали именно такую декомпозицию.}
@ifinfo

@example
(S_0, T_0) | (S_0, T_1)  (S_0, T_2)  ...
-----------+-----------------------------
           | (S_1, T_1)  (S_1, T_2)  ...
           |             (S_2, T_2)  ...
           |                         ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & \vrule
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
\noalign{\hrule}
        & $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
        & 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
        & 			& 			& $ \dots $ \cr }
} $$
@end tex
Заметим, что третья часть этой декомпозиции (пары, не
лежащие в первом ряду) суть пары, получаемые (рекурсивно) из
@code{(stream-cdr S)} и @code{(stream-cdr T)}. Заметим также, что вторая
часть (остаток первого ряда) есть

@lisp
(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
@end lisp

@noindent
Таким образом, мы можем сформировать наш поток пар так:

@lisp
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (@math{\langle}@var{combine-in-some-way}@math{\rangle}
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t)))))
@end lisp

@noindent
Чтобы закончить определение процедуры, нужно выбрать какой-нибудь способ
смешать два внутренних потока. В голову приходит воспользоваться
потоковым аналогом процедуры @code{append} из @ref{2.2.1}:

@lisp
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
@end lisp

@noindent
Однако эта идея не срабатывает с бесконечными потоками, поскольку,
прежде чем перейти ко второму потоку, нужно пройти весь первый поток до
конца. В частности, если мы попробуем породить все пары натуральных
чисел при помощи

@lisp
(pairs integers integers)
@end lisp

@noindent
то получившийся поток сначала попытается перечислить все пары, где
первый элемент равен 1, а следовательно, никогда не породит ни одной
пары с другим значением первого члена.

Для работы с бесконечными потоками требуется придумать способ смешения,
который гарантировал бы, что каждый элемент будет достигнут, если
программе дать достаточно времени. Изящный способ добиться этого состоит
в том, чтобы воспользоваться следующей процедурой
@code{interleave}:@footnote{Точная формулировка требования, которому
должен удовлетворять порядок слияния, выглядит так: должна существовать
функция от двух аргументов @math{f}, такая, что пара, соответствующая
@math{i}-му элементу первого потока и @math{j}-му элементу второго,
появится в качестве элемента выходного потока под номером @math{f(i,j)}.
Трюк с чередованием через @code{interleave} нам показал Дэвид Тёрнер,
который использовал его в языке KRC (Turner 1981).}

@lisp
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
@end lisp

@noindent
Поскольку @code{interleave} чередует элементы из двух потоков, всякий
элемент второго потока рано или поздно попадет в смешанный поток, даже
если первый поток бесконечен.

Таким образом, мы можем породить требуемый поток пар так:

@lisp
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.66}Упражнение 3.66:}
Рассмотрим поток @code{(pairs integers integers)} Можете ли
Вы что-то сказать о порядке, в котором пары попадают в поток? Например,
сколько приблизительно пар предшествуют паре (1, 100)? Паре (99, 100)?
(100, 100)? (Если Вы способны предоставить точные математические
утверждения, --- прекрасно. Однако если Вы увязаете в деталях,
достаточно качественных оценок.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.67}Упражнение 3.67:}
Измените процедуру так, чтобы
@code{(pairs integers integers)} порождало поток из @emph{всех} пар
натуральных чисел @math{(i,j)}, без дополнительного условия
@math{i \leq j}. Подсказка: потребуется примешать еще один поток.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.68}Упражнение 3.68:}
Хьюго Дум считает, что построение потока пар из трех
частей --- процедура слишком сложная. Он предлагает вместо того, чтобы
отделять пару @math{(S_0, T_0)}, работать с первой строкой целиком:

@lisp
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
@end lisp

Будет ли такой код работать? Посмотрите, что произойдет, если мы
попытаемся вычислить @code{(pairs integers integers)}, используя
определение Хьюго.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.69}Упражнение 3.69:}
Напишите процедуру @code{triples}, которая берет три
бесконечных потока @math{S}, @math{T} и @math{U}, и порождает поток
троек @math{(S_i, T_j, U_k)}, таких, что @math{i \leq j \leq k}. С
помощью @code{triples} породите поток всех Пифагоровых троек натуральных
чисел, т. е. таких троек @math{(i,j,k)}, что @math{i \leq
j} и @math{i^2 + j^2 = k^2}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.70}Упражнение 3.70:}
Интересно было бы уметь порождать потоки в каком-либо
полезном порядке, а не в порядке, задаваемом к случаю придуманным
процессом чередования. Можно воспользоваться методом, подобным процедуре
@code{merge} из упражнения @ref{Упражнение 3.56}, если мы определим
способ сказать, что одна пара целых чисел <<меньше>> другой. Один из
способов состоит в том, чтобы определить <<функцию взвешивания>>
@math{W(i,j)} и постановить, что @math{(i_1, j_1)} меньше, чем
@math{(i_2, j_2)}, если @math{W(i_1, j_1) < W(i_2, j_2)}. Напишите процедуру
@code{merge-weighted}, которая во всем подобна @code{merge}, но только в
качестве дополнительного аргумента принимает процедуру @code{weight},
которая вычисляет вес пары, и используется для определения порядка, в
котором элементы должны появляться в получающемся смешанном
потоке.@footnote{Мы будем требовать от функции взвешивания, чтобы вес
пары возрастал при движении вправо по строке или вниз по столбцу в
матрице пар.} При помощи @code{merge-weighted} напишите процедуру
@code{weighted-pairs}, обобщающую @code{pairs}. Она должна принимать два
потока и процедуру, вычисляющую функцию взвешивания, и порождать поток
пар, упорядоченных по весу. Породите, используя эту процедуру:

@enumerate a.

@item
Поток всех пар натуральных чисел @math{(i,j)} где @math{i \leq j},
упорядоченных по сумме @math{i+j}.

@item
поток всех пар натуральных чисел @math{(i,j)}, где @math{i \leq j}, ни
@math{i}, ни @math{j} не делится ни на 2, ни на 3, ни на 5, и пары
упорядочены по значению суммы @math{2i + 3j + 5ij}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 3.71}Упражнение 3.71:}
Числа, которые можно выразить в виде суммы двух кубов
более, чем одним способом, иногда называют (@newterm{Ramanujan numbers}), в
честь математика Шринивасы Рамануджана.@footnote{Цитата из некролога на смерть
Рамануджана, написанного Г. Х. Харди (Hardy 1921): <<Кажется, это
мистер Литлвуд заметил, что <<каждое натуральное число было ему
другом>>. Я помню, как однажды навестил его, когда он лежал больной в
Путни. Я приехал в такси номер 1729, сказал, что число показалось мне
скучным, и выразил надежду, что это не было несчастливым знаком. <<Нет,
--- ответил он, --- это очень интересное число; это наименьшее число,
которое можно двумя различными способами выразить как сумму двух
кубов>>. Трюк с использованием взвешенных пар для порождения чисел
Рамануджана нам показал Чарльз Лейзерсон.} Упорядоченные потоки пар
предлагают изящное решение для задачи порождения таких чисел. Чтобы
найти число, которое можно двумя разными способами записать в виде суммы
двух кубов, требуется только породить поток пар натуральных чисел
@math{(i,j)}, взвешенных согласно сумме @math{i^3 + j^3}
(см. упражнение @ref{Упражнение 3.70}), и искать в этом потоке две
пары подряд с одинаковым весом. Напишите процедуру для порождения чисел
Рамануджана. Первое такое число 1729. Каковы следующие пять?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.72}Упражнение 3.72:} Используя метод, подобный
описанному в упражнении @ref{Упражнение 3.71}, породите поток всех чисел,
которые можно записать как сумму двух квадратов тремя различными способами (и
покажите, каковы эти способы).
@end quotation

@comment @subsubheading Streams as signals
@subsubheading Потоки как сигналы

Мы начали обсуждение потоков с того, что описали их как вычислительные
аналоги <<сигналов>> в системах обработки сигналов. На самом деле с
помощью потоков такие системы можно моделировать самым непосредственным
образом, представляя значения сигнала в последовательные моменты времени
как последовательные элементы потока. Например, можно реализовать
(@newterm{integrator}), или (@newterm{summer}), который, для входного потока
@math{x = (x_i)}, начального значения @math{C} и малого приращения
времени @math{dt}, собирает сумму
@ifinfo

@example
           i
          ---
S_i = C + >   x_j dt
          ---
          j=1
@end example

@end ifinfo
@tex
$$ S_i = C + \sum_{j=1}^i x_{\kern-0.07em j} \kern0.1em dt $$
@end tex
@noindent
и возвращает поток значений @math{S = (S_i)}. Следующая процедура
@code{integral} напоминает <<неявное>> определение потока целых (@ref{3.5.2}):

@lisp
(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
@end lisp

@noindent
На рисунке @ref{Рисунок 3.32} показана система преобразования
сигналов, соответствующая процедуре @code{integral}. Входной поток
делится на отрезки @math{dt} и пропускается через сумматор, а вывод
сумматора опять направляется на его вход. Ссылка на самого себя в
определении @code{int} отражена на диаграмме в виде цикла обратной
связи, соединяющего выход сумматора с одним из его входов.

@float
@c @quotation
@anchor{Рисунок 3.32}
@ifinfo
@strong{Рисунок 3.32:} The @code{integral} procedure viewed as a signal-processing system.

@example
                             initial-value
                                  |
       +-----------+              |   |\__
input  |           |      |\__    +-->|   \_  integral
------>| scale: dt +----->|   \_      |cons_>--*------->
       |           |      | add_>---->| __/    |
       +-----------+  +-->| __/       |/       |
                      |   |/                   |
                      |                        |
                      +------------------------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.32,102mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 3.32:} The @code{integral} procedure viewed as a signal-processing system.}
@caption{@strong{Рисунок 3.32:} Процедура @code{integral} в виде системы преобразования сигналов}
@sp 0.8
@end iftex
@c @end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.73}Упражнение 3.73:}
Можно моделировать электрические цепи с помощью потоков,
представляющих значения тока или напряжения в определенные моменты
времени. Допустим, например, что у нас имеется (RC circuit), состоящая
из резистора с сопротивлением @math{R} и конденсатора емкостью @math{C},
соединенных последовательно. Значение напряжения @math{v} в зависимости
от заданного тока @math{i} определяется формулой, показанной на
рис. @ref{Рисунок 3.33}. Структура формулы показана на прилагаемой
диаграмме потока сигналов.

@float
@anchor{Рисунок 3.33}
@ifinfo
@strong{Рисунок 3.33:} An RC circuit and the associated signal-flow diagram.

@example
  +        v        -

 ->----'\/\/\,---| |---
  i       R         C


                  / t
               1  |
 v  =  v   +  --- |  i dt  +  R i
        0      C  |
                  / 0

         +--------------+
     +-->|   scale: R   |---------------------+   |\_
     |   +--------------+                     |   |  \_
     |                                        +-->|    \   v
  i  |   +--------------+     +------------+      | add >--->
 ----+-->|  scale: 1/C  |---->|  integral  |----->|   _/
         +--------------+     +------------+      | _/
                                    |             |/
                   v
                    0
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.33,94mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 3.33:} An RC circuit and the associated signal-flow diagram. }@short
@center @caption{@strong{Рисунок 3.33:} RC-цепь и связанная с ней диаграмма потока сигналов.}
@sp 0.9
@end iftex
@end float

Напишите процедуру @code{RC}, моделирующую эту цепь. На входе @code{RC}
должна получать значения @math{R}, @math{C} и @math{dt}, и выдавать
процедуру, которая принимает на входе поток значений тока @math{i} и
начальное значение напряжения @math{v_0}, а на выходе выдает поток
значений напряжения @math{v}. Например, у Вас должна быть возможность
смоделировать при помощи @code{RC} RC-цепь с @math{R = 5} ом,
@math{C = 1} фараде, и временным шагом в 0,5 секунды, вычислив
@code{(define RC1 (RC 5 1 0.5))}. Здесь @code{RC1} определяется как
процедура, которая принимает на входе поток, представляющий временную
последовательность токов, и исходное напряжение на конденсаторе, а на
выходе дает временной поток напряжений.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.74}Упражнение 3.74:}
Лиза П. Хакер разрабатывает систему для обработки
сигналов, приходящих от физических сенсоров. Один из важных
инструментов, который она хочет построить, --- это сигнал, описывающий
(@newterm{zero crossings}). Выходной сигнал должен равняться +1, когда сигнал на
входе меняется с отрицательного на положительный, -1, когда сигнал
меняется с положительного на отрицательный, и 0 в остальных случаях.
(Допустим, что знак нулевого входа положителен). Например, типичный
входной сигнал и связанный с ним сигнал перехода через ноль могут
выглядеть так:

@lisp
@dots{} 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 @dots{}
@dots{} 0 0  0  0  0   -1   0  0  0   0   1  0 0 @dots{}
@end lisp

В Лизиной системе сигнал от сенсора представляется как поток
@code{sense-data}, а @code{zero-crossings} представляет соответствующий
поток пересечений нуля. Для начала Лиза пишет процедуру
@code{sign-change-detector}, которая берет два значения в качестве
аргументов и, сравнив их знаки, выдает 0, 1 или -1. Затем она строит
поток переходов через ноль следующим образом:

@lisp
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream)
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
@end lisp

Мимо проходит Лизина начальница Ева Лу Атор и замечает, что программа
приблизительно равносильна следующей, написанной с использованием
обобщенной версии @code{stream-map} из упражнения @ref{Упражнение 3.50}:

@lisp
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              @math{\langle}@var{выражение}@math{\rangle}))
@end lisp

Завершите программу, вставив необходимое
@math{\langle}@var{выражение}@math{\rangle}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.75}Упражнение 3.75:}
К сожалению, Лизин детектор перехода через ноль из
упражнения @ref{Упражнение 3.74} оказывается недостаточным, потому что
зашумленный сигнал от сенсоров приводит к ложным срабатываниям.
Инженер-электронщик Дайко Поправич предлагает Лизе сгладить сигнал,
чтобы отфильтровать шум, прежде, чем отлавливать пересечение нуля. Лиза
принимает его совет и решает извлечь переходы через ноль из сигнала,
полученного взятием среднего арифметического каждого значения входных
данных с предыдущим значением. Она объясняет задачу своему помощнику
Хьюго Думу, и тот пытается реализовать идею, поправив Лизин текст
следующим образом:

@lisp
(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream)
                    last-value)
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings
      (stream-cdr input-stream) avpt))))
@end lisp

Этот код неверно реализует замысел Лизы. Найдите ошибку, внесенную
Хьюго, и исправьте ее, не меняя структуру программы. (Подсказка:
придется увеличить число аргументов @code{make-zero-crossings}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.76}Упражнение 3.76:}
Ева Лу Атор недовольна подходом Хьюго из
упражнения @ref{Упражнение 3.75}. Написанная им программа не модульна,
поскольку смешивает операции сглаживания и отлова пересечений ноля.
Например, тест на пересечение не должен изменяться, если Лизе удастся
найти другой способ улучшить качество входного сигнала. Помогите Хьюго и
напишите процедуру @code{smooth}, которая берет на входе поток, а на
выходе выдает поток, элементы которого получены усреднением каждых двух
последовательных элементов входного потока. Затем используйте
@code{smooth} как компоненту и реализуйте детектор перехода через ноль в
более модульном стиле.
@end quotation

@comment @subsection Streams and Delayed Evaluation
@subsection Потоки и задержанное вычисление
@node	3.5.4, 3.5.5, 3.5.3, 3.5

Процедура @code{integral} в конце предыдущего раздела показывает, как с
помощью потоков можно моделировать системы обработки сигналов, которые
содержат циклы обратной связи. Цикл обратной связи для сумматора,
показанный на рис. @ref{Рисунок 3.32}, моделируется тем, что
внутренний поток @code{int} в процедуре @code{integral} определяется с
использованием себя самого:

@lisp
(define int
  (cons-stream
   initial-value
   (add-streams (scale-stream integrand dt)
                int)))
@end lisp

@noindent
Способность интерпретатора работать с таким косвенным определением
зависит от @code{delay}, встроенного в @code{cons-stream}. Без этой
задержки интерпретатор не мог бы построить @code{int}, не вычислив оба
аргумента @code{cons-stream}, а для этого нужно, чтобы @code{int} уже
был определен. В общем случае, @code{delay} играет ключевую роль, когда
мы моделируем системы обработки сигналов с обратной связью при помощи
потоков. В отсутствие задержки нам приходилось бы формулировать модели
так, чтобы вход всякого обрабатывающего блока полностью вычислялся,
прежде чем блок выдает что-либо на выходе. Такое условие исключает циклы.

@float
@quotation
@anchor{Рисунок 3.34}
@ifinfo
@strong{Рисунок 3.34:} An ``analog computer circuit'' that solves the equation @math{dy\! / dt = f(y)}.

@example
                            y_0
                             |
                             V
    +----------+  dy   +----------+     y
+-->|  map: f  +------>| integral +--*----->
|   +----------+       +----------+  |
|                                    |
+------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.34,67mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 3.34:} An ``analog computer circuit'' that solves the equation @math{dy / dt = f(y)}.}
@caption{@strong{Рисунок 3.34:} <<Аналоговая компьютерная цепь>>, которая решает уравнение @math{dy / dt = f(y)}.}
@sp 0.9
@end iftex
@end quotation
@end float

К сожалению, потоковые модели систем с циклами могут требовать
применения задержек помимо той, которая <<спрятана>> в
@code{cons-stream}. Например, на рисунке @ref{Рисунок 3.34} показана
система обработки сигналов, решающая дифференциальное уравнение
@math{dy/dt = f(y)}, где @math{f} --- заданная функция. На рисунке
показан отображающий блок, который применяет @math{f} ко входному
сигналу, связанный в цикл обратной связи с интегратором. Это очень
похоже на работу аналоговых схем, действительно используемых для решения
такого рода уравнений.

Если нам дано начальное значение @math{y_0}, мы могли бы попытаться
смоделировать эту систему с помощью процедуры

@lisp
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

@noindent
Эта процедура не работает, потому что вызов @code{integral} в первой
строке @code{solve} требует, чтобы был определен входной поток
@code{dy}, а это происходит только во второй строке процедуры
@code{solve}.

С другой стороны, замысл, заключенный в этом определении, вполне здрав,
поскольку мы можем, в принципе, начать порождать поток @code{y} и не
зная @code{dy}. Действительно, @code{integral} и многие другие операции
над потоками обладают свойствами, подобными @code{cons-stream}, а
именно, мы можем породить часть ответа, даже если нам дана только
частичная информация об аргументах. В случае @code{integral}, первый
элемент выходного потока есть указанное начальное значение
@code{initial-value}. Таким образом, можно породить первый элемент
выходного потока и не вычисляя интегрируемую величину @code{dy}. А раз
мы знаем первый элемент @code{y}, то @code{stream-map} во второй строке
@code{solve} может начать работать и породить первый элемент @code{dy},
а с его помощью мы получим второй элемент @code{y}, и так далее.

Чтобы воспользоваться этой идеей, переопределим @code{integral} так,
чтобы он ожидал интегрируемый поток в виде (@newterm{delayed argument}).
@code{Integral} будет размораживать вычисление входного потока через
@code{force} только тогда, когда ему нужно породить элементы входного
потока помимо первого:

@lisp
(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (let ((integrand (force delayed-integrand)))
       (add-streams (scale-stream integrand dt) int))))
  int)
@end lisp

@endpage
@noindent
Теперь можно реализовать процедуру @code{solve}, задержав вычисление
@code{dy} внутри определения @code{y}:@footnote{Не гарантируется, что эта
процедура будет работать во всех реализациях Scheme, но для любой
реализации должен найтись простой способ заставить подобную процедуру
работать. Проблемы связаны с тонкими различиями в том, как реализации
Scheme обрабатывают внутренние определения.  (См. @ref{4.1.6}.)}

@lisp
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

@noindent
Теперь при любом вызове @code{integral} необходимо задерживать
интегрируемый аргумент. Можно показать, что процедура @code{solve}
работает, аппроксимируя @math{e \approx 2.718} вычислением в точке
@math{y = 1} решения дифференциального уравнения @math{dy/dt = y} с
начальным условием @math{y(0) = 1}:

@lisp
(stream-ref (solve (lambda (y) y)
                   1
                   0.001)
            1000)
@i{2.716924}
@end lisp

@quotation
@strong{@anchor{Упражнение 3.77}Упражнение 3.77:}
Вышеприведенная процедура @code{integral} была аналогична <<непрямому>>
определению бесконечного потока натуральных чисел из @ref{3.5.2}. В виде
альтернативы можно дать определение @code{integral}, более похожее на
@code{integers-starting-from} (также в @ref{3.5.2}):

@smalllisp
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
@end smalllisp

В системах с циклами эта реализациея порождает такие же проблемы, как и
наша исходная версия @code{integral}. Модифицируйте процедуру так, чтобы
она ожидала @code{integrand} как задержанный аргумент, а следовательно,
могла быть использована в процедуре @code{solve}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.35}
@ifinfo
@strong{Рисунок 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.

@example
               dy_0                y_0
                |                   |
                V                   V
   ddy     +----------+    dy  +----------+    y
+--------->| integral +-----*--+ integral +--*--->
|          +----------+     |  +----------+  |
|                           |                |
|            +----------+   |                |
|     __/|<--+ scale: a |<--+                |
|   _/   |   +----------+                    |
+--<_add |                                   |
     \__ |   +----------+                    |
        \|<--+ scale: b |<-------------------+
             +----------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.35a,91mm,,,.pdf}
@sp 0.3
@comment @caption{@strong{Рисунок 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.}
@caption{@strong{Рисунок 3.35:} Диаграмма потока сигналов для решения линейного дифференциального уравнения второго порядка.}
@sp 0.8
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.78}Упражнение 3.78:}
Рассмотрим задачу проектирования системы обработки сигналов
для решения гомогенных линейных дифференциальных уравнений второго
порядка
@ifinfo

@example
d^2 y        d y
-----  -  a -----  -  by  =  0
d t^2        d t
@end example

@end ifinfo
@tex
$$ {d^2\!y \over dt^2} - a {dy \over dt} - by = 0. $$
@end tex
Выходной поток, моделирующий @math{y}, порождается сетью, содержащей цикл. Этот
цикл возникает потому, что значение @math{d^2\!y / dt^2} зависит от
значений @math{y} и @math{dy/dt}, а они оба получаются интегрированием
@math{d^2\!y / dt^2}. Диаграмма, которую нам хотелось бы закодировать,
показана на рис. @ref{Рисунок 3.35}. Напишите процедуру
@code{solve-2nd}, которая в качестве аргументов берет константы
@math{a}, @math{b} и @math{dt} и начальные значения @math{y_0} и
@math{dy_0} для @math{y} и @math{dy}, и порождает поток последовательных
значений @math{y}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.79}Упражнение 3.79:}
Обобщите процедуру @code{solve-2nd} из
упражнения @ref{Упражнение 3.78} так, чтобы с ее помощью можно было
решать дифференциальные уравнения второго порядка общего вида
@math{d^2\!y / dt^2 = f(dy / dt, y)}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.36}
@ifinfo
@strong{Рисунок 3.36:} A series RLC circuit.

@example
              + v_R -
        i_R
     +--->----'\/\/\,--------+
     |                       |  i_L
    \|/          R          \|/
  +  |  i_C                  |_   +
    -+-                       _)
v_C -+- C                     _)  v_L
     |                        _)
  -  |                       |    -
     +-----------------------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.36,60mm,,,.pdf}
@sp 0.5
@comment @center @caption{@strong{Рисунок 3.36:} A series RLC circuit.}
@center @caption{@strong{Рисунок 3.36:} Последовательная RLC-цепь.}
@sp 0.9
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.80}Упражнение 3.80:}
(@newterm{series RLC circuit}) состоит из резистора, конденсатора и
катушки индуктивности, соединенных последовательно, как показано на
рис. @ref{Рисунок 3.36}. Если сопротивление, индуктивность и емкость
равны, соответственно, @math{R}, @math{L} и @math{C}, то отношения между
напряжением @math{v} и током @math{i} на трех элементах описываются
уравнениями
@ifinfo

@example
v_R = i_R R

         d i_L
v_L = L -------
          d t

         d v_C
i_C = C -------
          d t
@end example

@end ifinfo
@tex
$$ 	v_R 	= 	i_R R, \qquad\quad
	v_L 	= 	L {di_L \over dt}\,, \qquad\quad
	i_C 	= 	C {dv_C \over dt}\,, $$
@end tex
а цепь диктует соотношения
@ifinfo

@example
i_R = i_L = -i_C

v_C = v_L + v_R
@end example

@end ifinfo
@tex
$$ 	i_R 	= 	i_L = -i_C\,, \qquad\quad
	v_C 	= 	v_L +  v_R\,.  $$
@end tex
Сочетание этих условий
показывает, что состояние цепи (характеризуемое через @math{v_C},
напряжение на конденсаторе, и @math{i_L}, ток через катушку) описывается
парой дифференциальных уравнений
@ifinfo

@example
d v_C        i_L
-----  =  -  ---
 d t          C

d i_L      1           R
-----  =  --- v_C  -  --- i_L
 d t       L           L
@end example

@end ifinfo
@tex
$$  {dv_C \over dt}  =  -{i_L \over C}\,, \qquad\quad
    {di_L \over dt}  =   {1   \over L} v_C - {R \over L} i_L\,. $$
@end tex
Диаграмма потока сигналов, представляющая эту систему дифференциальных
уравнений, показана на рисунке @ref{Рисунок 3.37}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.37}
@ifinfo
@strong{Рисунок 3.37:} A signal-flow diagram for the solution to a series RLC circuit.

@example
                 +-------------+
+----------------+  scale: l/L |<--+
|                +-------------+   |
|                                  |
|                +-------------+   |  v_C
|       dv_C +-->|   integral  +---*------>
|            |   +-------------+
|            |        ^
|            |        | v_(C_0)
|            |
|            |   +-------------+
|            +---+ scale: -l/C |<--+
|                +-------------+   |
|  |\__                            |
+->|   \_  di_L  +-------------+   |  i_L
   | add_>------>|   integral  +---*------>
+->| __/         +-------------+   |
|  |/                 ^            |
|                     | i_(L_0)    |
|                                  |
|                +-------------+   |
+----------------+ scale: -R/L |<--+
                 +-------------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.37a,68mm,,,.pdf}
@sp 0.8
@comment @caption{@strong{Рисунок 3.37:} A signal-flow diagram for the solution to a series RLC circuit.}
@caption{@strong{Рисунок 3.37:} Диаграмма потока сигналов для решения уравнений последовательной RLC-цепи.}
@sp 0.8
@end iftex
@end quotation
@end float

@quotation
Напишите процедуру @code{RLC}, которая в качестве аргументов берет
параметры цепи @math{R}, @math{L} и @math{C} и точность по времени
@math{dt}. Подобно процедуре @code{RC} из
упражнения @ref{Упражнение 3.73}, @code{RLC} должна порождать
процедуру, которая берет начальные значения переменных состояния
@math{v_{C_0}} и @math{i_{L_0}} и порождает (через @code{cons}) пару
потоков состояния @math{v_C} и @math{i_L}. С помощью @code{RLC} породите
пару потоков, которая моделирует поведение RLC-цепи c @math{R = 1} ом,
@math{C = 0.2} фарад, @math{L = 1} генри, @math{dt = 0.1} секунды, и
начальными значениями @math{i_{L_0} = 0} ампер и @math{v_{C_0} = 10} вольт.
@end quotation

@comment @subsubheading Normal-order evaluation
@subsubheading Нормальный порядок вычислений

Примеры из этого раздела показывают, как явное использование
@code{delay} и @code{force} сообщает программированию большую гибкость,
однако те же самые примеры показывают, как наши программы от этого могут
стать сложнее и запутаннее. Например, новая процедура @code{integral}
позволяет моделировать системы с циклами, но теперь нам приходится
помнить, что звать ее надо с задержанным аргументом, и все процедуры,
которые пользуются @code{integral}, должны это знать. В результате мы
создали два класса процедур: обычные и те, которым требуются задержанные
аргументы. В общем случае создание новых классов процедур требует от нас
еще и создания новых классов процедур высших порядков.@footnote{Здесь мы
получаем в Лиспе слабое отражение тех сложностей, которые возникают при
работе с процедурами высших порядков в обыкновенных сильно
типизированных языках вроде Паскаля. В таких языках программисту нужно
указывать типы данных для аргументов и результата каждой процедуры:
число, логическое значение, последовательность и т. д. Следовательно,
мы не можем выразить такую абстракцию, как <<применить данную процедуру
@code{proc} ко всем элементам последовательности>> в виде единой
процедуры высшего порядка вроде @code{stream-map}. Вместо этого нам
потребуется отдельная процедура для каждой комбинации типов аргументов и
результата, которые можно указать для @code{proc}. Практическая
поддержка понятия <<тип данных>> при наличии процедур высших порядков
приводит ко многим интересным проблемам. Один из способов работы с ними
иллюстрирует язык ML (Gordon, Milner, and Wadsworth 1979), в котором
<<полиморфные типы данных>> включают шаблоны для преобразований между
типами данных высшего уровня. Более того, для большинства процедур в ML
типы данных явно не определяются программистом. Вместо этого в ML
встроен механизм (type inference), который при помощи контекстной
информации вычисляет типы данных для вновь определяемых процедур.}

Один из способов избежать необходимости вводить два класса процедур
состоит в том, чтобы заставить все процедуры принимать задержанные
аргументы. Можно принять модель вычислений, в которой все аргументы
процедур автоматически задерживаются, и вынуждение происходит только
тогда, когда их значения реально нужны (например, для выполнения
элементарной операции). Таким образом наш язык станет использовать
нормальный порядок вычислений, который мы впервые описали, когда
разговор шел о подстановочной модели вычислений в @ref{1.1.5}.
Переход к нормальному порядку вычислений предоставляет нам изящный и
единообразный способ упростить использование задержанных вычислений, и
если бы нас интересовала только обработка потоков, было бы естественно
принять эту стратегию. В @ref{4.2},
после того, как мы изучим устройство вычислителя, мы увидим, как можно
преобразовать язык именно таким способом. К сожалению, добавив задержки
в вызовы процедур, мы совершенно лишили себя возможности строить
программы, работа которых зависит от порядка событий, то есть программы,
использующие присваивание, изменяющие свои данные или производящие
ввод-вывод. Одно-единственное использование @code{delay} в форме
@code{cons-stream} уже может привести к неразберихе, как показано в
упражнениях @ref{Упражнение 3.51} и @ref{Упражнение 3.52}. Насколько
известно, в языках программирования изменение состояния и задержанные
вычисления плохо совместимы, и поиск возможностей использовать
одновременно и то, и другое является активной областью исследований.

@comment @subsection Modularity of Functional Programs@* and Modularity of Objects
@subsection Модульность функциональных программ и модульность объектов
@node	3.5.5,  , 3.5.4, 3.5

Как мы видели в @ref{3.1.2}, одно из
основных преимуществ от введения присваивания состоит в том, что мы
можем повысить модульность своих систем при помощи инкапсуляции, или
<<сокрытия>>, частей большой системы во внутренних переменных. Потоковые
модели могут предоставить нам такой же уровень модульности без
использования присваивания. В качестве примера мы можем заново
реализовать аппроксимацию @math{\pi} методом Монте-Карло, которую мы
рассматривали в @ref{3.1.2}, с точки зрения обработки потоков.

Главная задача при обеспечении модульности состояла в том, что нам
хотелось спрятать внутреннее состояние генератора случайных чисел от
программ, которые пользуются случайными числами. Мы начали с процедуры
@code{rand-update}, последовательные значения которой служили для нас
источником случайных чисел, и уже с ее помощью построили генератор
случайных чисел:

@lisp
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
@end lisp

@noindent
При формулировке посредством потоков генератора случайных чисел как
такового не существует, имеется только поток случайных чисел, полученных
вызовами @code{rand-update}:

@lisp
(define random-numbers
  (cons-stream
   random-init
   (stream-map rand-update random-numbers)))
@end lisp

@noindent
С его помощью мы порождаем поток результатов испытаний Чезаро,
проведенных на последовательных парах потока случайных чисел (@code{random-numbers}):

@lisp
(define cesaro-stream
  (map-successive-pairs
   (lambda (r1 r2) (= (gcd r1 r2) 1))
   random-numbers))
(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
@end lisp

@noindent
Поток @code{cesaro-stream} подается на вход процедуре
@code{monte-carlo}, которая порождает поток оценок вероятности. Затем
этот результат преобразуется, и получается поток оценок значения
@math{\pi}. В этой версии программы не требуется параметра,
указывающего, сколько испытаний требуется проводить. Более точные оценки
@math{\pi} (полученные при большем количестве испытаний) можно получить,
дальше заглянув в поток @code{pi}:

@lisp
(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))
(define pi
  (stream-map
   (lambda (p) (sqrt (/ 6 p)))
   (monte-carlo cesaro-stream 0 0)))
@end lisp

@noindent
Такой подход достаточно модулен, поскольку мы по-прежнему имеем
возможность сформулировать общую процедуру @code{monte-carlo},
работающую с произвольными испытаниями. Однако здесь нет ни
присваивания, ни внутреннего состояния.

@quotation
@strong{@anchor{Упражнение 3.81}Упражнение 3.81:}
В упражнении @ref{Упражнение 3.6} обсуждалась возможность
обобщить генератор случайных чисел и позволить пользователю сбрасывать
последовательность случайных чисел, так, чтобы можно было порождать
воспроизводимые <<случайные>> последовательности. Постройте потоковый
вариант такой же процедуры-генератора, которая работает со входным
потоком запросов вида @code{generate} --- породить новое число, либо
@code{reset} --- сбросить последовательность в нужную точку, и которая
порождает требуемый поток случайных чисел. Не используйте в своем
решении присваивание.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.82}Упражнение 3.82:} Переделайте на основе потоков
упражнение @ref{Упражнение 3.5} на интегрирование методом Монте-Карло.
Потоковая версия процедуры @code{estimate-integral} не требует
аргумента, который говорит, сколько проводить испытаний. Вместо этого
она порождает поток оценок, основанных на все большем количестве испытаний.
@end quotation

@comment @subsubheading A functional-programming view of time
@subsubheading Взгляд на время в функциональном программировании

Вернемся теперь к вопросам об объектах и изменении, поднятым в начале
этой главы, и рассмотрим их в новом свете. Мы ввели присваивание и
изменяемые объекты, чтобы иметь механизм для модульного построения
программ, которые моделируют обладающие состоянием системы. Мы порождали
вычислительные объекты с внутренними переменными состояния и изменяли
эти объекты при помощи присваивания. Мы моделировали временно́е поведение
объектов мира через временное поведение соответствующих вычислительных
объектов.

Теперь мы видим, что потоки дают альтернативный способ моделирования
объектов, обладающих внутренним состоянием. Можно моделировать
изменяющуюся величину, например, внутреннее состояние какого-либо
объекта, через поток, который представляет динамику изменений состояния.
В сущности, с помощью потоков мы представляем время явно, так что время
в моделируемом мире оказывается отделено от последовательности событий,
происходящих во время вычисления. Действительно, благодаря наличию
@code{delay} между имитируемым временем модели и последовательностью
событий при вычислении может быть весьма мало общего.

Чтобы сопоставить эти два подхода к моделированию, рассмотрим еще раз
<<обработчик снятия денег>>, следящий за значением баланса на банковском
счету. В @ref{3.1.3} мы реализовали упрощенную версию такой программы обработки:

@lisp
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
@end lisp

@noindent
Вызовы @code{make-simplified-withdraw} порождают вычислительные объекты,
и каждый из них содержит внутреннюю переменную @code{balance}, которая
уменьшается при каждом обращении к объекту. Этот объект принимает в
качестве аргумента количество денег @code{amount}, а возвращает новый
баланс. Можно представить себе, как пользователь банковского счета
печатает последовательность входных данных для такого объекта и
рассматривает на экране дисплея последовательность возвращаемых данных.

С другой стороны, можно смоделировать обработчик снятия денег и в виде
процедуры, которая принимает на входе баланс и поток снимаемых сумм, а
порождает поток последовательных балансов на счету:

@lisp
(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
@end lisp

@noindent
@code{stream-withdraw} реализует хорошо определенную математическую
функцию, выход которой полностью определяется входом. Однако
предположим, что вход @code{amount-stream} есть поток последовательных
значений, вводимых пользователем, и что получающийся поток балансов
выводится на печать. В таком случае, с точки зрения пользователя,
который печатает значения и смотрит на результаты, потоковый процесс
обладает тем же поведением, что и объект, созданный при помощи
@code{make-simplified-withdraw}. Однако в потоковой версии нет ни
присваивания, ни внутренней переменной состояния, и, следовательно, она
не вызывает никаких теоретических сложностей из описанных в
@ref{3.1.3}. И все-таки система обладает состоянием!

Это достижение достойно внимания. Несмотря на то, что
@code{stream-withdraw} реализует хорошо определенную математическую
функцию, поведение которой не меняется, у пользователя создается
впечатление, что он взаимодействует с системой, обладающей изменяющимся
состоянием. Один из способов разрешить парадокс заключается в том, чтобы
понять, что именно существование пользователя во времени навязывает
системе состояние. Если бы пользователь мог принять более отстраненную
точку зрения и думать в терминах потоков и балансов, а не отдельных
актов взаимодействия, система выглядела бы как объект без
состояния.@footnote{Подобным образом в физике, когда мы наблюдаем за
движением частицы, мы говорим, что позиция (состояние) частицы
изменяется. Однако с точки зрения мировой линии частицы в
пространстве-времени никакого изменения нет.}

С точки зрения одной части сложного процесса кажется, что другие его
части меняются со временем. Они содержат скрытое изменчивое внутреннее
состояние. Если мы хотим писать программы, моделирующие такой тип
естественной декомпозиции нашего мира (как мы видим его со своей точки
зрения, будучи частицами этого мира) при помощи структур в нашем
компьютере, мы строим вычислительные объекты, не являющиеся
функциональными, --- они обязаны меняться со временем. Мы моделируем
состояние при помощи внутренних переменных, и изменение состояния мы
моделируем через присваивание этим переменным. Пойдя по этому пути, мы
делаем время выполнения вычислительной модели временем мира, частью
которого мы являемся, и так в нашем компьютере возникают <<объекты>>.

Моделирование при помощи объектов --- мощная и интуитивно понятная
техника, во многом потому, что она соответствует восприятию
взаимодействия с миром, частью которого мы являемся. Однако, как мы
неоднократно видели в этой главе, в таких моделях возникают неудобные
вопросы управления порядком событий и синхронизации множественных
процессов. Возможность избежать этих проблем стимулировала развитие
(@newterm{functional programming languages}), в которых нет понятий присваивания и
изменяемых данных. В таком языке все процедуры реализуют точно
определенные математические функции, поведение которых не меняется.
Функциональный подход весьма привлекателен при работе с параллельными
системами.@footnote{Джон Бэкус, изобретатель Фортрана, привлек внимание к
функциональному программированию, когда в 1978 году получил премию
Тьюринга Американской Ассоциации по Вычислительным Машинам (ACM). В
своей инаугурационной речи (Backus 1978) он горячо отстаивал
функциональный подход. Хороший обзор функционального программирования
дается в книгах Henderson 1980 и Darlington, Henderson, and
Turner 1982.}

С другой стороны, при более внимательном взгляде мы обнаружим, что и
функциональные модели не избавляют от проблем, связанных со временем.
Одна из самых болезненных возникает, когда нам нужно проектировать
интерактивные системы, особенно такие, которые моделируют взаимодействие
между независимыми сущностями. К примеру, рассмотрим еще раз реализацию
банковской системы, которая позволяет иметь совместные счета. В
традиционной системе с присваиванием и объектами информация о том, что у
Петра и Павла есть общий счет, моделировалась бы тем, что и Петр, и
Павел посылали бы заказы на транзакции одному и тому же
объекту-банковскому счету, как мы видели в @ref{3.1.3}. С точки
зрения потоков, где <<объекты>> сами по себе не существуют, банковский
счет, как мы уже указывали, может моделироваться в виде процесса,
работающего с потоком заказов на транзакции и порождающего поток
реакций. Соответственно, информация о том, что Петр и Павел совместно
владеют счетом, может моделироваться путем смешения потока заказов Петра
на транзакции с потоком Павла и направления слитого потока в
процесс-поток банковского счета, как показано на
рисунке @ref{Рисунок 3.38}.

@float
@quotation
@anchor{Рисунок 3.38}
@ifinfo
@strong{Рисунок 3.38:} A joint bank account, modeled by merging two streams of transaction requests.

@example
Peter's requests   +---------+     +---------+
------------------>|         |     |         |
Paul's requests    |  merge  |---->| bank    |---->
------------------>|         |     | account |
                   +---------+     +---------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.38,88mm,,,.pdf}
@sp 0.6
@comment @caption{@strong{Рисунок 3.38:} A joint bank account, modeled by merging two streams of transaction requests.}
@caption{@strong{Рисунок 3.38:} Совместный банковский счет, смоделированный через слияние двух потоков событий-транзакций.}
@sp 1.2
@end iftex
@end quotation
@end float

Проблему в этой формулировке вызывает понятие (@newterm{merge}). Неверным решением
будет просто брать по очереди один заказ от Петра и один от Павла.
Допустим, что Павел очень редко обращается к счету. Не следует
заставлять Петра ждать, пока Павел обратится к счету, прежде чем он
сможет осуществить вторую транзакцию. Как бы ни было реализовано
слияние, оно должно чередовать потоки транзакций так, чтобы
соответствовать <<реальному времени>> с точки зрения Петра и Павла, в
том смысле, что если Петр и Павел встретятся, то они могут согласиться,
что определенные транзакции произошли до встречи, а определенные
после.@footnote{Заметим, что для любых двух потоков в принципе существует
более одного возможного способа чередования. Так что с технической точки
зрения <<слияние>> не функция, а отношение --- ответ не является
детерминистской функцией аргументов. Мы уже упоминали (в примечании
@ref{Сноска 3.39}), что недетерминизм имеет существенное значение при
работе с параллельными процессами. Отношение слияния показывает тот же
самый недетерминизм с функциональной точки зрения. В @ref{4.3}
мы рассмотрим еще одну точку зрения на недетерминизм.} Это в точности то
же самое ограничение, с которым нам приходилось сталкиваться в @ref{3.4.1},
где у нас возникла необходимость ввести явную синхронизацию, чтобы добиться
<<правильного>> порядка событий при параллельной обработке объектов,
обладающих состоянием. Таким образом, при попытке поддержать
функциональный стиль необходимость сливать потоки ввода от различных
агентов опять привносит те самые проблемы, от которых функциональный
стиль должен был нас избавить.

В начале этой главы мы поставили цель научиться строить вычислительные
модели, чья структура соответствует нашему восприятию реального мира,
который мы моделируем. Мы можем моделировать мир либо как собрание
ограниченных во времени взаимодействующих объектов, обладающих
состоянием, либо же как единую, вневременную, лишенную состояния
сущность. Каждая из этих точек зрения имеет свои преимущества, но ни
одна из них не удовлетворяет нас полностью. Время великого объединения
пока не настало.@footnote{Объектная модель строит приближенное описание
мира, разделяя его на отдельные фрагменты. Функциональная модель не
проводит границ модулей по границам объектов. Объектная модель полезна
тогда, когда раздельное состояние <<объектов>> намного больше, чем
состояние, общее для всех или некоторых из них. Примером области, где
объектный взгляд не работает, является квантовая механика, где попытки
думать об объектах как отдельных частицах ведут к парадоксам и
недоразумениям. Объединение объектного взгляда с функциональным может
иметь отношение не столько к программированию, сколько к фундаментальным
вопросам эпистемологии.}
@comment @chapter Metalinguistic Abstraction
@chapter Метаязыковая абстракция
@node    Chapter 4, Chapter 5, Chapter 3, Top

@quotation
@dots{} Именно в словах кроется магия --- в таких, как <<абракадабра>>,
<<Сезам, откройся>> и проч., --- но магические слова из одной истории
перестают быть таковыми в следующей. Настоящая магия состоит в том,
чтобы понять, когда и для чего слово сработает; трюк в том, чтобы
выучить трюк.

@dots{} А слова эти состоят из букв нашего алфавита: пара дюжин
закорючек, которые мы способны черкнуть пером. Вот где ключ @dots{}! И
сокровище тоже, если только мы сумеем его заполучить! Как
будто @dots{} как будто ключ к сокровищу и @emph{есть} само сокровище!

---John Barth, @cite{Chimera} (Перевод Виктора Лапицкого)
@end quotation

@c @sp 0.8

@noindent
\lettrine{И}{сследуя науку проектирования программ}, мы видели, что
программисты-эксперты управляют сложностью своих программ при помощи тех
же общих методик, какими пользуются проектировщики всех сложных систем.
Они сочетают элементарные единицы, получая при этом составные объекты, с
помощью абстракции составных объектов формируют строительные блоки
высших порядков, и при этом с целью сохранения модульности выбирают
наиболее удобный общий взгляд на структуру системы. Демонстрируя эти
методы, мы использовали Лисп как язык для описания процессов и для
построения вычислительных объектов данных, и процессы --- для
моделирования сложных явлений реального мира. Однако по мере того, как
мы сталкиваемся со все более сложными задачами, мы обнаруживаем, что
Лиспа, да и любого заранее заданного языка программирования,
недостаточно для наших нужд. Чтобы эффективнее выражать свои мысли,
постоянно приходится обращаться к новым языкам. Построение новых языков
является мощной стратегией управления сложностью в инженерном
проектировании; часто оказывается, что можно расширить свои возможности
работы над сложной задачей, приняв новый язык, позволяющий нам описывать
(а следовательно, и обдумывать) задачу новым способом, используя
элементы, методы их сочетания и механизмы абстракции, специально
подогнанные под стоящие перед нами проблемы.@footnote{Та же самая идея
встречается во всех областях техники. Например, у
инженеров-электронщиков существует множество языков для описания схем.
Два из них --- это язык электрических @emph{сетей} и язык электрических
@emph{систем}. Язык сетей делает акцент на физическом моделировании
устройств в терминах дискретных электрических элементов. Элементарными
объектами этого языка являются элементарные электрические
компоненты --- резисторы, конденсаторы, катушки индуктивности и
транзисторы, задаваемые через физические переменные: напряжение и ток.
Описывая схемы на языке сетей, инженер озабочен физическими
характеристиками своего проекта. Элементами системного языка, напротив,
являются модули обработки сигнала, например, фильтры и усилители.
Существенно только функциональное поведение модулей, и сигналами
манипулируют безотносительно к тому, в виде какого напряжения или тока
они реализуются физически. Язык систем построен на языке сетей, в том
смысле, что элементы систем обработки сигнала состоят из электрических
схем. Однако здесь инженера интересует крупномасштабная организация
электрических устройств, решающая определенную задачу; их физическая
совместимость подразумевается. Такая послойная организация языков служит
еще одним примером уровневого метода проектирования,
проиллюстрированного в @ref{2.2.4} на примере языка описания изображений.}

Программирование изобилует языками. Есть физические языки, например,
языки машинных кодов для конкретных компьютеров. Основным вопросом для
них является представление данных и управления через отдельные биты
памяти и машинные команды. Пишущий программы на машинном языке озабочен
тем, чтобы при помощи данной аппаратуры создать системы и инструменты
для эффективной реализации вычисления при ограниченных ресурсах. Языки
высокого уровня, возводимые поверх машинных, скрывают вопросы конкретной
реализации данных в виде набора битов и представления программ как
последовательности машинных команд. В этих языках присутствуют средства
комбинации и абстракции, например определения функций, которые подходят
для более крупномасштабной организации систем.

(@newterm{metalinguistic abstraction}), то есть построение новых языков, играет
важную роль во всех отраслях инженерного проектирования. Для
компьютерного программирования она особенно важна, поскольку в
программировании мы можем не только формулировать новые языки, но и
реализовывать их через построение вычислителей. (@newterm{evaluator}) (или
(@newterm{interpreter)}) для языка программирования --- это процедура, которая,
будучи примененной к выражению языка, производит действия, необходимые
для вычисления этого выражения.

Без преувеличения можно сказать, что самая основополагающая идея в
программировании такова:

@quotation
Вычислитель, который определяет значение выражений в языке
программирования --- всего лишь обычная программа.
@end quotation

@noindent
С этой мыслью приходит и новое представление о себе самих: мы начинаем
видеть в себе разработчиков языков, а не просто пользователей языков,
придуманных другими.

На самом деле, почти любую программу можно рассматривать как вычислитель
для какого-то языка. Например, система работы с многочленами из @ref{2.5.3}
заключает в себе правила арифметики многочленов и реализует их в
терминах операций над данными в списочной форме. Если мы дополним эту
систему процедурами для чтения и печати многочленов, то перед нами
окажется ядро специализированного языка для решения задач символьной
математики. И программа моделирования цифровой логики из @ref{3.3.4},
и программа распространения ограничений из @ref{3.3.5}
содержат свои собственные языки, со своими примитивами, средствами их
комбинирования и абстракции. С этой точки зрения, техника работы с
крупномасштабными компьютерными системами сливается с техникой создания
новых компьютерных языков, и вся информатика --- не более (но и не
менее), чем наука о построении подходящих языков описания.

Сейчас мы начинаем обзор методов, которые позволяют создавать одни языки
на основе других. В этой главе в качестве основы мы будем использовать
Лисп, и вычислители будем реализовывать как процедуры на Лиспе. Лисп
особенно хорошо подходит для этой задачи благодаря своей способности
представлять символические выражения и обрабатывать их. Первый шаг к
пониманию того, как реализуются языки, мы сделаем, построив вычислитель
для самого Лиспа. Язык, реализуемый нашим интерпретатором, будет
подмножеством диалекта Лиспа Scheme, которым мы пользуемся в этой книге.
Несмотря на то, что интерпретатор, описанный в этой главе, написан для
конкретного диалекта Лиспа, он содержит основную структуру вычислителя
для любого языка, ориентированного на выражения и предназначенного для
написания программ для последовательной машины. (На самом деле, глубоко
внутри большинства языковых процессоров содержится маленький
интерпретатор <<Лиспа>>.) Этот интерпретатор несколько упрощен для
удобства и наглядности обсуждения, и некоторые детали, которые важно
было бы включить в Лисп-систему промышленного качества, здесь были
оставлены за рамками изложения. Тем не менее, этот простой интерпретатор
способен выполнить большинство программ из данной книги.@footnote{Самое
важное, чего не хватает в нашем интерпретаторе, --- это механизмов,
обрабатывающих ошибки и поддерживающих отладку. Более подробное
обсуждение вычислителей можно найти в книге Friedman, Wand, and Haynes
1992, которая содержит обзор языков программирования на примере
последовательности интерпретаторов, написанных на Scheme.}

Важное преимущество, которое нам дает вычислитель, доступный в виде
программы на Лиспе, состоит в том, что мы можем реализовывать
альтернативные правила вычисления, описывая их как модификации программы
вычислителя. В частности, мы можем извлечь из этой способности немалую
выгоду, добиваясь более полного контроля над тем, как в вычислительных
моделях реализуется понятие времени. Этому вопросу была специально
посвящена @ref{Глава 3}.
Там мы смягчили некоторые сложности работы с состоянием и
присваиваниями, при помощи потоков отделив представление времени во
внешнем мире от времени внутри компьютера. Однако программы, работающие
с потоками, иногда бывали излишне громоздки, поскольку их ограничивал
аппликативный порядок вычисления, принятый в Scheme. В @ref{4.2} мы изменим
язык и получим более изящный подход в виде интерпретатора с
(@newterm{normal-order evaluation}).

В @ref{4.3}
язык меняется более радикально, и выражения получают не одно
единственное значение, а множество. В этом языке (@newterm{nondeterministic
computing}) становится естественным порождать все возможные значения
выражения, а затем искать среди них те, которые удовлетворяют
определенным ограничениям. Если описывать это в терминах вычисления и
времени, то время как будто разветвляется на множество <<возможных
будущих>>, и мы ищем среди них подходящие временные линии. При работе с
недетерминистским интерпретатором отслеживание множества значений и
поиск осуществляются автоматически встроенными механизмами языка.

В @ref{4.4} мы реализуем язык (@newterm{logic programming}), в котором знание
выражается в терминах отношений, а не в
терминах вычислений со входами и выходами. Несмотря на то, что язык при
этом оказывается сильно отличным от Лиспа, как, впрочем, и от любого
привычного языка, мы увидим, что интерпретатор для языка логического
программирования имеет, в сущности, ту же структуру, что и интерпретатор
Lisp.

@menu
* 4-1::              Метациклический интерпретатор
* 4-2::              Scheme с вариациями ленивый интерпретатор
* 4-3::              Scheme с вариациями --- недетерминистское вычисление
* 4-4::              Логическое программирование
@end menu

@comment @section The Metacircular Evaluator
@section Метациклический интерпретатор
@node	4.1, 4.2, Chapter 4, Chapter 4

Наш интерпретатор Лиспа будет реализован как программа на Лиспе. Может
показаться, что размышления о выполнении Лисп-программ при помощи
интерпретатора, который сам написан на Лиспе, составляют порочный круг.
Однако вычисление есть процесс, так что вполне логично описывать процесс
вычисления с помощью Лиспа --- в конце концов, это наш инструмент для
описания процессов.@footnote{Даже с учетом этого, остаются важные стороны
процесса вычисления, которые в нашем интерпретаторе не проясняются.
Самая важная из них --- точные механизмы того, как одни процедуры
вызывают другие и возвращают значения процедурам, которые их вызвали.
Эти вопросы мы рассмотрим в @ref{Глава 5},
где мы исследуем процесс вычисления более внимательно, реализуя
вычислитель как простую регистровую машину.} Интерпретатор, написанный
на языке, который он сам реализует, называется (@newterm{metacircular}).

В сущности, метациклический интерпретатор является формулировкой на
языке Scheme модели вычислений с окружениями, описанной в @ref{3.2}.
Напомним, что в этой модели было две основные части:

@enumerate 1

@item
Чтобы выполнить комбинацию (составное выражение, не являющееся особой
формой), нужно вычислить его подвыражения и затем применить значение
подвыражения-оператора к значениям подвыражений-операндов.

@item
Чтобы применить составную процедуру к набору аргументов, нужно выполнить
тело процедуры в новом окружении. Для того, чтобы построить это
окружение, нужно расширить окружение объекта-процедуры кадром, в котором
формальные параметры процедуры связаны с аргументами, к которым
процедура применяется.

@end enumerate

@noindent
Эти два правила описывают сущность процесса вычисления, основной цикл, в
котором выражения, которые требуется выполнить в окружении, сводятся к
процедурам, которые нужно применить к аргументам, а те, в свою очередь,
сводятся к новым выражениям, которые нужно выполнить в новых окружениях,
и так далее, пока мы не доберемся до символов, чьи значения достаточно
найти в окружении, и элементарных процедур, которые применяются напрямую
(см. @ref{Рисунок 4.1}).@footnote{Если нам дается возможность
применять примитивы, то что остается сделать для реализации
интерпретатора? Задача интерпретатора состоит не в том, чтобы определить
примитивы языка, а в том, чтобы обеспечить связующие элементы ---
средства комбинирования и абстракции, --- которые превращают набор
примитивов в язык. А именно:

@math{\bullet} Интерпретатор позволяет работать с вложенными выражениями. Например,
чтобы вычислить значение выражения @code{(+ 1 6)}, достаточно применения
примитивов, но этого недостаточно для работы с выражением
@code{(+ 1 (* 2 3))}. Сама по себе элементарная процедура @code{+}
способна работать только с числами, и если передать ей аргумент ---
выражение @code{(* 2 3)}, она сломается. Одна из важных задач
интерпретатора --- устроить вычисление так, чтобы @code{(* 2 3)} свелось
к значению 6, прежде чем оно будет передано @code{+} как аргумент.

@math{\bullet} Интерпретатор позволяет использовать переменные. Например, элементарная
процедура сложения не знает, как работать с выражениями вроде
@code{(+ x 1)}. Нам нужен интерпретатор, чтобы следить за переменными и
получать их значения, прежде чем запускать элементарные процедуры.

@math{\bullet} Интерпретатор позволяет определять составные процедуры. При этом нужно
хранить определения процедур, знать, как эти определения используются
при вычислении выражений, и обеспечивать механизм, который позволяет
процедурам принимать аргументы.

@math{\bullet} Интерпретатор дает особые формы, вычисляющиеся иначе, чем вызовы
процедур.} Этот цикл вычисления будет построен в виде взаимодействия
двух основных процедур интерпретатора, @code{eval} и @code{apply},
описанных в @ref{4.1.1} (см. рис. @ref{Рисунок 4.1}).

Реализация интерпретатора будет зависеть от процедур, определяющих
(@newterm{syntax}) выполняемых выражений. При помощи абстракции данных мы сделаем
интерпретатор независимым от представления языка. К примеру, вместо
того, чтобы окончательно решать, что присваивание выражается в виде
списка, в котором первым элементом стоит символ @code{set!}, мы
пользуемся абстрактным предикатом @code{assignment?}, чтобы распознавать
присваивание, и абстрактными селекторами @code{assignment-variable} и
@code{assignment-value}, чтобы обращаться к его частям. Реализация
выражений будет подробно рассмотрена в @ref{4.1.2}. Имеются также операции,
описанные в @ref{4.1.3}, которые определяют представление процедур и окружений. Например,
@code{make-procedure} порождает составные процедуры,
@code{lookup-variable-value} извлекает значения переменных, а
@code{apply-primitive-procedure} применяет элементарную процедуру к
указанному списку аргументов.

@float
@c @quotation
@anchor{Рисунок 4.1}
@ifinfo
@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.

@example
                           .,ad88888888baa,
                  _    ,d8P"""        ""9888ba.      _
                 /  .a8"          ,ad88888888888a   |\
               /   aP'          ,88888888888888888a   \
              /  ,8"           ,88888888888888888888,  \
             |  ,8'            (888888888888888888888, |
            /  ,8'             `8888888888888888888888  \
            |  8)               `888888888888888888888, |
Procedure,  |  8                  "88888 Apply 8888888) | Expression
Arguments   |  8     Eval          `888888888888888888) | Environment
            |  8)                    "8888888888888888  |
            \  (b                     "88888888888888'  /
             | `8,                     8888888888888)  |
             \  "8a                   ,888888888888)  /
              \   V8,                 d88888888888"  /
              _\| `8b,             ,d8888888888P' _/
                     `V8a,       ,ad8888888888P'
                        ""88888888888888888P"
                             """"""""""""

                               [graphic by Normand Veillux, modified]
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.1,100mm,,,.pdf}
@sp 0.5
@comment @caption{@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.}
@caption{@strong{Рисунок 4.1:} Цикл @code{eval}-@code{apply} раскрывает сущность компьютерного языка.}
@sp 0.7
@end iftex
@c @end quotation
@end float

@menu
* 4-1-1::            Ядро интерпретатора
* 4-1-2::            Представление выражений
* 4-1-3::            Структуры данных интерпретатора
* 4-1-4::            Выполнение интерпретатора как программы
* 4-1-5::            Данные как программы
* 4-1-6::            Внутренние определения
* 4-1-7::            Отделение синтаксического анализа от выполнения
@end menu

@comment @subsection The Core of the Evaluator
@subsection Ядро интерпретатора
@node	4.1.1, 4.1.2, 4.1, 4.1

Процесс вычисления можно описать как взаимодействие двух процедур:
@code{eval} и @code{apply}.

@comment @subsubheading Eval
@subsubheading Eval

Процедура @code{eval} в качестве аргументов принимает выражение и
окружение. Она относит выражение к одному из возможных классов и
управляет его выполнением. @code{Eval} построена как разбор случаев в
зависимости от синтаксического типа выполняемого выражения. Для того,
чтобы процедура была достаточно общей, определение типа выражения мы
формулируем абстрактно, не связывая себя никакой конкретной реализацией
различных типов выражений. Для каждого типа выражений имеется предикат,
который распознает этот тип, и абстрактные средства для выбора его
частей. Такой (@newterm{abstract syntax}) позволяет легко видеть, как можно
изменить синтаксис языка и использовать тот же самый интерпретатор, но
только с другим набором синтаксических процедур.

\bigskip
@noindent
@b{Элементарные выражения}

@itemize @bullet

@item
Для самовычисляющихся выражений, например, чисел, @code{eval} возвращает
само выражение.

@item
@code{eval} должен находить значения переменных, просматривая окружение.

@end itemize

@noindent
@b{Особые формы}

@itemize @bullet

@item
Для выражений с кавычкой @code{eval} возвращает само закавыченное выражение.
    
@item
Присваивание переменной (или ее определение) должно вызвать @code{eval}
рекурсивно, чтобы вычислить новое значение, которое требуется связать с
переменной. Окружение нужно модифицировать, изменяя (или создавая)
связывание для переменной.

@item
Выражение @code{if} требует специальной обработки своих частей: если
предикат истинен, нужно выполнить следствие; если нет, альтернативу.

@item
Выражение @code{lambda} требуется преобразовать в процедуру, пригодную к
применению. Для этого нужно упаковать параметры и тело
@code{lambda}-выражения вместе с окружением, в котором оно вычисляется.

@item
Выражение @code{begin} требует выполнения своих подвыражений в том
порядке, как они появляются.

@item
Разбор случаев @code{cond} преобразуется во вложенные выражения
@code{if} и затем вычисляется.

@end itemize

@noindent
@b{Комбинации}

@itemize @bullet

@item
Для применения процедуры @code{eval} должна рекурсивно вычислить
операцию и операнды комбинации. Получившиеся процедура и аргументы
передаются @code{apply}, которая распоряжается собственно применением
процедуры.

@end itemize

@noindent
Вот определение @code{eval}:

@lisp
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))
@end lisp

@noindent
Ясности ради, @code{eval} реализована как перебор альтернатив через
@code{cond}. Недостаток этой реализации --- наша процедура обрабатывает
только несколько указанных типов выражений, и, не меняя определение
@code{eval}, новые типы добавить нельзя. В большинстве реализаций Лиспа
распределение выражений по типам сделано в стиле, управляемом данными.
Это дает пользователю возможность добавлять новые типы выражений,
которые @code{eval} будет способен распознать, не меняя само определение
@code{eval}. (См. упражнение @ref{Упражнение 4.3}.)

@comment @subsubheading Apply
@subsubheading Apply

Процедура @code{apply} принимает два аргумента: процедуру и список
аргументов, к которым ее надо применить. @code{Apply} делит процедуры на
два класса: для применения примитивов она зовет
@code{ apply-primitive-procedure}; составные процедуры она применяет, по
очереди вычисляя выражения, составляющие тело процедуры. Окружение, в
котором вычисляется тело составной процедуры, получается из базового
окружения, хранящегося в процедуре, добалением кадра, где параметры
процедуры связываются с аргументами, к которым процедура применяется.
Вот определение @code{apply}:

@lisp
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))
@end lisp

@comment @subsubheading Procedure arguments
@subsubheading Аргументы процедур

Обрабатывая применение процедуры, @code{eval} получает список
аргументов, к которым процедуру надо применить, при помощи
@code{list-of-values}. Процедура @code{list-of-values} в качестве
аргумента берет список операндов комбинации. Она вычисляет каждый
аргумент и возвращает список соответствующих значений.@footnote{Ветку
@code{application?} в @code{eval} можно было бы упростить, используя
@code{map} (и постановив, что @code{operands} возвращает список) вместо
того, чтобы писать явным образом процедуру @code{list-of-values}. Мы
решили не использовать здесь @code{map}, чтобы подчеркнуть, что
интерпретатор можно написать без обращения к процедурам высших порядков
(а следовательно, его можно написать на языке, в котором нет таких
процедур), притом, что язык, поддерживаемый интерпретатором, содержит
процедуры высших порядков.}

@lisp
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
@end lisp

@comment @subsubheading Conditionals
@subsubheading Условные выражения

Процедура @code{eval-if} вычисляет предикатную часть выражения @code{if}
в данном окружении. Если результат истинен, @code{eval-if} выполняет
следствие, если нет, --- альтернативу:

@lisp
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Использование @code{true?} в @code{eval-if} подчеркивает вопрос о связи
между реализуемым языком и языком реализации. Выражение
@code{if-predicate} выполняется в реализуемом языке, и, следовательно,
результат его является значением этого языка. Предикат интерпретатора
@code{true?} переводит это значение в значение, которое может быть
проверено выражением @code{if} в языке реализации: метациклическое
представление истины может не совпадать с ее представлением в
нижележащей Scheme.@footnote{В нашем случае, язык реализации и
реализуемый язык совпадают. Размышления о значении @code{true?}
расширяют наше сознание безотносительно к материальной сущности
истины.}

@comment @subsubheading Sequences
@subsubheading Последовательности

Процедура @code{eval-sequence} вызывается из @code{apply} для выполнения
последовательности выражений в теле процедуры, а также из @code{eval}
для обработки последовательности выражений в выражении @code{begin}. Она
принимает в виде аргументов последовательность выражений и окружение, и
выполняет выражения в том порядке, в котором они ей даны. Возвращаемое
значение совпадает со значением последнего выражения.

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))
@end lisp

@comment @subsubheading Assignments and definitions
@subsubheading Присваивания и определения

Следующая процедура обрабатывает присваивание переменным. При помощи
@code{eval} она находит значение, которое требуется присвоить, и
передает переменную и получившееся значение в процедуру
@code{set-variable-value!} для включения в текущее окружение.

@lisp
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
@end lisp

@noindent
Определения переменных обрабатываются сходным образом:@footnote{Эта
реализация @code{define} не учитывает один тонкий вопрос в обработке
внутренних определений, хотя в большинстве случаев работает правильно. В
чем состоит проблема и как ее решить, мы увидим в @ref{4.1.6}.}

@lisp
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
@end lisp

@noindent
В качестве возвращаемого значения для присваивания или определения мы
выбрали символ @code{ok}.@footnote{Как мы упоминали при введении
@code{define} и @code{set!}, их значения в Scheme зависят от
реализации --- то есть автор реализации имеет право выбрать такое
значение, какое он хочет.}

@quotation
@strong{@anchor{Упражнение 4.1}Упражнение 4.1:}
Заметим, что мы не можем сказать, вычисляет ли
метациклический интерпретатор операнды слева направо или справа налево.
Порядок вычисления наследуется от нижележащего Лиспа: если аргументы
@code{cons} в процедуре @code{list-of-values} вычисляются слева направо,
то и операнды в @code{list-of-values} будут вычисляться слева направо.
Если же вычисление аргументов @code{cons} происходит справа налево, то и
@code{list-of-values} будет вычислять операнды справа налево.

Напишите версию @code{list-of-values}, которая вычисляет операнды слева
направо, вне зависимости от порядка вычислений в нижележащем Лиспе.
Напишите также версию, которая вычисляет операнды справа налево.
@end quotation

@comment @subsection Representing Expressions
@subsection Представление выражений
@node	4.1.2, 4.1.3, 4.1.1, 4.1

Интерпретатор напоминает программу символьного дифференцирования,
описанную в @ref{2.3.2}.
Обе программы работают с символьными выражениями. В обеих результат
работы с составным выражением определяется рекурсивной обработкой частей
выражения и сочетанием частичных результатов, причем способ сочетания
зависит от типа выражения. И там, и там мы использовали абстракцию
данных, чтобы отделить общие правила работы от деталей того, как
представлены выражения. Для программы дифференцирования это означало,
что одна и та же процедура взятия производной могла работать с
алгебраическими выражениями в префиксной, инфиксной или какой-либо
другой записи. Для интерпретатора это означает, что синтаксис языка
определяется исключительно процедурами, которые классифицируют выражения
и выделяют их части.

Вот описание синтаксиса нашего языка:

@itemize

@item
К самовычисляющимся объектам относятся только числа и строки:

@lisp
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
@end lisp

@item
Переменные представляются в виде символов:

@lisp
(define (variable? exp) (symbol? exp))
@end lisp

@item
Выражения с кавычкой имеют форму
@code{(quote @math{\langle}@var{закавыченное-выражение}@math{\rangle})}

@lisp
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
@end lisp

@code{quoted?} определена посредством процедуры @code{tagged-list?},
которая распознает списки, начинающиеся с указанного символа:@footnote{В
@ref{2.3.1} упоминается, что интерпретатор
рассматривает закавыченное выражение как список, начинающийся с
@code{quote}, даже если выражение напечатано через знак кавычки.
Например, выражение @code{'a} будет выглядеть для интерпретатора как
@code{(quote a)}. См. упражнение @ref{Упражнение 2.55}.}

@lisp
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
@end lisp

@item
Присваивания имеют форму
@code{(set! @math{\langle}@var{переменная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle})}:

@lisp
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
@end lisp

@item
Определения имеют вид

@lisp
(define @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle})
@end lisp

@noindent
или
or the form

@lisp
(define (@math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{параметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{параметр}@math{_{\monoit{n}}\rangle})
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

Вторая форма (стандартное определение процедуры) является синтаксическим сахаром для

@lisp
(define @math{\langle}@var{переменная}@math{\rangle}
  (lambda (@math{\langle}@var{параметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{параметр}@math{_{\monoit{n}}\rangle})
    @math{\langle}@var{тело}@math{\rangle}))
@end lisp

Соответствующие синтаксические процедуры выглядят так:

@lisp
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)     @r{; formal parameters}
                   (cddr exp))))   @r{; body}
@end lisp

@item
@code{lambda}-выражения являются списками, которые начинаются с символа @code{lambda}:

@lisp
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
@end lisp

Мы приводим также конструктор для @code{lambda}-выражений. Он
используется в вышеприведенной процедуре @code{definition-value}:

@lisp
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
@end lisp

@item
Условные выражения начинаются с @code{if} и имеют предикат, следствие и
(необязательную) альтернативу. Если в выражении нет части-альтернативы,
мы указываем в ее качестве @code{false}.@footnote{Значение выражения
@code{if} в случае, когда предикат ложен, а альтернатива отсутствует, в
Scheme не определено; здесь мы решили сделать его ложным. Мы будем
поддерживать переменные @code{true} и @code{false} в выполняемых
выражениях путем связывания их в глобальном окружении.
См. @ref{4.1.4}.}

@lisp
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
@end lisp

Мы предоставляем также конструктор для @code{if}-выражений. Его будет
использовать процедура @code{cond->if} для преобразования выражений
@code{cond} в выражения @code{if}:

@lisp
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
@end lisp

@item
@code{Begin} упаковывает последовательность выражений в одно выражение.
В синтаксические операции над выражениями @code{begin} мы включаем
извлечение самой последовательности из выражения @code{begin}, а также
селекторы, которые возвращают первое выражение и остаток выражений в
последовательности.@footnote{Эти селекторы для списка выражений, а также
соответствующие им селекторы для списка операндов, не предназначаются
для абстракции данных. Они введены в качестве мнемонических имен для
основных списковых операций, чтобы легче было понимать вычислитель с
явным управлением из @ref{5.4}.}

@lisp
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
@end lisp

Кроме того, мы даем конструктор @code{sequence->exp} (для использования
в процедуре @code{cond->if}), который преобразует последовательность в
единое выражение, используя, если надо, @code{begin}:

@lisp
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
@end lisp

@item
Вызов процедуры --- это любое составное выражение, не попадающее ни в
один из перечисленных типов. Его @code{car} --- это оператор, а
@code{cdr} --- список операндов:

@lisp
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
@end lisp

@end itemize

@comment @subsubheading Derived expressions
@subsubheading Производные выражения

Некоторые особые формы языка можно определить через выражения,
включающие другие особые формы, вместо того, чтобы задавать их напрямую.
Как пример рассмотрим @code{cond}, который можно реализовать как гнездо
выражений @code{if}. Например, задачу вычисления выражения

@lisp
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
@end lisp

@noindent
можно свести к задаче вычисления следующего выражения, состоящего из
форм @code{if} и @code{begin}:

@lisp
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
@end lisp

@noindent
Такая реализация обработки @code{cond} упрощает интерпретатор, поскольку
она уменьшает количество особых форм, для которых требуется явно
описывать процесс вычисления.

Мы включаем в интерпретатор синтаксические процедуры, которые определяют
доступ к частям выражения @code{cond}, а также процедуру
@code{cond->if}, которая преобразует выражения @code{cond} в выражения
@code{if}. Анализ случаев начинается с @code{cond} и состоит из списка
ветвей-вариантов вида предикат-действие. Вариант считается
умолчательным, если его предикатом является символ
@code{else}.@footnote{Значение выражения @code{cond}, когда все предикаты
ложны, а вариант по умолчанию @code{else} отсутствует, в языке Scheme не
определено; здесь мы решили сделать его ложным.}

@lisp
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                        @r{; no @code{else} clause}
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
@end lisp

@noindent
Выражения (вроде @code{cond}), которые мы желаем реализовать через
синтаксические преобразования, называются (@newterm{derived expressions}).
Выражения @code{let} также являются производными
(см. @ref{Упражнение 4.6}).@footnote{Практические
Lisp-системы предоставляют механизм, который дает пользователю
возможность добавлять новые производные выражения и определять их
значения через синтаксические преобразования, не внося изменений в
вычислитель. Такое преобразование, определяемое пользователем,
называется (@newterm{macro}). Добавить простой механизм для определения макросов
легко, однако в получающемся языке возникают сложные проблемы конфликта
имен. Множество исследований посвящено поиску механизмов определения
макросов, в которых такие проблемы не возникают. См., например,
Kohlbecker 1986, Clinger and Rees 1991 и Hanson 1991.}

@quotation
@strong{@anchor{Упражнение 4.2}Упражнение 4.2:}
Хьюго Дум хочет переупорядочить ветви @code{eval} так, чтобы
ветвь для вызова процедур располагалась перед веткой для присваивания.
Он утверждает, что при этом интерпретатор станет эффективнее: поскольку
в программах обычно больше вызовов процедур, чем присваиваний,
определений и т. д., его усовершенствованный @code{eval} обычно будет
рассматривать меньше вариантов, чем исходный, при распознавании типа
выражения.

@enumerate a.

@item
Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением @code{(define x 3)}?)

@item
Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до
того, как он проверяет все остальные типы выражений. Помогите ему,
изменив синтаксис интерпретируемого языка так, чтобы вызовы процедур
начинались с символа @code{call}. Например, вместо @code{(factorial 3)}
нам теперь придется писать @code{(call factorial 3)}, а вместо
@code{(+ 1 2)} --- @code{(call + 1 2)}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.3}Упражнение 4.3:}
Перепишите @code{eval} так, чтобы диспетчеризация
происходила в стиле, управляемом данными. Сравните результат с
дифференцированием, управляемым данными, из @ref{Упражнение 2.73}.
(Можно использовать @code{car} составного выражения в качестве типа
этого выражения, так как это хорошо сочетается с синтаксисом, реализованным
в этом разделе.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.4}Упражнение 4.4:} Вспомним определения особых
форм @code{and} и @code{or} из @ref{Глава 1}:

@itemize @bullet

@item
@code{and:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается ложным, возвращается ложь; оставшиеся выражения не
вычисляются. Если все выражения оказываются истинными, возвращается
значение последнего из них. Если нет ни одного выражения, возвращается
истина.

@item
@code{or:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается истинным, возвращается это значение; оставшиеся
выражения не вычисляются. Если все выражения оказываются ложными, или
нет ни одного выражения, возвращается ложь.

@end itemize

Введите @code{and} и @code{or} в качестве новых особых форм
интерпретатора, определив соответствующие синтаксические процедуры и
процедуры выполнения @code{eval-and} и @code{eval-or}. В качестве
альтернативы покажите, как можно реализовать @code{and} и @code{or} в
виде производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.5}Упражнение 4.5:}
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
@code{cond}, @code{(@math{\langle}@var{проверка}@math{\rangle} =>
@math{\langle}@var{потребитель}@math{\rangle})}.  Если результат
вычисления @math{\langle}@var{проверки}@math{\kern0.08em\rangle}
оказывается истинным значением, то вычисляется
@math{\langle}@var{потребитель}@math{\kern0.08em\rangle}. Его значение
должно быть одноместной процедурой; эта процедура вызывается со значением
@math{\langle}@var{проверки}@math{\kern0.08em\rangle} в качестве аргумента,
и результат этого вызова возвращается как значение выражения @code{cond}.
Например:

@lisp
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
@end lisp

@noindent
имеет значение 2. Измените обработку @code{cond} так, чтобы она
поддерживала этот расширенный синтаксис.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.6}Упражнение 4.6:}
Выражения @code{let} производны, поскольку

@lisp
(let ((@math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{пер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
эквивалентно

@lisp
((lambda (@math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{пер}@math{_{\monoit{n}}\rangle})
   @math{\langle}@var{тело}@math{\rangle})
 @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}
 @dots{}
 @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle})
@end lisp

Напишите синтаксическое преобразование @code{let->combination}, которое
сводит вычисление @code{let}-выражений к вычислению комбинаций
указанного вида, и добавьте соответствующую ветку для обработки
@code{let} к @code{eval}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.7}Упражнение 4.7:}
Особая форма @code{let*} подобна @code{let}, но только
связывания переменных в @code{let*} происходят последовательно, и каждое
следующее связывание происходит в окружении, где видны все предыдущие.
Например,

@lisp
(let* ((x 3)  (y (+ x 2))  (z (+ x y 5)))
  (* x z))
@end lisp

@noindent
возвращает значение 39. Объясните, каким образом можно переписать
выражение @code{let*} в виде набора вложенных выражений @code{let}, и
напишите процедуру @code{let*->nested-lets}, которая проделывает это
преобразование. Если мы уже реализовали @code{let}
(@ref{Упражнение 4.6}) и хотим теперь расширить
интерпретатор так, чтобы он обрабатывал @code{let*}, достаточно ли будет
добавить в @code{eval} ветвь, в которой действием записано

@lisp
(eval (let*->nested-lets exp) env)
@end lisp

@noindent
или нужно явным образом преобразовывать @code{let*} в набор
непроизводных выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.8}Упражнение 4.8:}
<<Именованный @code{let}>> --- это вариант , который имеет
вид

@lisp
(let @math{\langle}@var{var}@math{\rangle} @math{\langle}@var{bindings}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@math{\langle}@var{связывание}@math{\rangle} и
@math{\langle}@var{тело}@math{\rangle} такие же, как и в обычном
@code{let}, но только @math{\langle}@var{переменная}@math{\rangle}
связана в @math{\langle}@var{теле}@math{\rangle} с процедурой, у
которой тело @math{\langle}@var{тело}@math{\rangle}, а имена
параметров --- переменные в
@math{\langle}@var{связываниях}@math{\rangle}. Таким образом, можно
неоднократно выполнять @math{\langle}@var{тело}@math{\rangle}, вызывая
процедуру по имени @math{\langle}@var{переменная}@math{\rangle}.
Например, итеративную процедуру для порождения чисел Фибоначчи
(@ref{1.2.2}) можно переписать при помощи именованного @code{let} как

@lisp

(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
@end lisp

Измените преобразование @code{let->combination} из
упражнения @ref{Упражнение 4.6} так, чтобы оно поддерживало именованный
@code{let}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.9}Упражнение 4.9:}
Во многих языках имеются различные конструкции для
построения циклов, например, @code{do}, @code{for}, @code{while} и
@code{until}. В Scheme итеративные процессы можно выразить через обычные
вызовы процедур, так что особые конструкции не дают никакого
существенного выигрыша в вычислительной мощности. С другой стороны,
часто они удобны. Придумайте какие-нибудь конструкции для итерации,
дайте примеры их использования и покажите, как их реализовать в виде
производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.10}Упражнение 4.10:}
При помощи абстракции данных мы смогли написать процедуру
@code{eval} так, что она не зависит от конкретного синтаксиса
интерпретируемого языка. Чтобы проиллюстрировать это свойство,
разработайте новый синтаксис для Scheme, изменив процедуры из этого
раздела и ничего не трогая в @code{eval} и @code{apply}.
@end quotation

@comment @subsection Evaluator Data Structures
@subsection Структуры данных интерпретатора
@node	4.1.3, 4.1.4, 4.1.2, 4.1

Помимо внешнего синтаксиса выражений, реализация интерпретатора должна
определить также внутренние структуры данных, с которыми она работает во
время выполнения программы, в частности, представление процедур и
окружений, а также истинных и ложных значений.

@comment @subsubheading Testing of predicates
@subsubheading Проверка предикатов

В условных выражениях мы воспринимаем в качестве истины все, кроме
специального ложного объекта @code{false}.

@lisp
(define (true? x)  (not (eq? x false)))
(define (false? x) (eq? x false))
@end lisp

@comment @subsubheading Representing procedures
@subsubheading Представление процедур

Работая с примитивами, мы предполагаем, что у нас есть следующие
процедуры:

@itemize @bullet

@item
@code{(apply-primitive-procedure @math{\langle}@var{процедура}@math{\rangle}
@math{\langle}@var{аргументы}@math{\rangle})}

@noindent
применяет данную элементарную процедуру к значениям аргументов из списка
@math{\langle}@var{аргументы}@math{\rangle} и возвращает результат
вызова.

@item
@code{(primitive-procedure? @math{\langle}@var{процедура}@math{\rangle})}

@noindent
проверяет, является ли @math{\langle}@var{процедура}@math{\rangle}
элементарной.

@end itemize

@noindent
Эти механизмы работы с элементарными процедурами подробнее описаны в
@ref{Часть 4.1.4}.

Составная процедура строится из параметров, те́ла процедуры и окружения
при помощи конструктора @code{make-procedure}:

@lisp
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
@end lisp

@comment @subsubheading Operations on Environments
@subsubheading Действия над окружениями

Интерпретатору нужно иметь несколько операций, действующих над
окружениями. Как объясняется в @ref{3.2},
окружение представляет собой последовательность кадров, а каждый кадр
является таблицей связываний, соотносящих переменные с их значениями.
Для работы с окружениями мы используем следующие операции:

@itemize @bullet

@item
@code{(lookup-variable-value @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
возвращает значение, связанное с символом
@math{\langle}@var{переменная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle}, либо сообщает об ошибке,
если переменная не связана.

@item
@code{(extend-environment @math{\langle}@var{переменные}@math{\rangle} @math{\langle}@var{значения}@math{\rangle} @math{\langle}@var{исх-окр}@math{\rangle})}
возвращает новое окружение, состоящее из нового кадра, в котором символы
из списка  @math{\langle}@var{переменные}@math{\rangle} связаны с
соответствующими элементами списка
@math{\langle}@var{значения}@math{\rangle}, а объемлющим окружением
является окружение @math{\langle}@var{исх-окр}@math{\rangle}.

@item
@code{(define-variable! @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
добавляет к первому кадру @math{\langle}@var{окружение}@math{\rangle}
новое связывание, которое сопоставляет
@math{\langle}@var{переменная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle}.

@item
@code{(set-variable-value! @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
изменяет связывание @math{\langle}@var{переменная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle} так, что в дальнейшем ей
будет соответствовать @math{\langle}@var{значение}@math{\rangle}, либо
сообщает об ошибке, если переменная не связана.

@end itemize

@noindent
Чтобы реализовать все эти операции, мы представляем окружение в виде
списка кадров. Объемлющее окружение живет в @code{cdr} этого списка.
Пустое окружение --- это просто пустой список.

@lisp
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
@end lisp

@noindent
Каждый кадр в окружении представляется в виде пары списков: список
переменных, связанных в кадре, и список значений.@footnote{В
нижеследующем коде кадры не являются настоящей абстракцией данных:
@code{set-variable-value!} и @code{define-variable!} явным образом
изменяют значения в кадре при помощи @code{set-car!}. Назначение
процедур работы с кадрами --- сделать код операций над окружениями
простым для чтения.}

@lisp
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
@end lisp

@noindent
Чтобы расширить окружение новым кадром, который связывает переменные со
значениями, мы порождаем кадр, который состоит из списка переменных и
списка значений, и присоединяем его к окружению. Если количество
переменных и количество значений не совпадают, сообщаем об ошибке.

@lisp
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
@end lisp

@noindent
Чтобы найти переменную в окружении, мы просматриваем список переменных в
первом кадре. Если находим нужную переменную, то возвращаем
соответствующий элемент списка значений. Если мы не находим переменную в
текущем кадре, то ищем в объемлющем окружении, и так далее. Если мы
добираемся до пустого окружения, нужно сообщить об ошибке
<<неопределенная переменная>>.

@lisp
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы присвоить переменной новое значение в указанном окружении, мы ищем
переменную, точно так же, как в @code{lookup-variable-value}, и изменяем
соответствующее значение, когда его находим.

@lisp
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы определить переменную, мы просматриваем первый кадр в поисках
связывания для нее, и изменяем связывание, если его удается найти (так
же, как в @code{set-variable-value!}). Если связывания не существует, мы
присоединяем его к первому кадру.

@lisp
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))
@end lisp

@noindent
Описанный здесь метод --- только один из многих способов представления
окружений. Поскольку мы при помощи абстракции данных отделили конкретную
реализацию от остальных частей интерпретатора, при желании мы можем
сменить представление окружений.
(См. @ref{Упражнение 4.11}.) В Lisp-системе промышленного
качества быстрота операций над окружениями --- особенно обращения к
переменной --- очень сильно влияет на общую производительность.
Представление, описанное здесь, при всей своей концептуальной простоте
неэффективно и, скорее всего, его не стали бы использовать в рабочей
системе.@footnote{Недостаток этого представления (как и варианта из
@ref{Упражнение 4.11}) состоит в том, что вычислителю может
понадобиться просматривать слишком много кадров, чтобы найти связывание
конкретной переменной. Такой подход называется (@newterm{deep binding}).
Один из способов избежать такой потери производительности --- использовать
стратегию под названием (@newterm{lexical addressing}), которая обсуждается в
@ref{5.5.6}.}

@quotation
@strong{@anchor{Упражнение 4.11}Упражнение 4.11:}
Вместо того, чтобы представлять кадр в виде списка
списков, его можно представить как список связываний, где каждое
связывание является парой из имени и значения. Перепишите операции с
окружениями в соответствии с этим альтернативным представлением.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.12}Упражнение 4.12:}
Процедуры @code{set-variable-value!},
@code{define-variable!} и @code{lookup-variable-value} можно выразить
посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.13}Упражнение 4.13:}
Scheme позволяет создавать новые связывания через
@code{define}, но не дает никакого способа избавиться от связывания.
Реализуйте в интерпретаторе особую форму @code{make-unbound!}, которая
изымает связывание данного символа из окружения, в котором
@code{make-unbound!} выполняется. Задача определена не до конца.
Например, нужно ли удалять связывания в других кадрах, кроме первого?
Дополните спецификацию и объясните свой выбор вариантов.
@end quotation

@comment @subsection Running the Evaluator as a Program
@subsection Выполнение интерпретатора как программы
@node	4.1.4, 4.1.5, 4.1.3, 4.1

Написав интерпретатор, мы получаем в руки описание (выраженное на Lisp)
процесса вычисления лисповских выражений. Одно из преимуществ наличия
описания в виде программы в том, что эту программу можно запустить. У
нас внутри Лиспа есть работающая модель того, как сам Лисп вычисляет
выражения. Она может служить средой для экспериментов с правилами
вычисления, и дальше в этой главе мы такими экспериментами и займемся.

Программа-вычислитель в конце концов сводит выражения к применению
элементарных процедур. Следовательно, единственное, что нам требуется
для запуска интерпретатора, --- создать механизм, который обращается к
нижележащей Лисп-системе и моделирует вызовы элементарных процедур.

Нам нужно иметь связывание для каждого имени элементарной процедуры,
чтобы, когда @code{eval} выполняет вызов примитива, у него был объект,
который можно передать в @code{apply}. Поэтому мы выстраиваем глобальное
окружение, связывающее особые объекты с именами элементарных процедур,
которые могут появляться в вычисляемых нами выражениях. Кроме того,
глобальное окружение включает связывания для символов и @code{false},
так что их можно использовать как переменные в вычисляемых выражениях.

@lisp
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))
@end lisp

@noindent
Как именно мы представляем объекты-элементарные процедуры, не имеет
значения. Требуется только, чтобы их можно было распознавать и
применять, вызывая процедуры @code{primitive-procedure?} и
@code{apply-primitive-procedure}. Мы решили представлять примитивы в
виде списка, начинающегося с символа @code{primitive} и содержащего
процедуру нижележащего Лиспа, которая реализует данный примитив.

@lisp
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
@end lisp

@noindent
@code{setup-environment} получит имена и реализации элементарных
процедур из списка:@footnote{Любую процедуру, определенную в нижележащем
Лиспе, можно использовать как примитив для метациклического
интерпретатора. Имя примитива, установленного в интерпретаторе, не
обязательно должно совпадать с именем его реализации в нижележащем
Лиспе; здесь имена одни и те же потому, что метациклический
интерпретатор реализует саму Scheme. Так, например, мы могли бы написать
в списке @code{primitive-procedures} что-нибудь вроде
@code{(list 'first car)} или
@code{(list 'square (lambda (x) (* x x)))}.}

@lisp
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        @math{\langle}@var{другие примитивы}@math{\rangle} ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
@end lisp

@noindent
Чтобы вызвать элементарную процедуру, мы просто применяем
процедуру-реализацию к аргументам, используя нижележащую
Lisp-систему.@footnote{@code{apply-in-underlying-scheme} --- это процедура
@code{apply}, которой мы пользовались в предыдущих главах. Процедура
@code{apply} метациклического интерпретатора (@ref{4.1.1}) имитирует работу
этого примитива. Наличие двух процедур с одинаковым именем ведет к технической
проблеме при запуске интерпретатора, поскольку определение @code{apply}
метациклического интерпретатора загородит определение примитива. Можно
избежать этого, переименовав метациклический @code{apply}, и избавиться
таким образом от конфликта с именем элементарной процедуры. Мы же вместо
этого приняли решение сохранить ссылку на исходный @code{apply}, выполнив

@lisp
(define apply-in-underlying-scheme apply)
@end lisp

@noindent
прежде, чем определили @code{apply} в интерпретаторе. Теперь мы можем
обращаться к исходной версии @code{apply} под другим именем.}

@lisp
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Для удобства работы с метациклическим интерпретатором мы организуем
(@newterm{driver loop}), который моделирует цикл чтения-выполнения-печати
нижележащей Лисп-системы. Этот цикл печатает (@newterm{prompt}), считывает входное
выражение, вычисляет это выражение в глобальном окружении и
распечатывает результат. Перед каждым результатом мы помещаем (output
prompt), чтобы отличить значение выражения от всего прочего, что может
быть напечатано.@footnote{Элементарная процедура ожидает ввода от
пользователя и возвращает ближайшее полное выражение, которое он
напечатает. Например, если пользователь напечатает @code{(+ 23 x)},
результатом @code{read} будет трехэлементный список из символа @code{+},
числа 23 и символа @code{x}. Если пользователь введет @code{'x},
результатом @code{read} будет двухэлементный список из символа
@code{quote} и символа @code{x}.}

@lisp
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
@end lisp

@noindent
Мы пользуемся специальной процедурой вывода @code{user-print}, чтобы не
печатать окружение составных процедур, которое может быть очень длинным
списком, и даже может содержать циклы.

@lisp
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
@end lisp

@noindent
Теперь для запуска интерпретатора нам остается только
проинициализировать глобальное окружение и войти в управляющий цикл. Вот
пример работы интерпретатора:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)

@i{;;; M-Eval input:}
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
@i{;;; M-Eval value:}
@i{ok}
@i{;;; M-Eval input:}
(append '(a b c) '(d e f))
@i{;;; M-Eval value:}
@i{(a b c d e f)}
@end lisp

@c @sp 1
@quotation
@strong{@anchor{Упражнение 4.14}Упражнение 4.14:}
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение @code{map}
и запускает несколько тестовых программ с его использованием. Они
замечательно работают. Хьюго, со своей стороны, ввел системную версию
@code{map} как примитив метациклического интерпретатора. Когда он
пытается его выполнить, все ломается самым ужасным образом. Объясните,
почему у Хьюго @code{map} не работает, а у Евы работает.
@end quotation

@comment @subsection Data as Programs
@subsection Данные как программы
@node	4.1.5, 4.1.6, 4.1.4, 4.1

При рассмотрении программы на Лиспе, вычисляющей лисповские выражения,
может быть полезна аналогия. Одна из возможных точек зрения на значение
программы состоит в том, что программа описывает абстрактную (возможно,
бесконечно большую) машину. Рассмотрим, например, знакомую нам программу
для вычисления факториалов:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Можно считать эту программу описанием машины, которая содержит узлы для
вычитания, умножения и проверки на равенство, двухпозиционный
переключатель и еще одну факториал-машину. (Факториал-машина получается
бесконечной, поскольку она содержит другую факториал-машину внутри
себя.) На рисунке @ref{Рисунок 4.2} изображена потоковая диаграмма
факториал-машины, которая показывает, как спаяны ее части.

Подобным образом, мы можем рассматривать вычислитель как особого рода
машину, которой подается в виде сырья описание другой машины. Обработав
свои входные данные, вычислитель перестраивает себя так, чтобы
моделировать описываемую машину. Например, если мы скормим вычислителю
определение @code{factorial}, как показано на
рисунке @ref{Рисунок 4.3}, он сможет считать факториалы.

@float
@quotation
@anchor{Рисунок 4.2}
@ifinfo
@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.

@example
    +-----------------------------------+
    | factorial                   |1    |
    |              |1             V     |
    |              |           +-----+  |
    |              V           | #   |  |
    |           +-----+        |     |  |
6 --------*-----|  =  |------->|   #-+-----> 720
    |     |     +-----+        |  /  |  |
    |     |                    | #   |  |
    |     |                    +-----+  |
    |     |                       ^     |
    |     |                       |     |
    |     |                    +--+--+  |
    |     *------------------->|  *  |  |
    |     |                    +-----+  |
    |     V                       ^     |
    |  +-----+    +-----------+   |     |
    |  |  -  +--->| factorial +---+     |
    |  +-----+    +-----------+         |
    |     ^                             |
    |     |1                            |
    +-----------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.2,84mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.}
@center @caption{@strong{Рисунок 4.2:} Программа вычисления факториала, изображенная в виде абстрактной машины.}
@sp 0.9
@end iftex
@end quotation
@end float

С этой точки зрения, наш вычислитель-интерпретатор выглядит как
(@newterm{universal machine}). Она имитирует другие машины, представленные
в виде Lisp-программ.@footnote{То, что машины описаны на языке Лисп,
несущественно. Если дать нашему интерпретатору программу на Лиспе,
которая ведет себя как вычислитель для какого-нибудь другого языка,
скажем, Си, то вычислитель для Лиспа будет имитировать вычислитель для
Си, который, в свою очередь, способен сымитировать любую машину,
описанную в виде программы на Си. Подобным образом, написание
интерпретатора Лиспа на Си порождает программу на Си, способную
выполнить любую программу на Лиспе. Главная идея здесь состоит в том,
что любой вычислитель способен имитировать любой другой. Таким образом,
понятие <<того, что в принципе можно вычислить>> (если не принимать во
внимание практические вопросы времени и памяти, потребной для
вычисления), независимо от языка компьютера и выражает глубинное понятие
(computability). Это впервые было ясно показано Аланом М. Тьюрингом
(1912-1954), чья статья 1936 года заложила основы теоретической
информатики. В этой статье Тьюринг представил простую модель
вычислений, --- теперь известную как (@newterm{Turing machine}), --- и
утверждал, что любой <<эффективный процесс>> выразим в виде программы
для такой машины. (Этот аргумент известен как (@newterm{Church-Turing thesis}).)
Затем Тьюринг реализовал универсальную машину, т. е. машину Тьюринга,
которая работает как вычислитель для программ машин Тьюринга. При помощи
этой схемы рассуждений он показал, что существуют коррекно поставленные
задачи, которые не могут быть решены машиной Тьюринга
(см. @ref{Упражнение 4.15}), а следовательно не могут быть
сформулированы в виде <<эффективного процесса>>. Позднее Тьюринг внес
фундаментальный вклад и в развитие практической информатики. Например,
ему принадлежит идея структурирования программ с помощью подпрограмм
общего назначения. Биографию Тьюринга можно найти в Hodges 1983.} Это
замечательное устройство. Попробуйте представить себе аналогичный
вычислитель для электрических схем. Это была бы схема, которой на вход
поступает сигнал, кодирующий устройство какой-то другой схемы, например,
фильтра. Восприняв этот вход, наша схема-вычислитель стала бы работать
как фильтр, соответствующий описанию. Такая универсальная электрическая
схема имеет почти невообразимую сложность. Удивительно, что
интерпретатор программ --- сам по себе программа довольно
простая.@footnote{Некоторые считают странным, что вычислитель,
реализованный с помощью относительно простой процедуры, способен
имитировать программы, более сложные, чем он сам. Существование
универсальной машины-вычислителя --- глубокое и важное свойство
вычисления. (recursion theory), отрасль математической логики,
занимается логическими пределами вычислимости. В прекрасной книге
Дугласа Хофштадтера <<Гёдель, Эшер, Бах>> (Hofstadter 1979) исследуются
некоторые из этих идей.}

@float
@quotation
@anchor{Рисунок 4.3}
@ifinfo
@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.

@example
                   +--------+
            6 ---->|  eval  |----> 720
                   +--------+
                       /
             . . .    /  . . .
       . . .       ../. .      .
     .                           ..
    .   (define (factorial n)      . . .
   .      (if (= n 1)                   . .
    .         1                            .
    .         (* (factorial (- n 1)) n)))   .
      . .                       . .        .
          . .  . .      . . . .     . . . .
                   . ..
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.3,69mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.}
@center @caption{@strong{Рисунок 4.3:} Вычислитель, моделирующий факториальную машину.}
@sp 0.9
@end iftex
@end quotation
@end float

Еще одна замечательная черта интерпретатора заключается в том, что он
служит мостом между объектами данных, которыми манипулирует язык
программирования, и самим языком. Представим себе, что работает
программа интерпретатора (реализованная на Лиспе), и что пользователь
вводит выражения в интерпретатор и рассматривает результаты. С точки
зрения пользователя, входное выражение вроде @code{(* x x)} является
выражением языка программирования, которое интерпретатор должен
выполнить. Однако с точки зрения интерпретатора это всего лишь список (в
данном случае, список из трех символов: @code{*}, @code{x} и @code{x}), с
которым нужно работать по ясно очерченным правилам.

Нас не должно смущать, что программы пользователя являются данными для
интерпретатора. На самом деле, иногда бывает удобно игнорировать это
различие и, предоставляя пользовательским программам доступ к
@code{eval}, давать пользователю возможность явным образом вычислить
объект данных как выражение Лиспа. Во многих диалектах Лиспа имеется
элементарная процедура @code{eval}, которая в виде аргументов берет
выражение и окружение, и вычисляет выражение в указанном
окружении.@footnote{Предупреждение: эта процедура @code{eval} --- не то
же самое, что процедура @code{eval}, реализованная нами в @ref{4.1.1},
потому что она работает с @emph{настоящими} окружениями, а не с
искусственными структурами окружений, которые мы построили в @ref{4.1.3}.
С этими настоящими
окружениями пользователь не может работать, как с обычными списками; к
ним нужно обращаться через @code{eval} или другие специальные операции.
Подобным образом, элементарная процедура @code{apply}, упомянутая
раньше, не то же самое, что метациклическая @code{apply}, поскольку она
использует настоящие процедуры Scheme, а не объекты-процедуры, которые
мы конструировали в разделах @ref{4.1.3} и @ref{4.1.4}.} Таким образом, как

@lisp
(eval '(* 5 5) user-initial-environment)
@end lisp

@noindent
так и

@lisp
(eval (cons '* (list 5 5)) user-initial-environment)
@end lisp

@noindent
возвращают результат 25.@footnote{Реализация MIT Scheme имеет процедуру
@code{eval}, а также символ , связанный с исходным окружением, в котором
вычисляются выражения.}

@quotation
@strong{@anchor{Упражнение 4.15}Упражнение 4.15:}
Если даны одноаргументная процедура @code{p} и объект
@code{a}, то говорят, что @code{p} <<останавливается>> на @code{a}, если
выражение @code{(p a)} возвращает значение (а не печатает сообщение об
ошибке или выполняется вечно). Покажите, что невозможно написать
процедуру @code{halts?}, которая бы точно определяла для любой процедуры
@code{p} и любого объекта @code{a}, останавливается ли @code{p} на
@code{a}. Используйте следующее рассуждение: если бы имелась такая
процедура @code{halts?}, можно было бы написать следующую программу:

@lisp
(define (run-forever) (run-forever))
(define (try p)
  (if (halts? p p) (run-forever) 'halted))
@end lisp

Теперь рассмотрите выражение @code{(try try)} и покажите, что любое
возможное завершение (остановка или вечное выполнение) нарушает
требуемое поведение @code{halts?}.@footnote{Хотя здесь мы предположили,
что @code{halts?} получает процедурный объект, заметим, что рассуждение
остается в силе даже в том случае, когда на вход подается текст
процедуры и ее окружение. В этом и состоит знаменитая (Halting Theorem)
Тьюринга, в которой был дан первый пример (non-computable) задачи,
т. е. корректно поставленного задания, которое невозможно выполнить с
помощью вычислительной процедуры.}
@end quotation

@comment @subsection Internal Definitions
@subsection Внутренние определения
@node	4.1.6, 4.1.7, 4.1.5, 4.1

Наша модель вычислений с окружениями и метациклический интерпретатор
выполняют определения по очереди, расширяя кадр окружения на одно
определение за раз. Это особенно удобно для диалоговой разработки
программы, когда программисту нужно свободно смешивать вызовы процедур с
определениями новых процедур. Однако если мы внимательно поразмыслим над
внутренними определениями, с помощью которых реализуется блочная
структура (введенная в @ref{1.1.8}), то мы увидим, что пошаговое расширение
окружения --- одно имя за другим --- может оказаться не лучшим способом
определения локальных переменных.

Рассмотрим процедуру с внутренними определениями, например

@lisp
(define (f x)
  (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)  (if (= n 0) false (even? (- n 1))))
  @math{\langle}@var{остаток тела @code{f}}@math{\rangle})
@end lisp

@noindent
Здесь нам хочется, чтобы имя @code{odd?} в теле процедуры @code{even?}
ссылалось на процедуру @code{odd?}, которая определена позже, чем
@code{even?}. Область действия имени @code{odd?} --- это все тело
@code{f}, а не только та его часть, которая лежит за точкой внутри
@code{f}, где определяется @code{odd?}. В самом деле, ели заметить, что
сама @code{odd?} определена с помощью @code{even?} --- так что
@code{even?} и @code{odd?} являются взаимно рекурсивными
процедурами, --- то становится ясно, что единственная
удовлетворительная интерпретация двух @code{define} --- рассматривать
их так, как будто @code{even?} и @code{odd?} были добавлены в окружение
одновременно. В общем случае, сферой действия локального имени является
целиком тело процедуры, в котором вычисляется @code{define}.

В нынешнем виде интерпретатор будет вычислять вызовы @code{f} правильно,
но причина этого <<чисто случайная>>: поскольку определения внутренних
процедур расположены в начале, никакие их вызовы не вычисляются, пока
они все не определены. Следовательно, к тому времени, когда выполняется
@code{even?}, @code{odd?} уже определена. Фактически, последовательный
механизм вычисления дает те же результаты, что и механизм,
непосредственно реализующий одновременное определение, для всякой
процедуры, где внутренние определения стоят в начале тела, а вычисление
выражений для определяемых переменных не использует ни одну из этих
переменных. (Пример процедуры, которая не удовлетворяет этим
требованиям, так что последовательное определение не равносильно
одновременному, можно найти в @ref{Упражнение 4.19}.)@footnote{Нежелание
зависеть в программах от этого механизма вычисления побудило нас написать
<<администрация ответственности не несет>> в примечании @ref{Сноска 28} в
@ref{Глава 1}.
Настаивая на том, чтобы внутренние определения стояли в начале тела и не
использовали друг друга во время вычисления самих определений, стандарт
IEEE Scheme дает авторам реализаций некоторую свободу при выборе
механизма вычисления этих определений. Выбор того или иного правила
вычисления может показаться мелочью, которая влияет только на
интерпретацию <<плохих>> программ. Однако в @ref{5.5.6} мы увидим, что
через переход к модели с одновременным определением внутренних
переменных можно избежать некоторых досадных трудностей, которые бы в
противном случае возникли при написании компилятора.}

Однако имеется простой способ обрабатывать определения так, чтобы у
локально определенных имен оказалась действительно общая сфера
действия, --- достаточно лишь создать все будущие внутренние переменные
текущего окружения, прежде чем начнется вычисление какого-либо из
выражений, возвращающих значение. Можно это сделать, например, путем
синтаксического преобразования @code{lambda}-выражений. Прежде чем
выполнять тело выражения @code{lambda}, мы <<прочесываем>> его и
уничтожаем все внутренние определения. Локально определенные переменные
будут созданы через @code{let}, а затем получат значения посредством
присваивания. Например, процедура

@lisp
(lambda @math{\langle}@var{переменные}@math{\rangle}
  (define u @math{\langle}@var{e1}@math{\rangle})
  (define v @math{\langle}@var{e2}@math{\rangle})
  @math{\langle}@var{e3}@math{\rangle})
@end lisp

@noindent
преобразуется в

@lisp
(lambda @math{\langle}@var{переменные}@math{\rangle}
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u @math{\langle}@var{e1}@math{\rangle})
    (set! v @math{\langle}@var{e2}@math{\rangle})
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

@noindent
где @code{unassigned*} --- специальный символ, который при поиске
переменной вызывает сообщение об ошибке, если программа пытается
использовать значение переменной, которой ничего еще не присвоено.

Альтернативная стратегия поиска внутренних определений показана в
упражнении @ref{Упражнение 4.18}. В отличие от преобразования,
продемонстрированного только что, она навязывает программисту следующее
ограничение: значение каждой определяемой переменной должно вычисляться
без обращения к значениям других определяемых
переменных.@footnote{Стандарт IEEE Scheme допускает различные стратегии
реализации. В нем говорится, что программист обязан подчиняться этому
ограничению, но реализация может его не проверять. Некоторые реализации
Scheme, включая MIT Scheme, используют преобразование, показанное выше.
В таких реализациях будут работать некоторые из программ, которые это
ограничение нарушают.}

@quotation
@strong{@anchor{Упражнение 4.16}Упражнение 4.16:}
В этом упражнении мы реализуем только что описанный метод
обработки внутренних определений. Мы предполагаем, что интерпретатор
поддерживает @code{let} (см. упражнение @ref{Упражнение 4.6}).

@enumerate a.

@item
Измените процедуру @code{lookup-variable-value} (@ref{4.1.3}) так, чтобы она,
обнаруживая в качестве значения символ @code{*unassigned*}, сообщала об ошибке.

@item
Напишите процедуру , которая берет тело процедуры и возвращает его
эквивалент без внутренних определений, выполняя описанное нами
преобразование.

@item
Вставьте @code{scan-out-defines} в интерпретатор, либо в
@code{make-procedure}, либо в @code{procedure-body} (см. @ref{4.1.3}).
Какое из этих мест лучше? Почему?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.17}Упражнение 4.17:}
Нарисуйте диаграммы окружения, которое находится в силе в
момент выполнения выражения @emph{@math{\langle}e3@math{\rangle}} из
процедуры выше по тексту, и сравните его устройство при последовательной
обработке определений и при описанном выше преобразовании. Откуда в
преобразованной программе берется дополнительный кадр? Объясните, почему
это различие никогда не отражается на поведении корректных программ.
Придумайте, как заставить интерпретатор реализовать правило
<<одновременной>> сферы действия для внутренних определений без создания
дополнительного кадра.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.18}Упражнение 4.18:} Рассмотрим альтернативную
стратегию обработки определений, которая переводит пример из текста в

@lisp
(lambda @math{\langle}@var{переменные}@math{\rangle}
  (let ((u '*unassigned*) (v '*unassigned*))
    (let ((a @math{\langle}@var{e1}@math{\rangle}) (b @math{\langle}@var{e2}@math{\rangle}))
      (set! u a)
      (set! v b))
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

Здесь @code{a} и @code{b} представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру @code{solve} из @ref{3.5.4}:

@lisp
(define (solve f y0 dt)
  (define  y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

Будет ли эта процедура работать, если внутренние определения
преобразуются так, как предлагается в этом упражнении? А если так, как в
тексте раздела? Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.19}Упражнение 4.19:}
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том,
каким должен быть результат выражения

\enlargethispage{\baselineskip}

@lisp
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
@end lisp

Бен говорит, что следует действовать согласно последовательному правилу
для @code{define}: @code{b} равно 11, затем @code{a} определяется как 5,
так что общий результат равен 16. Лиза возражает, что взаимная рекурсия
требует правила одновременной сферы действия для внутренних определений
и нет причин рассматривать имена процедур отдельно от прочих имен. То
есть она выступает за механизм, реализованный в @ref{Упражнение 4.16}.
При этом @code{a} оказывается не
определено в момент, когда вычисляется @code{b}. Следовательно, по
мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с обоими.
Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение @code{a} должно использоваться при
вычислении @code{b}. Следовательно, по мнению Евы, @code{a} должно
равняться 5, @code{b} должно быть 15, а общий результат 20. Какую из
этих точек зрения Вы поддерживаете (если у Вас нет своей четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?@footnote{Авторы MIT Scheme согласны с
Лизой, и вот почему: в принципе права Ева --- определения следует
рассматривать как одновременные. Однако придумать универсальный
эффективный механизм, который вел бы себя так, как она требует, кажется
трудным. Если же такого механизма нет, то лучше порождать ошибку в
сложных случаях параллельных определений (мнение Лизы), чем выдавать
неверный ответ (как хочет Бен).}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.20}Упражнение 4.20:}
Поскольку внутренние определения выглядят
последовательными, а на самом деле параллельны, некоторые предпочитают
их вовсе избегать и вместо этого пользуются особой формой @code{letrec}.
@code{Letrec} выглядит так же, как @code{let}, поэтому неудивительно,
что переменные в нем связываются одновременно и имеют одинаковую для
всех сферу действия. Можно переписать процедуру-пример @code{f} из
текста без внутренних определений, но при этом в точности с тем же
значением, так:

@lisp
(define (f x)
  (letrec
    ((even? (lambda (n)
              (if (= n 0) true  (odd?  (- n 1)))))
     (odd?  (lambda (n)
              (if (= n 0) false (even? (- n 1))))))
    @math{\langle}@var{остаток тела @code{f}}@math{\rangle}))
@end lisp

Выражение @code{letrec} имеет вид

@lisp
(letrec ((@math{\langle}@var{пер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{пер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
и является вариантом @code{let}, в котором выражения
@math{\langle}@var{выр}@math{_k\rangle},
устанавливающие начальные значения для переменных
@math{\langle}@var{пер}@math{_k\rangle}, вычисляются
в окружении, которое включает все связывания @code{letrec}. Это делает
возможным рекурсию между связываниями, к примеру, взаимную рекурсию
@code{even?} и @code{odd?} в последнем примере, или вычисление
факториала 10 через

@lisp
(letrec
  ((fact (lambda (n)
           (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
@end lisp

@enumerate a.

@item
Реализуйте @code{letrec} как производное выражение, переводя выражение
@code{letrec} в выражение @code{let}, как показано в тексте раздела или
в упражнении @ref{Упражнение 4.18}. То есть переменные @code{letrec}
должны создаваться в @code{let}, а затем получать значение через
@code{set!}.

@item
Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся @code{define} внутри процедуры, то
пусть пользуются обычным @code{let}. Покажите, что́ в его рассуждениях
неверно. Нарисуйте диаграмму, показывающую окружение, в котором
выполняется @math{\langle}@var{остаток тела @code{f}}@math{\rangle} во
время вычисления выражения @code{(f 5)}, если @code{f} определена как в
этом упражнении. Нарисуйте диаграмму окружений для того же вычисления,
но только с @code{let} на месте @code{letrec} в определении @code{f}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.21}Упражнение 4.21:}
Как ни удивительно, интуитивная догадка Хьюго (в @ref{Упражнение 4.20})
оказывается верной. Действительно,
можно строить рекурсивные процедуры без использования @code{letrec} (и
даже без @code{define}), только способ это сделать намного тоньше, чем
казалось Хьюго. Следующее выражение вычисляет факториал 10 с помощью
рекурсивной процедуры:@footnote{В этом примере показан программистский
трюк, позволяющий формулировать рекурсивные процедуры без помощи
@code{define}. Самый общий прием такого рода называется (Y operator), и
с его помощью можно реализовать рекурсию в <<чистом
@math{\lambda}-исчислении>>. (Подробности о лямбда-исчислении можно
найти в Stoy 1977, а демонстрацию @math{Y}-оператора на Scheme в Gabriel
1988.)}

@lisp
((lambda (n)
   ((lambda (fact) (fact fact n))
    (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
 10)
@end lisp

@enumerate a.

@item
Проверьте, что это выражение на самом деле считает факториалы (вычисляя
его). Постройте аналогичное выражение для вычисления чисел Фибоначчи.

@item
Рассмотрим следующую процедуру, включающую взаимно рекурсивные
внутренние определения:

@lisp
(define (f x)
  (define (even? n)
    (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)
    (if (= n 0) false (even? (- n 1))))
  (even? x))
@end lisp

Восстановите пропущенные фрагменты так, чтобы получилось альтернативное
определение @code{f}, где нет ни внутренних определений, ни @code{letrec}:

@lisp
(define (f x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))))
@end lisp
@end enumerate
@end quotation

@comment @subsection Separating Syntactic Analysis from Execution
@subsection Отделение синтаксического анализа от выполнения
@node	4.1.7,  , 4.1.6, 4.1

Написанный нами интерпретатор прост, но очень неэффективен, потому что
синтаксический анализ выражений перемешан в нем с их выполнением. Таким
образом, сколько раз выполняется программа, столько же раз анализируется
ее синтаксис. Рассмотрим, например, вычисление @code{(factorial 4)},
если дано следующее определение факториала:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Каждый раз, когда вызывается @code{factorial}, интерпретатор должен
определить, что тело процедуры является условным выражением, и извлечь
его предикат. Только после этого он может вычислить предикат и поступить
в соответствии с его значением. Каждый раз, когда вычисляется выражение
@code{(* (factorial (- n 1)) n)} или подвыражения
@code{(factorial (- n 1))} и @code{(- n 1)}, интерпретатор должен
произвести анализ случаев внутри @code{eval}, выяснить, что выражение
является вызовом процедуры, а также извлечь его оператор и операнды.
Такой анализ недёшев. Проделывать его многократно --- неразумно.

Можно преобразовать интерпретатор так, чтобы синтаксический анализ
проводился только один раз, и повысить таким образом эффективность
работы.@footnote{Такое преобразование является неотъемлемой частью
процесса компиляции, который мы рассмотрим в @ref{Глава 5}.
Джонатан Рис написал для проекта T интерпретатор Scheme с похожей
структурой приблизительно в 1982 голу (Rees and Adams 1982). Марк Фили
(Feeley 1986, см. также Feeley and Lapalme 1987) независимо изобрел этот
метод в своей дипломной работе.} Мы разбиваем процедуру @code{eval},
которая принимает выражение и окружение, на две части. @code{analyze}
берет только выражение. Она выполняет синтаксический анализ и возвращает
новую @emph{исполнительную процедуру} (@newterm{execution procedure}). В этой
процедуре упакована работа, которую придется проделать при выполнении
выражения. Исполнительная процедура берет в качестве аргумента окружение
и завершает вычисление. При этом экономится работа, потому что
@code{analyze} будет для каждого выражения вызываться только один раз, а
исполнительная процедура, возможно, многократно.

После разделения анализа и выполнения @code{eval} превращается в

@lisp
(define (eval exp env) ((analyze exp) env))
@end lisp

@noindent
Результатом вызова @code{analyze} является исполнительная процедура,
которая применяется к окружению. @code{Analyze} содержит тот же самый
анализ, который делал исходный @code{eval} из @ref{4.1.1}, однако процедуры,
между которыми мы выбираем, только анализируют, а не окончательно выполняют
выражение.

@lisp
(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else (error "Unknown expression type: ANALYZE" exp))))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Вот самая простая из процедур анализа, которая обрабатывает
самовычисляющиеся выражения. Ее результатом является исполнительная
процедура, которая игнорирует свой аргумент-окружение и просто
возвращает само выражение:

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
@end lisp

@noindent
В случае кавычки мы можем добиться некоторого выигрыша, извлекая
закавыченное выражение только один раз на стадии анализа, а не на стадии
выполнения.

@lisp
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
@end lisp

@noindent
Поиск переменной нужно проводить на стадии выполнения, поскольку при
этом требуется знать окружение.@footnote{Есть, впрочем, важная часть
поиска переменной, которую все-таки @emph{можно} осуществить во время
синтаксического анализа. Как мы покажем в @ref{5.5.6}, можно
определить позицию в структуре окружения, где будет находиться нужное
значение, и таким образом избежать необходимости искать в окружении
элемент, который соответствует переменной.}

@lisp
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
@end lisp

@noindent
Анализ присваивания, @code{analyze-assignment}, также должен отложить
само присваивание до времени выполнения, когда будет в наличии
окружение. Однако возможность (рекурсивно) проанализировать выражение
@code{assignment-value} сразу, на стадии анализа, --- это большой
выигрыш в эффективности, поскольку теперь это выражение будет
анализироваться только однажды. То же верно и для определений:

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
@end lisp

@noindent
Для условных выражений мы извлекаем и анализируем предикат, следствие и
альтернативу на стадии анализа.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
@end lisp

@noindent
При анализе выражения @code{lambda} также достигается значительный
выигрыш в эффективности: тело @code{lambda} анализируется только один
раз, а процедура, получающаяся в результате выполнения @code{lambda},
может применяться многократно.

@lisp
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
@end lisp

@noindent
Анализ последовательности выражений (в @code{begin} или в теле
@code{lambda}-выражения) более сложен.@footnote{См. @ref{Упражнение 4.23},
в котором объясняются некоторые подробности обработки последовательностей.}
Каждое выражение в последовательности анализируется, и для каждого
получается исполнительная процедура. Эти исполнительные процедуры
комбинируются в одну общую исполнительную процедуру, которая принимает в
качестве аргумента окружение и последовательно вызывает каждую из
частичных исполнительных процедур, передавая ей окружение как аргумент.

@lisp
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@noindent
Для вызова процедуры мы анализируем оператор и операнды и строим
исполнительную процедуру, которая вызывает исполнительную процедуру
оператора (получая при этом объект-процедуру, которую следует применить)
и исполнительные процедуры операндов (получая аргументы). Затем мы все
это передаем в @code{execute-application}, аналог @code{apply} из @ref{4.1.1}.
@code{Execute-application} отличается от @code{apply} тем, что тело
составной процедуры уже проанализировано, так что нет нужды в дальнейшем
анализе. Вместо этого мы просто вызываем исполнительную процедуру для
тела, передавая ей расширенное окружение.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env)
       (map (lambda (aproc) (aproc env))
            aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@noindent
В нашем новом интерпретаторе используются те же структуры данных,
синтаксические процедуры и вспомогательные процедуры времени выполнения,
что и в разделах @ref{4.1.2}, @ref{4.1.3} и @ref{4.1.3}.

@endpage
@quotation
@strong{@anchor{Упражнение 4.22}Упражнение 4.22:}
Расширьте интерпретатор из этого раздела так, чтобы он
поддерживал @code{let}. (См. упражнение @ref{Упражнение 4.6}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.23}Упражнение 4.23:}
Лиза П. Хакер не понимает, зачем делать
@code{analyze-sequence} такой сложной. Все остальные процедуры
анализа --- простые трансформации соответствующих вычисляющих процедур
(или ветвей @code{eval}) из @ref{4.1.1}. Лиза ожидала, что
@code{analyze-sequence} будет выглядеть так:

@lisp
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (lambda (env)
      (execute-sequence procs env))))
@end lisp

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше
работы по вычислению последовательности во время анализа. В Лизиной
исполнительной процедуре вызовы частичных исполнительных процедур,
вместо того, чтобы быть встроенными, перебираются в цикле. В результате,
хотя отдельные выражения в последовательности оказываются
проанализированы, сама последовательность анализируется во время
выполнения.

Сравните две версии @code{analyze-sequence}. Рассмотрите, например,
обычный случай (типичный для тел процедур), когда в последовательности
только одно выражение. Какую работу будет делать исполнительная
процедура, предложенная Лизой? А процедура из текста раздела? Как
соотносятся эти две процедуры в случае последовательности из двух
выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.24}Упражнение 4.24:}
Спроектируйте и проведите несколько экспериментов, чтобы
сравнить скорость исходного метациклического вычислителя и его версии из
этого раздела. С помощью результатов этих опытов оцените долю времени,
которая тратится на анализ и на собственно выполнение в различных
процедурах.
@end quotation

@comment @section Variations on a Scheme --- Lazy Evaluation
@section Scheme с вариациями: ленивый интерпретатор
@node	4.2, 4.3, 4.1, Chapter 4

Теперь, имея в своем распоряжении интерпретатор, выраженный в виде
программы на Лиспе, мы можем экспериментировать с различными вариантами
строения языка, просто модифицируя этот интерпретатор. В самом деле,
часто изобретение нового языка начинается с того, что пишут
интерпретатор, который встраивает новый язык в существующий язык
высокого уровня. Например, если нам хочется обсудить какую-то деталь
предлагаемой модификации Лиспа с другим членом Лисп-сообщества, мы можем
предъявить ему интерпретатор, в котором эта модификация реализована.
Тогда наш адресат может поэкспериментировать с новым интерпретатором и
послать в ответ свои замечания в виде дальнейших модификаций. Реализация
на высокоуровневой основе не только упрощает проверку и отладку
вычислителя; такое встраивание к тому же позволяет разработчику
слизывать@footnote{Слизывать (@emph{snarf}): <<Брать, в особенности
большой документ или файл, с целью использовать с разрешения владельца
или без оного>>. Пролизывать (@emph{snarf down}): <<Слизывать, иногда с
дополнительным значением восприятия, переработки или понимания>>. (Эти
определения были слизаны из Steele et al. 1983. См. также Raymond
1993.)} черты языка-основы, как наш встроенный интерпретатор Лиспа
использовал примитивы и структуру управления нижележащего Лиспа. Только
позже (да и то не всегда) разработчику приходится брать на себя труд
построения полной реализации на низкоуровневом языке или в аппаратуре. В
этом разделе и следующем мы изучаем некоторые вариации на тему Scheme,
которые значительно увеличивают ее выразительную силу.

@menu
* 4-2-1::            Нормальный порядок вычислений и аппликативный
* 4-2-2::            Интерпретатор с ленивым вычислением
* 4-2-3::            Потоки как ленивые списки
@end menu

@comment @subsection Normal Order and Applicative Order
@subsection Нормальный порядок вычислений и аппликативный порядок
@node	4.2.1, 4.2.2, 4.2, 4.2

В @ref{1.1}, где мы начали обсуждение моделей вычисления, мы указали, что
Scheme --- язык с (@newterm{applicative-order language}), а именно, что все
аргументы процедур в Scheme вычисляются в момент вызова. Напротив, в языках с
(@newterm{normal-order language}) вычисление аргументов процедур задерживается
до момента, когда действительно возникает нужда в их значениях. Если
вычисление аргументов процедур откладывается как можно дольше (например,
до того момента, когда они требуются какой-либо элементарной процедуре),
то говорят о @emph{ленивом вычислении} (@newterm{lazy evaluation}).
@footnote{Терминологическая разница между выражениями <<ленивый>> и
<<нормальный порядок вычислений>> несколько размыта.
Обычно <<ленивый>> относится к механизмам конкретных интерпретаторов, а
<<нормальный порядок>> к семантике языков независимо от способа
реализации. Однако разделение здесь не жесткое, и часто эти термины
употребляются как синонимы.} Рассмотрим процедуру

@lisp
(define (try a b) (if (= a 0) 1 b))
@end lisp

@noindent
Выполнение @code{(try 0 (/ 1 0))} в Scheme приводит к ошибке. При
ленивых вычислениях никакой ошибки не возникнет. Вычисление выражения
даст результат 1, поскольку к аргументу @code{(/ 1 0)} обращаться не
понадобится.

Примером использования ленивых вычислений может служить процедура
@code{unless}:

@lisp
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
@end lisp

@noindent
которую можно использовать в выражениях вроде

@lisp
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0") 0))
@end lisp

@noindent
В аппликативном языке это не будет работать, потому что и обычное
значение, и значение исключения будут выполнены еще до вызова
@code{unless} (См. упражнение @ref{Упражнение 1.6}). Преимущество
ленивых вычислений в том, что некоторые процедуры, например, та же
@code{unless}, могут выполнять полезные действия, даже если вычисление
некоторых их аргументов способно привести к ошибке или бесконечному
циклу.

Если тело процедуры начинает выполняться прежде, чем вычисляется ее
аргумент, то процедура называется (non-strict) по этому аргументу. Если
же аргумент вычисляется прежде, чем происходит вход в процедуру, то
процедура называется (strict) по этому аргументу.@footnote{Термины
<<строгий>> и <<нестрогий>> означают, в сущности, то же самое, что
<<аппликативный>> и <<нормальный>> порядок вычислений, но только они
относятся к отдельным процедурам и их аргументам, а не к языку в целом.
На конференциях по языкам программирования можно услышать, как
кто-нибудь говорит: <<В языке Hassle с нормальным порядком вычислений
есть несколько строгих примитивов. Остальные процедуры принимают
аргументы через ленивое вычисление>>.} В чисто аппликативном языке все
процедуры строги по всем своим аргументам. В языке с чисто нормальным
порядком вычислений все составные процедуры нестроги по всем своим
аргументам, а элементарные процедуры могут быть и такими, и такими.
Бывают также языки (см. упражнение @ref{Упражнение 4.31}), которые
дают программисту возможность явно обозначать строгость определяемых им
процедур.

Яркий пример процедуры, которой может быть полезно оказаться
нестрогой, --- это @code{cons} (и вообще почти любой конструктор
структур данных). Можно производить полезные вычисления, составлять из
элементов структуры данных и работать с ними, даже если значения
элементов неизвестны. Вполне имеет смысл задача, например, посчитать
длину списка, не зная значений его отдельных элементов. В
@ref{4.2.3} мы развиваем эту идею и реализуем потоки из @ref{Глава 3}
в виде списков, составленных из нестрогих @code{cons}-пар.

@quotation
@strong{@anchor{Упражнение 4.25}Упражнение 4.25:}
Предположим, что мы (в обычной Scheme с аппликативным
порядком вычислений) определяем @code{unless} как показано выше, а затем
определяем @code{factorial} через @code{unless}:

@lisp
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
@end lisp

Что произойдет, если мы попытаемся вычислить @code{(factorial 5)}? Будут
ли наши определения работать в языке с нормальным порядком вычислений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.26}Упражнение 4.26:}
Бен Битобор и Лиза П. Хакер расходятся во мнениях о
важности ленивых вычислений для реализации конструкций вроде
@code{unless}. Бен указывает, что при аппликативном порядке
@code{unless} можно реализовать как особую форму. Лиза отвечает, что в
таком случае @code{unless} будет просто синтаксисом, а не процедурой,
которую можно использовать в сочетании с процедурами высших порядков.
Проясните детали в обеих позициях. Покажите, как реализовать
@code{unless} в виде производного выражения (вроде @code{cond} или
@code{let}), и приведите пример ситуации, когда имеет смысл, чтобы
@code{unless} была процедурой, а не особой формой.
@end quotation

@comment @subsection An Interpreter with Lazy Evaluation
@subsection Интерпретатор с ленивым вычислением
@node	4.2.2, 4.2.3, 4.2.1, 4.2

В этом разделе мы реализуем язык с нормальным порядком вычислений,
который отличается от Scheme только тем, что все составные процедуры по
всем аргументам нестроги. Элементарные процедуры по-прежнему будут
строгими. Совсем несложно, модифицируя интерпретатор из раздела
@ref{4.1.1}, добиться, чтобы интерпретируемый
язык вел себя таким образом. Почти что все требуемые изменения
сосредоточены вокруг механизма процедурного вызова.

Основная идея состоит в том, что при вызове процедуры интерпретатор
должен определить, какие аргументы требуется вычислить, а какие
задержать. Задержанные аргументы не вычисляются, а преобразуются в
объекты, называемые (@newterm{thunks}).@footnote{Название <<санк>> было
придумано в неформальной группе, которая обсуждала реализацию вызова по имени в
Алголе 60. Было замечено, что большую часть анализа (<<обдумывания>>,
@emph{thinking about}) выражения можно производить во время компиляции;
таким образом, во время выполнения выражение будет уже большей частью
<<обдумано>> (@emph{thunk about} --- намеренно неверно образованная
английская форма) (Ingerman et al. 1960).} В санке должна содержаться
информация, необходимая, чтобы вычислить значение аргумента, когда оно
потребуется, и сделать это так, как будто оно вычислено во время вызова.
Таким образом, санк должен содержать выражение-аргумент и окружение, в
котором вычисляется вызов процедуры.

Процесс вычисления санка называется (@newterm{forcing}).@footnote{Это
аналогично использованию слова @code{force} (<<вынудить>>,
<<заставить>>) для задержанных объектов, при помощи которых в @ref{Глава 3}
представлялись потоки. Основная разница между тем, что мы делаем здесь,
и тем, чем мы занимались в @ref{Глава 3},
состоит в том, что теперь мы встраиваем задержку и вынуждение в
интерпретатор, и они применяются автоматически и единообразно во всем
языке.} Вообще говоря, санк вынуждается только тогда, когда требуется
его значение: когда он передается в элементарную процедуру, использующую
его значение; когда он служит предикатом в условном выражении; или когда
он является значением оператора, который нужно применить как процедуру.
Мы должны решить, будем ли мы (@newterm{memoize}) санки, как мы делали с
задержанными объектами в @ref{3.5.1}.
При использовании мемоизации, когда санк вынуждается в первый раз, он
запоминает вычисленное значение. Последующие вызовы только возвращают
запомненное значение, не вычисляя его заново. Мы делаем выбор в пользу
мемоизации, поскольку для многих приложений это эффективнее. Здесь,
однако, имеются тонкости.@footnote{Ленивые вычисления, совмещенные с
мемоизацией, иногда называют методом передачи аргументов с
(@newterm{call by need}), в отличие от (@newterm{call-by-name}). (Вызов
по имени, введенный в Алголе 60, аналогичен немемоизированному ленивому
вычислению.) Как проектировщики языка мы можем сделать интерпретатор
мемоизирующим или немемоизирующим, или же оставить это на усмотрение
программистов (упражнение @ref{Упражнение 4.31}). Как можно было ожидать
из @ref{Глава 3}, этот выбор вызывает к жизни вопросы, особенно тонкие и
запутанные в присутствии присваивания. (См. упражнения @ref{Упражнение 4.27}
и @ref{Упражнение 4.29}.) В замечательной статье Клингера (Clinger 1982)
делается попытка прояснить многомерную путаницу, которая здесь возникает.}

@comment @subsubheading Modifying the evaluator
@subsubheading Преобразование интерпретатора

Основная разница между ленивым интерпретатором и интерпретатором из @ref{4.1}
состоит в обработке вызовов процедур внутри @code{eval} и @code{apply}.

Ветка @code{application?} в @code{eval} принимает вид

@lisp
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
@end lisp

@noindent
Это почти тот же код, что был в ветке @code{application?} в @code{eval}
из @ref{}. Однако при ленивом
вычислении мы зовем @code{apply} с выражениями операндов, а не с
аргументами, которые получаются при их вычислении. Мы также передаем
@code{apply} окружение, поскольку оно понадобится для построения санков,
если нам хочется, чтобы аргуметы вычислялись с задержкой. Оператор мы
по-прежнему вычисляем, потому что сама применяемая процедура нужна
@code{apply}, чтобы выбрать действие на основании ее типа (элементарная
или составная) и применить ее.

Всякий раз, когда нам требуется собственно значение выражения, мы вместо
простого @code{eval} пользуемся процедурой

@lisp
(define (actual-value exp env)
  (force-it (eval exp env)))
@end lisp

@noindent
чтобы, если значение выражения является санком, оно было вынуждено.

Наша новая версия @code{apply} также почти совпадает с версией из @ref{4.1.1}.
Разница состоит в том, что @code{eval} передает ей невычисленные выражения:
для элементарных процедур (они строгие) мы вычисляем все аргументы и затем
вызываем примитив; для составных процедур (они нестрогие) мы прежде применения
процедуры замораживаем все аргументы.

@lisp
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))   @r{; изменение}
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)  @r{; изменение}
           (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY"
                     procedure))))
@end lisp

@noindent
Процедуры, обрабатывающие аргументы, почти такие же, как @code{list-of-values}
из @ref{4.1.1}, но только @code{list-of-delayed-args} замораживает аргументы,
вместо того, чтобы их вычислять, а в @code{list-of-arg-values} вместо
@code{eval} используется @code{actual-value}:

@lisp
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))
(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
@end lisp

@noindent
Кроме того, нам требуется изменить в интерпретаторе обработку @code{if},
где вместо @code{eval} мы должны вызывать @code{ actual-value}, чтобы
значение предикатного выражения вычислялось прежде, чем мы проверим,
истинно оно или ложно:

@lisp
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Наконец, нужно изменить процедуру @code{driver-loop} (@ref{4.1.4}), чтобы она
звала @code{actual-value} вместо @code{eval}. Таким образом, если
задержанное значение добирается до цикла чтение-вычисление-печать, то
оно, прежде чем печататься, будет разморожено. Кроме того, чтобы
показать, что работа идет с ленивым интерпретатором, мы изменим подсказки:

@lisp
(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value
            input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
@end lisp

@noindent
Внеся эти изменения, мы можем запустить интерпретатор и протестировать
его. Успешное вычисление выражения @code{try}, описанного в @ref{4.2.1},
показывает, что интерпретатор проводит ленивое вычисление:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)
@i{;;; L-Eval input:}
(define (try a b) (if (= a 0) 1 b))
@i{;;; L-Eval value:}
@i{ok}
@i{;;; L-Eval input:}
(try 0 (/ 1 0))
@i{;;; L-Eval value:}
@i{1}
@end lisp

@comment @subsubheading Representing thunks
@subsubheading Представление санков

Наш интерпретатор должен устроить работу так, чтобы при применении
процедур к аргументам порождались санки, и чтобы потом они вынуждались.
Выражение в санке должно запаковываться вместе с окружением, так, чтобы
потом можно было по ним вычислить аргумент. Чтобы вынудить санк, мы
просто извлекаем из него выражение и окружение, и вычисляем выражение в
окружении. Мы используем при этом не @code{eval}, а @code{actual-value},
так что если результат выражения сам окажется санком, мы и его вынудим,
и так пока не доберемся до не-санка.

@lisp
(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
@end lisp

@noindent
Простой способ упаковать выражение вместе с окружением --- создать
список из выражения и окружения. Таким образом, мы порождаем санк так:

@lisp
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr  thunk))
(define (thunk-env thunk) (caddr thunk))
@end lisp

@noindent
Однако на самом деле нам в интерпретаторе нужны не такие санки, а
мемоизированные. Мы сделаем так, чтобы санк при вынуждении превращался в
вычисленный санк. Для этого мы будем заменять хранимое в нем выражение
на значение и менять метку санка, чтобы можно было понять, что он уже
вычислен.@footnote{Заметим, что, вычислив выражение, мы еще и стираем из
санка окружение. Это не влияет на то, какие значения возвращает
интерпретатор. Однако при этом экономится память, поскольку стирание
ссылки из санка на @code{env}, когда она становится больше не нужна,
позволяет подвергнуть эту структуру (@newterm{garbage collection}) и заново
использовать ее память. Мы обсудим это в @ref{5.3}.

Подобным образом можно было бы разрешить собирать как мусор ненужные
окружения в мемоизированных задержанных объектах из @ref{3.5.1}:
@code{memo-proc}, сохранив значение процедуры @code{proc}, делала бы
что-нибудь вроде @code{(set! proc '())}, чтобы забыть саму процедуру
(включающую окружение, где было вычислено @code{delay}).}

@lisp
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk)
  (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj)
                                     (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj)
                     result)     @r{; replace @code{exp} with its value}
           (set-cdr! (cdr obj)
                     '())        @r{; forget unneeded @code{env}}
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
@end lisp

@noindent
Заметим, что одна и та же процедура @code{delay-it} работает и с
мемоизацией, и без нее.

@quotation
@strong{@anchor{Упражнение 4.27}Упражнение 4.27:}
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

@lisp
(define count 0)
(define (id x) (set! count (+ count 1)) x)
@end lisp

Вставьте пропущенные значения в данной ниже последовательности действий
и объясните свои ответы.@footnote{Это упражнение показывает, что
взаимодействие между ленивыми вычислениями и побочными эффектами может
быть весьма запутанным. Ровно этого можно было ожидать после обсуждения в
@ref{Глава 3}.}

@lisp
(define w (id (id 10)))
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
w
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.28}Упражнение 4.28:}
@code{Eval}, передавая оператор в @code{apply}, вычисляет
его не при помощи @code{eval}, а через @code{actual-value}, чтобы
вынудить. Приведите пример, который показывает, что такое вынуждение
необходимо.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.29}Упражнение 4.29:}
Придумайте пример программы, которая, по Вашему мнению,
будет работать намного медленнее без мемоизации, чем с мемоизацией.
Рассмотрим, помимо этого, следующую последовательность действий, в
которой процедура @code{id} определена как в
упражнении @ref{Упражнение 4.27}, а счетчик @code{count} начинает с 0:

@lisp
(define (square x) (* x x))
@i{;;; L-Eval input:}
(square (id 10))
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp

Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.30}Упражнение 4.30:}
Пабло Э. Фект, бывший программист на языке C,
беспокоится, что ленивый интерпретатор не вынуждает выражения в
последовательности, и оттого некоторые побочные эффекты могут никогда не
произойти. Поскольку ни у одного выражения в последовательности, помимо
конечного, значение не используется (выражение стоит там только ради
своего эффекта, например, чтобы присвоить значение переменной или
что-нибудь напечатать), у значения такого выражения не может
впоследствии быть применения, для которого его потребуется вынудить
(например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
@code{eval-sequence} из @ref{4.1.1}
так, чтобы она вместо @code{eval} использовала @code{actual-value}:

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
@end lisp

@enumerate a.

@item
Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
@code{for-each} из упражнения @ref{Упражнение 2.23} --- важный пример
последовательности с побочными эффектами:

@lisp
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
@end lisp

Он утверждает, что интерпретатор из текста (с исходным @code{eval-sequence})
правильно работает с этой процедурой:

@lisp
@i{;;; L-Eval input:}
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
@i{57}
@i{321}
@i{88}
@i{;;; L-Eval value:}
@i{done}
@end lisp

Объясните, почему Бен прав насчет поведения @code{for-each}.

@item
Пабло соглашается с Беном по поводу примера с @code{for-each}, но
говорит, что, предлагая изменить @code{eval-sequence}, он имел в виду
другой тип программ. Он определяет в ленивом интерпретаторе следующие
две процедуры:

@lisp
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
@end lisp

Какие значения вернут @code{(p1 1)} и @code{(p2 1)} с исходной
@code{eval-sequence}? Каковы будут значения с изменением, которое
предлагает Пабло?

@item
Пабло указывает также, что изменение @code{eval-sequence}, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

@item
Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.31}Упражнение 4.31:}
Подход, принятый в этом разделе, нехорош тем, что вносит
изменение в Scheme, не сохраняя ее семантику. Было бы приятнее
реализовать ленивые вычисления как (@newterm{upward-compatible extension}), то
есть так, чтобы обычные программы на Scheme работали как прежде. Этого
можно добиться, расширив синтаксис определений процедур, так, чтобы
пользователь мог решать, нужно ли задерживать аргументы. При этом можно
еще предоставить пользователю выбор между задержкой с мемоизацией и без
нее. Например, определение

@lisp
(define (f a (b lazy) c (d lazy-memo))
  @dots{})
@end lisp

@noindent
делало бы @code{f} процедурой от четырех аргументов, причем первый и
третий вычисляются при вызове процедуры, второй задерживается, а
четвертый задерживается и мемоизируется. Таким образом, обыкновенные
определения процедур будут задавать такое же поведение, как в обычной
Scheme, а добавление декларации @code{lazy-memo} к каждому параметру
каждой составной процедуры приведет к поведению, как у ленивого
интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового
синтаксиса @code{define}. Кроме того, надо будет добиться, чтобы
@code{eval} и @code{apply} определяли, когда надо задерживать аргументы,
и соответствующим образом задерживали и вынуждали их. Наконец, придется
обеспечить,чтобы вынуждение было с мемоизацией или без оной, смотря по
обстоятельствам.
@end quotation

@comment @subsection Streams as Lazy Lists
@subsection Потоки как ленивые списки
@node	4.2.3,  , 4.2.2, 4.2

В @ref{3.5.1} мы показали, как реализовать потоки в виде задержанных списков.
Мы ввели особые формы @code{delay} и @code{cons-stream}, которые позволили нам
строить <<обещания>> вычислить @code{cdr} потока, не выполняя эти
обещания до более позднего времени. Можно было бы использовать этот же
метод и вводить новые особые формы всякий раз, когда нам требуется
детальное управление процессом вычисления, но это было бы весьма
неуклюже. Прежде всего, особая форма, в отличие от процедуры, не
является полноправным объектом, и ее нельзя использовать в сочетании с
процедурами высших порядков.@footnote{Это как раз тот вопрос, который
возник по отношению к процедуре @code{unless} в @ref{Упражнение 4.26}.}
Кроме того, нам пришлось ввести
потоки как новый тип объектов данных, похожий на списки, но отличный от
них, и из-за этого потребовалось заново переписать для работы с потоками
множество обычных операций над списками (@code{map}, @code{append} и
тому подобное).

Когда у нас есть ленивое вычисление, списки и потоки можно считать одним
и тем же типом, так что не возникает нужды в особых формах и в отдельных
наборах операций для списков и потоков. Все, что нам требуется, --- это
так устроить дела, чтобы @code{cons} оказалась нестрогой. Можно сделать
это, расширив интерпретатор и разрешив нестрогие элементарные процедуры,
а затем реализовать @code{cons} как одну из таких процедур. Однако проще
вспомнить (из @ref{2.1.3}), что
вообще не существует особой нужды реализовывать @code{cons} как
примитив. Вместо этого можно представлять пары в виде
процедур:@footnote{Это процедурное представление, описанное в
упражнении @ref{Упражнение 2.4}. В сущности, подошла бы и любая другая
процедурная реализация (например, на основе передачи сообщений).
Обратите внимание, что внести эти определения в ленивый интерпретатор
можно, просто набрав их в управляющем цикле. Если мы изначально включили
@code{cons}, @code{car} и @code{cdr} как примитивы в глобальное
окружение, они будут переопределены. (См. также @ref{Упражнение 4.33} и @ref{Упражнение 4.34}.)}

@lisp
(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))
@end lisp

@noindent
Выраженные через эти базовые операции, стандартные определения операций
над списками будут работать как с бесконечными списками (потоками), так
и с конечными, а потоковые операции можно определить как операции над
списками. Вот несколько примеров:

@lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items)) (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
(define ones (cons 1 ones))
(define integers (cons 1 (add-lists ones integers)))
@i{;;; L-Eval input:}
(list-ref integers 17)
@i{;;; L-Eval value:}
@i{18}
@end lisp

@noindent
Заметим, что ленивые списки еще ленивее, чем потоки в @ref{Глава 3}:
задерживается не только @code{cdr} списка, но и @code{car}.
@footnote{Благодаря этому можно реализовать задержанные версии
не только последовательностей, но и более общих видов списковых
структур. В Hughes 1990 обсуждаются некоторые применения <<ленивых
деревьев>>.} На самом деле, даже доступ к @code{car} или @code{cdr}
ленивой пары не обязательно вынуждает значение элемента списка. Значение
будет вынуждено только тогда, когда это действительно нужно ---
например, чтобы использовать его в качестве аргумента примитива или
напечатать в качестве ответа.

Ленивые пары также помогают с решением проблемы, которая возникла в @ref{3.5.4},
где мы обнаружили, что формулировка потоковых моделей систем с циклами
может потребовать оснащения программы явными операциями @code{delay},
помимо тех, что встроены в @code{cons-stream}. При ленивом вычислении
все аргументы процедур единообразно задерживаются. Например, можно
реализовать процедуры для интегрирования списка и решения
дифференциальных уравнений так, как мы изначально намеревались в @ref{3.5.4}:

@lisp
(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) int)))
  int)
(define (solve f y0 dt)
  (define  y (integral dy y0 dt))
  (define dy (map f y))
  y)
@i{;;; L-Eval input:}
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
@i{;;; L-Eval value:}
@i{2.716924}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.32}Упражнение 4.32:}
Приведите несколько примеров, которые показывают разницу между потоками из
@ref{Глава 3} и <<более ленивыми>> списками, описанными в этом разделе.
Как можно воспользоваться этой дополнительной ленивостью?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.33}Упражнение 4.33:}
Бен Битобор проверяет вышеописанную реализацию при помощи выражения

@lisp
(car '(a b c))
@end lisp

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что <<списки>>. которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями
@code{cons}, @code{car} и @code{cdr}. Измените работу интерпретатора с
закавыченными выражениями так, чтобы при вводе списковых выражений в
цикле управления получались настоящие ленивые списки.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.34}Упражнение 4.34:}
Измените управляющий цикл интерпретатора так, чтобы
ленивые пары и списки печатались каким-либо разумным образом. (Как Вы
собираетесь работать с бесконечными списками)? Вероятно, понадобится
также изменить представление ленивых пар, чтобы при печати интерпретатор
их распознавал и печатал особым образом.
@end quotation

@comment @section Variations on a Scheme --- Nondeterministic Computing
@section Scheme с вариациями --- недетерминистское вычисление
@node	4.3, 4.4, 4.2, Chapter 4

В этом разделе мы расширяем интерпретатор Scheme так, чтобы он поддерживал
парадигму программирования, называемую (@newterm{nondeterministic computing}),
встраивая в интерпретатор средства поддержки автоматического поиска. Это
значительно более глубокое изменение в языке, чем введение ленивых вычислений в
@ref{Часть 4.2}.

Подобно обработке потоков, недетерминистское вычисление полезно в
задачах типа <<порождение и проверка>>. Рассмотрим такую задачу: даются
два списка натуральных чисел, и требуется найти пару чисел --- одно из
первого списка, другое из второго, --- сумма которых есть простое число. В
@ref{2.2.3} мы уже рассмотрели, как это можно сделать при помощи операций над
конечными последовательностями, а в @ref{3.5.3} ---
при помощи бесконечных потоков. Наш подход состоял в том, чтобы породить
последовательность всех возможных пар и отфильтровать ее, выбирая пары,
в которых сумма есть простое число. Порождаем ли мы на самом деле
сначала всю последовательность, как в @ref{Глава 2},
или чередуем порождение и фильтрацию, как в @ref{Глава 3},
несущественно для общей картины того, как организовано вычисление.

\enlargethispage{\baselineskip}

При недетерминистском подходе используется другой образ. Просто
представим себе, что мы (каким-то образом) выбираем число из первого
списка и число из второго списка, а затем предъявляем (при помощи
какого-то механизма) требование, чтобы их сумма была простым числом. Это
выражается следующей процедурой:

@lisp
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
@end lisp

@noindent
Может показаться, что эта процедура просто переформулирует задачу, а не
указывает способ ее решить. Однако это законная недетерминистская
программа.@footnote{Мы предполагаем, что уже заранее определена процедура
@code{prime?}, которая проверяет числа на простоту. Даже если такая
процедура определена, @code{prime-sum-pair} может подозрительно
напоминать бестолковую попытку определения квадратного корня на
псевдо-Лиспе из начала @ref{1.1.7}.
На самом деле, подобного рода процедура вычисления квадратного корня
может быть сформулирована в виде недетерминистской программы. Вводя в
интерпретатор механизм поиска, мы размываем границу между чисто
декларативными описаниями и императивными спецификациями способов
вычислить ответ. В @ref{4.4} мы пойдем еще дальше в этом направлении.}

Основная идея здесь состоит в том, что выражениям в недетерминистском
языке разрешается иметь более одного возможного значения. Например,
@code{an-element-of} может вернуть любой элемент данного списка. Наш
интерпретатор недетерминистских программ будет автоматически выбирать
возможное значение и запоминать, что он выбрал. Если впоследствии
какое-либо требование не будет выполнено, интерпретатор попробует другой
вариант выбора и будет перебирать варианты, пока вычисление не
закончится успешно или пока варианты не иссякнут. Подобно тому, как
ленивый интерпретатор освобождал программиста от заботы о деталях
задержки и вынуждения значений, недетерминистский интерпретатор
позволяет ему не заботиться о том, как происходит выбор.

Поучительно будет сравнить различные понятия времени, складывающиеся при
недетерминистских вычислениях и обработке потоков. При обработке потоков
ленивые вычисления используются для того, чтобы устранить связь между
временем, когда строится поток возможных ответов, и временем, когда
порождаются собственно ответы. Интерпретатор создает иллюзию, что все
возможные ответы предоставлены нам во вневременной последовательности.
При недетерминистских вычислениях выражение представляет собой
исследование множества возможных миров, каждый из которых определяется
множеством выбранных вариантов. Некоторые возможные миры приводят в
тупик, другие дают полезные ответы. Вычислитель недетерминистских
программ создает иллюзию, что время разветвляется, и что у наших
программ есть различные возможные истории исполнения. Если мы
оказываемся в тупике, мы можем вернуться к последней точке выбора и
продолжить путь по другой ветке.

Описываемый в этом разделе интерпретатор недетерминистских программ
называется @code{amb}-интерпретатор, потому что он основан на новой
особой форме @code{amb}. Мы можем ввести вышеприведенное определение
@code{prime-sum-pair} в управляющем цикле @code{amb}-интерпретатора
(наряду с определениями @code{prime?}, @code{an-element-of} и @code{require})
и запустить процедуру:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}
@end lisp

@noindent
Возвращенное значение было получено после того, как интерпретатор сделал
несколько попыток выбора из каждого списка, последняя из которых
оказалась успешной.

В @ref{4.3.1} и показывается, как она поддерживает недетерминизм через механизм
поиска, встроенный в интерпретатор. В @ref{4.3.2} приводятся примеры
недетерминистских программ, а @ref{4.3.3} содержит подробности
того, как реализовать @code{amb}-интерпретатор путем модификации
обычного интерпретатора Scheme.

@menu
* 4-3-1::            Amb и Search
* 4-3-2::            Примеры недетерминистских программ
* 4-3-3::            Реализация @code{amb}-интерпретатора
@end menu

@comment @subsection Amb and Search
@subsection @code{Amb} и @code{search}
@node	4.3.1, 4.3.2, 4.3, 4.3

Чтобы расширить Scheme и поддержать недетерминистское программирование,
мы вводим новую особую форму @code{amb}.@footnote{Идея недетерминистского
программирования с помощью @code{amb}-выражений впервые была описана
Джоном Маккарти в 1961 году (см. McCarthy 1967).} Выражение

@lisp
(amb @math{\langle}@var{e}@math{_{\mono{1}}\rangle} @math{\langle}@var{e}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{e}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
возвращает <<произвольным образом>> значение одного из @math{n}
выражений @math{\langle}@math{e_i}@math{\rangle}.  Например, выражение

@lisp
(list (amb 1 2 3) (amb 'a 'b))
@end lisp

@noindent
имеет шесть возможных значений:

@lisp
@code{(1 a)} @code{(1 b)} @code{(2 a)} @code{(2 b)} @code{(3 a)} @code{(3 b)}
@end lisp

@noindent
@code{amb} с одним вариантом возвращает обыкновенное (одно) значение.

@noindent
@code{amb} без вариантов --- выражение @code{(amb)} --- является
выражением без приемлемых значений. С операционной точки зрения,
выполнение выражения @code{(amb)} приводит к <<неудаче>> в вычислении:
выполнение обрывается, и никакого значения не возвращается. При помощи
этого выражения можно следующим образом выразить требование, чтобы
выполнялось предикатное выражение @code{p}:

@lisp
(define (require p) (if (not p) (amb)))
@end lisp

@noindent
Через @code{amb} и @code{require} можно реализовать процедуру
@code{an-element-of}, используемую выше:

@lisp
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
@end lisp

@noindent
Если список пуст, @code{an-element-of} терпит неудачу. В противном
случае он произвольным образом возвращает либо первый элемент списка,
либо элемент, выбранный из хвоста списка.

Можно также выразить выбор из бесконечного множества. Следующая
процедура произвольным образом возвращает целое число, большее или
равное некоторому данному @code{n}:

@lisp
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
@end lisp

@noindent
Это похоже на потоковую процедуру @code{integers-starting-from}, описанную в
@ref{3.5.2}, но есть важное различие: потоковая процедура возвращает поток,
который представляет последовательность всех целых чисел, начиная с
@code{n}, а процедура, написанная через @code{amb}, выдает одно целое
число.@footnote{На самом деле, различие между произвольным выбором с
возвратом единственного значения и возвратом всех возможных значений
выбора определяется в некоторой степени точкой зрения. С точки зрения
того кода, который использует значение, недетерминистский выбор
возвращает одно значение. С точки зрения программиста, проектирующего
код, недетерминистский выбор потенциально возвращает все возможные
значения, а вычисление разветвляется, вследствие чего каждое значение
исследуется отдельно.}

Мысля абстрактно, мы можем представить, что выполнение выражения
@code{amb} заставляет время разветвиться, и на каждой ветке оно
продолжается с одним из возможных значений выбора. Мы говорим, что @code{amb}
представляет собой (@newterm{nondeterministic choice point}). Если бы у
нас была машина с достаточным числом процессоров, которые можно было бы
динамически выделять, то поиск можно было бы реализовать напрямую.
Выполнение происходило бы, как в последовательной машине, пока не
встретится выражение @code{amb}. В этот момент выделялись и
инициализировались бы дополнительные процессоры, которые продолжали бы
все параллельные потоки выполнения, обусловленные выбором. Каждый
процессор продолжал бы последовательное выполнение одного из потоков,
как если бы он был единственным, пока поток не оборвется, потерпев
неудачу, не разделится сам или не завершится.@footnote{Можно возразить,
что этот механизм безнадежно неэффективен. Чтобы решить какую-нибудь
просто сформулированную задачу таким образом, могут потребоваться
миллионы процессоров, и бо́льшую часть времени бо́льшая часть этих
процессоров будет ничем не занята. Это возражение нужно воспринимать в
контексте истории. Память раньше точно так же считалась дорогим
ресурсом. В 1964 году мегабайт памяти стоил 400 000 долларов. Сейчас в
каждом персональном компьютере имеется много мегабайтов памяти, и
бо́льшую часть времени бо́льшая часть этой памяти не используется. Трудно
недооценить стоимость электроники при массовом производстве.}

С другой стороны, если у нас есть машина, которая способна выполнять
только один процесс (или небольшое число параллельных процессов),
альтернативы приходится рассматривать последовательно. Можно представить
себе интерпретатор, который в каждой точке выбора произвольным образом
выбирает, по какой ветке продолжить выполнение. Однако случайный выбор
может легко привести к неудачам. Можно было бы запускать такой
интерпретатор многократно, делая случайный выбор и надеясь, что в конце
концов мы получим требуемое значение, но лучше проводить (systematic
search) среди всех возможных путей выполнения. @code{Amb}-интерпретатор,
который мы разработаем в этом разделе, реализует систематический поиск
следующим образом: когда интерпретатор встречает выражение @code{amb},
он сначала выбирает первый вариант. Такой выбор может в дальнейшем
привести к другим точкам выбора. В каждой точке выбора интерпретатор
сначала будет выбирать первый вариант. Если выбор приводит к неудаче,
интерпретатор автомагически@footnote{Автомагически: <<Автоматически, но
при этом таким способом, который говорящий почему-либо (обычно либо
из-за его сложности, либо уродливости, или даже тривиальности) не
склонен объяснять>>. (Steele 1983; Raymond 1993)} (backtracks) к
последней точке выбора и пробует следующий вариант. Если в какой-то
точке выбора варианты исчерпаны, интерпретатор возвращается к предыдущей
точке выбора и продолжает оттуда. Такой процесс реализует стратегию
поиска, которую называют (depth-first search) или (chronological
backtracking).@footnote{У встраивания стратегий автоматического
поиска в языки программирования долгая и пестрая история. Первые
предположения, что недетерминистские алгоритмы можно изящно реализовать
в языке программирования с поиском и автоматическим возвратом,
высказывались Робертом Флойдом (Floyd 1967). Карл Хьюитт (Hewitt 1969)
изобрел язык программирования Плэнер (Planner), который явным образом
поддерживал автоматический хронологический поиск в возвратом,
обеспечивая встроенную стратегию поиска в глубину. Сассман, Виноград и
Чарняк (Sussman, Winograd, and Charniak 1971) реализовали подмножество
этого языка, названное ими МикроПлэнер (MicroPlanner), которое
использовалось в работе по автоматическому решению задач и планированию
действий роботов. Похожие идеи, основанные на логике и доказательстве
теорем, привели к созданию в Эдинбурге и Марселе изящного языка Пролог
(Prolog) (который мы обсудим в @ref{4.4}).
Разочаровавшись в автоматическом поиске, Макдермот и Сассман (McDermott
and Sussman 1972) разработали язык Коннивер (Conniver), в котором
имелись механизмы, позволявшие программисту управлять стратегией поиска.
Однако это оказалось слишком громоздким, и Сассман и Столлман (Sussman
and Stallman 1975) нашли более удобный в обращении подход, когда
исследовали методы символьного анализа электрических цепей. Они
разработали схему нехронологического поиска с возвратом, которая была
основана на отслеживании логических зависимостей, связывающих факты, и
стала известна как метод (@newterm{dependency-directed backtracking}). При всей
своей сложности, их метод позволял строить достаточно эффективные
программы, так как почти не проводилось излишнего поиска. Дойл (Doyle
1979) и Макаллестер (McAllester 1978; McAllester 1980) обобщили и
сделали более ясными идеи Столлмана и Сассмана, разработав новую
парадигму для формулирования поиска, называемую сейчас (truth
maintenance). Все современные системы решения задач основаны на
какой-либо форме поддержания истины. У Форбуса и де Клеера (Forbus and
deKleer 1993) можно найти обсуждение изящных способов строить системы с
поддержанием истины и приложения, в которых используется поддержание
истины. Заби, Макаллестер и Чепман (Zabih, McAllester, and Chapman 1987)
описывают недетерминистское расширение Scheme, основанное на @code{amb};
оно похоже на интерпретатор, обсуждаемый в этом разделе, но более
сложно, поскольку использует поиск с возвратом, управляемый
зависимостями, а не хронологический. Уинстон (Winston 1992) дает
введение в обе разновидности поиска с возвратом.}.

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора не совсем обычен. Он
считывает выражение и печатает значение первого успешного вычисления,
как в примере с @code{prime-sum-pair} в начале раздела. Если нам хочется
увидеть значение следующего успешного выполнения, мы можем попросить
интерпретатор вернуться и попробовать породить значение следующего
успешного выполнения. Для этого нужно ввести символ . Если вводится
какое-то другое выражение, а не @code{try-again}, интерпретатор начнет
решать новую задачу, отбрасывая неисследованные варианты предыдущей. Вот
пример работы с интерпретатором:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(3 110)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(8 35)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; There are no more values of}
@i{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}

@i{;;; Amb-Eval input:}
(prime-sum-pair '(19 27 30) '(11 36 58))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(30 11)}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.35}Упражнение 4.35:}
Напишите процедуру @code{an-integer-between}, которая
возвращает целое число, лежащее между двумя заданными границами. С ее
помощью можно следующим образом реализовать процедуру для поиска
Пифагоровых троек, то есть троек чисел @math{(i, j, k)} между заданными
границами, таких, что @math{i \leq j} и @math{i^2 + j^2 = k^2}:

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.36}Упражнение 4.36:}
В упражнении @ref{Упражнение 3.69} рассматривалась задача
порождения потока @emph{всех} Пифагоровых троек, без всякой верхней
границы диапазона целых чисел, в котором надо искать. Объясните, почему
простая замена @code{an-integer-between} на
@code{an-integer-startingfrom} в процедуре из
упражнения @ref{Упражнение 4.35} не является адекватным способом
порождения произвольных Пифагоровых троек. Напишите процедуру, которая
решает эту задачу. (Это значит, что Вам нужно написать процедуру, для
которой многократный запрос @code{try-again} в принципе способен
породить все Пифагоровы тройки.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.37}Упражнение 4.37:}
Бен Битобор утверждает, что следующий метод порождения
Пифагоровых троек эффективнее, чем приведенный в
упражнении @ref{Упражнение 4.35}. Прав ли он? (Подсказка: найдите,
сколько вариантов требуется рассмотреть.)

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
@end lisp
@end quotation

@comment @subsection Examples of Nondeterministic Programs
@subsection Примеры недетерминистских программ
@node	4.3.2, 4.3.3, 4.3.1, 4.3

В @ref{4.3.3} описывается реализация @code{amb}-интерпретатора. Однако
для начала мы приведем несколько примеров его использования. Преимущество
недетерминистского программирования состоит в том, что можно отвлечься от
деталей процесса поиска, а следовательно, выражать программы на более высоком
уровне абстракции.

@comment @subsubheading Logic Puzzles
@subsubheading Логические загадки

Следующая задача (взятая из Dinesman 1968) --- типичный представитель
большого класса простых логических загадок.

@quotation
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах
пятиэтажного дома. Бейкер живет не на верхнем этаже. Купер живет не на
первом этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер
живет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?
@end quotation

@noindent
Можно впрямую определить, кто на каком этаже живет, перечислив все
возможности и наложив данные нам ограничения.@footnote{В нашей программе
используется следующая процедура, определяющая, все ли элементы списка
отличны друг от друга:

@lisp
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
@end lisp

@noindent
Процедура @code{member} подобна @code{memq}, но на равенство проверяет с
помощью @code{equal?}, а не @code{eq?}.}

@lisp
(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
        (smith    (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)       (list 'cooper cooper)
          (list 'fletcher fletcher) (list 'miller miller)
          (list 'smith smith))))
@end lisp

@noindent
Выполнение выражения @code{(multiple-dwelling)} дает следующий результат:

@lisp
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
@end lisp

@noindent
Эта простая процедура работает, но работает очень медленно. В
@ref{Упражнение 4.39} и @ref{Упражнение 4.40} обсуждаются возможные улучшения.

@quotation
@strong{@anchor{Упражнение 4.38}Упражнение 4.38:}
Измените процедуру @code{multiple-dwelling}, отказавшись
от требования, что Смит и Флетчер живут не на соседних этажах. Сколько
решений имеется у измененной загадки?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.39}Упражнение 4.39:}
Влияет ли порядок ограничений в процедуре
@code{multiple-dwelling} на ответ? Влияет ли он на время, необходимое
для поиска ответа? Если Вы считаете, что он имеет значение, то покажите,
как можно ускорить программу, переупорядочив ограничения. Если Вы
считаете, что порядок значения не имеет, объясните, почему.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.40}Упражнение 4.40:}
Сколько возможных соответствий между людьми и этажами
имеется в задаче о проживании, если учитывать требование, что все живут
на разных этажах, и если его не учитывать? Крайне неэффективно порождать
все возможные соответствия между людьми и этажами, а затем полагаться на
то, что поиск с возвратом отсечет лишнее. Например, большая часть
ограничений зависит только от одной или двух переменных, соответствующих
людям, и их можно было бы проверять раньше, чем этажи выбраны для всех
действующих лиц. Напишите и продемонстрируйте значительно более
эффективную недетерминистскую процедуру, которая бы решала задачу,
порождая только те варианты, которые еще не исключены благодаря
предыдущим ограничениям. (Подсказка: потребуется набор вложенных
выражений @code{let}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.41}Упражнение 4.41:}
Напишите процедуру для решения задачи о проживании на обычной Scheme.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.42}Упражнение 4.42:}
Решите задачу <<Лгуньи>> (из Phillips 1934):

Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что
каждая девочка должна написать домой о результатах экзамена и при этом
сделать одно верное и одно неверное утверждение. Вот соответствующие
выдержки из их писем:

@itemize @bullet

@item
Бетти: <<Китти была на экзамене второй, а я только третьей>>.

@item
Этель: <<Вам будет приятно узнать, что я написала лучше всех. Второй была Джоан>>.

@item
Джоан: <<Я была третьей, а бедная Этель последней>>.

@item
Китти: <<Я оказалась второй. Мэри была только четвертой>>.

@item
Мэри: <<Я была четвертой. Первое место заняла Бетти>>.

@end itemize

В каком порядке на самом деле расположились отметки девочек?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.43}Упражнение 4.43:}
Решите с помощью @code{amb}-интерпретатора следующую
задачу.@footnote{Задача взята из книжки <<Занимательные загадки>>,
опубликованной в 60-е годы издательством Литтон Индастриз. Книжка
приписывает задачу газете <<Кэнзас стейт энджинир>>.}

У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей тоже.
Эти четверо друзей --- полковник Даунинг, мистер Холл, сэр Барнакл Худ
и доктор Паркер. У каждого из них тоже есть по дочери, и каждый из них
назвал свою яхту в честь дочери одного из своих друзей. Яхта сэра
Барнакла называется Габриэлла, яхта мистера Мура --- Лорна, а у мистера
Холла яхта Розалинда. Мелисса, яхта полковника Даунинга, названа в честь
дочери сэра Барнакла. Отец Габриэллы владеет яхтой, названной в честь
дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно (см.
упражнение @ref{Упражнение 4.40}). Кроме того, определите, сколько
будет решений, если не указывается, что фамилия Мэри Энн --- Мур.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.44}Упражнение 4.44:} В упражнении
@ref{Упражнение 2.42} описывалась <<задача о восьми ферзях>>, в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.
@end quotation

@comment @subsubheading Parsing natural language
@subsubheading Синтаксический анализ естественного языка

Программы, которые должны принимать на входе естественный язык, обычно
прежде всего пытаются провести (@newterm{parsing}) ввода, то есть сопоставить
входному тексту какую-то грамматическую структуру. Например, мы могли бы
попытаться распознавать простые предложения, состоящие из артикля, за
которым идет существительное, а вслед за ними глагол, например @emph{The
cat eats} (<<Кошка ест>>). Чтобы выполнять такой анализ, нам нужно уметь
определять части речи, к которым относятся отдельные слова. Мы можем для
начала составить несколько списков, которые задают классы
слов:@footnote{Здесь мы используем соглашение, что первый элемент списка
обозначает часть речи, к которой относятся остальные слова списка.}

@lisp
(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
@end lisp

@noindent
Нам также нужна (@newterm{grammar}), то есть набор правил, которые описывают,
как элементы грамматической структуры составляются из меньших элементов.
Простейшая грамматика может постановить, что предложение всегда состоит
из двух частей --- именной группы, за которой следует глагол, --- и
что именная группа состоит из артикля и имени существительного. С такой
грамматикой предложение @emph{The cat eats} разбирается так:

@lisp
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
@end lisp

@noindent
Мы можем породить такой разбор при помощи простой программы, в которой
для каждого грамматического правила имеется своя процедура. Чтобы
разобрать предложение, мы определяем две его составные части и
возвращаем список из этих элементов, помеченный символом @code{sentence}:

@lisp
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
@end lisp

@noindent
Подобным образом, разбор именной группы состоит в поиске артикля и
существительного:

@lisp
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
@end lisp

@noindent
На самом нижнем уровне разбор сводится к многократной проверке, является
ли следующее неразобранное слово элементом списка слов для данной части
речи. Чтобы реализовать это, мы заводим глобальную переменную
@code{*unparsed*}, содержащую еще неразобранный ввод. Каждый раз,
проверяя слово, мы требуем, чтобы @code{*unparsed*} не была пустым
списком и чтобы ее значение начиналось со слова из указанного списка.
Если это так, мы убираем слово из @code{*unparsed*} и возвращаем его
вместе с частью речи (которую можно найти в голове
списка).@footnote{Обратите внимание, что @code{parse-word} изменяет
список необработанных слов при помощи @code{set!}. Для того, чтобы это
работало, @code{amb}-интерпретатор при возврате должен отменять действия
операций @code{set!}.}

@lisp
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
@end lisp

@noindent
Чтобы запустить разбор, нужно только присвоить переменной @code{*unparsed*}
весь имеющийся ввод, попытаться проанализировать предложение и убедиться,
что ничего не осталось в конце:

@lisp
(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*)) sent))
@end lisp

Теперь мы можем опробовать анализатор и убедиться, что он работает на
нашем простом примере:

@lisp
@i{;;; Amb-Eval input:}
(parse '(the cat eats))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@end lisp
@smalllisp
@i{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}
@end smalllisp

@noindent
@code{amb}-интерпретатор здесь удобно использовать потому, что
ограничения на разбор легко выражаются при помощи @code{require}. Однако
по-настоящему достоинства автоматического поиска с возвратом проявляются
тогда, когда мы обращаемся к более сложным грамматикам, где имеются
варианты декомпозиции единиц.

Добавим к грамматике список предлогов:

@lisp
(define prepositions '(prep for to in by with))
@end lisp

@noindent
и определим предложную группу (например, @emph{for the cat}, <<для
кошки>>) как последовательность из предлога и именной группы:

@lisp
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
@end lisp

@noindent
Теперь мы можем сказать, что предложение --- это именная группа, за
которой следует глагольная группа, а глагольная группа --- это либо
глагол, либо глагольная группа, дополненная предложной
группой@footnote{Заметим, что это определение рекурсивно --- за
глаголом может следовать любое число предложных групп.}:

@lisp
(define (parse-sentence)
  (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend
          (list 'verb-phrase
                verb-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
@end lisp

@noindent
Раз уж мы занялись этим делом, можно также уточнить определение именной
группы и разрешить выражения вроде @emph{a cat in the class} (<<кошка в
аудитории>>). То, что раньше называлось именной группой, теперь мы будем
называть простой именной группой, а именная группа теперь может быть
либо простой именной группой, либо именной группой, которая дополняется
предложной группой:

@lisp
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend
          (list 'noun-phrase
                noun-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
@end lisp

@noindent
Обновленная грамматика позволяет разбирать более сложные предложения.
Например,

@lisp
(parse '(the student with the cat sleeps in the class))
@end lisp

@noindent
дает

@lisp
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase
   (prep in)
   (simple-noun-phrase (article the) (noun class)))))
@end lisp

@noindent
Заметим, что входное предложение может иметь более одного законного
анализа. В предложении @emph{The professor lectures to the student with
the cat} (<<Профессор читает лекцию студенту с кошкой>>) может иметься в
виду, что профессор вместе с кошкой читают лекцию, или что кошка --- у
студента. Наша недетерминистская программа находит оба варианта:

@lisp
(parse '(the professor lectures to the student with the cat))
@end lisp

@noindent
дает

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase
    (prep to)
    (simple-noun-phrase (article the) (noun student))))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat)))))
@end lisp

@noindent
Если попросить интерпретатор поискать еще, получится

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase
    (simple-noun-phrase (article the) (noun student))
    (prep-phrase
     (prep with)
     (simple-noun-phrase (article the) (noun cat)))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.45}Упражнение 4.45:}
Согласно заданной выше грамматике, следующее предложение
можно проанализировать пятью различными способами: @emph{The professor
lectures to the student in the class with the cat} (<<Профессор читает
лекцию студенту в аудитории с кошкой>>). Покажите эти пять разборов и
объясните разницу в оттенках значения между ними.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.46}Упражнение 4.46:} Интерпретаторы в разделах
@ref{4.1} и @ref{4.2} не определяют, в каком порядке вычисляются операнды
при вызове процедуры. Мы увидим, что @code{amb}-интерпретатор вычисляет их
слева направо. Объясните, почему программа разбора не стала бы работать, если
бы операнды вычислялись в каком-нибудь другом порядке.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.47}Упражнение 4.47:}
Хьюго Дум говорит, что поскольку глагольная группа --- это
либо глагол, либо глагольная группа плюс предложная группа, было бы
намного естественнее определить процедуру @code{parse-verb-phrase} так
(и то же сделать для именных групп):

@lisp
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
@end lisp

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в @code{amb}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.48}Упражнение 4.48:}
Дополните описанную выше грамматику так, чтобы она могла
работать с более сложными предложениями. Например, можно позволить
именным и глагольным группам включать прилагательные и наречия, или же
можно обрабатывать сложные предложения.@footnote{Грамматики такого рода
могут быть сколь угодно сложными, но по сравнению с настоящей обработкой
естественного языка они остаются игрушкой. Настоящее понимание
естественного языка компьютером требует сложного сочетания
синтаксического анализа с интерпретацией значения. С другой стороны,
даже простые анализаторы могут быть полезны для поддержки гибких
командных языков в программах вроде систем поиска информации. Уинстон
(Winston 1992) описывает вычислительные подходы к пониманию настоящего
естественного языка, а также применение простых грамматик в командных
языках.}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.49}Упражнение 4.49:}
Лизу П. Хакер больше интересует не анализ предложений, а
их порождение. Она замечает, что если изменить процедуру
@code{parse-word} так, чтобы она игнорировала <<входное предложение>>,
всегда заканчивалась успехом и порождала подходящее слово, мы сможем
использовать те же программы, которые мы написали для анализа, для
порождения предложений. Реализуйте идею Лизы и покажите первые
пять-шесть порожденных предложений.@footnote{Несмотря на то, что идея
Лизы (будучи удивительно простой) дает результат, порождаемые
предложения оказываются довольно скучными --- они не отображают
возможные предложения нашего языка никаким интересным образом. Дело в
том, что грамматика рекурсивна во многих местах, а метод Лизы
<<проваливается>> в одну из рекурсий и там застревает. Как с этим можно
бороться, Вы увидите в упражнении @ref{Упражнение 4.50}.}
@end quotation

@comment @subsection Implementing the @code{amb} Evaluator
@subsection Реализация @code{amb}-интерпретатора
@node	4.3.3,  , 4.3.2, 4.3

Выполнение выражения в обыкновенной Scheme может вернуть результат,
может вообще не завершиться, и, наконец, может закончиться сообщением об
ошибке. В недетерминистской Scheme при выполнении выражения, в
дополнение ко всему этому, может еще обнаружиться тупик, и в этом случае
вычисление должно откатиться к предыдущей точке выбора. Интерпретация
недетерминистской Scheme осложняется из-за этой дополнительной
возможности.

Мы построим @code{amb}-интерпретатор для недетерминистской Scheme,
модифицировав анализирующий интерпретатор из @ref{4.1.7}.@footnote{В
@ref{4.2} мы решили реализовать ленивый интерпретатор как модификацию
обыкновенного метациклического интерпретатора из @ref{4.1.1}. Напротив,
здесь в основу @code{amb}-интерпретатора мы кладем анализирующий
интерпретатор из @ref{4.1.7},
поскольку исполнительные процедуры этого интерпретатора служат удобной
базой для реализации поиска с возвратом.} Как и в анализирующем
интерпретаторе, вычисление выражения происходит путем вызова
исполнительной процедуры, которая получается при анализе этого
выражения. Разница между интерпретацией обыкновенной Scheme и
недетерминистской Scheme будет полностью сводиться к исполнительным
процедурам.

@comment @subsubheading Execution procedures and continuations
@subsubheading Исполнительные процедуры и продолжения

Напомним, что исполнительные процедуры обыкновенного интерпретатора
принимают один аргумент: окружение, в котором происходит вычисление
выражения. В противоположность этому, исполнительные процедуры
@code{amb}-интерпретатора принимают три аргумента: окружение и две
процедуры, называемые (@newterm{continuation procedures}). Вычисление выражения
будет заканчиваться вызовом одного из этих продолжений: если результатом
вычисления является значение, то зовется (@newterm{success continuation}) с этим
значением в качестве аргумента; если вычисление натыкается на тупик,
вызывается (@newterm{failure continuation}). Построение и вызов соответствующих
продолжений служит механизмом, с помощью которого в недетерминистском
интерпретаторе реализуется поиск с возвратом.

Задача продолжения успеха --- принять значение и продолжить вычисление.
Помимо этого значения, продолжение успеха получает дополнительное
продолжение неудачи, которое нужно будет вызвать, если использование
значения приведет в тупик.

Задача продолжения неудачи --- попробовать другую ветвь
недетерминистского процесса. Главная особенность недетерминистского
языка состоит в том, что выражения могут представлять собой точки выбора
между вариантами. Выполнение такого выражения должно продолжиться
согласно одному из указанных взаимоисключающих вариантов, несмотря на
то, что заранее неизвестно, какие варианты приведут к приемлемым
результатам. При обработке такой ситуации интерпретатор выбирает один из
вариантов и передает его значение продолжению успеха. Кроме того, он
строит и передает вместе со значением продолжение неудачи, которое потом
можно вызвать, чтобы рассмотреть другой вариант.

Неудача возникает во время вычисления (то есть, зовется продолжение
неудачи), когда пользовательская программа явным образом отказывается от
текущего рассматриваемого варианта (например, вызов @code{require} может
привести к выполнению @code{(amb)}, а это выражение всегда терпит
неудачу --- см. @ref{4.3.1}). В этом месте
продолжение неудачи вернет нас к последней по времени точке и оттуда
направит по другому варианту. Если же в этой точке выбора больше не
осталось вариантов, то запускается неудача в предыдущей точке выбора, и
так далее. Кроме того, продолжения неудачи запускаются управляющим
циклом в ответ на запрос @code{try-again}, чтобы найти еще одно значение
последнего выражения.

Помимо того, если на какой-то ветке процесса, возникшей в результате
выбора, происходит операция с побочным эффектом (например, присваивание
переменной), то может понадобиться отменить побочный эффект, если
процесс наткнется на неудачу, прежде чем будет сделан новый выбор. Этого
мы добиваемся, заставив операцию с побочным эффектом порождать
продолжение неудачи, которое отменяет эффект и отправляет неудачу
дальше.

\enlargethispage{\baselineskip}

Итак, продолжения неудачи порождаются
@itemize @bullet

@item
в выражениях @code{amb} --- чтобы обеспечить механизм выбора
альтернативных вариантов, если текущий выбор, сделанный внутри
@code{amb}, приведет к тупику;

@item
в управляющем цикле верхнего уровня --- чтобы иметь возможность
сообщить о неудаче, когда перебраны все альтернативы;

@item
в присваиваниях --- чтобы во время отката перехватывать неудачи и
отменять присваивания.
@end itemize

@noindent
Неудачи возбуждаются только тогда, когда программа заходит в тупик. Это
происходит

@itemize @bullet

@item
если пользовательская программа выполняет выражение @code{(amb)};

@item
если пользователь печатает @code{try-again} в управляющем цикле.

@end itemize

@noindent
Кроме того, продолжения неудачи вызываются при обработке неудачи:

@itemize @bullet

@item
Когда продолжение неудачи, порожденное присваиванием, заканчивает отмену
побочного эффекта, оно вызывает то предложение неудачи, которое оно само
перехватило, и посредством его отправляет неудачу назад до точки выбора,
которая привела к присваиванию, либо до верхнего уровня.

@item
Когда продолжение неудачи для @code{amb} исчерпывает все варианты
выбора, оно вызывает продолжение неудачи, которое изначально было дано
@code{amb}, и посредством его распространяет неудачу до предыдущей точки
выбора, либо до верхнего уровня.
@end itemize

@comment @subsubheading Structure of the evaluator
@subsubheading Структура интерпретатора

Процедуры представления синтаксиса и данных в @code{amb}-интерпретаторе,
а также базовая процедура @code{analyze}, совпадают с соответствующими
процедурами в интерпретаторе из @ref{4.1.7}, только здесь требуются
дополнительные синтаксические процедуры для анализа особой формы @code{amb}:
@footnote{Мы предполагаем, что интерпретатор поддерживает @code{let} (см.
@ref{Упражнение 4.22}), который мы использовали в недетерминистских программах.}

@lisp
(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
@end lisp

@noindent
Кроме того, требуется добавить в процедуру разбора @code{analyze} ветку,
которая будет распознавать эту особую форму и порождать соответствующую
исполнительную процедуру:

@lisp
((amb? exp) (analyze-amb exp))
@end lisp

@noindent
Процедура верхнего уровня @code{ambeval} (сходная с версией @code{eval},
приведенной в @ref{4.1.7}) анализирует данное выражение и применяет полученную
исполнительную процедуру к данному окружению и двум данным продолжениям:

@lisp
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
@end lisp

@noindent
Продолжение успеха представляет собой процедуру от двух аргументов:
только что полученного значения и продолжения неудачи, которое нужно
будет применить, если обработка значения впоследствии приведет к
неудаче. Продолжение неудачи представляет собой процедуру без
аргументов. Таким образом, общая форма исполнительной процедуры такова:

@lisp
(lambda (env succeed fail)
  @r{;; @code{succeed} выглядит как @code{(lambda (value fail) @dots{})}}
  @r{;; @code{fail} выглядит как @code{(lambda () @dots{})}}
  @dots{})
@end lisp

@noindent
Например

@lisp
(ambeval @math{\langle}@var{вурыжение}@math{\rangle}
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
@end lisp

@noindent
попытается вычислить данное выражение, и вернет либо его значение (если
вычисление будет успешным), либо символ @code{failed} (если вычисление
потерпит неудачу). Вызов @code{ambeval} в нижеприведенном управляющем
цикле использует намного более сложные процедуры продолжения, которые
возвращаются к выполнению цикла и поддерживают запрос @code{try-again}.

Сложность @code{amb}-интерпретатора по большей части заключается в
механизмах передачи продолжений, когда исполнительные процедуры вызывают
друг друга. Читая код в этом разделе, следует сравнивать каждую
исполнительную процедуру с соответствующей процедурой обыкновенного
интерпретатора из @ref{4.1.7}.

@comment @subsubheading Simple expressions
@subsubheading Простые выражения

Исполнительные процедуры для простейших видов выражений здесь, в
сущности, такие же, как и в обычном интерпретаторе, не считая того, что
здесь надо уметь управлять продолжениями. Исполнительные процедуры
просто зовут продолжение успеха, давая ему значение выражения, и
передают дальше продолжение неудачи, которое получили сами.

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env) fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env) fail))))
@end lisp

@noindent
Заметим, что поиск переменной всегда <<успешен>>. Если процедуре
@code{lookup-variable-value} не удается найти значение, она, как обычно,
сообщает об ошибке. Такая <<неудача>> означает ошибку в программе:
ссылку на несвязанную переменную; это не означает, что нам нужно
пробовать какой-либо другой вариант недетерминистского выбора вместо
того, который исполняется сейчас.

@comment @subsubheading Conditionals and sequences
@subsubheading Условные выражения и последовательности

Обработка условных выражений также похожа на соответствующий процесс в
обычном интерпретаторе. Исполнительная процедура, порождаемая в
@code{analyze-if}, зовет исполнительную процедуру предиката @code{pproc}
с продолжением успеха, которое, проверив, истинно ли значение предиката,
в соответствии с этим выполняет либо следствие, либо альтернативу. Если
выполнение @code{pproc} терпит неудачу, вызывается исходное продолжение
неудачи, переданное в выражение @code{if}.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             @r{;; продолжение успеха при вычислении предиката}
             @r{;; и получении @code{pred-value}}
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             @r{;; продолжение неудачи при вычислении предиката}
             fail))))
@end lisp

@noindent
Последовательности тоже обрабатываются так же, как и в предыдущем
интерпретаторе, если не считать махинаций в подпроцедуре
@code{sequentially}, которые требуются для передачи продолжений. А
именно, чтобы выполнить последовательно @code{a} и @code{b}, мы вызываем
@code{a} с продолжением успеха, вызывающим @code{b}.

@lisp
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         @r{;; продолжение успеха при вызове @code{a}}
         (lambda (a-value fail2)
           (b env succeed fail2))
         @r{;; продолжение неудачи при вызове @code{a}}
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@comment @subsubheading Definitions and assignments
@subsubheading Определения и присваивания

Определения --- еще один случай, когда обработка продолжений сопряжена
с известными трудностями, поскольку требуется сначала вычислить
выражение, которое будет значением определяемой переменной, а затем уже
ее собственно определить. Ради этого процедура вычисления значения
@code{vproc} вызывается со следующими аргументами: окружение,
продолжение успеха и продолжение неудачи. Если вычисление @code{vproc}
происходит успешно и дает значение @code{val} для определяемой
переменной, то переменная определяется и успех распространяется далее:

@lisp
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
@end lisp

@noindent
Присваивания устроены интереснее. Это первый случай, когда мы
действительно используем продолжения, а не просто передаем их из
процедуры в процедуру. Исполнительная процедура для присваивания
начинается так же, как и процедура для определения. Сначала она пытается
получить новое значение, которое надо присвоить переменной. Если
вычисление @code{vproc} терпит неудачу, неудачно и все присваивание.

Однако если @code{vproc} выполняется удачно, и мы действительно
выполняем присваивание, то нам нужно рассмотреть возможность, что
текущая ветка вычисления позже, может быть, приведет к неудаче. Тогда
нам понадобится откатиться к моменту до присваивания. Таким образом, нам
нужно уметь отменить присваивание в процессе возврата@footnote{Мы не
заботились об отмене определений, поскольку можно предположить, что
внутренние определения изымаются (@ref{4.1.6}).}

Этого мы добиваемся, передавая @code{vproc} продолжение успеха
(отмеченное ниже комментарием <<@emph{1*}>>), которое сохраняет старое
значение переменной, прежде чем присвоить ей новое значение и продолжить
вычисление. Продолжение неудачи, которое передается вместе со значением
присваивания (и отмечено ниже комментарием <<@emph{2*}>>),
восстанавливает старое значение переменной, прежде чем продолжить откат.
То есть, успешное присваивание дает продолжение неудачи, которое
перехватит последующую неудачу; неудача, которая в противном случае
вызвала бы @code{fail2}, вместо этого зовет эту процедуру, а она
отменяет присваивание и уже затем зовет @code{fail2}.

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        @r{; *1*}
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    @r{; *2*}
                            (set-variable-value!
                             var old-value env)
                            (fail2)))))
             fail))))
@end lisp

@comment @subsubheading Procedure applications
@subsubheading Вызов процедур

Исполнительная процедура для вызовов не содержит никаких новшеств, кроме
сложных технических деталей работы с продолжениями. Сложность возникает
внутри @code{analyze-application} и обусловлена необходимостью следить
за продолжениями успеха и неудачи при вычислении операндов. Мы вычисляем
операнды с помощью процедуры @code{get-args}, а не простого @code{map},
как в обыкновенном интерпретаторе.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
@end lisp

@noindent
Заметьте, как в @code{get-args} для движения через @code{cdr} по списку
исполнительных процедур @code{aproc} и сборки через @code{cons}
получающегося списка аргументов каждая @code{aproc} в списке вызывается
с продолжением успеха, которое рекурсивно зовет @code{get-args}. Каждый
из этих рекурсивных вызовов @code{get-args} имеет продолжение успеха,
значение которого --- @code{cons} свежеполученного аргумента со списком
уже собранных аргументов:

@lisp
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       @r{;; продолжение успеха для этой @code{aproc}}
       (lambda (arg fail2)
         (get-args
          (cdr aprocs)
          env
          @r{;; продолжение успеха для}
          @r{;; рекурсивного вызова @code{get-args}}
          (lambda (args fail3)
            (succeed (cons arg args) fail3))
          fail2))
       fail)))
@end lisp

@noindent
Собственно вызов процедуры, который выполняет
@code{execute-application}, осуществляется так же, как и в обыкновенном
интерпретаторе, не считая того, что необходимо управлять продолжениями.

@lisp
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@comment @subsubheading Evaluating @code{amb} expressions
@subsubheading Выполнение выражений @code{amb}

Особая форма @code{amb} --- ключевой элемент недетерминистского языка.
Здесь лежит сущность процесса интерпретации и обоснование необходимости
отслеживать продолжения. Исполнительная процедура для @code{amb}
определяет цикл @code{try-next}, который перебирает исполнительные
процедуры для всех возможных значений выражения @code{amb}. Каждая из
исполнительных процедур вызывается с продолжением неудачи, которое
попробует выполнить следующий вариант. Когда вариантов больше не
остается, все выражение @code{amb} терпит неудачу.

@lisp
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda () (try-next (cdr choices))))))
      (try-next cprocs))))
@end lisp

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора сложен из-за наличия
механизма, позволяющего пользователю заново попытаться выполнить
выражение. Цикл использует процедуру @code{internal-loop}, которая в
качестве аргумента принимает процедуру @code{try-again}. Наш замысел
состоит в том, чтобы вызов @code{try-again} переходил к следующему
нерассмотренному варианту в недетерминистском вычислении. Процедура
@code{internal-loop} либо зовет @code{try-again}, если пользователь
набирает @code{try-again} в управляющем цикле, либо запускает новое
вычисление, вызывая @code{ambeval}.

Продолжение неудачи в этом вызове @code{ambeval} сообщает пользователю,
что значений больше нет, и перезапускает управляющий цикл.

Продолжение успеха для вызова @code{ambeval} устроено тоньше. Мы
печатаем вычисленное значение, а потом заново запускаем внутренний цикл
с процедурой @code{try-again}, которая сможет попробовать следующий
вариант. Этот переход к следующему варианту выражается процедурой
@code{next-alternative}, которая передана вторым аргументом в
продолжение успеха. Обычно мы считаем этот второй аргумент продолжением
неудачи, которое придется использовать, если текущая ветвь исполнения
потерпит неудачу. Однако в данном случае мы завершили успешное
вычисление, так что <<неудачный>> вариант можно позвать для того, чтобы
найти дополнительные успешные варианты вычисления.

@lisp
(define input-prompt  ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline) (display ";;; Starting a new problem ")
            (ambeval
             input
             the-global-environment
             @r{;; @code{ambeval} успех}
             (lambda (val next-alternative)
               (announce-output output-prompt)
               (user-print val)
               (internal-loop next-alternative))
             @r{;; @code{ambeval} неудача}
             (lambda ()
               (announce-output
                ";;; There are no more values of")
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline) (display ";;; There is no current problem")
     (driver-loop))))
@end lisp

@noindent
Самый первый вызов @code{internal-loop} использует процедуру
@code{try-again}, которая жалуется, что не было дано никакой задачи, и
возобновляет управляющий цикл. Такое поведение требуется, если
пользователь набирает @code{try-again}, еще не задав выражение для
вычисления.

@quotation
@strong{@anchor{Упражнение 4.50}Упражнение 4.50:}
Реализуйте новую особую форму @code{ramb}, которая подобна
@code{amb}, однако перебирает варианты не слева направо, а в случайном
порядке. Покажите, как такая форма может пригодиться в Лизиной задаче из
упражнения @ref{Упражнение 4.49}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.51}Упражнение 4.51:}
Реализуйте новую разновидность присваивания
@code{permanent-set!} --- присваивание, которое не отменяется при
неудачах. Например, можно выбрать два различных элемента в списке и
посчитать, сколько для этого потребовалось попыток, следующим образом:

@lisp
(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(a b 2)}
@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(a c 3)}
@end lisp

Какие значения были бы напечатаны, если бы мы вместо
@code{permanent-set!} использовали здесь обычный @code{set!}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.52}Упражнение 4.52:}
Реализуйте новую конструкцию @code{if-fail}, которая
позволяет пользователю перехватить неудачу при выполнении выражения.
@code{If-fail} принимает два выражения. Первое она выполняет как обычно
и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения, как в
следующем примере:

@lisp
@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{all-odd}

@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{8}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.53}Упражнение 4.53:} Если у нас есть
@code{permanent-set!}, описанное в упражнении @ref{Упражнение 4.51}, и
@code{if-fail} из упражнения @ref{Упражнение 4.52}, то каков будет
результат вычисления

@lisp
(let ((pairs '()))
  (if-fail
   (let ((p (prime-sum-pair '(1 3 5 8)
                            '(20 35 110))))
     (permanent-set! pairs (cons p pairs))
     (amb))
   pairs))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.54}Упражнение 4.54:}
Если бы мы не догадались, что конструкцию можно
реализовать как обычную процедуру с помощью @code{amb}, так что
пользователь сам может определить ее в своей недетерминистской
программе, то нам пришлось бы задать эту конструкцию в виде особой
формы. Потребовались бы синтаксические процедуры

@lisp
(define (require? exp)
  (tagged-list? exp 'require))
(define (require-predicate exp)
  (cadr exp))
@end lisp

@noindent
новая ветвь разбора в @code{analyze}:

@lisp
((require? exp) (analyze-require exp))
@end lisp

@noindent
а также процедура @code{analyze-require}, которая обрабатывает выражения
@code{require}. Допишите следующее определение @code{analyze-require}:

@lisp
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if @math{\langle}??@math{\rangle}
                   @math{\langle}??@math{\rangle}
                   (succeed 'ok fail2)))
             fail))))

@end lisp
@end quotation


@comment @section Logic Programming
@section Логическое программирование
@node	4.4,  , 4.3, Chapter 4

В @ref{Глава 1} мы подчеркивали, что информатика имеет дело с императивным
знанием (<<как сделать>>), в то время как математика имеет дело с декларативным
знанием (<<что такое>>). Действительно, языки программирования требуют,
чтобы программист, выражая свои знания, указывал методы пошагового
решения определенных задач. С другой стороны, языки высокого уровня
обеспечивают в рамках своих реализаций существенный объем
методологических знаний, которые освобождает пользователя от забот о
многих деталях того, как проходит описываемое вычисление.

Большинство языков программирования, включая Лисп, построены вокруг
вычисления значений математических функций. Языки, ориентированные на
выражения, (такие, как Лисп, Фортран и Алгол) пользуются тем, что
выражение, описывающее значение функции, можно интерпретировать и как
способ вычислить это значение. По этой причине большинство языков
программирования имеют уклон в однонаправленные вычисления (вычисления
со строго определенными входом и выходом). Имеются, однако, совсем
другие языки программирования, в которых этот уклон ослаблен. Пример
такого языка мы видели в @ref{3.3.5},
где объектами вычисления были арифметические ограничения. В системе
ограничений направление и порядок вычислений определены не столь четко;
стало быть, чтобы провести вычисление, система должна содержать в себе
более детальное знание <<как сделать>>, чем в случае с обычным
арифметическим вычислением. Однако это не значит, что пользователь вовсе
не отвечает за то, чтобы обеспечить систему императивным знанием.
Существует множество сетей, которые задают одно и то же множество
ограничений, и пользователю нужно выбрать из множества математически
эквивалентных сетей одну подходящую, чтобы описать нужное вычисление.

Недетерминистский интерпретатор программ из @ref{4.3}
тоже представляет собой отход от представления, что программирование
связано с построением алгоритмов для вычисления однонаправленных
функций. В недетерминистском языке у выражений может быть более одного
значения, и оттого вычисление работает с отношениями, а не с функциями,
у которых значение только одно. Логическое программирование расширяет
эту идею, сочетая реляционный взгляд на программирование с мощной
разновидностью символьного сопоставления с образцом, которую называют
(@newterm{unification}).@footnote{Логическое программирование выросло из долгой
традиции исследований по автоматическому доказательству теорем. Ранние
программы доказательства теорем достигали лишь скромных результатов, так
как они полностью перебирали пространство возможных доказательств.
Крупный прорыв, который сделал такой поиск осмысленным, случился в
начале 1960х годов, когда были открыты (unification algorithm) и
(resolution principle) (Robinson 1965). Резолюцию использовали,
например, Грин и Рафаэль (Green and Raphael 1968, см. также Green 1969)
как основу дедуктивной системы вопрос-ответ. Большую часть этого периода
исследователи сосредотачивались на алгоритмах, которые гарантированно
находят решение, если оно существует. Такими алгоритмами было трудно
управлять, и трудно было указать им направление доказательства. Хьюитт
(Hewitt 1969) нашел возможность сочетать управляющую структуру языка
программирования с операциями системы логического манипулирования, и это
привело к появлению работы по автоматическому поиску, упомянутой в
@ref{4.3.1} (@ref{Сноска 4.47}).
В то же самое время в Марселе Кольмероэ разрабатывал системы обработки
естественного языка, основанные на правилах (см. Colmerauer et al.
1973). Для представления этих правил он изобрел язык Пролог. Ковальски
(Kowalski 1973; Kowalski 1979) в Эдинбурге обнаружил, что выполнение
программы на Прологе можно интерпретировать как доказательство теорем (с
использованием метода доказательства, называемого линейной резолюцией
Хорновских форм). Слияние этих двух линий привело к возникновению
традиции логического программирования. Таким образом, в споре о
приоритетах в области логического программирования французы могут
указать на корни Пролога в Марсельском университете, а британцы на
работы, сделанные в университете Эдинбурга. А по мнению исследователей
из MIT, обе эти группы разработали логическое программирование, когда
пытались понять, что же хотел сказать Хьюитт в своей блистательной, но
трудночитаемой диссертации. Историю логического программирования можно
найти в Robinson 1983.}

Когда этот подход работает, он служит весьма мощным способом написания
программ. Отчасти эта мощь проистекает из того, что один факт вида <<что
такое>> можно использовать для решения нескольких различных задач с
разными компонентами <<как сделать>>. Для примера рассмотрим операцию
@code{append}, которая в качестве аргументов принимает два списка и
объединяет их элементы в один список. В процедурном языке вроде Лиспа
можно определить @code{append} через базовый конструктор списков
@code{cons}, как в @ref{2.2.1}:

@lisp

(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
@end lisp

@noindent
Эту процедуру можно рассматривать как перевод на Лисп следующих двух
правил; первое покрывает случай, когда первый список пуст, а второе ---
случай непустого списка, представляющего собой @code{cons} двух частей:

@itemize @bullet

@item
Для любого списка @code{y}, @code{append} пустого списка и @code{y} дает
@code{y}.

@item
Для любых @code{u}, @code{v}, @code{y} и @code{z}, @code{append} от
@code{(cons u v)} и @code{y} дает @code{(cons u z)}, если @code{append}
от @code{v} и @code{y} дает @code{z}.@footnote{Соответствие между
правилами и процедурой такое: пусть @code{x} из процедуры (когда
@code{x} непустой) соответствует @code{(cons u v)} из правила. Тогда
@code{z} из правила соответствует @code{append} от @code{(cdr x)} и @code{y}.}

@end itemize

@noindent
С помощью процедуры @code{append} мы можем решать задачи типа

@quotation
Найти @code{append} от @code{(a b)} и @code{(c d)}.
@end quotation

@noindent
Однако тех же двух правил достаточно для решения следующих типов
вопросов, на которые процедура ответить не может:

@quotation
Найти список @code{y}, такой, что @code{append} @code{(a b)} и @code{y}
дает @code{(a b c d)}.

Найти все такие @code{x} и @code{y}, что @code{append} от них дает
@code{(a b c d)}.
@end quotation

@noindent
В языке логического программирования, когда программист пишет
<<процедуру>> @code{append}, он формулирует два правила, приведенные
выше. Знание <<как сделать>> автоматически обеспечивается
интерпретатором, что позволяет использовать одну эту пару правил для
ответа на все три типа вопросов об @code{append}.@footnote{Это ни в коем
случае не освобождает программиста полностью от решения задачи, как
вычислить ответ. Существует множество математически эквивалентных
наборов правил для отношения @code{append}, и только некоторые из них
можно превратить в эффективное средство для вычисления в каком-либо
направлении. Вдобавок, иногда информация <<что такое>> ничего не говорит
о том, @emph{как} вычислить ответ, --- возьмем, например, задачу найти
такое @math{y}, что @math{y^2 = x}.}

У современных языков логического программирования (включая тот, который
мы сейчас реализуем) есть существенные недостатки, а именно: их общие
методы <<как сделать>> порой заводят в ненужные бесконечные циклы или
вызывают нежелательное поведение другого рода. Логическое
программирование сейчас активно исследуется в информатике.@footnote{Пик
интереса к логическому программированию пришелся на начало 80-х, когда
японское правительство инициировало амбициозный проект, целью которого
было построение сверхбыстрых компьютеров, оптимизированных для
логических языков программирования. Скорость таких компьютеров
предполагалось измерять в LIPS (Logical Inferences Per Second --- число
логических выводов в секунду), а не в обычных FLOPS (FLoating-point
Operations Per Second --- число операций с плавающей точкой в секунду).
Несмотря на то, что в рамках проекта удалось создать аппаратное и
программное обеспечение, которое изначально планировалось, интересы
международной компьютерной промышленности сместились в другом
направлении. Обзор и оценку японского проекта можно найти в Feigenbaum
and Shrobe 1993. К тому же и в сообществе логических программистов
возник интерес к реляционному программированию на основе других методов,
помимо простого сопоставления с образцом, например, к работе с
численными ограничениями --- вроде тех, которые присутствуют в системе
распространения ограничений из @ref{3.3.5}.}

Ранее в этой главе мы изучили технологию реализации интерпретаторов и
описали те ее элементы, которые необходимы в интерпретаторе
Лисп-подобного языка (в сущности, любого традиционного языка). Теперь мы
воспользуемся этими идеями при рассмотрении интерпретатора для языка
логического программирования. Мы называем этот язык (query language),
поскольку он весьма удобен для извлечения информации из баз данных при
помощи (queries), то есть выраженных на нашем языке вопросов. Несмотря
на то, что язык запросов сильно отличается от Лиспа, его удобно
обсуждать в терминах той же самой общей схемы, которую мы использовали
до сих пор: как набор элементарных составляющих, дополненных средствами
комбинирования, которые позволяют нам сочетать простые составляющие и
получать при этом сложные, и средствами абстракции, которые позволяют
нам рассматривать сложные составляющие как единые концептуальные
единицы. Интерпретатор языка логического программирования существенно
сложнее, чем интерпретатор языка типа Лиспа. Тем не менее, нам предстоит
убедиться, что наш интерпретатор языка запросов содержит многие из тех
же элементов, которые были в интерпретаторе из @ref{4.1}. В частности, у
нас будет часть <<eval>>, которая классифицирует выражения в соответствии
с типом, и часть <<apply>>, которая реализует механизм абстракции языка
(процедуры в случае Лиспа и (rules) в случае логического
программирования). Кроме того, в реализации центральную роль будет
играть структура данных, построенная из кадров и определяющая
соотношение между символами и связанными с ними значениями. Еще одна
интересная сторона нашей реализации языка запросов --- то, что мы
существенным образом используем потоки, введенные в
@ref{Глава 3}.

@menu
* 4-4-1::            Дедуктивный поиск информации
* 4-4-2::            Как действует система обработки запросов
* 4-4-3::            Является ли логическое программирование математической логикой?
* 4-4-4::            Реализация запросной системы
@end menu

@comment @subsection Deductive Information Retrieval
@subsection Дедуктивный поиск информации
@node	4.4.1, 4.4.2, 4.4, 4.4

Логическое программирование хорошо приспособлено для построения
интерфейсов к базам данных, служащих для поиска информации. Язык
запросов, который мы реализуем в этой главе, спроектирован именно для
такого использования.

Чтобы показать, чем занимается система запросов, мы покажем, как с ее
помощью управлять базой данных персонала для <<Микрошафт>>, процветающей
компании из окрестностей Бостона со специализацией в области высоких
технологий. Язык предоставляет возможность поиска информации о
сотрудниках, производимого с помощью образцов; он также может
осуществлять логический вывод на основании общих правил.

@comment @subsubheading A sample data base
@subsubheading База данных

База данных персонала <<Микрошафт>> содержит (@newterm{assertions}) о
сотрудниках компании. Вот информация о Бене Битоборе, местном компьютерном гуру:

@lisp
@code{(адрес (Битобор Бен) (Сламервилл (Ридж Роуд) 10))}
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(зарплата (Битобор Бен) 60000)}
@end lisp

Каждое утверждение представляет собой список (в данном случае тройку).
элементы которого сами могут быть списками.

В качестве местного гуру Бен отвечает за компьютерный отдел компании и
руководит двумя программистами и одним техником. Вот информация о них:

@lisp
@code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(зарплата (Хакер Лиза П) 40000)}
@code{(начальник (Хакер Лиза П) (Битобор Бен))}

@code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(зарплата (Фект Пабло Э) 35000)}
@code{(начальник (Фект Пабло Э) (Битобор Бен))}

@code{(адрес (Поправич Дайко) (Бостон (Бэй Стейт Роуд) 22))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@code{(зарплата (Поправич Дайко) 25000)}
@code{(начальник (Поправич Дайко) (Битобор Бен))}
@end lisp

Имеется также программист-стажер, над которым начальствует Лиза:

@lisp
@code{(адрес (Дум Хьюго) (Сламервилл (Пайн Три Роуд) 80))}
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@code{(зарплата (Дум Хьюго) 30000)}
@code{(начальник (Дум Хьюго) (Хакер Лиза П))}
@end lisp

Все эти служащие работают в компьютерном отделе, на что указывает слово
@code{компьютеры} в начале описания их должностей.

Бен --- служащий высокого ранга. Его начальник --- сам глава компании:

@lisp
@code{(начальник (Битобор Бен) (Уорбак Оливер))}

@code{(адрес (Уорбак Оливер) (Суэлсли (Топ Хип Роуд)))}
@code{(должность (Уорбак Оливер) (администрация большая шишка))}
@code{(зарплата (Уорбак Оливер) 150000)}
@end lisp

Помимо компьютерного отдела, руководимого Беном, в компании имеется
бухгалтерия, где работает главный бухгалтер со своим помощником:

@lisp
@code{(адрес (Скрудж Эбин) (Уэстон (Шейди Лейн) 10))}
@code{(должность (Скрудж Эбин) (бухгалтерия главный бухгалтер))}
@code{(зарплата (Скрудж Эбин) 75000)}
@code{(начальник (Скрудж Эбин) (Уорбак Оливер))}

@code{(адрес (Крэтчит Роберт) (Олстон (Норт Гарвард Стрит) 16))}
@code{(должность (Крэтчит Роберт) (бухгалтерия писец))}
@code{(зарплата (Крэтчит Роберт) 18000)}
@code{(начальник (Крэтчит Роберт) (Скрудж Эбин))}
@end lisp

Есть еще секретарь главы компании:

@lisp
@code{(адрес (Фиден Кон) (Сламервилл (Онион Сквер) 5))}
@code{(должность (Фиден Кон) (администрация секретарь))}
@code{(зарплата (Фиден Кон) 25000)}
@code{(начальник (Фиден Кон) (Уорбак Оливер))}
@end lisp

Данные содержат также утверждения о том, какой род работы могут
выполнять сотрудники, имеющие другую должность. Например, компьютерный
гуру способен выполнять работу как компьютерного программиста, так и
компьютерного техника:

@lisp
@code{(может-замещать (компьютеры гуру) (компьютеры программист))}
@code{(может-замещать (компьютеры гуру) (компьютеры техник))}
@end lisp

Программист может выполнять работу стажера:

@lisp
@code{(может-замещать (компьютеры программист)
                (компьютеры программист стажер))}
@end lisp

Кроме того, как всем известно,

@lisp
@code{(может-замещать (администрация секретарь)
                (администрация большая шишка))}
@end lisp

@comment @subsubheading Simple queries
@subsubheading Простые запросы

Язык запросов дает пользователям возможность извлекать информацию из
базы данных, формулируя запросы в ответ на приглашение системы.
Например, чтобы найти всех программистов, можно сказать

@lisp
@i{;;; Ввод запроса:}
@end lisp
@example
(должность ?x (компьютеры программист))
@end example

Система выведет следующие результаты:

@lisp
@i{;;; Результаты запроса:}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@end lisp

@noindent
Входной запрос указывает, что мы ищем в базе данных записи,
соответствующие некоторому (@newterm{pattern}). В этом примере образец указывает,
что запись должна состоять из трех элементов, из которых первый является
символом @code{должность}, второй может быть чем угодно, а третий
представляет собой список @code{(компьютеры программист)}. <<Что
угодно>>, которое может стоять на второй позиции в искомом списке,
изображается (@newterm{pattern variable}) @code{?x}. В общем случае переменная
образца --- это символ, который мы считаем именем переменной,
предваряемый знаком вопроса. Несколько позже мы увидим, почему имеет
смысл давать переменным образца имена, а не просто ставить в образцы
@code{?}, означающее <<что угодно>>. Система отвечает на простой запрос,
выводя все записи в базе данных, соответствующие введенному образцу.

В образце может содержаться более одной переменной. Например,
@lisp
(address ?x ?y)
@end lisp

@noindent
выводит адреса всех служащих.

В образце может совсем не быть переменных. В этом случае запрос просто
проверяет, содержится ли запись в базе. Если да, будет одна подходящая
под образец запись; если нет, ни одной.

Одна и та же переменная может встречаться в образце в нескольких местах,
и это означает, что одинаковое <<что угодно>> должно встретиться в
каждом из этих мест. Ради этого переменным и даются имена. Например,

@lisp
(supervisor ?x ?x)
@end lisp

@noindent
находит всех сотрудников, которые сами себе начальники (впрочем, в нашей
пробной базе таковых не имеется).

Запросу

@lisp
(job ?x (computer ?type))
@end lisp

@noindent
соответствуют все записи о должностях, в которых третий элемент является
двухэлементным списком, а первый элемент в нем @code{компьютеры}:

@lisp
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@end lisp

@noindent
Этому образцу @emph{не} соответствует запись

@lisp
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@end lisp

@noindent
поскольку третий элемент здесь является списком из трех элементов, а
третий элемент образца указывает, что элементов должно быть два. Если бы
нам захотелось изменить образец так, чтобы третий элемент мог быть любым
списком, который начинается с @code{компьютеры}, мы могли бы
написать@footnote{Здесь используется точечная запись, введенная в
упражнении @ref{Упражнение 2.20}.}

@lisp
@code{(должность ?x (компьютеры . ?type))}
@end lisp

@noindent
Например,

@lisp
@code{(компьютеры . ?type)}
@end lisp

@noindent
соответствуют данные

@lisp
@code{(компьютеры программист стажер)}
@end lisp

@noindent
причем @code{?type} равняется списку @code{(программист стажер)}. Тому
же образцу соответствуют данные

@lisp
@code{(компьютеры программист)}
@end lisp

@noindent
где @code{?type} равняется списку @code{(программист)}, и данные

@lisp
@code{(компьютеры)}
@end lisp

@noindent
где @code{?type} равняется пустому списку @code{()}.

Можно следующим образом описать обработку простых запросов в нашем языке:

@itemize @bullet

@item
Система находит все присваивания переменным в образце запроса, которые
(@newterm{satisfy}) запросу --- то есть, все наборы значений переменных, такие,
что если переменные образца (@newterm{instantiated with}), то есть замещаются,
своими значениями, то результат находится в базе данных.

@item
Система отвечает на запрос, перечисляя все конкретизации образца с
удовлетворяющими ему присваиваниями переменным.

@end itemize

@noindent
Заметим, что в случае, когда образец не содержит переменных, запрос
сводится к выяснению, находится ли образец в базе. Если да, то нулевое
присваивание, не сообщающее значений никаким переменным, удовлетворяет
запросу к текущей базе данных.

@quotation
@strong{@anchor{Упражнение 4.55}Упражнение 4.55:}
Постройте простые запросы, которые извлекают из базы
данных следующую информацию:

@enumerate

@item
Все сотрудники, начальником которых является Бен Битобор.

@item
Имена и должности всех работников бухгалтерии.

@item
Имена и адреса всех сотрудников, живущих в Сламервилле.

@end enumerate
@end quotation

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Простые запросы являются элементарными операциями языка запросов. Чтобы
порождать составные операции, язык предоставляет средства
комбинирования. Один из элементов, превращающих язык запросов в язык
логического программирования --- то, что средства комбинирования
запросов отражают средства комбинирования, используемые при построении
логических выражений: @code{and} (и), @code{or} (или) и @code{not} (не).
(Здесь @code{and}, @code{or} и @code{not} --- это не элементарные
выражения Лиспа, а операции, встроенные в язык запросов.)

Мы можем найти адреса всех программистов с помощью @code{and} так:

@lisp
(and (@code{должность} ?person (@code{компьютеры программист}))
     (@code{адрес} ?person ?where))
@end lisp

@noindent
Получаем на выводе

@lisp
(and @code{(должность (Хакер Лиза П) (компьютеры программист))}
     @code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78)))}

(and @code{(должность (Фект Пабло Э) (компьютеры программист))}
     @code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(and @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
удовлетворяют все наборы значений переменных образца, которые
одновременно удовлетворяют @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Как и в случае с простыми запросами, система при обработке составного
запроса находит все присваивания переменным образца, удовлетворяющие
запросу, и затем печатает все конкретизации запроса этими значениями.

Другой метод построения составных запросов --- через @code{or}.
Например,

@lisp
(or @code{(начальник ?x (Битобор Бен))}
    @code{(начальник ?x (Хакер Лиза П)))}
@end lisp

@noindent
найдет всех сотрудников, над которыми начальствует Бен Битобор или Лиза
П. Хакер:

@lisp
(or @code{(начальник (Хакер Лиза П) (Битобор Бен))}
    @code{(начальник (Хакер Лиза П) (Хакер Лиза П)))}

(or @code{(начальник (Фект Пабло Э) (Битобор Бен))}
    @code{(начальник (Фект Пабло Э) (Хакер Лиза П)))}

(or @code{(начальник (Поправич Дайко) (Битобор Бен))}
    @code{(начальник (Поправич Дайко) (Хакер Лиза П)))}

(or @code{(начальник (Дум Хьюго) (Битобор Бен))}
    @code{(начальник (Дум Хьюго) (Хакер Лиза П)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(or @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяют все наборы значений переменных образца, которые
удовлетворяют по крайней мере одному из @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Кроме того, составные запросы можно порождать при помощи @code{not}.
Например,

@lisp
(and @code{(начальник ?x (Битобор Бен))}
     (not @code{(должность ?x (компьютеры программист))}))
@end lisp

@noindent
ищет всех сотрудников, для которых начальник Бен Битобор, не являющихся
программистами. В общем случае, запросу

@lisp
(not @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle})
@end lisp

@noindent
удовлетворяют все присваивания переменным образца, которые не удовлетворяют
@math{\langle}@var{запросу}@math{_1\rangle}.@footnote{Это
описание @code{not} верно только для простых случаев. На самом деле
поведение этой конструкции более сложное. Мы исследуем тонкости
@code{not} в разделах @ref{Часть 4.4.2} и @ref{Часть 4.4.3}.}

Последняя комбинирующая форма называется @code{lisp-value}. Когда она
стоит в начале образца, она указывает, что следующий элемент является
предикатом Лиспа, который требуется применить к остальным
(конкретизированным) элементам как к аргументам. В общем случае, образец

@lisp
(lisp-value @math{\langle}@var{предикат}@math{\rangle} @math{\langle}@var{arg}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{arg}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяется теми присваиваниями переменным образца, для которых
применение @math{\langle}@var{предиката}@math{\rangle} к конкретизированным
@math{\langle}@var{arg}@math{_1\rangle} @dots{}
@math{\langle}@var{arg}@math{_n\rangle} дает истину.
Например, чтобы найти всех сотрудников с зарплатой выше 30000 долларов,
можно написать@footnote{@code{lisp-value} имеет смысл использовать
только для тех операций, которых нет в языке запросов. В частности, с
его помощью не следует проверять равенство (так как для этого
предназначено сопоставление в языке запросов) и неравенство (так как это
можно сделать посредством правила @code{same}, приведенного ниже).}

@lisp
(and (salary ?person ?amount) (lisp-value > ?amount 30000))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.56}Упражнение 4.56:}
Сформулируйте составные запросы для получения следующей
информации:

@enumerate a.

@item
имена всех сотрудников, у которых начальником Бен Битобор, и их адреса;

@item
все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой Бена;

@item
все сотрудники, у которых начальник не относится к компьютерному отделу,
вместе с именем и должностью их начальника.

@end enumerate

@end quotation

@comment @subsubheading Rules
@subsubheading Правила

В дополнение к элементарным и составным запросам, наш язык обладает
средством абстракции запросов. Это @newterm{rules}. Правило

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
говорит, что двое людей живут рядом друг с другом, если они живут в
одном городе. Выражение @code{not} в конце необходимо для того, чтобы
правило не говорило про всех людей, что они живут сами около себя.
Отношение @code{same} (тот же самый) определяется очень простым
правилом:@footnote{Заметим, что правило @code{same} не нужно для того,
чтобы сделать два объекта одинаковыми: достаточно просто использовать
одну и ту же переменную образца --- тогда у нас с самого начала будет
иметься только один объект, а не два. Например, обратите внимание на
@code{?town} в правиле @code{lives-near} или @code{?middle-manager} в
правиле @code{wheel} ниже. @code{same} оказывается полезным, когда нам
хочется, чтобы два объекта различались, как @code{?person-1} и
@code{?person-2} в правиле @code{lives-near}. При том, что
использование одной переменной в двух местах в запросе требует, чтобы в
обоих местах присутствовало одно значение, использование разных
переменных не означает, что значения различаются. (Значения,
присваиваемые различным переменным образца, могут быть как разными, так
и одинаковыми.)}

@lisp
(rule (same ?x ?x))
@end lisp

@noindent
Следующее правило объявляет, что сотрудник является <<wheel>>, если он
начальствует над кем-нибудь, кто сам является начальником:

@lisp
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
@end lisp

@noindent
В общем случае правило выглядит как

@lisp
(rule @math{\langle}@var{conclusion}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@noindent
где @math{\langle}@var{conclusion}@math{\rangle} --- это образец, а
@math{\langle}@var{body}@math{\rangle} --- произвольный
запрос.@footnote{Кроме того, мы разрешаем иметь правила без тела, вроде
@code{same}, и будем полагать, что такое правило означает, что
заключение удовлетворяется любыми значениями переменных.} Можно
считать, что правило представляет собой большое (даже бесконечное)
множество утверждений, а именно, все конкретизации заключения при помощи
присваиваний переменным, удовлетворяющих телу правила. Когда мы
описывали простые запросы (образцы), мы сказали, что присваивание
переменным удовлетворяет образцу в том случае, когда конкретизированный
образец имеется в базе данных. Однако образец не обязательно должен явно
присутствовать в базе данных как утверждение. Это может быть неявное
утверждение, следующее из правила. Например, запрос

@lisp
(lives-near ?x (Bitdiddle Ben))
@end lisp

@noindent
выдает

@lisp
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
@end lisp

@noindent
Чтобы найти всех программистов, живущих около Бена Битобора, можно
спросить

@lisp
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
@end lisp

@noindent
Как и в случае с составными процедурами, правила можно использовать
внутри других правил (как мы видели в @code{lives-near}), и они даже
могут быть рекурсивными. Например, правило

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
@end lisp

@noindent
говорит, что служащий подчиняется руководителю, если руководитель
командует им непосредственно или (рекурсивно) непосредственный начальник
служащего подчиняется руководителю.

@quotation
@strong{@anchor{Упражнение 4.57}Упражнение 4.57:}
Определите правило, которое говорит, что служащий 1 может
заменить служащего 2, если либо служащий 1 имеет ту же должность, что и
служащий 2, либо человек с должностью служащего 1 может выполнять работу
служащего 2, и при этом служащие 1 и 2 --- разные люди. Используя это
правило, составьте запросы, которые находят следующую информацию:

@enumerate a.

@item
все служащие, которые могут заменить П.Э. Фекта.

@item
все служащие, которые могут заменить кого-то, кто получает больше их
самих, с указанием двух зарплат.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.58}Упражнение 4.58:}
Определите правило, которое говорит, что человек
<<независим>> в своем отделе, если он работает в этом отделе, но у него
нет начальника, который работает в том же отделе.

@end quotation

@quotation
@strong{@anchor{Упражнение 4.59}Упражнение 4.59:}
Бен Битобор пропускает слишком много совещаний. Опасаясь
потерять из-за этой глупой привычки работу, он решает, что с ней надо
что-то делать. Он добавляет данные обо всех еженедельных совещаниях в
базу данных <<Микрошафт>> в виде следующих утверждений:

@lisp
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
@end lisp

Все эти утверждения сообщают о совещаниях отделов. Кроме того, Бен
вводит утверждение о совещании всей компании, которое относится ко всем
отделам. Все сотрудники компании должны ходить на это совещание.

@lisp
(meeting whole-company (Wednesday 4pm))
@end lisp

@enumerate a.

@item
В пятницу утром Бен хочет спросить у базы данных, какие совещания
происходят в этот день. Как ему надо составить запрос?

@item
Лиза П. Хакер недовольна. Она считает, что намного полезнее было бы,
если бы можно было спрашивать о совещаниях, указывая свое имя. Она пишет
правило, гласящее, что совещания, куда служащему надо ходить, это
совещания всей компании и совещания отдела, где он работает. Допишите
тело Лизиного правила.

@lisp
(rule (meeting-time ?person ?day-and-time)
      @math{\langle}@var{rule-body}@math{\rangle})
@end lisp

@item
Лиза приходит на работу в среду и хочет узнать, на какие совещания ей
нужно идти в этот день. Если имеется правило @code{время-совещания}, то
какой запрос ей надо подать?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.60}Упражнение 4.60:}
Подав запрос

@lisp
(lives-near ?person (Hacker Alyssa P))
@end lisp

Лиза П. Хакер может найти людей, которые живут с ней рядом, и с
которыми она вместе может ездить на работу. С другой стороны, когда она
пытается найти все пары людей, живущих друг около друга, при помощи
запроса

@lisp
(lives-near ?person-1 ?person-2)
@end lisp

@noindent
она видит, что каждая подходящая пара людей попадается в выводе дважды,
например

@lisp
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
@end lisp

Почему так происходит? Можно ли получить список людей, живущих рядом
друг с другом, в котором каждая пара появлялась бы по одному разу? Ответ
объясните.
@end quotation

@comment @subsubheading Logic as programs
@subsubheading Логика как программы

Можно рассматривать правило как своего рода логическую импликацию:
@emph{если} присваивание значений переменным образца удовлетворяет телу,
@emph{то} оно удовлетворяет заключению. Следовательно, можно считать,
что язык запросов способен производить (@newterm{logical deduction}) на основании
правил. В качестве примера рассмотрим операцию @code{append}, описанную
в начале @ref{4.4}. Как мы уже сказали,
@code{append} характеризуется следующими двумя правилами:

@itemize @bullet

@item
Для любого списка @code{y}, @code{append} пустого списка и @code{y} дает
@code{y}

@item
Для любых @code{u}, @code{v}, @code{y} и @code{z}, @code{append} от
@code{(cons u v)} и @code{y} дает @code{(cons u z)}, если @code{append}
от @code{v} и @code{y} дает @code{z}.

@end itemize

@noindent
Чтобы выразить это в нашем языке запросов, мы определяем два правила для
отношения

@lisp
(append-to-form x y z)
@end lisp

@noindent
которое можно интерпретировать как <<@code{append} от @code{x} и
@code{y} дает @code{z}>>:

@lisp
(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
@end lisp

@noindent
В первом правиле нет тела, и это означает, что следствие выполняется для
любого значения @code{?y}. Обратите также внимание, как во втором
правиле @code{car} и @code{cdr} списка изображаются с использованием
точечной записи.

При помощи этих двух правил мы можем формулировать запросы, которые
вычисляют @code{append} от двух списков:

@lisp
@i{;;; Ввод запроса:}
(append-to-form (a b) (c d) ?z)
@i{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
Удивительнее то, что мы с помощью тех же правил можем задать вопрос
<<Какой список, будучи добавлен к @code{(a b)}, дает @code{(a b c d)}?>>
Это делается так:

@lisp
@i{;;; Ввод запроса:}
(append-to-form (a b) ?y (a b c d))
@i{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
Можно также запросить все пары списков, @code{append} от которых дает
@code{(a b c d)}:

@lisp
@i{;;; Ввод запроса:}
(append-to-form ?x ?y (a b c d))
@i{;;; Результаты запроса:}
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
@end lisp

@noindent
Может показаться, что, используя правила для вывода ответов на
перечисленные запросы, система демонстрирует немалый интеллект. На самом
же деле, как мы увидим в следующем разделе, при разборе правил она
следует хорошо определенному алгоритму. К сожалению, хотя в случае с
@code{append} результаты впечатляют, в более сложных ситуациях общие
методы могут не сработать, как мы увидим в @ref{4.4.3}.

@quotation
@strong{@anchor{Упражнение 4.61}Упражнение 4.61:}
Следующие правила определяют отношение @code{next-to},
которое находит в списке соседние элементы:

@lisp
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
@end lisp

Каков будет ответ на следующие запросы?

@lisp
(?x next-to ?y in (1 (2 3) 4))
(?x next-to  1 in (2 1 3 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.62}Упражнение 4.62:}
Определите правила, которые реализуют операцию
@code{last-pair} из упражнения @ref{Упражнение 2.17}, которая
возвращает последнюю пару непустого списка. Проверьте Ваши правила на
таких запросах, как @code{(last-pair (3) ?x)},
@code{(last-pair (1 2 3) ?x)} и @code{(last-pair (2 ?x) (3))}. Правильно
ли Ваши правила работают с запросами вида @code{(last-pair ?x (3))}?

@end quotation

@quotation
@strong{@anchor{Упражнение 4.63}Упражнение 4.63:}
Следующая база данных (см. книгу Бытия, 4) содержит
генеалогию сыновей Ады вплоть до Адама, через Каина:

@example
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)
@end example

@comment @lisp
@comment (son Adam Cain)
@comment (son Cain Enoch)
@comment (son Enoch Irad)
@comment (son Irad Mehujael)
@comment (son Mehujael Methushael)
@comment (son Methushael Lamech)
@comment (wife Lamech Ada)
@comment (son Ada Jabal)
@comment (son Ada Jubal)
@comment @end lisp

Сформулируйте правила, такие как <<Если @math{S} сын @math{F}, а
@math{F} сын @math{G}, то @math{S} внук @math{G}>> и <<Если @math{W}
жена @math{M}, а @math{S} сын @math{W}, то @math{S} также сын @math{M}>>
(предполагается, что в библейские времена это в большей степени
соответствовало истине, чем теперь). Эти правила должны позволить
системе найти внука Каина; сыновей Ламеха; внуков Мафусала. (В
упражнении @ref{Упражнение 4.69} можно найти правила, с помощью
которых выводятся более сложные родственные связи.)
@end quotation

@comment @subsection How the Query System Works
@subsection Как действует система обработки запросов
@node	4.4.2, 4.4.3, 4.4.1, 4.4

В @ref{4.4.4} мы представим
реализацию интерпретатора запросов в виде набора процедур. В этом
разделе дается обзор системы и объясняется ее общая структура, без
низкоуровневых деталей реализации. После того, как мы опишем
интерпретатор, нам легче будет понять его ограничения и некоторые
тонкости, в которых логические операции языка запросов отличаются от
операций математической логики.

Должно быть очевидно, что вычислителю запросов требуется какая-то
разновидность поиска, чтобы сопоставлять запросы с фактами и правилами в
базе данных. Одним из способов сделать это была бы реализация системы
запросов в виде недетерминистской программы с использованием
@code{amb}-интерпретатора из @ref{4.3}
(см. упражнение @ref{Упражнение 4.78}). Другая возможность состоит в
том, чтобы управлять поиском при помощи потоков. Наша реализация
использует этот второй подход.

Запросная система организована вокруг двух основных операций, которые
называются @emph{сопоставление с образцом} (@newterm{pattern matching}) и
(@newterm{unification}). Сначала мы опишем сопоставление с образцом и объясним,
как эта операция, вместе с организацией информации в виде потоков
кадров, позволяет нам реализовывать как простые, так и составные
запросы. Затем мы обсудим унификацию --- обобщение сопоставления с
образцом, которое требуется для реализации правил. Наконец, мы покажем,
как части интерпретатора связываются воедино процедурой,
классифицирующей выражения, подобно тому, как @code{eval} разбирает
выражения в интерпретаторе, описанном в @ref{4.1}.

@endpage
@comment @subsubheading Pattern matching
@subsubheading Сопоставление с образцом

(@newterm{pattern matcher}) --- это программа, которая проверяет, соответствует
ли некоторая структура данных указанному образцу. Например, список
@code{((a b) c (a b))} соответствует образцу @code{(?x c ?x)} при
значении переменной @code{?x}, равном @code{(a b)}. Этот же список
соответствует образцу @code{(?x ?y ?z)} при значениях переменных
@code{?x} и @code{?z}, равных @code{(a b)} и значении @code{?y}, равном
@code{b}. Однако он не соответствует образцу @code{(?x a ?y)}, поскольку
этот образец требует, чтобы вторым элементом списка был символ @code{a}.

Сопоставитель, который используется в запросной системе, принимает на
входе образец, структуру данных и (@newterm{frame}), в котором указываются
связывания для различных переменных образца. Он проверяет, соответствует
ли структура данных образцу без противоречия со связываниями переменных,
уже находящимися в кадре. Если да, то сопоставитель возвращает кадр,
дополнив его связываниями, определенными во время сопоставления. Если
нет, он указывает, что сопоставление неудачно.

Например, сопоставление образца @code{(?x ?y ?x)} со списком
@code{(a b a)} при пустом начальном кадре вернет кадр, в котором
переменная @code{?x} связана со значением @code{a}, а @code{?y} со
значением @code{b}. Попытка сопоставления того же списка с тем же
образцом при начальном кадре, в котором указывается, что @code{?y}
связывается с @code{a}, окажется неудачной. Попытка сопоставления с теми
же данными и образцом, при начальном кадре, в котором @code{?y} связана
со значением @code{b}, а @code{?x} несвязана, вернет исходный кадр,
дополненный связыванием @code{a} для @code{?x}.

Сопоставитель --- единственный механизм, необходимый для обработки
простых образцов, не содержащих правил. Например, чтобы обработать запрос:

@lisp
(job ?x (computer programmer))
@end lisp

@noindent
--- мы просматриваем все утверждения в базе данных и выбираем те,
которые соответствуют образцу при пустом начальном кадре. Для каждого
найденного утверждения мы подставляем в образец значение @code{?x} из
кадра, полученного при сопоставлении.

@endpage
@comment @subsubheading Streams of frames
@subsubheading Потоки кадров

Проверка образцов по отношению к кадрам организована посредством
потоков. Получив кадр, процесс сопоставления просматривает элементы базы
данных один за другим. Для каждого входа базы данных сопоставитель
порождает либо специальный символ, указывающий, что сопоставление
оказалось неудачным, либо расширение кадра. Из результатов сопоставления
всей базы данных собирается поток, и этот поток пропускается через
фильтр, отбрасывающий неудачи. Получается поток всех кадров, которые
расширяют данный кадр за счет сопоставления с каким-либо утверждением из
базы.@footnote{Поскольку сопоставление --- в общем случае весьма дорогая
операция, нам хотелось бы избежать применения полного сопоставителя к
каждому элементу базы данных. Обычное решение этой проблемы --- разбить
процесс на грубое (быстрое) сопоставление и окончательное сопоставление.
Грубое сопоставление отфильтровывает базу и находит кандидатуры на
окончательное сопоставление. Если действовать аккуратно, можно построить
базу данных таким образом, что часть работы грубого сопоставителя
проделывается при построении базы, а не в момент отбора кандидатов. Это
называется (@newterm{indexing}) базы данных. Существует множество приемов и схем
индексирования баз данных. Наша реализация, которую мы описываем
@ref{4.4.4}, содержит простейший вариант такой оптимизации.}

В нашей системе запрос принимает входной поток кадров и для каждого
кадра применяет вышеописанную операцию сопоставления, как показано на
рис. @ref{Рисунок 4.4}. А именно, для каждого кадра во входном потоке
запрос генерирует новый поток, содержащий все расширения этого кадра,
порожденные сопоставлением с утверждениями из базы. Затем все эти потоки
собираются в один громадный поток, который содержит все возможные
расширения всех кадров входного потока. Этот поток и есть результат
запроса.

Чтобы ответить на простой запрос, мы применяем его к потоку, который
состоит из одного пустого кадра. Поток на выходе содержит все расширения
пустого кадра (то есть, все ответы на наш запрос). Затем на основе этого
потока кадров создается поток копий исходного образца запроса, в которых
переменные конкретизированы значениями из всех кадров, и этот поток в
конце концов печатается.

@float
@c @quotation
@anchor{Рисунок 4.4}
@ifinfo
@strong{Рисунок 4.4:} A query processes a stream of frames.

@example
                                  output stream
  input stream   +-------------+  of frames,
  of frames      |    query    |  filtered and extended
---------------->|             +------------------------->
                 | (job ?x ?y) |
                 +-------------+
                        ^
                        |
               stream of assertions
                  from data base
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.4,102mm,,,.pdf}
@sp 0.7
@comment @center @caption{@strong{Рисунок 4.4:} A query processes a stream of frames.}
@center @caption{@strong{Рисунок 4.4:} Запрос обрабатывает поток кадров.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Изящество реализации с потоками кадров по-настоящему проявляется при
работе с составными запросами. При обработке составных запросов мы
пользуемся тем, что наш сопоставитель умеет требовать, чтобы
сопоставление не противоречило указанному кадру. Например, чтобы
обработать @code{and} от двух запросов, скажем,

@lisp
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
@end lisp

@noindent

(неформально, <<найти всех сотрудников, способных выполнять работу
программиста-стажера>>), сначала мы находим все записи базы, отвечающие
образцу

@lisp
(can-do-job ?x (computer programmer trainee))
@end lisp

@float
@quotation
@anchor{Рисунок 4.5}
@ifinfo
@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced
by operating on the stream of frames in series.

@example
                +----------------------+
                |       (and A B)      |
  input stream  |                      |  output stream
  of frames     |   +---+       +---+  |  of frames
------------------->| A +------>| B +-------------------->
                |   +---+       +---+  |
                |     ^           ^    |
                |     |           |    |
                |     +-----*-----+    |
                +-----------|----------+
                            |
                        data base
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap4/Fig4.5,93mm,,,.pdf}
@sp 0.4
@comment @caption{@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced by operating on the stream of frames in series.}
@center @caption{@strong{Рисунок 4.5:} Комбинация двух запросов через @code{and} осуществляется последовательной обработкой потока кадров.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Получается поток кадров, каждый из которых содержит связывание для @code{?x}.
Затем для всех кадров этого потока мы находим записи, соответствующие образцу

@lisp
(job ?person ?x)
@end lisp

@noindent
таким образом, чтобы не менять уже известное связывание переменной
@code{?x}. Каждое новое сопоставление породит кадр, в котором будут
содержаться связывания для @code{?x} и @code{?person}. @code{And} от
двух запросов можно рассматривать как последовательное применение двух
составляющих запросов, как показано на рис. @ref{Рисунок 4.5}. Кадры,
прошедшие через первый запрос, фильтруются и расширяются вторым
запросом.

@float
@anchor{Рисунок 4.6}
@ifinfo
@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced
by operating on the stream of frames in parallel and merging the results.

@example
           +---------------------------+
           |          (or A B)         |
           |    +---+                  |
input      | +->| A |------------+     |  output
stream of  | |  +---+            V     |  stream of
frames     | |    ^          +-------+ |  frames
-------------*    |          | merge +--------------->
           | |    |          +-------+ |
           | |    |              ^     |
           | |    |   +---+      |     |
           | +------->| B +------+     |
           |      |   +---+            |
           |      |     ^              |
           |      |     |              |
           |      +--*--+              |
           +---------|-----------------+
                     |
                 data base
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap4/Fig4.6,107mm,,,.pdf}
@sp 0.4
@comment @caption{@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced by operating on the stream of frames in parallel and merging the results.}
@caption{@strong{Рисунок 4.6:} Комбинация двух запросов через @code{or} осуществляется путем параллельной обработки потока кадров и слияния результатов.}
@sp 0.4
@end iftex
@end float

На рисунке @ref{Рисунок 4.6} показан аналогичный метод для вычисления
@code{or} от двух запросов через параллельное выполнение двух
составляющих запросов. Каждый запрос отдельно расширяет входной поток
кадров. Затем два получившихся потока сливаются и образуют окончательный
поток-результат.

Даже из этого высокоуровневого описания ясно, что обработка составных
запросов может занимать много времени. Например, поскольку запрос может
породить более одного выходного кадра для каждого входного, а каждый
подзапрос в @code{and} принимает входные кадры от предыдущего
подзапроса, в наихудшем случае число сопоставлений, которые должен
произвести запрос @code{and}, растет экспоненциально с числом
подзапросов (см. упражнение @ref{Упражнение 4.76}).@footnote{Впрочем,
такой экспоненциальный взрыв в запросах @code{and} происходит редко,
поскольку, как правило, дополнительные условия не увеличивают, а
уменьшают число порождаемых кадров.} Несмотря на то, что системы для
обработки простых запросов вполне могут быть практически полезны,
обработка сложных запросов чрезвычайно трудоемка.@footnote{Имеется
обширная литература по системам управления базами данных, в которой
основной темой является эффективная обработка сложных запросов.}

С точки зрения потока кадров, запрос @code{not} работает как фильтр,
уничтожающий все кадры, для которых его подзапрос можно удовлетворить.
Например, имея образец

@lisp
(not (job ?x (computer programmer)))
@end lisp

@noindent
мы для каждого кадра во входном потоке пытаемся породить расширенные
кадры, которые удовлетворяют образцу
@code{(job ?x (computer programmer))}. Все кадры, для которых
такие расширения существуют, мы изымаем из входного потока. В результате
получается поток, состоящий только из тех кадров, в которых связывание
для @code{?x} не удовлетворяет @code{(job ?x (computer programmer))}.
Например, при обработке запроса

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
@end lisp

@noindent
первый подзапрос породит кадры со связанными значениями @code{?x} и
@code{?y}. Затем выражение @code{not} отфильтрует этот поток, удалив все
кадры, в которых значение @code{?x} удовлетворяет ограничению, что
@code{?x} является программистом.@footnote{Существует тонкое различие
между реализацией @code{not} в виде фильтра и значением отрицания в
математической логике.
См. @ref{4.3.3}.}

Особая форма @code{lisp-value} реализуется при помощи подобного же
фильтра для потоков кадров. При помощи каждого кадра из потока мы
конкретизируем все переменные образца, а затем применяем лисповский
предикат. Все кадры, для которых предикат оказывается ложным, мы удаляем
из входного потока.

@comment @subsubheading Unification
@subsubheading Унификация

Чтобы обрабатывать правила языка запросов, нам нужно уметь находить
правила, в которых заключения соответствуют данному входному образцу.
Заключения правил подобны утверждениям, но только в них могут
содержаться переменные, так что нам требуется обобщенный вариант
сопоставления с образцом, --- называемый (@newterm{unification}), --- в котором
как <<образец>>, так и <<данные>> могут содержать переменные.

Унификатор берет два образца, в каждом из которых могут быть константы и
переменные, и определяет, возможно ли присвоить переменным значения,
которые сделают два образца одинаковыми. Если да, то он возвращает кадр,
содержащий эти значения. Например, при унификации @code{(?x a ?y)} и
@code{(?y ?z a)} получится кадр, в котором все три переменные @code{?x},
@code{?y} и @code{?z} связаны со значением @code{a}. С другой стороны,
унификация @code{(?x ?y a)} и @code{(?x b ?y)} потерпит неудачу,
поскольку не имеется такого значения для @code{?y}, которое бы сделало
два образца одинаковыми. (Чтобы вторые элементы образцов оказались
равными, @code{?y} должно равняться @code{b}; однако, чтобы совпали
третьи элементы, @code{?y} обязан быть @code{a}.) Подобно сопоставителю,
унификатор, используемый в системе запросов, принимает на входе кадр и
проводит унификации, не противоречащие содержимому этого кадра.

Алгоритм унификации --- самая технически сложная часть запросной
системы. При наличии сложных образцов может показаться, что для
унификации требуются дедуктивные способности. Например, чтобы
унифицировать @code{(?x ?x)} и @code{((a ?y c) (a b ?z))}, алгоритм
обязан вычислить, что @code{?x} должен быть равен @code{(a b c)},
@code{?y} должен быть @code{b}, а @code{?z} должен быть равен @code{c}.
Можно считать, что этот процесс решает систему уравнений, описывающую
компоненты образцов. В общем случае это будут взаимозависимые уравнения,
для решения которых требуются существенные преобразования.@footnote{В
одностороннем сопоставлении с образцом все уравнения, которые содержат
переменные, заданы явно и уже решены относительно неизвестного
(переменной образца).} К примеру, унификацию @code{(?x ?x)} и
@code{((a ?y c) (a b ?z))} можно рассматривать как систему уравнений

@lisp
?x  =  (a ?y c)
?x  =  (a b ?z)
@end lisp

@noindent
Из этих уравнений следует, что

@lisp
(a ?y c)  =  (a b ?z)
@end lisp

@noindent
а отсюда, в свою очередь, что

@lisp
 a  =  a,
?y  =  b,
 c  =  ?z,
@end lisp

@noindent
и, следовательно,

@lisp
?x = (a b c)
@end lisp

@noindent
При успешном сопоставлении с образцом все переменные оказываются
связанными, и значения, с которыми они связаны, содержат только
константы. Это верно и для всех примеров унификации, которые мы до сих
пор рассмотрели. Однако в общем случае успешная унификация может не
полностью определить значения переменных; какие-то переменные могут
остаться неопределенными, а значения других сами могут содержать
переменные.

Рассмотрим унификацию @code{(?x a)} и @code{((b ?y) ?z)}. Можно
вычислить, что @code{?x = (b ?y)}, а @code{a = ?z}, но ничего больше
нельзя сказать о значениях @code{?x} и @code{?y}. Унификация
заканчивается успешно, поскольку, естественно, можно сделать образцы
одинаковыми, присвоив значения @code{?x} и @code{?y}. Поскольку
сопоставление никак не ограничивает значение, которое может принимать
переменная @code{?y}, никакого ее значения не оказывается в
кадре-результате. Однако результат ограничивает значение @code{?x}.
Какое бы значение не имела переменная @code{?y}, @code{?x} должен
равняться @code{(b ?y)}. Таким образом, в кадр помещается связывание
@code{?x} со значением @code{(b ?y)}. Если позже значение @code{?y}
оказывается определенным (путем сопоставления с образцом или унификации,
которая должна соответствовать этому кадру) и добавляется в кадр,
значение, связанное с @code{?x}, будет ссылаться на него.@footnote{Можно
считать, что унификация находит наиболее общий образец, который является
специализацией двух входных образцов. А именно, унификация @code{(?x a)}
и @code{((b ?y) ?z)} равна @code{((b ?y) a)}, а унификация
@code{(?x a ?y)} и @code{(?y ?z a)}, описанная выше, равна
@code{(a a a)}. Однако в нашей реализации удобнее считать, что
результатом унификации является не образец, а кадр.}

@comment @subsubheading Applying rules
@subsubheading Применение правил

Главной операцией в компоненте запросной системы, который производит
логический вывод на основе правил, является унификация. Чтобы увидеть,
как этот компонент работает, рассмотрим обработку запроса, содержащего
обращение к правилу, например:

@lisp
(lives-near ?x (Hacker Alyssa P))
@end lisp

@noindent
Обрабатывая этот запрос, сначала мы при помощи описанной ранее
обыкновенной процедуры сопоставления смотрим, имеются ли в базе данных
утверждения, которые сопоставляются с данным образцом. (В данном случае
таковых не окажется, поскольку в нашей базе данных нет никаких прямых
утверждений о том, кто около кого живет.) На следующем шаге мы пытаемся
унифицировать образец-запрос с заключением каждого правила. Мы
обнаруживаем, что образец унифицируется с заключением правила

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
и получается кадр, в котором переменная @code{?person-2} связана со
значением @code{(Hacker Alyssa P)}, а переменная @code{?x} связана с
(должна иметь то же значение, что и) @code{?person-1}. Теперь по
отношению к этому кадру мы вычисляем составной запрос, содержащийся в
теле правила. Успешные сопоставления расширят кадр, сообщив значение
переменной @code{?person-1}, а соответственно, и @code{?x}, которую мы
можем использовать при конкретизации исходного образца-запроса.

В общем случае обработчик запросов при применении правила, когда он
пытается распознать образец-запрос в кадре, который содержит связывания
для некоторых переменных образца, использует следующий метод:

@itemize @bullet

@item
Унифицировать запрос с заключением правила и получить (если унификация
успешна) расширение исходного кадра.

@item
По отношению к расширенному кадру вычислить запрос, который является
телом правила.

@end itemize

@noindent
Обратите внимание, насколько это похоже на метод применения процедуры в
интерпретаторе @code{eval/apply} для Лиспа:

@itemize @bullet

@item
Связать параметры процедуры с ее аргументами и получить кадр,
расширяющий исходное окружение процедуры.

@item
По отношению к расширенному окружению вычислить выражение, которое
является телом процедуры.
@end itemize

@noindent
Подобие двух вычислителей неудивительно. Точно так же, как в Лиспе
средством абстракции являются определения процедур, в языке запросов
средством абстракции являются определения правил. В каждом случае мы
развертываем абстракцию, создавая соответствующие связывания и вычисляя
тело правила либо процедуры по отношению к расширенной среде.

@comment @subsubheading Simple queries
@subsubheading Простые запросы

В этом разделе мы уже рассматривали, как вычислять простые запросы при
отсутствии правил. Теперь, разобравшись, как применяются правила, мы
можем описать, как простые запросы вычисляются с помощью как правил, так
и утверждений.

Получая запрос-образец и поток кадров, мы порождаем для каждого входного
кадра два новых потока:

@itemize @bullet

@item
поток расширенных кадров, получаемых сопоставлением образца со всеми
утверждениями базы данных (при помощи сопоставителя), а также

@item
поток расширенных кадров, полученных применением всех возможных правил
(при помощи унификатора).@footnote{Поскольку унификация является
обобщением сопоставления, можно было бы упростить систему и порождать
оба потока с помощью унификатора. Однако обработка простого случая с
помощью обычного сопоставителя показывает, как сопоставление (а не
полноразмерная унификация) может само по себе быть полезным.}
@end itemize

@noindent
Соединение двух этих потоков порождает поток, который состоит изо всех
способов, которыми данный образец можно удовлетворить в соответствии с
исходным кадром. Эти потоки (по одному на каждый кадр входного потока)
соединяются, и получается единый большой поток. Окончательный поток,
таким образом, состоит изо всех способов, которыми какой-либо кадр
входного потока может быть расширен так, чтобы получалось сопоставление
с данным запросом.

@comment @subsubheading The query evaluator and the driver loop
@subsubheading Вычислитель запросов и управляющий цикл

Несмотря на сложность встроенных операций сопоставления, система
организована подобно интерпретатору любого языка. Процедура,
координирующая операции сопоставления, называется и играет роль,
аналогичную процедуре @code{eval} для Лиспа. @code{qeval} принимает на
входе запрос и поток кадров. Ее выходом служит поток кадров,
соответствующих успешным сопоставлениям с запросом, которые расширяют
какой-либо кадр во входном потоке, как показано на
рис. @ref{Рисунок 4.4}. Подобно @code{eval}, @code{qeval} распознает
различные типы выражений (запросов) и для каждого из них вызывает
соответствующую процедуру. Имеется по процедуре для каждой особой формы
(@code{and}, @code{or}, @code{not} и @code{lisp-value}) и еще одна для
простых запросов.

Управляющий цикл, аналогичный процедуре @code{driver-loop} из других
интерпретаторов этой главы, считывает запросы с терминала. Для каждого запроса
он вызывает @code{qeval} с запросом и потоком, состоящим из одного пустого кадра.
Получается поток всех возможных сопоставлений (всех возможных расширений
пустого кадра). Для каждого кадра в выходном потоке управляющий цикл
конкретизирует входной запрос с использованием значений переменных,
имеющихся в кадре. Затем этот поток конкретизированных запросов
печатается.@footnote{Мы используем потоки (а не списки) кадров потому,
что рекурсивное применение правил может порождать бесконечное число
значений, удовлетворяющих запросу. Здесь существенно задержанное
вычисление, осуществляемое потоками: система будет печатать ответы один
за другим по мере их порождения, независимо от того, получается ли
конечное или бесконечное количество ответов.}

Кроме того, управляющий цикл распознает особую команду @code{assert!},
которая говорит, что на вход поступает не запрос, а новое утверждение
или правило, которое следует добавить в базу данных. Например,

@lisp
(assert! (job (Bitdiddle Ben)
              (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
@end lisp

@direntry
@lisp
(assert! (должность (Битобор Бен) (компьютеры гуру)))
(assert! (rule (шишка ?person)
               (and (начальник ?middle-manager ?person)
                    (начальник ?x ?middle-manager))))
@end lisp
@end direntry

@comment @subsection Is Logic Programming Mathematical Logic?
@subsection Является ли логическое программирование математической логикой?
@node	4.4.3, 4.4.4, 4.4.2, 4.4

На первый взгляд может показаться, что средства комбинирования,
используемые в языке запросов, совпадают с операторами математической
логики --- @code{and}, @code{or} и отрицанием @code{not}, а при применении
правил языка запросов производится корректный логический вывод.
@footnote{То, что конкретный метод
логического вывода корректен --- утверждение не тривиальное. Требуется
доказать, что исходя из истинных посылок, можно придти только к истинным
заключениям. В применении правил используется , известный метод вывода,
который говорит, что если истинны утверждения @math{A} и @emph{из
@math{A} следует @math{B}}, то можно заключить истинность утверждения
@math{B}.} Однако такая идентификация языка запросов с математической
логикой неверна, поскольку язык запросов обладает (@newterm{control structure}),
которая интерпретирует логические утверждения процедурным образом. Часто
из этой структуры управления можно извлечь пользу. Например, чтобы найти
начальников всех программистов, можно сформулировать запрос двумя
логически эквивалентными способами:

@lisp
(and (job ?x (computer programmer)) (supervisor ?x ?y))
@end lisp

@direntry
@lisp
(and (должность ?x (компьютеры программист))
     (начальник ?x ?y))
@end lisp
@end direntry

@noindent
и

@lisp
(and (supervisor ?x ?y) (job ?x (computer programmer)))
@end lisp

@direntry
@lisp
(and (начальник ?x ?y)
     (должность ?x (компьютеры программист)))
@end lisp
@end direntry

@noindent
Если в компании намного больше начальников, чем программистов (обычный
случай), то первую форму использовать выгоднее, чем вторую, поскольку
для каждого промежуточного результата (кадра), порождаемого первым
подзапросом @code{and}, требуется просмотреть базу данных.

Цель логического программирования состоит в том, чтобы дать программисту
способ разбить вычислительную задачу на две отдельные подзадачи: <<что>>
требуется посчитать и <<как>> это сделать. Этого добиваются, выделив
подмножество утверждений математической логики --- достаточно мощное,
чтобы описать все, что захочется вычислить, но при этом достаточно
слабое, чтобы иметь управляемую процедурную реализацию. Идея состоит в
том, чтобы, с одной стороны, программа, выраженная на языке логического
программирования, была эффективной, и компьютер мог бы ее исполнить.
Управление (<<как>> считать) определяется порядком вычислений языка. У
нас должна быть возможность определять порядок выражений и порядок
подвыражений в них так, чтобы вычисление проходило правильным и
эффективным способом. В то же самое время мы должны быть способны
рассматривать результат вычислений (<<что>> считать) как простое
следствие законов логики.

Наш язык запросов можно рассматривать в качестве именно такого
процедурно интерпретируемого подмножества математической логики.
Утверждение представляет простой факт (атомарную пропозицию). Правило
представляет импликацию, говорящую, что заключение истинно в случаях,
когда истинно тело правила. Правило обладает естественной процедурной
интерпретацией: чтобы доказать заключение правила, требуется доказать
его тело. Следовательно, правила описывают вычисления. Однако поскольку
правила можно рассматривать и как формулы математической логики, мы
можем оправдать любой <<вывод>>, производимый логической программой,
показав, что того же результата можно достичь, работая строго в рамках
логики.@footnote{Это утверждение нужно ограничить соглашением: говоря о
<<выводе>>, производимом логической программой, мы предполагаем, что
вычисление имеет конец. К сожалению, даже это ограниченное утверждение
оказывается ложным для нашей реализации языка запросов (а также для
программ на Прологе и большинстве других современных математических
языков) из-за использования @code{not} и @code{lisp-value}. Как будет
описано ниже, примитив @code{not}, реализованный в языке запросов, не
всегда имеет то же значение, что отрицание в математической логике, а
использование @code{lisp-value} вызывает дополнительные сложности. Можно
было бы реализовать язык, согласованный с математической логикой, если
просто убрать из него @code{not} и @code{lisp-value} и согласиться
писать программы с использованием исключительно простых запросов,
@code{and} и @code{or}. Однако при этом оказалась бы ограничена
выразительная сила языка. Одна из основных тем исследований в логическом
программировании --- поиск способов более тесного согласования с
математической логикой без чрезмерной потери выразительной силы.}

@comment @subsubheading Infinite loops
@subsubheading Бесконечные циклы

Вследствие процедурной интерпретации логических программ для решения
некоторых задач можно построить безнадежно неэффективные программы.
Частным случаем неэффективности является ситуация, когда программа при
работе над выводом впадает в бесконечный цикл. Возьмем простой пример:
предположим, что мы строим базу данных знаменитых супружеских пар, в том
числе

@lisp
(assert! (married Minnie Mickey))
@end lisp

@direntry
@lisp
(assert! (супруг Минни Микки))
@end lisp
@end direntry

@noindent
Если теперь мы спросим

@lisp
(married Mickey ?who)
@end lisp

@direntry
@lisp
(супруг Микки ?who)
@end lisp
@end direntry

@noindent
мы не получим ответа, поскольку система не знает, что если @math{A}
является супругом @math{B}, то @math{B} является супругом @math{A}.
Поэтому мы вводим правило

@lisp
(assert! (rule (married ?x ?y) (married ?y ?x)))
@end lisp

@direntry
@lisp
(assert! (rule (супруг ?x ?y)
               (супруг ?y ?x)))
@end lisp
@end direntry

@noindent
и снова делаем запрос

@lisp
(married Mickey ?who)
@end lisp

@direntry
@lisp
(супруг Микки ?who)
@end lisp
@end direntry

К сожалению, это вводит систему в бесконечный цикл следующим образом:

@itemize @bullet

@item
Система обнаруживает, что применимо правило @code{married}; а именно,
заключение @code{(married ?x ?y)} успешно унифицируется с
образцом-запросом @code{(married Mickey ?who)} и получается кадр, в
котором переменная @code{?x} связана со значением @code{Mickey}, а
переменная @code{?y} со значением @code{?who}. Интерпретатор должен,
таким образом, выполнить в этом кадре запрос @code{(married ?y ?x)} ---
в сущности, выполнить запрос @code{(married ?who Mickey)}.

@item
Один ответ находится как утверждение в базе данных:
@code{(married Minnie Mickey)}.

@item
Применимо также и правило @code{married}, так что интерпретатор снова
выполняет его тело, которое теперь равно @code{(married Mickey ?who)}.

@end itemize

@noindent
Теперь система оказалась в бесконечном цикле. В сущности, найдет ли
система простой ответ @code{(married Minnie Mickey)} прежде, чем окажется в
цикле, зависит от деталей реализации, связанных с порядком, в котором
система проверяет записи базы данных. Это простой пример циклов, которые
могут возникнуть. Наборы взаимосвязанных правил могут привести к циклам,
которые значительно труднее предвидеть, а возникновение цикла может
зависеть от порядка подвыражений в @code{and}
(см. упражнение @ref{Упражнение 4.64}) или от низкоуровневых деталей,
связанных с порядком обработки запросов в системе.@footnote{Это проблема
не собственно логики, а процедурной интерпретации логики, которую дает
наш интерпретатор. В данном случае можно написать интерпретатор, который
не попадет в цикл. Например, можно пронумеровать доказательства,
выводимые из наших утверждений и правил, по ширине, а не по глубине.
Однако в такой системе оказывается труднее использовать порядок правил в
программах. Одна из попыток встроить в такую программу тонкое управление
вычислениями описана в deKleer et al. 1977. Еще один метод, который не
ведет к столь же сложным проблемам с управлением, состоит в добавлении
специальных знаний, например, детекторов для каких-то типов циклов
(см. упражнение @ref{Упражнение 4.67}). Однако общую схему надежного
предотвращения бесконечных путей в рассуждениях построить невозможно.
Представьте себе дьявольское правило вида <<чтобы доказать истинность
@math{P(x)}, докажите истинность @math{P(f(x))}>> для какой-нибудь хитро
выбранной функции @math{f}.}

@comment @subsubheading Problems with @code{not}
@subsubheading Проблемы с @code{not}

Еще одна особенность запросной системы связана с @code{not}. Рассмотрим
следующие два запроса к базе данных из @ref{4.4.1}:

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
@end lisp

@direntry
@lisp
(and (начальник ?x ?y)
     (not (должность ?x (компьютеры программист))))

(and (not (должность ?x (компьютеры программист)))
     (начальник ?x ?y))
@end lisp
@end direntry

Эти два запроса приводят к различным результатам. Первый запрос сначала
находит все записи в базе данных, соответствующие образцу
@code{(supervisor ?x ?y)}, затем фильтрует полученные кадры, удаляя те, в
которых значение @code{?x} удовлетворяет образцу
@code{(job ?x (computer programmer))}. Второй запрос сначала
фильтрует входные кадры, пытаясь удалить те, которые удовлетворяют
образцу @code{(job ?x (computer programmer))}. Поскольку
единственный входной кадр пуст, он проверяет базу данных и смотрит, есть
ли там записи, соответствующие
@code{(job ?x (computer programmer))}. Поскольку, как правило,
такие записи имеются, выражение @code{not} удаляет пустой кадр, и
остается пустой поток кадров. Следовательно, весь составной запрос также
возвращает пустой поток.

Сложность состоит в том, что наша реализация @code{not} предназначена
только для того, чтобы служить фильтром для значений переменных. Если
выражение @code{not} обрабатывается с кадром, в котором часть переменных
остается несвязанными (как @code{?x} в нашем примере), система выдаст
неверный результат. Подобные сложности возникают и с использованием
@code{lisp-value} --- предикат Lisp не сможет работать, если часть из
его аргументов несвязана. См. упражнение @ref{Упражнение 4.77}.

Есть еще один, значительно более серьезный аспект, в котором @code{not}
языка запросов отличается от отрицания в математической логике. В логике
мы считаем, что выражение <<не @math{P}>> означает, что @math{P} ложно.
Однако в системе запросов <<не @math{P}>> означает, что @math{P}
невозможно доказать на основе информации из базы данных. Например, имея
базу данных из @ref{4.4.1},
система радостно выведет разнообразные отрицательные утверждения,
например, что Бен Битобор не любитель бейсбола, что на улице нет дождя,
и что 2 + 2 не равно 4.@footnote{Рассмотрим запрос
@code{(not (baseball-fan (Bitdiddle Ben))}. Система обнаруживает,
что записи @code{(baseball-fan (Bitdiddle Ben))} в базе нет, так что
пустой кадр образцу не соответствует и не удаляется из исходного потока
кадров. Таким образом, результатом запроса является пустой кадр, он
используется для конкретизации запроса, и выходит
@code{(not (baseball-fan (Bitdiddle Ben)))}.} Иными словами,
операция @code{not} в языках логического программирования отражает так
называемую (closed world assumption) и считает, что вся релевантная
информация включена в базу данных.@footnote{Обсуждение и защита такой
интерпретации @code{not} содержится в статье Кларка (Clark 1978).}

@quotation
@strong{@anchor{Упражнение 4.64}Упражнение 4.64:}
Хьюго Дум по ошибке уничтожил в базе данных правило @code{outranked-@/by}
(@ref{4.4.1}). Обнаружив это, он быстро набивает правило заново, только, к
сожалению, по ходу дела вносит небольшое изменение:

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person
                           ?middle-manager))))
@end lisp

@direntry
@lisp
(rule (подчиняется ?staff-person ?boss)
      (or (начальник ?staff-person ?boss)
          (and (подчиняется ?middle-manager ?boss)
               (начальник ?staff-person ?middle-manager))))
@end lisp
@end direntry

Сразу после того, как Хьюго ввел информацию в систему, Кон Фиден хочет
посмотреть, кому подчиняется Бен Битобор. Он вводит запрос

@lisp
(outranked-by (Bitdiddle Ben) ?who)
@end lisp

@direntry
@lisp
(подчиняется (Битобор Бен) ?who)
@end lisp
@end direntry

После ответа система проваливается в бесконечный цикл. Объясните,
почему.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.65}Упражнение 4.65:}
П.Э. Фект, ожидая собственного продвижения по иерархии,
дает запрос, который находит всех @code{wheel} (используя правило из @ref{4.4.1}):

@lisp
(wheel ?who)
@end lisp

@direntry
@lisp
(шишка ?who)
@end lisp
@end direntry

К его удивлению, система отвечает

@lisp
@i{;;; Результаты запроса:}
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
@end lisp

@direntry
@lisp
@i{;;; Результаты запроса:}
(шишка (Уорбак Оливер))<F9>
(шишка (Битобор Бен))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
@end lisp
@end direntry

Почему система упоминает Оливера Уорбака четыре раза?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.66}Упражнение 4.66:}
Бен работал над обобщением системы запросов так, чтобы
можно было собирать статистику о компании. Например, чтобы найти сумму
зарплат всех программистов, можно было бы сказать

@lisp
(sum ?amount (and (job ?x (computer programmer))
                  (salary ?x ?amount)))
@end lisp

@direntry
@lisp
(sum ?amount
     (and (должность ?x (компьютеры программист))
          (зарплата ?x ?amount)))
@end lisp
@end direntry

В общем случае новая система Бена допускает запросы вида

@lisp
(accumulation-function @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{запрос-образец}@math{\rangle})
@end lisp

@noindent
где в виде @code{accumulation-function} могут выступать @code{sum}
(сумма), @code{average} (среднее) или @code{maximum} (максимум). Бен
думает, что реализовать это расширение будет проще простого. Он просто
скормит образец-запрос функции @code{qeval} и получит поток кадров.
Затем он пропустит поток через функцию-отображение, которая из каждого
кадра извлечет значение указанной переменной, и получившийся поток
значений отдаст функции-накопителю. Когда Бен заканчивает свою
реализацию и собирается ее опробовать, мимо проходит Пабло, все еще
смущенный результатом запроса из упражнения @ref{Упражнение 4.65}.
Когда Пабло показывает Бену полученный им от системы ответ, Бен
хватается за голову: <<Моя простая схема накопления не будет работать!>>

Что понял Бен? Опишите, как он мог бы исправить ситуацию.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.67}Упражнение 4.67:}
Придумайте, как в запросную систему можно вставить
детектор циклов, который избегает простых зацикливаний, вроде показанных
в тексте и в упражнении @ref{Упражнение 4.64}. Общая идея состоит в
том, что система должна хранить в каком-то виде историю текущей цепи
рассуждений и не начинать обработку запроса, если она уже над ним
работает. Опишите, информация какого вида (образцы и кадры) включается в
историю и как можно проводить проверку. (После того, как Вы изучите в
деталях реализацию запросной системы из @ref{4.4.4}, Вы можете захотеть
изменить систему и включить в нее свой детектор циклов.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.68}Упражнение 4.68:}
Определите правила, с помощью которых реализуется операция
из упражнения @ref{Упражнение 2.18}, возвращающая список, элементы
которого те же, что и в исходном, но идут в обратном порядке.
(Подсказка: используйте @code{append-to-form}.) Могут ли Ваши правила
ответить и на запрос @code{(reverse (1 2 3) ?x)}, и на
@code{(reverse ?x (1 2 3))}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.69}Упражнение 4.69:}
Начав с базы данных и правил, сформулированных Вами в
упражнении @ref{Упражнение 4.63}, постройте правила для добавления
приставок <<пра>> в отношение @code{внук}. Система должна уметь понять,
что Ирад --- правнук Адама, а Иавал и Иувал приходятся Адаму
прапрапрапраправнуками. (Подсказка: представляйте, например, утверждение
об Ираде как @code{((great grandson) Adam Irad)}. Напишите правила, которые
определяют, заканчивается ли список словом @code{grandson}. С помощью этого
определите правило, которое позволяет вывести отношение
@code{((great . ?rel) ?x ?y)}, где список @code{?rel} оканчивается на
@code{grandson}.) Проверьте свои правила на запросах
@code{((great grandson) ?g ?ggs)} и @code{(?relationship Adam Irad)}.
@end quotation

@comment @subsection Implementing the Query System
@subsection Реализация запросной системы
@node	4.4.4,  , 4.4.3, 4.4

В @ref{4.4.2} описывалось, как работает запросная система. Теперь мы
представляем полную реализацию системы во всех деталях.

@menu
* 4-4-4-1::          Управляющий цикл и конкретизация
* 4-4-4-1::          Вычислитель
* 4-4-4-1::          Поиск утверждений с помощью сопоставления с образцом
* 4-4-4-1::          Правила и унификация
* 4-4-4-1::          Ведение базы данных
* 4-4-4-1::          Операции над потоками
* 4-4-4-1::          Процедуры определяющие синтаксис запросов
* 4-4-4-1::          Кадры и связывания
@end menu

@comment @subsubsection The Driver Loop and Instantiation
@subsubsection Управляющий цикл и конкретизация
@node 4.4.4.1, 4.4.4.2, 4.4.4, 4.4.4

Управляющий цикл запросной системы читает входные выражения. Если
выражение является правилом или утверждением, которое требуется добавить
в базу данных, то происходит добавление. В противном случае
предполагается, что выражение является запросом. Управляющий цикл
передает запрос вычислителю @code{qeval} вместе с начальным потоком,
состоящим из одного пустого кадра. Результатом вычисления является поток
кадров, порожденных заполнением переменных запроса значениями,
найденными в базе данных. С помощью этих кадров порождается новый поток,
состоящий из копий исходного запроса, в которых переменные
конкретизированы значениями из потока кадров. Этот последний поток
печатается на терминале:

@lisp
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
@end lisp

@noindent
Здесь, как и в других интерпретаторах из этой главы, мы пользуемся
абстрактным синтаксисом языка запросов. Реализация синтаксиса выражений,
включая предикат @code{assertion-to-be-added?} и селектор
@code{add-assertion-body}, дается в
@ref{4.4.4.7}. Процедура
@code{add-rule-or-assertion!} определяется в
@ref{4.4.4.5}.

Прежде чем обрабатывать входное выражение, управляющий цикл преобразует
его синтаксис в форму, которая делает обработку эффективнее. При этом
меняется представление переменных образца. Когда запрос
конкретизируется, то все переменные, которые остались несвязанными,
преобразуются, прежде чем печататься, обратно во входное представление.
Эти преобразования производятся процедурами @code{query-syntax-process}
и @code{contract-question-mark}
(@ref{4.4.4.7}).

Чтобы конкретизировать выражение, мы его копируем, заменяя при этом все
переменные выражения их значениями из данного кадра. Значения сами по
себе конкретизируются, поскольку и они могут содержать переменные
(например, если @code{?x} внутри @code{exp} связано в результате
унификации со значением @code{?y}, а уже @code{?y} связано со значением
5). Действие, которое требуется предпринять, если переменную не удается
конкретизировать, задается процедурным аргументом @code{instantiate}.

@lisp
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
@end lisp

@noindent
Процедуры, управляющие связываниями, определяются в
@ref{4.4.4.8}.

@comment @subsubsection The Evaluator
@subsubsection Вычислитель
@node 4.4.4.2, 4.4.4.3, 4.4.4.1, 4.4.4

Процедура @code{qeval}, вызываемая из @code{query-driver-loop}, является
основным вычислителем запросной системы. Она принимает на входе запрос и
поток кадров и возвращает поток расширенных кадров. Особые формы она
распознает через диспетчеризацию, управляемую данными, при помощи
@code{get} и @code{put}, в точности так же, как мы реализовывали
обобщенные операции в @ref{Глава 2}.
Все запросы, которые не распознаются как особая форма, считаются
простыми запросами и обрабатываются процедурой @code{simple-query}.

@lisp
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
@end lisp

@noindent
Селекторы @code{type} и @code{contents}, определяемые в
@ref{4.4.4.7}, реализуют абстрактный синтаксис особых форм.

@comment @subsubheading Simple queries
@subsubheading Простые запросы

Процедура @code{simple-query} обрабатывает простые запросы. В качестве
аргументов она принимает простой запрос (образец) и поток кадров, а
возвращает поток, порожденный путем расширения каждого кадра всеми
результатами успешного сопоставления записей базы данных с запросом.

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
@end lisp

@noindent
Для каждого кадра из входного потока мы с помощью @code{find-assertions}
(@ref{4.4.4.3})
сопоставляем образец со всеми утверждениями из базы данных, получая при
этом поток расширенных кадров. Кроме того, с помощью @code{apply-rules}
(@ref{4.4.4.4}) мы применяем все
подходящие правила и получаем при этом еще один поток расширенных
кадров. Два этих потока сливаются (при помощи
@code{stream-append-delayed} из @ref{4.4.4.6}) и дают на выходе поток,
перечисляющий все способы, которыми исходный запрос можно удовлетворить
в соответствии с исходным кадром
(см. упражнение @ref{Упражнение 4.71}). Потоки от отдельных входных
кадров соединяются через @code{stream-flatmap} (@ref{4.4.4.6}) в один большой поток,
содержащий все способы, которыми можно расширить кадры из входного
потока и получить сопоставление с исходным запросом.

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Запросы с операцией @code{and} обрабатываются так, как показано на
рис. @ref{Рисунок 4.5}, процедурой @code{conjoin}. @code{conjoin}
принимает в качестве аргументов конъюнкты и поток кадров, а возвращает
поток расширенных кадров. Сначала она обрабатывает поток кадров и
получает поток всех их возможных расширений, удовлетворяющих первому
запросу конъюнкции. Затем, используя этот новый поток кадров, она
рекурсивно применяет @code{conjoin} к остальным конъюнктам.

@lisp
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts) frame-stream))))
@end lisp

@noindent
Выражение

@lisp
(put 'and 'qeval conjoin)
@end lisp

настраивает процедуру @code{ qeval} так, чтобы она при обнаружении формы
@code{and} вызывала @code{conjoin}.

Запросы @code{or} обрабатываются подобным же образом, как показано на
рис. @ref{Рисунок 4.6}. Выходные потоки отдельных дизъюнктов @code{or}
вычисляются раздельно и смешиваются при помощи процедуры
@code{interleave-delayed} из @ref{4.4.4.6}.
(См. упражнения @ref{Упражнение 4.71}.)

@lisp
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
(put 'or 'qeval disjoin)
@end lisp

Предикаты и селекторы для синтаксиса конъюнктов и дизъюнктов даны в
@ref{4.4.4.7}.

@comment @subsubheading Filters
@subsubheading Фильтры

Запросы @code{not} обрабатываются так, как описано в @ref{4.4.2}. Мы
пытаемся расширить каждый кадр входного потока так, чтобы удовлетворялся
отрицаемый запрос, и включаем данный кадр в поток-результат только в том
случае, если расширить его нельзя.

@lisp
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null?
          (qeval (negated-query operands)
                 (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
@end lisp

@noindent
@code{lisp-value} --- фильтр, подобный @code{not}. Образец расширяется
с помощью каждого кадра из входного потока, применяется указанный
предикат, и кадры, для которых он возвращает ложное значение,
исключаются из входного потока. Если остаются несвязанные переменные
запроса, возникает ошибка.

@lisp
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var: -- LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
@end lisp

@noindent
Процедура @code{execute}, которая применяет предикат к аргументам,
должна вызвать @code{eval} от предикатного выражения, чтобы получить
применяемую процедуру. Однако она не должна вычислять аргументы,
поскольку это сами аргументы и есть, а не выражения, вычисление которых
(на Лиспе) даст нам аргументы. Обратите внимание, что @code{execute}
реализована с помощью @code{eval} и @code{apply} из нижележащей
Lisp-системы.

@lisp
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
@end lisp

Особая форма @code{always-true} порождает запрос, который всегда
удовлетворяется. Она игнорирует свое подвыражение (обычно пустое) и
попросту пропускает через себя все кадры входного потока.
@code{Always-true} используется в селекторе @code{rule-body}
(@ref{4.4.4.7}) чтобы дать тела правилам, для которых тела не определены
(то есть правилам, заключения которых всегда удовлетворяются).

@lisp
(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
@end lisp

Селекторы, которые определяют синтаксис @code{not} и @code{lisp-value},
определены в @ref{4.4.4.7}.

@comment @subsubsection Finding Assertions@* by Pattern Matching
@subsubsection Поиск утверждений с помощью сопоставления с образцом
@node 4.4.4.3, 4.4.4.4, 4.4.4.2, 4.4.4

Процедура @code{find-assertions}, вызываемая из @code{simple-query}
(@ref{4.4.4.2}), принимает на входе образец и
кадр. Она возвращает поток кадров, каждый из которых расширяет исходный
кадр сопоставлением данного образца с записью базы данных. Она
пользуется @code{fetch-assertions} (@ref{4.4.4.5}), чтобы найти поток
всех утверждений базы, которые следует проверять на сопоставление с
данными образцом и кадром. Мы используем @code{fetch-assertions} потому,
что часто можно с помощью простых тестов исключить множество записей в
базе данных из числа кандидатов на успешное сопоставление. Система
продолжала бы работать, если бы мы исключили @code{fetch-assertions} и
попросту проверяли поток всех утверждений базы, но при этом вычисление
было бы менее эффективным, поскольку пришлось бы делать намного больше
вызовов сопоставителя.

@lisp
(define (find-assertions pattern frame)
  (stream-flatmap
    (lambda (datum) (check-an-assertion datum pattern frame))
    (fetch-assertions pattern frame)))
@end lisp

Процедура @code{check-an-assertion} принимает в качестве аргументов
образец, объект данных (утверждение) и кадр, и возвращает либо
одноэлементный поток с расширенным кадром, либо, если сопоставление
неудачно, @code{the-empty-stream}.

@lisp
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
@end lisp

Сопоставитель как таковой возвращает либо символ @code{failed}, либо
расширение данного кадра. Основная идея сопоставителя состоит в том,
чтобы сравнивать образец с данными, элемент за элементом, и собирать при
этом связывания переменных образца. Если образец и объект данных
совпадают, то сопоставление оказывается успешным, и мы возвращаем поток
собранных связываний. В противном случае, если образец является
переменной, мы расширяем имеющийся кадр, связывая переменную с данными,
если это не противоречит уже имеющимся в кадре связываниям. Если и
образец, и данные являются парами, мы (рекурсивно) сопоставляем
@code{car} образца с @code{car} данных и получаем кадр; затем с этим
кадром мы сопоставляем @code{cdr} образца с @code{cdr} данных. Если ни
один из этих случаев не применим, сопоставление терпит неудачу, и мы
возвращаем символ @code{failed}.

@lisp
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match
           (cdr pat)
           (cdr dat)
           (pattern-match (car pat) (car dat) frame)))
        (else 'failed)))
@end lisp

Вот процедура, которая расширяет кадр, добавляя к нему новое связывание,
если это не противоречит уже имеющимся в кадре связываниям:

@lisp
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
@end lisp

Если для переменной в кадре нет связывания, мы просто добавляем к нему
новое связывание этой переменной с элементом данных. В противном случае
мы вызываем сопоставитель в данном кадре от элемента данных и имеющегося
значения переменной в кадре. Если хранимое значение содержит только
константы, (а это всегда так будет, если оно само было создано
процедурой @code{extend-if-consistent} во время сопоставления с
образцом), то это сопоставление просто проверит, совпадает ли хранимое
значение с новым. Если да, то кадр вернется неизменным; если нет,
вернется символ неудачи. Однако если хранимое в кадре значение было
создано при унификации (см. @ref{4.4.4.4}), то оно может
содержать переменные образца. Рекурсивное сопоставление хранимого
образца с новым элементом данных добавит или проверит связывания
переменных в этом образце. Предположим, к примеру, что у нас есть кадр,
в котором переменная @code{?x} связана с выражением @code{(f ?y)}, а
@code{?y} несвязана, и что теперь мы хотим расширить этот кадр, связав
@code{?x} со значением @code{(f b)}. Мы ищем в кадре @code{?x} и видим,
что она связана с @code{(f ?y)}. Теперь нам нужно сопоставить
@code{(f ?y)} с предлагаемым новым значением @code{(f b)} в том же самом
кадре. В конце концов это сопоставление расширяет кадр, добавив
связывание @code{?y} с @code{b}. @code{?X} по-прежнему связано с
@code{(f ?y)}. Мы никогда не изменяем хранимое связывание и никогда не
храним более одного связывания для одной и той же переменной.

Процедуры, при помощи которых @code{extend-if-consistent} работает со
связываниями, определены в @ref{4.4.4.8}.

@comment @subsubheading Patterns with dotted tails
@subsubheading Образцы с точечными хвостами

Если в образце содержится точка, за которой следует переменная образца,
то переменная сопоставляется с остатком списка (а не со следующим его
элементом), как и следовало ожидать от точечной записи, описанной в
упражнении @ref{Упражнение 2.20}. Несмотря на то, что реализованный
нами сопоставитель на занимается специально поиском точек, работает он в
этом случае так, как ему следует. Это происходит потому, что лисповский
примитив @code{read}, с помощью которого @code{query-driver-loop}
считывает запрос и представляет его в виде списковой структуры,
обрабатывает точки особым образом.

Когда @code{read} встречает точку, вместо того, чтобы сделать следующее
выражение очередным элементом списка (@code{car} в ячейке @code{cons},
@code{cdr} которой будет остатком списка), он делает его @code{cdr}ом
списковой структуры. Например, списковая структура, которую @code{read}
порождает при чтении образца @code{(computer ?type)} могла бы быть
построена с помощью выражения
@code{(cons 'computer (cons '?type '()))}, а та, которая получается
при чтении @code{(computer . ?type)}, могла бы получиться при
вычислении @code{(cons 'computer '?type)}.

Таким образом, когда @code{pattern-match} рекурсивно сравнивает
@code{car}-ы и @code{cdr}-ы списка данных и образца, содержащего точку, он
в конце концов сопоставляет переменную после точки (она служит
@code{cdr} образца) с подсписком списка данных, и связывает переменную с
этим списком. Например, сопоставление образца
@code{(computer . ?type)} со списком
@code{(computer programmer trainee)} сопоставит переменную
@code{?type} с подсписком @code{(programmer trainee)}.

@comment @subsubsection Rules and Unification
@subsubsection Правила и унификация
@node 4.4.4.4, 4.4.4.5, 4.4.4.3, 4.4.4

Процедура @code{apply-rules} --- это аналог @code{find-assertion} (@ref{4.4.4.3}).
Она принимает на входе образец и кадр, а порождает поток расширенных кадров,
применяя правила из базы данных. @code{Stream-flatmap} отображает через
@code{apply-rule} поток возможно применимых правил (отобранных процедурой
@code{fetch-rules} из @ref{4.4.4.5}) и склеивает получившиеся потоки кадров.

@lisp
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
@end lisp

Процедура @code{apply-a-rule} применяет правила способом, описанным в
@ref{4.4.2}. Сначала она дополняет
кадр-аргумент, унифицируя в его рамках заключение правила с образцом.
Если это удается, она выполняет в получившемся кадре тело правила.

Однако прежде всего программа переименовывает все переменные в правиле и
дает им уникальные новые имена. Это делается потому, что мы не хотим,
чтобы переменные из различных применений правил смешивались друг с
другом. К примеру, если в двух правилах используется переменная
@code{?x}, то каждое из них может добавить связывание этой переменной к
кадру, в котором оно применяется. Однако эти два @code{?x} не имеют друг
к другу никакого отношения, и мы не должны обманываться и считать, что
два связывания этих переменных обязаны соответствовать друг другу.
Вместо переименования переменных мы могли бы придумать более хитрую
структуру окружений; однако выбранный здесь подход с
переименованиями --- самый простой, хотя и не самый эффективный.
(См. упражнение @ref{Упражнение 4.79}.) Вот процедура
@code{apply-a-rule}:

@lisp
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
@end lisp

Селекторы @code{rule-body} и @code{conclusion}, извлекающие части
правил, описаны в @ref{4.4.4.7}.

Чтобы породить уникальные имена переменных, мы связываем с каждым
применением правила уникальный идентификатор (например, число) и цепляем
его к исходным именам переменных. Например, если идентификатор
применения правила равен 7, мы можем заменить все @code{?x} в правиле на
@code{?x-7}, а все @code{?y} на @code{?y-7}. (Процедуры
@code{make-new-variable} и @code{new-rule-application-id} содержатся
среди синтаксических процедур в @ref{4.4.4.7}.)

@lisp
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
@end lisp

Алгоритм унификации реализуется в виде процедуры, которая принимает на
входе два образца и кадр, а возвращает либо расширенный кадр, либо
символ @code{failed}. Унификатор в основном подобен сопоставителю, но
только он симметричен --- переменные разрешаются с обеих сторон
сопоставления. Процедура @code{unify-match} подобна
@code{pattern-match}, за исключением нового отрезка кода (отмеченного
знаком <<@code{***}>>), где обрабатывается случай, когда объект на правой
стороне сопоставления является переменной.

@lisp
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame)) @r{; ***}
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
@end lisp

При унификации, как и при одностороннем сопоставлении с образцом, нам
нужно принимать предлагаемое расширение кадра только в том случае, когда
оно не противоречит имеющимся связываниям. Процедура
@code{extend-if-possible}, используемая при унификации, подобна
@code{extend-if-consistent} из сопоставителя, за исключением двух
проверок, отмеченных в программе значком <<@code{***}>>. В первом случае,
если переменная, которую мы пытаемся сопоставить, не найдена, но
значение, с которым мы ее сопоставляем, само является (другой)
переменной, требуется проверить, нет ли у этой второй переменной
значения, и если да, сопоставить его. Если же обе стороны сопоставления
несвязаны, мы любую из них можем связать с другой.

Вторая проверка связана с попытками связать переменную с образцом,
который ее саму содержит. Такая ситуация может возникнуть, когда в обоих
образцах повторяются переменные. Рассмотрим, например, унификацию
образцов @code{(?x ?x)} и
@code{(?y @math{\langle}@var{выражение, содержащее @code{?y}}@math{\rangle})}
в кадре, где не связаны ни @code{?x}, ни @code{?y}. Сначала @code{?x}
сопоставляется с @code{?y}, и возникает связывание переменной @code{?x} с
@code{?y}. Затем та же переменная @code{?x} сопоставляется с данным выражением,
которое включает @code{?y}. Поскольку @code{?x} уже связана со значением
@code{?y}, это приводит к тому, что с выражением сопоставляется
@code{?y}. Если мы считаем, что унификатор занят поиском набора значений
для переменных, которые делают образцы одинаковыми, то значит, эти
образцы содержат инструкции найти такое значение @code{?y}, чтобы
@code{?y} был равен выражению, содержащему @code{?y}. Общего метода для
решения таких задач не существует, так что мы такие связывания
отвергаем; эти случаи распознаются предикатом
@code{ depends-on?}.@footnote{В общем случае унификация @code{?y} с
выражением, содержащим @code{?y}, требует нахождения неподвижной точки
уравнения @code{?y} = @math{\langle}@var{выражение, содержащее ?y}@math{\rangle}. Иногда
возможно синтаксическим образом создать выражение, которое кажется
решением уравнения. Например, кажется, что @code{?y = (f y)} имеет
неподвижную точку @code{(f (f (f @dots{} )))}, которую мы можем получить,
начав с выражения @code{(f ?y)} и систематически подставляя
@code{(f ?y)} вместо @code{?y}. К сожалению, не у всякого такого
уравнения имеется осмысленная неподвижная точка. Вопросы, возникающие
здесь, подобны вопросам работы с бесконечными последовательностями в
математике. Например, мы знаем, что решение уравнения @math{y = 1 + y/2}
равно 2. Если мы начнем с выражения @math{1 + y/2} и будем подставлять
@ifinfo

@example
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ...
@end example

@end ifinfo
@tex
$$ 2 = y = 1 + {y \over 2} = 1 + {1\over2}\left(1 + {y \over 2}\right) =
	1 + {1\over2} + {y \over 4} = \dots , $$
@end tex
@noindent
что ведек к
@ifinfo

@example
2 = 1 + 1/2 + 1/4 + 1/8 + ...
@end example

@end ifinfo
@tex
$$ 2 = 1 + {1\over2} + {1\over4} + {1\over8} + \dots. $$
@end tex
@noindent
Однако если мы попытаемся проделать те же преобразования, использовав тот факт,
что решение уравнения @math{y = 1 + 2y} равно -1, то получим
@ifinfo

@example
-1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ...
@end example

@end ifinfo
@tex
$$ -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \dots, $$
@end tex
@noindent
что ведет к
@ifinfo

@example
-1 = 1 + 2 + 4 + 8 + ...
@end example

@end ifinfo
@tex
$$ -1 = 1 + 2 + 4 + 8 + \dots. $$
@end tex
@noindent

Несмотря на то, что формальные преобразования, ведущие к этим двум
уравнениям, одинаковы, первый результат является верным утверждением о
бесконечных последовательностях, а второй нет. Подобным образом и при
работе с унификациями работа с произвольными синтаксически правильными
выражениями может привести к ошибкам.} С другой стороны, нам не хочется
отвергать попытки связать переменную саму с собой. Рассмотрим, например,
унификацию @code{(?x ?x)} с @code{(?y ?y)}. Вторая попытка связать
@code{?x} с @code{?y} вызывает сопоставление @code{?y} (старое значение
@code{?x}) с @code{?y} (новым значением @code{?x}). Этот случай
обрабатывается веткой @code{equal?} внутри @code{unify-match}.

@lisp
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                     @r{; ***}
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)    @r{; ***}
           'failed)
          (else (extend var val frame)))))
@end lisp

Процедура @code{depends-on?} --- это предикат. Он проверяет, зависит ли
выражение, которое предлагается сделать значением переменной образца, от
этой переменной. Это нужно делать по отношению к текущему кадру,
поскольку выражение может содержать вхождения переменной, уже обладающей
значением, которое, в свою очередь, зависит от нашей переменной. По
структуре @code{depends-on?} представляет собой простой рекурсивный
обход дерева, во время которого мы по необходимости подставляем значения
переменных.

@lisp
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
@end lisp

@comment @subsubsection Maintaining the Data Base
@subsubsection Ведение базы данных
@node 4.4.4.5, 4.4.4.6, 4.4.4.4, 4.4.4

Одна из важных задач при разработке логических языков
программирования --- так организовать работу, чтобы при проверке
каждого образца просматривалось как можно меньше ненужных записей из
базы. В нашей системе, помимо того, что мы храним все утверждения в
одном большом потоке, мы в отдельных потоках храним утверждения,
@code{car}ы которых являются константными символами, в таблице,
индексируемой по этим символам. Чтобы получить утверждения, которые
могут сопоставляться с образцом, мы сначала смотрим, не является ли
@code{car} образца константным символом. Если это так, то мы возвращаем
(сопоставителю для проверки) все хранимые утверждения с тем же
@code{car}. Если @code{car} образца не является константным символом, мы
возвращаем все хранимые утверждения. Более изысканные методы могли бы
использовать еще информацию из кадра, либо пытаться оптимизировать и тот
случай, когда @code{car} образца не является константным символом. Мы
избегаем встраивания критериев для индексации (использование @code{car},
обработка только случая с константными символами) в программу: вместо
этого мы вызываем предикаты и селекторы, реализующие эти критерии.

@lisp
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
@end lisp

Процедура @code{get-stream} ищет поток в таблице и, если ничего там не
находит, возвращает пустой поток.

@lisp
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
@end lisp

Правила хранятся подобным же образом, с использованием @code{car}
заключения правила. Однако в заключениях правил могут стоять
произвольные образцы, и таким образом, они отличаются от утверждений
тем, что могут содержать переменные. Образец, в @code{car} которого
стоит константный символ, может сопоставляться не только с правилами, у
которых @code{car} заключения содержит тот же символ, но и с правилами,
где в начале заключения стоит переменная. Таким образом, при поиске
правил, которые могут сопоставляться с образцом, у которого в начале
константный символ, мы возвращаем как правила с этим символом в
@code{car} заключения, так и правила с переменной в начале заключения.
Ради этого мы храним правила с переменными в начале заключения в
отдельном потоке, который находится в таблице под индексом @code{?}.

@lisp
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
@end lisp

Процедура @code{add-rule-or-assertion!} вызывается из @code{query-driver-loop},
когда требуется добавить к базе данных правило или утверждение. Каждая запись
сохраняется в индексе, если это требуется, а также в общем потоке правил либо
утверждений базы данных.

@lisp
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
@end lisp

@noindent
Чтобы вставить в базу утверждение или правило, мы проверяем, можно ли
его проиндексировать. Если да, то мы сохраняем его в соответствующем
потоке.

@lisp
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream
                assertion
                current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
@end lisp

Следующие процедуры определяют, как используется индекс базы данных.
Образец (утверждение или заключение правила) сохраняется в таблице, если
он начинается с переменной или константного символа.

@lisp
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
@end lisp

Ключ, под которым образец сохраняется в таблице --- это либо @code{?}
(если он начинается с переменной), либо константный символ из его
начала.

@lisp
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
@end lisp

Для поиска записей, которые могут соответствовать образцу, используется
индекс в том случае, когда образец начинается с константного символа.

@lisp
(define (use-index? pat) (constant-symbol? (car pat)))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.70}Упражнение 4.70:}
Какова цель выражений @code{let} в процедурах
@code{add-assertion!} и @code{add-rule!}? Что неправильно в следующем
варианте @code{add-assertion!}? Подсказка: вспомните определение
бесконечного потока единиц из
@ref{3.5.2}: @code{(define ones (cons-stream 1 ones))}.

@lisp
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
@end lisp
@end quotation

@comment @subsubsection Stream Operations
@subsubsection Операции над потоками
@node 4.4.4.6, 4.4.4.7, 4.4.4.5, 4.4.4

В запросной системе используется несколько операций над потоками, помимо
представленных в @ref{Глава 3}.

Процедуры @code{stream-append-delayed} и @code{interleave-delayed}
подобны @code{stream-append} и @code{interleave} (@ref{3.5.3}),
но только они принимают задержанный аргумент (как процедура @code{integral}
из @ref{3.5.4}).  В некоторых случаях это откладывает зацикливание
(см. упражнение @ref{Упражнение 4.71}).

@lisp
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed
        (stream-cdr s1)
        delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed
        (force delayed-s2)
        (delay (stream-cdr s1))))))
@end lisp

Процедура @code{stream-flatmap}, которая многократно используется в
интерпретаторе, чтобы применить процедуру ко всем элементам потока
кадров и соединить получающиеся потоки кадров, является потоковым
аналогом процедуры @code{flatmap} для обычных списков, введенной в @ref{2.2.3}.
Однако, в отличие от обычного @code{flatmap}, потоки мы собираем с
помощью чередующего процесса, а не просто сцепляем их
(см. упражнения @ref{Упражнение 4.72}).

@lisp
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
@end lisp

Кроме того, интерпретатор пользуется следующей простой процедурой для
порождения потока, который состоит из одного элемента:

@lisp
(define (singleton-stream x) 
  (cons-stream x the-empty-stream))
@end lisp

@comment @subsubsection Query Syntax Procedures
@subsubsection Процедуры, определяющие синтаксис запросов
@node 4.4.4.7, 4.4.4.8, 4.4.4.6, 4.4.4

Процедуры @code{type} и @code{contents}, используемые в @code{qeval}
(@ref{4.4.4.2}), указывают, что особая форма определяется символом в ее
@code{car}. Это те же процедуры, что @code{type-tag} и @code{contents} из
@ref{2.4.2}, с точностью до сообщения об ошибке.

@lisp
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))

(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
@end lisp

Следующие процедуры, вызываемые из @code{query-driver-loop} (@ref{4.4.4.1}),
указывают, что утверждения и правила добавляются в базу данных при помощи
выражений вида @code{(assert! @math{\langle}@var{правило-или-утверждение
(rule-or-assertion)}@math{\rangle})}:

@lisp
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp) (car (contents exp)))
@end lisp

Вот синтаксические определения для особых форм @code{and}, @code{or},
@code{not} и @code{lisp-value} (@ref{4.4.4.2}):

@lisp
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
@end lisp

@noindent
Следующие три процедуры определяют синтаксис правил:

@lisp
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule)) '(always-true) (caddr rule)))
@end lisp

@noindent
@code{query-driver-loop} (@ref{4.4.4.1}) вызывает
@code{query-syntax-process}, чтобы преобразовать переменные образца в
выражении, имеющие форму @code{?symbol}, к внутреннему формату
@code{(? symbol)}. Это означает, что образец вроде
@code{(должность ?x ?y)} на самом деле представляется внутри системы как
@code{(должность (? x) (? y))}. Это повышает эффективность обработки
запросов, потому что позволяет системе проверять, является ли выражение
переменной, путем проверки @code{car} (не является ли @code{car}
символом @code{?}), вместо того, чтобы извлекать из символа буквы.
Преобразование синтаксиса осуществляется следующей
процедурой:@footnote{Большинство Лисп-систем позволяет пользователю
изменять обыкновенную процедуру @code{read} и осуществлять такие
преобразования путем определения (reader macro characters). Закавыченные
выражения уже обрабатываются таким образом: процедура чтения
автоматически переводит @code{'expression} в @code{(quote expression)},
прежде чем выражение видит интерпретатор. Можно было бы устроить
преобразование @code{?expression} в @code{(? expression)} таким же
образом; однако ради большей ясности мы здесь представили процедуру
преобразования явно.

@code{expand-question-mark} и @code{contract-question-mark} используют
несколько процедур, имя которых содержит @code{string}. Это примитивы
языка Scheme.}

@lisp
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
@end lisp

@noindent
После того, как переменные таким образом преобразованы, переменные в
образцах --- это списки, начинающиеся с @code{?}, а константные символы
(которые требуется распознавать для индексирования базы данных,
@ref{4.4.4.5}) --- это просто символы.

@lisp
(define (var? exp) (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
@end lisp

@noindent
Во время применения правил при помощи следующих процедур порождаются
уникальные переменные (@ref{4.4.4.4}).
Уникальным идентификатором правила служит число, которое увеличивается
при каждом применении правила:

@lisp
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
@end lisp

Когда @code{query-driver-loop} конкретизирует запрос для печати ответа,
она преобразует все несвязанные переменные запроса обратно к печатной
форме при помощи

@lisp
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?" 
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
@end lisp

@comment @subsubsection Frames and Bindings
@subsubsection Кадры и связывания
@node 4.4.4.8,  , 4.4.4.7, 4.4.4

Кадры представляются как списки связываний, которые, в свою очередь,
являются парами вида <<переменная-значение>>:

@lisp
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding) (car binding))
(define (binding-value binding) (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.71}Упражнение 4.71:}
Хьюго Дум не понимает, почему процедуры (@ref{4.4.4.2})
@code{simple-query} и @code{disjoin} реализованы через явные операции
@code{delay}, а не следующим образом:

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append
        (find-assertions query-pattern frame)
        (apply-rules query-pattern frame)))
   frame-stream))

(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts)
                frame-stream)
       (disjoin (rest-disjuncts disjuncts)
                frame-stream))))
@end lisp

Можете ли Вы дать примеры запросов, с которыми эти простые определения
приведут к нежелательному поведению?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.72}Упражнение 4.72:}
Почему @code{adjoin} и @code{stream-flatmap} чередуют
потоки, а не просто их сцепляют? Приведите примеры, которые показывают,
что чередование работает лучше. (Подсказка: зачем мы пользовались
@code{interleave} в @ref{3.5.3}?)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.73}Упражнение 4.73:}
Почему @code{flatten-stream} использует @code{delay} явно?
Что было бы неправильно в таком определении:

@lisp
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.74}Упражнение 4.74:}
Лиза П. Хакер предлагает использовать в @code{negate},
@code{lisp-value} и @code{find-assertions} упрощенную версию . Она
замечает, что в этих случаях процедура, которая отображает поток кадров,
всегда порождает либо пустой поток, либо поток из одного элемента, и
поэтому при слиянии этих потоков незачем использовать чередование.

@enumerate a.

@item
Заполните пропущенные выражения в программе Лизы.

@lisp
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))
(define (simple-flatten stream)
  (stream-map @math{\langle}??@math{\rangle}
              (stream-filter @math{\langle}??@math{\rangle} stream)))
@end lisp

@item
Если мы изменяем систему таким образом, меняется ли ее поведение?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.75}Упражнение 4.75:}
Реализуйте в языке запросов новую особую форму . Выражение
@code{unique} должно быть успешно, если в базе данных ровно одна запись,
удовлетворяющая указанному запросу. Например запрос

@lisp
(unique (job ?x (computer wizard)))
@end lisp

@noindent
@direntry
@lisp
(unique (должность ?x (компьютеры гуру)))
@end lisp
@end direntry

@noindent
должен печатать одноэлементный поток

@lisp
(unique (job (Bitdiddle Ben) (computer wizard)))
@end lisp

@direntry
@lisp
(unique (должность (Битобор Бен) (компьютеры гуру)))
@end lisp
@end direntry

поскольку Бен --- единственный компьютерный гуру, а

@lisp
(unique (job ?x (computer programmer)))
@end lisp

@direntry
@lisp
(unique (должность ?x (компьютеры программист)))
@end lisp
@end direntry

должно печатать пустой поток, поскольку программистов больше одного.
Более того,

@lisp
(and (job ?x ?j) (unique (job ?anyone ?j)))
@end lisp

@direntry
@lisp
(and (должность ?x ?j) (unique (должность ?anyone ?j)))
@end lisp
@end direntry

должно перечислять все должности, на которых работает по одному
человеку, а также самих этих людей.

Реализация @code{unique} состоит из двух частей. Первая заключается в
том, чтобы написать процедуру, которая обрабатывает эту особую форму, а
вторая в том, чтобы заставить @code{qeval} распознавать форму и вызывать
ее процедуру. Вторая часть тривиальна, поскольку @code{qeval} написана в
стиле программирования, управляемого данными. Если Ваша процедура
называется @code{uniquely-asserted}, то нужно только написать

@lisp
(put 'unique 'qeval uniquely-asserted)
@end lisp

и @code{qeval} будет передавать управление этой процедуре для всех
запросов, у которых в @code{type} (@code{car}) стоит символ
@code{unique}.

Собственно задача состоит в том, чтобы написать процедуру
@code{uniquely-asserted}. В качестве входа она должна принимать
@code{contents} (@code{cdr}) запроса @code{unique} и поток кадров. Для
каждого кадра в потоке она должна с помощью @code{qeval} находить поток
всех расширений, удовлетворяющих данному запросу. Потоки, в которых
число элементов не равно одному, должны отбрасываться. Оставшиеся потоки
нужно собирать в один большой поток. Он и становится результатом запроса
@code{unique}. Эта процедура подобна реализации особой формы @code{not}.

Проверьте свою реализацию, сформировав запрос, который находит всех
служащих, которые начальствуют ровно над одним человеком.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.76}Упражнение 4.76:}
Наша реализация @code{and} в виде последовательной
комбинации запросов (рисунок @ref{Рисунок 4.5}) изящна, но
неэффективна, поскольку при обработке второго запроса приходится
просматривать базу данных для каждого кадра, порожденного первым
запросом. Если в базе данных @math{N} записей, а типичный запрос
порождает число записей, пропорциональное @math{N} (скажем, @math{N/k}),
то проход базы данных для каждого кадра, порожденного первым запросом,
потребует @math{N^2/k} вызовов сопоставителя. Другой подход может
состоять в том, чтобы обрабатывать два подвыражения запроса @code{and}
по отдельности а затем искать совместимые пары входных кадров. Если
каждый запрос порождает @math{N/k} кадров, то нам придется проделать
@math{N^2/k^2} проверок на совместимость --- в @math{k} раз меньше, чем
число сопоставлений при нашем теперешнем методе.

Постройте реализацию @code{and} с использованием этой стратегии. Вам
придется написать процедуру, которая принимает на входе два кадра,
проверяет связывания в этих кадрах на совместимость и, если они
совместимы, порождает кадр, в котором множества связываний слиты. Эта
операция подобна унификации.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.77}Упражнение 4.77:}
В @ref{4.4.3} мы видели,
что выражения @code{not} и @code{lisp-value} могут заставить язык
запросов выдавать <<неправильные>> значения, если эти фильтрующие
операции применяются к кадрам с несвязанными переменными. Придумайте
способ избавиться от этого недостатка. Одна из возможностей состоит в
том, чтобы проводить <<задержанную>> фильтрацию, цепляя к кадру
<<обещание>> провести ее, которое выполняется только тогда, когда
связано достаточно переменных, чтобы операция стала возможна. Можно
ждать и проводить фильтрацию только тогда, когда выполнены все остальные
операции. Однако из соображений эффективности хотелось бы фильтровать
как можно раньше, чтобы уменьшить число порождаемых промежуточных
кадров.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.78}Упражнение 4.78:}
Перестройте язык запросов в виде недетерминистской
программы, реализуемой интерпретатором из @ref{4.3}, а
не в виде процесса обработки потоков. При таком подходе каждый запрос
будет порождать один ответ (а не поток всех возможных ответов), а
пользователь может ввести @code{try-again} и получить следующий ответ.
Вы увидите, что существенная часть механизмов, которые мы построили в
этом разделе, заменяется недетерминистским поиском и перебором с
возвратами. Однако помимо этого, Вы обнаружите, что новый язык запросов
отличается в тонких деталях поведения от реализованного нами в этом
разделе. Можете ли Вы привести примеры, показывающие эти отличия?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.79}Упражнение 4.79:}
Когда мы реализовывали в @ref{4.1} интерпретатор, мы видели,
как можно избежать конфликтов между именами параметров процедур при
помощи локальных окружений. Например, при вычислении

@lisp
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
@end lisp

@noindent
не возникает смешения между @code{x} из @code{square} и @code{x} из
@code{sum-of-squares}, поскольку тело каждой процедуры мы вычисляем в
окружении, которое специально построено для связывания локальных
переменных. В запросной системе мы избегаем конфликтов имен при
применении правил с помощью другой стратегии. Каждый раз при применении
правила мы переименовываем переменные и даем им новые имена, которые
обязаны быть уникальными. Аналогичная стратегия в интерпретаторе Лиспа
заключалась бы в том, чтобы отменить внутренние окружения и просто
переименовывать переменные в теле процедуры каждый раз, как мы ее
вызываем.

Реализуйте для языка запросов метод применения правил, который
использует не переименования, а окружения. Рассмотрите, можно ли
использовать Вашу систему окружений для построения в языке запросов
конструкций для работы с большими системами, например аналога блочной
структуры процедур для правил. Можно ли связать это с проблемой ведения
рассуждений в контексте (например: <<Если бы я предположил, что истинно
@math{P}, то я смог бы доказать @math{A} и @math{B}>>) в качестве метода
решения задач? (Это упражнение не имеет однозначного решения. Хороший
ответ, скорее всего, мог бы служить темой диссертации.)
@end quotation

@comment @chapter Computing with Register Machines
@chapter Вычисления на регистровых машинах
@node    Chapter 5, References, Chapter 4, Top

@c @sp 0.2

@quotation
Моя цель --- показать, что небесная машина не некое божественное живое
существо, а скорее часовой механизм (а тот, кто верит, что у часов есть
душа, приписывает славу творца творению), поскольку почти все из ее
многочисленных движений вызываются простейшей материальной силой, так
же, как все движения часов вызываются весом гири.

Иоганн Кеплер
(письмо к Герварту фон Гогенбургу, 1605)
@end quotation

@c @sp 1.0

\lettrine[findent=1pt]{Э}{та книга начинается} с изучения процессов и с описания
процессов в терминах процедур, написанных на Лиспе. Чтобы объяснить значение этих
процедур, мы последовательно использовали несколько моделей вычисления:
подстановочную модель из главы @ref{Глава 1}, модель с окружениями из
главы @ref{Глава 3} и метациклический интерпретатор из главы @ref{Глава 4}.
Изучая последний, мы по большей части сняли покров тайны с деталей
интерпретации лиспоподобных языков. Однако даже метациклический
интерпретатор оставляет многие вопросы без ответа, поскольку он не
проясняет механизмы управления Лисп-системы. Например, интерпретатор не
показывает, как при вычислении подвыражения удается вернуть значение
выражению, это значение использующему, или почему одни рекурсивные
процедуры порождают итеративные процессы (то есть занимают неизменный
объем памяти), в то время как другие процедуры порождают рекурсивные
процессы. Эти вопросы остаются без ответа потому, что метациклический
интерпретатор сам по себе является программой на Лиспе, а
следовательно, наследует управляющую структуру нижележащей Лисп-системы.
Чтобы предоставить более полное описание управляющей структуры
вычислителя Лиспа, нам нужно работать на более элементарном уровне, чем
сам Лисп.

В этой главе мы будем описывать процессы в терминах пошаговых операций
традиционного компьютера. Такой компьютер, или (register machine),
последовательно выполняет (instructions), которые работают с
ограниченным числом элементов памяти, называемых (registers). Типичная
команда регистровой машины применяет элементарную операцию к содержимому
нескольких регистров и записывает результат еще в один регистр. Наши
описания процессов, выполняемых регистровыми машинами, будут очень
похожи на <<машинный язык>> обыкновенных компьютеров. Однако вместо
того, чтобы сосредоточиться на машинном языке какого-то конкретного
компьютера, мы рассмотрим несколько процедур на Лиспе и спроектируем
специальную регистровую машину для выполнения каждой из этих процедур.
Таким образом, мы будем решать задачу с точки зрения архитектора
аппаратуры, а не с точки зрения программиста на машинном языке
компьютера. При проектировании регистровых машин мы разработаем
механизмы для реализации важных программистских конструкций, таких, как
рекурсия. Кроме того, мы представим язык для описания регистровых машин.
В разделе @ref{5.2} мы реализуем
программу на Лиспе, которая с помощью этих описаний имитирует
проектируемые нами машины.

Большинство элементарных операций наших регистровых машин очень просты.
Например, такая операция может складывать числа, взятые из двух
регистров, и сохранять результат в третьем. Несложно описать
устройство, способное выполнять такие операции. Однако для работы со
списковыми структурами мы будем использовать также операции @code{car},
@code{cdr} и @code{cons}, а они требуют сложного механизма выделения
памяти. В разделе @ref{5.3}
мы изучаем их реализацию на основе более простых операций.

В разделе @ref{5.4}, накопив опыт
выражения простых процессов в виде регистровых машин, мы спроектируем
машину, которая реализует алгоритм, описываемый метациклическим
интерпретатором из раздела @ref{4.1}.
Таким образом, окажется заполненным пробел в нашем понимании того, как
интерпретируются выражения языка Scheme, поскольку будет представлена
явная модель механизмов управления вычислителя. В
разделе @ref{5.5} мы рассмотрим простой компилятор,
переводящий программы на Scheme в последовательности команд, которые
можно впрямую выполнить с помощью регистров и операций регистровой
машины-вычислителя.

@menu
* 5-1::              Проектирование регистровых машин
* 5-2::              Программа моделирования регистровых машин
* 5-3::              Выделение памяти и сборка мусора
* 5-4::              Вычислитель с явным управлением
* 5-5::              Компиляция
@end menu

@comment @section Designing Register Machines
@section Проектирование регистровых машин
@node	5.1, 5.2, Chapter 5, Chapter 5

Чтобы спроектировать регистровую машину, требуется описать ее (@newterm{data paths}),
то есть регистры и операции, а также @emph{контроллер}
(@newterm{controller}), который управляет последовательностью этих операций. Чтобы
продемонстрировать строение простой регистровой машины, рассмотрим
алгоритм Евклида для вычисления наибольшего общего делителя (@acronym{НОД}) двух
натуральных чисел. Как мы видели в разделе @ref{1.2.5},
алгоритм Евклида можно реализовать в виде итеративного процесса,
который описывается следующей процедурой:

@lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
@end lisp

@noindent
Машина, реализующая алгоритм, должна отслеживать два числовых значения,
@math{a} и @math{b}. Поэтому предположим, что эти числа хранятся в двух
регистрах с такими же именами. Основные требуемые операции --- это
проверка, не является ли содержимое регистра @code{b} нулем, и
вычисление остатка от деления содержимого регистра @code{a} на
содержимое регистра @code{b}. Операция вычисления остатка --- сложный
процесс, однако пока что предположим, что у нас есть элементарное
устройство, вычисляющее остатки. В каждом цикле алгоритма вычисления НОД
содержимое регистра @code{a} требуется заменить содержимым регистра
@code{b}, а содержимое регистра @code{b} следует заменить на остаток от
деления старого содержимого @code{a} на старое содержимое @code{b}. Было
бы удобно, если бы можно было производить эти замены одновременно,
однако для нашей модели регистровых машин мы предположим, что на каждом
шаге можно присвоить новое значение только одному регистру. Чтобы
произвести замены, наша машина использует третий <<временный>> регистр,
который мы назовем @code{t}. (Сначала мы помещаем остаток в @code{t},
затем помещаем содержимое @code{b} в @code{a}, и наконец переносим
остаток, хранимый в @code{t}, в @code{b}.)

Можно изобразить регистры и операции, требуемые нашей машине, при помощи
диаграммы путей данных, показанной на рисунке @ref{Рисунок 5.1}.
Регистры (@code{a}, @code{b} и @code{t}) на этой диаграмме
изображаются в виде прямоугольников. Каждый способ присвоить регистру
значение обозначается стрелкой, указывающей из источника данных на
регистр, со значком Х позади головки. Можно считать этот Х кнопкой,
которая при нажатии позволяет значению из источника <<перетечь>> в
указанный регистр. Метка рядом --- это имя для кнопки. Имена эти
произвольны, и их можно подбирать с мнемоническим значением (например,
@code{a<-b} обозначает нажатие кнопки, которая присваивает содержимое
регистра @code{b} регистру @code{a}). Источником данных для регистра
может служить другой регистр (как в случае присваивания @code{a<-b}),
результат операции (как в случае присваивания @code{t<-r}) или
константа (встроенное значение, которое нельзя изменять и которое
представляется на диаграмме путей данных в виде треугольника со
значением внутри).

@float
@quotation
@anchor{Рисунок 5.1}
@ifinfo
@strong{Рисунок 5.1:} Data paths for a @acronym{GCD} machine.

@example
                              ___
+-----+          +-----+     /   \
|  a  |<--(X)----|  b  +--->|  =  |
+--+--+   a<-b   +-+---+     \___/
   |               |  ^        ^
   +------+   +----+  |        |
          |   |      (X) b<-t  |
       .--+---+--.    |       / \
        \  rem  /     |      / O \
         \_____/      |     +-----+
            |         |
           (X) t<-r   |
            |         |
            V         |
         +-----+      |
         |  t  +------+
         +-----+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.1a,58mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 5.1:} Data paths for a @acronym{GCD} machine.}
@center @caption{@strong{Рисунок 5.1:} Пути данных~в машине НОД.}
@sp 0.8
@end iftex
@end quotation
@end float

Операция, которая вычисляет значение на основе констант и содержимого
регистров, представляется на диаграмме путей данных в виде трапеции,
содержащей имя операции. Например, фигура, обозначенная на
рисунке @ref{Рисунок 5.1} как @code{rem}, представляет операцию,
вычисляющую остаток от деления содержимых регистров @code{a} и @code{b},
к которым она подсоединена. Стрелки (без кнопок) указывают из входных
регистров и констант на фигуру, а другие стрелки связывают результат
операции с регистрами. Сравнение изображается в виде круга, содержащего
имя теста. К примеру, в нашей машине НОД имеется операция, которая
проверяет, не равно ли содержимое регистра @code{b} нулю. У теста тоже
есть входные стрелки, ведущие из входных регистров и констант, но у него
нет исходящих стрелок; его значение используется контроллером, а не
путями данных. В целом, диаграмма путей данных показывает регистры и
операции, которые нужны машине, и как они должны быть связаны. Если мы
рассматриваем стрелки как провода, а кнопки Х как переключатели, то
диаграмма путей данных оказывается очень похожа на схему машины, которую
можно было бы построить из электронных деталей.

@float
@quotation
@anchor{Рисунок 5.2}
@ifinfo
@strong{Рисунок 5.2:} Controller for a @acronym{GCD} machine.

@example
     start
       |
       V
      / \ yes
+--->< = >-----> done
|     \ /
|      | no
|      V
|  +------+
|  | t<-r |
|  +---+--+
|      |
|      V
|  +------+
|  | a<-b |
|  +---+--+
|      |
|      V
|  +------+
+--+ b<-t |
   +------+
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap5/Fig5.2,41mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 5.2:} Controller for a @acronym{GCD} machine.}
@center @caption{@strong{Рисунок 5.2:} Контроллер машины НОД.}
@sp 0.7
@end iftex
@end quotation
@end float

Для того, чтобы пути данных вычисляли НОД, нужно нажимать кнопки в
правильной последовательности. Мы будем описывать эту последовательность
с помощью диаграммы контроллера, показанной на
рисунке @ref{Рисунок 5.2}. Элементы диаграммы контроллера показывают,
как следует работать с компонентами путей данных. Прямоугольные блоки в
такой диаграмме указывают, на какие кнопки следует нажимать, а стрелки
описывают последовательный переход от одного шага к другому. Ромб на
диаграмме обозначает выбор. Произойдет переход по одной из двух
исходящих стрелок, в зависимости от значения того теста в потоке
данных, имя которого указано в ромбе. Можно интерпретировать контроллер
с помощью физической аналогии: представьте себе, что диаграмма --- это
лабиринт, в котором катается шарик. Когда шарик закатывается в
прямоугольник, он нажимает на кнопку, имя которой в прямоугольнике
написано. Когда шарик закатывается в узел выбора (например, тест
@code{b} = 0), он покидает этот узел по стрелке, которую
определяет результат указанного теста. Взятые вместе, пути данных и
контроллер полностью определяют машину для вычисления НОД. Мы запускаем
контроллер (катящийся шарик) в месте, обозначенном @code{start},
поместив предварительно числа в регистры @code{a} и @code{b}. Когда
контроллер достигает точки, помеченной @code{done}, в регистре @code{a}
оказывается значение НОД.

@quotation
@strong{@anchor{Упражнение 5.1}Упражнение 5.1:} Спроектируйте
регистровую машину для вычисления факториалов с
помощью итеративного алгоритма, задаваемого следующей процедурой.
Нарисуйте для этой машины диаграммы путей данных и контроллера.

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp
@end quotation

@menu
* 5-1-1::            Язык для описания регистровых машин
* 5-1-2::            Абстракция в проектировании машин
* 5-1-3::            Подпрограммы
* 5-1-4::            Реализация рекурсии с помощью стека
* 5-1-5::            Обзор системы команд
@end menu

@comment @subsection A Language for Describing Register Machines
@subsection Язык для описания регистровых машин
@node	5.1.1, 5.1.2, 5.1, 5.1

Диаграммы путей данных и контроллера адекватно представляют простые
машины вроде машины НОД, но для описания сложных машин вроде
интерпретатора Лиспа они непригодны. Чтобы можно было работать со
сложными машинами, мы создадим язык, который представляет в текстовом
виде всю информацию, содержащуюся в диаграммах путей данных и
контроллера. Начнем с нотации, которая впрямую отражает диаграммы.

Мы определяем пути данных (@code{data-paths}) машины, описывая регистры
(@code{registers}) и операции (@code{operations}). Чтобы описать
регистр, мы даем ему имя (@code{name}) и указываем кнопки
(@code{buttons}), которые присваивают ему значение. Каждой из этих
кнопок мы даем имя (@code{name}) и указываем источник (@code{source})
для данных, которые попадают в регистр, управляемый кнопкой. Источником
может служить регистр (@code{register}), константа (@code{constant}) или
операция (@code{operation}). Для описания операции нам нужно дать ей имя
и указать входы (@code{inputs}) --- регистры или константы.

Контроллер машины мы определяем как последовательность @emph{команд}
(instructions) с @emph{метками} (labels), которые определяют @emph{точки
входа} (entry points). Есть следующие виды команд:

@itemize @bullet

@item
Имя кнопки на пути данных, которую следует нажать и присвоить регистру
значение. (Это соответствует прямоугольнику на диаграмме контроллера.)

@item
Команда @code{test}, которая выполняет указанный тест.

@item
Условный переход (команда @code{branch}) в место, определяемое меткой
контроллера, на основании предыдущего теста. (@code{Test} и
@code{branch} вместе соответствуют ромбу на диаграмме контроллера.) Если
тест дает результат <<ложь>>, контроллер должен выполнять следующую
команду в последовательности. В противном случае он должен выполнять
команду, которая следует за меткой.

@item
Безусловный переход (команда ), указывающий метку, с которой следует
продолжить выполнение.

@end itemize

@noindent
Машина начинает работу с начала последовательности команд контроллера и
заканчивает, когда выполнение достигает конца последовательности. Кроме
тех случаев, когда переход изменяет поток управления, команды
выполняются по порядку, так, как они перечислены.

@quotation
@strong{@anchor{Рисунок 5.3}Figure 5.3:} @math{\downarrow} A specification of the @acronym{GCD}
machine.

@direntry
@lisp
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem) (inputs (register a) (register b)))
  ((name =) (inputs (register b) (constant 0)))))
(controller
 test-b                           @r{; label}
   (test =)                       @r{; test}
   (branch (label gcd-done))      @r{; conditional branch}
   (t<-r)                         @r{; button push}
   (a<-b)                         @r{; button push}
   (b<-t)                         @r{; button push}
   (goto (label test-b))          @r{; unconditional branch}
 gcd-done)                        @r{; label}
@end lisp
@end direntry

@lisp
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0))))
 (controller
  test-b                        @r{; метка}
    (test =)                    @r{; тест}
    (branch (label gcd-done))   @r{; условный переход}
    (t<-r)                      @r{; нажатие кнопки}
    (a<-b)                      @r{; нажатие кнопки}
    (b<-t)                      @r{; нажатие кнопки}
    (goto (label test-b))       @r{; безусловный переход}
  gcd-done))                    @r{; метка}
@end lisp

@end quotation
На рисунке @ref{Рисунок 5.3} изображена описанная на нашем языке
машина НОД. Этот пример служит не более чем намеком на степень общности
таких описаний, поскольку машина НОД --- очень простой случай: у
каждого регистра всего по одной кнопке, и каждая кнопка используется в
контроллере только один раз.

К сожалению, такое описание неудобно читать. Чтобы понимать команды
контроллера, нам все время приходится смотреть на определения имен
кнопок и операций, а чтобы понять, что делают операции, приходится
обращаться к определениям имен операций. Поэтому мы изменим свой способ
записи и сольем информацию из описания контроллера и описания путей
данных, так, чтобы видеть их одновременно.

В этой новой форме записи мы заменим произвольные имена кнопок и
операций на описание их поведения. То есть, вместо того, чтобы говорить
(в контроллере) <<нажать кнопку @code{t<-r}>> и отдельно (в путях
данных) <<кнопка @code{t<-r} присваивает регистру @code{t} значение
операции @code{rem}>>, а также <<входы операции @code{rem} --- это
содержимое регистров @code{a} и @code{b}>>, мы будем говорить (в
контроллере) <<нажать кнопку, которая присваивает регистру @code{t}
результат операции @code{rem} от содержимого регистров @code{a} и
@code{b}>>. Подобным образом, вместо <<выполнить тест @code{=}>> (в
контроллере) и отдельно (в путях данных) <<тест @code{=} применяется к
содержимому регистра @code{b} и константе 0>>, будем говорить
<<выполнить тест @code{=} над содержимым регистра @code{b} и константой
0>>. Описание путей данных мы будем опускать, оставляя только
последовательность команд контроллера. Таким образом, машину НОД можно
описать так:

@lisp
(controller 
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
@end lisp

@noindent
Запись в такой форме проще читать, чем описания на разновидности языка,
показанной на рисунке @ref{Рисунок 5.3}, но есть у нее и недостатки:

@itemize @bullet

@item
Для больших машин такие описания длиннее, поскольку полные определения
элементов путей данных повторяются каждый раз, как эти элементы
упоминаются в последовательности команд контроллера. (В примере с НОД
этой проблемы не возникает, поскольку каждая операция и каждая кнопка
используются только по разу.) Более того, повторение описаний путей
данных скрывает структуру этих путей в машине; для больших машин
становится сложно определить, сколько в них регистров, операций и
кнопок, и как они связаны.

@item
Поскольку команды контроллера в определении машины похожи на выражения
Лиспа, легко забыть, что это не произвольные Лисп-выражения. Можно
описывать только разрешенные операции машины. Например, операции впрямую
могут работать только с константами и содержимым регистров, а не с
результатами других операций.

@end itemize

@noindent
Несмотря на указанные недостатки, мы будем использовать такой язык
описания регистровых машин на всем протяжении этой главы, поскольку нас
в большей мере будет занимать понимание работы контроллеров, чем
понимание элементов и связей в путях данных. Следует, однако, помнить,
что проектирование путей данных --- ключевой элемент в разработке
настоящих машин.

@quotation
@strong{@anchor{Упражнение 5.2}Упражнение 5.2:} С помощью языка регистровых
машин опишите итеративную факториал-машину из упражнения @ref{Упражнение 5.1}.
@end quotation

@comment @subsubheading Actions
@subsubheading Действия

Давайте теперь изменим машину НОД так, чтобы можно было вводить числа,
НОД которых мы хотим получить, и видеть результаты, напечатанные на
терминале. Мы не будем обсуждать, как построить машину для считывания и
печати, а предположим (как и с процедурами @code{read} и
@code{display} в Scheme), что эти действия доступны как элементарные
операции.@footnote{Такое предположение покрывает большую и сложную
область. Обычно значительная часть реализации Лисп-систем посвящена
работе ввода и вывода.}

@float
@c @quotation
@anchor{Рисунок 5.4}
@ifinfo
@strong{Рисунок 5.4:} A @acronym{GCD} machine that reads inputs and prints results.

@example
                   .--------.
                    \ read /
                     \____/
                       |
               +-------*------+
               |              |
        a<-rd (X)            (X) b<-rd
               |              |
               V              V           ___
            +-----+        +-----+       /   \
            |  a  |<--(X)--+  b  +----->|  =  |
            +-+-+-+  a<-b  +-+---+       \___/
              | |            |  ^          ^
           +--+ +----+    +--+  |          |
           |         |    |    (X) b<-t   / \
           V         V    V     |        / O \
      .---------.  .---------.  |       /_____\
--(X)->\ print /    \  rem  /   |
   P    \_____/      \_____/    |
                        |       |
                       (X) t<-r |
                        |       |
                        V       |
                     +-----+    |
                     |  t  +----+
                     +-----+
@end example

@lisp
 (controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
@end lisp

@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.4b,107mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 5.4:} A @acronym{GCD} machine that reads inputs and prints results. }@short
@center @caption{@strong{Рисунок 5.4:} Машина НОД, которая считывает входные числа и печатает результат.}
@sp 0.7
@end iftex
@c @end quotation
@end float

@code{Read} подобна операциям, которые мы использовали ранее, поскольку
она порождает значение, и его можно сохранить в регистре. Однако
@code{read} не принимает входа ни из каких регистров; ее значение
зависит от событий, происходящих за пределами тех компонентов машины,
проектированием которых мы заняты. Мы позволим операциям нашей машины
вести себя таким образом, и, следовательно, будем рисовать @code{read} и
изображать ее в языке описания так же, как любую другую операцию,
вычисляющую значение.

@code{Print}, с другой стороны, фундаментальным образом отличается от
тех операций, которыми мы до сих пор пользовались: она не порождает
результата, который можно было бы поместить в регистр. Хотя она и
производит эффект, этот эффект не касается тех частей машины, которые мы
проектируем. Этот тип операций мы будем называть (actions). На диаграмме
путей данных мы будем представлять действие так же, как и операции,
вычисляющие значение --- как трапецию с именем действия. В этот элемент
входят стрелки из входов (регистров или констант). Кроме того, мы
связываем с действием кнопку. Нажатие кнопки заставляет действие
совершиться. Чтобы скомандовать контроллеру нажать кнопку действия, мы
вводим новый тип команды @code{perform}. Таким образом, действие по
распечатке содержимого регистра @code{a} представляется в
последовательности контроллера командой

@lisp
(perform (op print) (reg a))
@end lisp

На рисунке @ref{Рисунок 5.4} показаны пути данных и контроллер для
новой машины НОД. Вместо того, чтобы останавливать машину после печати
ответа, мы приказываем ей начать сначала, так что она в цикле считывает
пару чисел, вычисляет их НОД и печатает результат. Такая структура
подобна управляющим циклам, которые мы использовали в интерпретаторах
из главы @ref{Глава 4}.


@comment @subsection Abstraction in Machine Design
@subsection Абстракция в проектировании машин
@node	5.1.2, 5.1.3, 5.1.1, 5.1

Часто в определении машины мы будем использовать <<элементарные>>
операции, которые на самом деле весьма сложны. Например, в
разделах @ref{5.4} и @ref{5.5} мы будем рассматривать операции с окружениями
Scheme как элементарные. Такая абстракция полезна, поскольку она
позволяет нам игнорировать детали частей машины, так что мы можем
сосредоточиться на других сторонах общего плана. Однако, хотя мы и
скрываем существенную часть сложности, это не означает, что проект
машины нереалистичен. Сложные <<примитивы>> всегда можно заменить более
простыми операциями.

Рассмотрим машину НОД. В ней содержится команда, которая вычисляет
остаток от деления содержимого регистров @code{a} и @code{b} и сохраняет
результат в регистре @code{t}. Если мы хотим построить машину НОД без
использования элементарной операции взятия остатка, нам нужно указать,
как вычислять остатки с помощью более простых операций, например,
вычитания. Действительно, можно написать на Scheme процедуру нахождения
остатка таким образом:

@lisp
(define (remainder n d)
  (if (< n d)
      n
      (remainder (- n d) d)))
@end lisp

@float[tp]
@quotation
@anchor{Рисунок 5.5}
@ifinfo
@strong{Рисунок 5.5:} Data paths and controller for the elaborated @acronym{GCD} machine.

@example
                                    ___
+-----+         +-----+            /   \
|  a  |<--(X)---+  b  +-------*-->|  =  |
+--+--+   a<-b  +-+---+       |    \___/
   |              |  ^        |
  (X) t<-a        |  |        |
   |              | (X) b<-t  |
   V              |  |       _V_
+-----+           |  |      /   \
|  t  +-------*---|--*-----|  <  |
+-----+       |   |         \___/
   ^          V   V
   |        ---------
  (X) t<-d   \  -  /
   |          --+--
   |            |
   +------------+


   start
     |
     V
    / \ yes            +-------+
+->< = >----> done     | t<-d  |<--+
|   \ /                +---+---+   |
|    | no                  |       |
|    |                     V       |
|    |   +------+         / \ no   |
|    +-->| t<-a +------->< < >-----+
|        +------+         \ /
|                          | yes
|      +-------------------+
|      V
|  +-------+
|  | a<-b  |
|  +---+---+
|      |
|      V
|  +-------+
+--+ b<-t  |
   +-------+
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap5/Fig5.5a,67mm,,,.pdf}
@sp 1.0
@comment @caption{@strong{Рисунок 5.5:} Data paths and controller for the elaborated @acronym{GCD} machine.}
@caption{@strong{Рисунок 5.5:} Пути данных и контроллер уточненной машины НОД.}
@sp 1.0
@end iftex
@end quotation
@end float

Значит, мы можем заменить операцию взятия остатка в машине НОД
операцией вычитания и тестом-сравнением. На рисунке @ref{Рисунок 5.5}
показаны пути данных и контроллер уточненной машины. Команда

@lisp
(assign t (op rem) (reg a) (reg b))
@end lisp

@noindent
в определении контроллера НОД заменяется на последовательность команд,
содержащую цикл, как показано на рисунке @ref{Рисунок 5.6}.

@quotation
@strong{@anchor{Рисунок 5.6}@w{Рисунок 5.6:}} @math{\downarrow} Последовательность команд контроллера машины НОД с рисунка @ref{Рисунок 5.5}.

@lisp
(controller test-b
              (test (op =) (reg b) (const 0))
              (branch (label gcd-done))
              (assign t (reg a))
            rem-loop
              (test (op <) (reg t) (reg b))
              (branch (label rem-done))
              (assign t (op -) (reg t) (reg b))
              (goto (label rem-loop))
            rem-done
              (assign a (reg b))
              (assign b (reg t))
              (goto (label test-b))
            gcd-done)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.3}Упражнение 5.3:} Спроектируйте машину
для вычисления квадратных корней методом Ньютона, как описано в разделе @ref{1.1.7}:

@lisp
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
@end lisp

Для начала предположите, что операции @code{good-enough?} и
@code{improve} имеются как примитивы. Затем покажите, как развернуть их
с помощью арифметических операций. Опишите каждую из версий машины
@code{sqrt}, нарисовав диаграмму путей данных, и написав определение
контроллера на языке регистровых машин.
@end quotation

@comment @subsection Subroutines
@subsection Подпрограммы
@node	5.1.3, 5.1.4, 5.1.2, 5.1

При проектировании машины для некоторого вычисления мы часто предпочтем
устроить так, чтобы компоненты ее разделялись различными частями
вычисления, а не дублировались. Рассмотрим машину, которая включает в
себя два вычисления НОД --- одно находит НОД содержимого регистров
@code{a} и @code{b}, а другое НОД содержимого регистров @code{c} и
@code{d}. Для начала можно предположить, что имеется элементарная
операция @code{gcd}, а затем развернуть два экземпляра @code{gcd} в
терминах более простых операций. На рисунке @ref{Рисунок 5.7} показаны
только части получившихся путей данных, относящиеся к НОД. Связи с
остальными частями машины опущены. Кроме того, на рисунке показаны
соответствующие сегменты последовательности команд контроллера машины.

@float
@c @quotation
@anchor{Рисунок 5.7}
@ifinfo
@strong{Рисунок 5.7:} Portions of the data paths and controller sequence for a machine with two @acronym{GCD} computations.

@example
                            ___                                 ___
+-----+        +-----+     /   \    +-----+        +-----+     /   \
|  a  |<-(X)---+  b  |--->|  =  |   |  c  |<-(X)---+  d  |--->|  =  |
+--+--+  a<-b  ++----+     \___/    +--+--+  c<-d  ++----+     \___/
   |            |  ^         ^         |            |  ^         ^
   `----.   .---'  |         |         `----.   .---'  |         |
        V   V     (X) b<-t   |              V   V     (X) d<-t   |
       -------     |        / \            -------     |        / \
       \ rem /     |       /_0_\           \ rem /     |       /_0_\
        --+--      |                        --+--      |
          |        |                          |        |
         (X) t<-r  |                         (X) s<-r  |
          |        |                          |        |
          V        |                          V        |
       +-----+     |                       +-----+     |
       |  t  +-----'                       |  s  +-----'
       +-----+                             +-----+
@end example

@lisp
gcd-1
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-1))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-1))
after gcd-1
   @dots{}
gcd-2
(test (op =) (reg d) (const 0))
(branch (label after-gcd-2))
(assign s (op rem) (reg c) (reg d))
(assign c (reg d))
(assign d (reg s))
(goto (label gcd-2))
after-gcd-2
@end lisp

@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap5/Fig5.7b,105mm,,,.pdf}
@sp 0.7
@noindent
@comment @caption{@strong{Рисунок 5.7:} Portions of the data paths and controller sequence for a @w{machine} with two @acronym{GCD} computations.}
@center @caption{@strong{Рисунок 5.7:} Части путей данных и последовательностей команд контроллера для машины с двумя вычислениями НОД.}
@sp 0.3
@end iftex
@c @end quotation
@end float

В этой машине два блока вычисления остатка и два блока проверки на
равенство. Если повторяющиеся компоненты сложны, как, например, блок
вычисления остатка, такое построение машины окажется неэкономным. Можно
избежать дублирования компонент путей данных, если использовать для
обоих вычислений НОД одни и те же компоненты, при условии, что такое
решение не повлияет на остальные вычисления большой машины. Если к тому
времени, как контроллер добирается до @code{gcd-2}, значения в
регистрах @code{a} и @code{b} не нужны (или если их можно временно
сохранить в каких-то еще регистрах), то мы можем изменить машину так,
чтобы она использовала регистры @code{a} и @code{b}, а не @code{c} и
@code{d}, при вычислении второго НОД, так же как и при вычислении
первого. Так у нас получится последовательность команд контроллера,
показанная на рисунке @ref{Рисунок 5.8}.

@quotation
@strong{@anchor{Рисунок 5.8}Figure 5.8:} @math{\downarrow} Сегменты последовательности команд контроллера для машины, которая использует одни и те же компоненты путей данных для двух различных вычислений НОД.
@lisp
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  @dots{}
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
@end lisp
@end quotation

Мы удалили одинаковые компоненты путей данных (так что они снова стали
такими, как на рисунке @ref{Рисунок 5.1}), но теперь в контроллере
содержатся две последовательности команд вычисления НОД, которые
различаются только метками. Было бы лучше заменить эти две
последовательности переходами к единой последовательности ---
(subroutine), --- в конце которой мы возвращаемся обратно к нужному
месту в основной последовательности команд. Этого можно добиться так:
прежде, чем перейти к @code{gcd}, мы помещаем определенное значение (0
или 1) в особый регистр, @code{continue}. В конце подпрограммы
@code{gcd} мы переходим либо к @code{after-gcd-1}, либо к
@code{after-gcd-2}, в зависимости от значения из регистра
@code{continue}. На рисунке @ref{Рисунок 5.9} показан соответствующий
сегмент получающейся последовательности команд контроллера, который
содержит только одну копию команд @code{gcd}.

@quotation
@strong{@anchor{Рисунок 5.9}Figure 5.9:} @math{\downarrow} Использование регистра @code{continue} ради избежания повторяющейся последовательности команд с рисунка @ref{Рисунок 5.8}.
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  @dots{}
 @r{;; Прежде, чем перейти к @code{gcd} из первого места, где}
 @r{;; он нужен, заносим 0 в регистр @code{continue}}
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  @dots{}
 @r{;;  Перед вторым использованием @code{gcd} помещаем 1}
 @r{;;  в регистр @code{continue}}
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
@end lisp
@end quotation

@direntry
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
   .
   .
   .
 @r{;; Прежде, чем перейти к @code{gcd} из первого места, где}
 @r{;; он нужен, заносим 0~в регистр @code{continue}}
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 @r{;;  Перед вторым использованием @code{gcd} помещаем 1~в регистр @code{continue}.}
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
@end lisp

@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   .
   .
   .
 @r{;; Перед вызовом @code{gcd} заносим~в @code{continue}}
 @r{;; метку, на которую @code{gcd} должен вернуться.}
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   .
   .
   .
 @r{;;  Второй вызов@code{gcd}, с другим продолжением.}
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
@end lisp
@end direntry

Для маленьких задач это разумный подход, однако если бы в
последовательности команд контроллера имелось много вызовов вычисления
НОД, он стал бы неудобен. Чтобы решить, где продолжать вычисление после
подпрограммы @code{gcd}, нам пришлось бы иметь в контроллере тесты и
переходы для всех мест, где используется @code{gcd}. Более мощный метод
реализации подпрограмм состоит в том, чтобы запоминать в регистре
@code{continue} метку точки входа в последовательности контроллера, с
которой выполнение должно продолжиться, когда подпрограмма закончится.
Реализация этой стратегии требует нового вида связи между путями данных
и контроллером регистровой машины: должно быть возможно присвоить
регистру метку в последовательности команд контроллера таким образом,
чтобы это значение можно было из регистра извлечь и с его помощью
продолжить выполнение с указанной точки входа.

Чтобы отразить эту возможность, мы расширим команду @code{assign} языка
регистровых машин и позволим присваивать регистру в качестве значения
метку из последовательности команд контроллера (как особого рода
константу). Кроме того, мы расширим команду @code{goto} и позволим
вычислению продолжаться с точки входа, которая описывается содержимым
регистра, а не только с точки входа, описываемой меткой-константой. С
помощью этих двух команд мы можем завершить подпрограмму @code{gcd}
переходом в место, хранимое в регистре @code{continue}. Это ведет к
последовательности команд, показанной на рисунке @ref{Рисунок 5.10}.

@quotation
@strong{@anchor{Рисунок 5.10}Figure 5.10:} @math{\downarrow} Присваивание регистру @code{continue} меток упрощает и обобщает стратегию с рисунка @ref{Рисунок 5.9}.
@lisp
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   @dots{}
 @r{;; Перед вызовом @code{gcd} заносим в @code{continue}}
 @r{;; метку, на которую @code{gcd} должен вернуться}
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   @dots{}
 @r{;;  Второй вызов @code{gcd}, с другим продолжением}
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
@end lisp
@end quotation

@noindent
Машина, в которой имеется более одной подпрограммы, могла бы
использовать различные регистры продолжения (например,
@code{gcd-continue}, @code{factorial-continue}), или же мы могли бы для
всех подпрограмм использовать один регистр @code{continue}. Разделение
регистра экономичнее, однако тогда требуется отслеживать случаи, когда
из одной подпрограммы (@code{sub1}) зовется другая (@code{sub2}). Если
@code{sub1} не сохранит значение @code{continue} в каком-то другом
регистре, прежде чем использовать @code{continue} при вызове
@code{sub2}, то @code{sub1} не будет знать, откуда продолжать выполнение
после ее конца. Механизм, который разрабатывается в следующем разделе
для работы с рекурсией, дает хорошее решение и для проблемы с вложенными
вызовами подпрограмм.

@comment @subsection Using a Stack to Implement Recursion
@subsection Реализация рекурсии с помощью стека
@node	5.1.4, 5.1.5, 5.1.3, 5.1

При помощи описанных до сих пор механизмов мы можем реализовать любой
итеративный процесс, задав регистровую машину, в которой имеется по
регистру на каждую переменную состояния процесса. Машина выполняет цикл
контроллера, изменяя при этом состояние регистров, до тех пор, пока не
окажется выполнено некоторое условие окончания процесса. В каждой точке
последовательности команд контроллера состояние машины (представляющее
состояние итеративного процесса) полностью определяется состоянием
регистров (значением переменных состояния).

Однако реализация рекурсивных процессов требует дополнительного
механизма. Рассмотрим следующий рекурсивный метод вычисления факториала,
описанный нами в разделе @ref{1.2.1}:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Как мы видим из этой процедуры, вычисление @math{n!} требует вычисления
@math{(n-1)!}. Машина НОД, которая моделирует процедуру

@lisp
(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))
@end lisp

@noindent
также должна была вычислять НОД других чисел, помимо начальных значений.
Однако между машиной НОД, которая сводит исходное вычисление к
вычислению другого НОД, и @code{factorial}, в котором нужно вычислить
другой факториал как подзадачу, есть существенная разница. В машине НОД
ответ, выдаваемый новым вычислением НОД --- это и есть ответ на
исходную задачу. Чтобы вычислить следующий НОД, мы просто помещаем новые
аргументы во входные регистры машины и заново используем ее пути данных,
прогоняя ту же самую последовательность команд контроллера. Когда машина
заканчивает решение последней задачи НОД, исходное вычисление также
заканчивается.

В случае с факториалом (и в любом другом рекурсивном процессе) ответ на
подзадачу-факториал не является решением общей задачи. Значение,
полученное для @math{(n-1)!}, требуется еще домножить на @math{n}, чтобы
получить окончательный ответ. Если мы попытаемся сымитировать решение
задачи НОД и решить подзадачу-факториал, уменьшив регистр @code{n} и
запустив машину заново, у нас больше не будет старого значения @code{n},
на которое можно было бы домножить результат. Для решения подзадачи нам
бы потребовалась еще одна факториальная машина. Во втором вычислении
факториала также есть подзадача-факториал, для нее требуется третья
факториальная машина, и так далее. Поскольку внутри каждой факториальной
машины содержится другая факториальная машина, в общей машине должно
содержаться бесконечное гнездо вложенных друг в друга машин, а
следовательно, ее нельзя построить из заранее заданного конечного числа
деталей.

Тем не менее реализовать факториальный процесс в виде регистровой машины
можно, если использовать одни и те же компоненты для всех встроенных ее
экземпляров.  а именно, машина, которая вычисляет @math{n!}, должна
использовать одни и те же детали для работы над подзадачей вычисления
@math{(n-1)!}, @math{(n-2)!} и так далее. Такое построение возможно,
поскольку, несмотря на то, что факториальный процесс требует для своего
вычисления неограниченное число одинаковых машин, в каждый момент
времени только одна из этих машин активна. Когда машина встречает
рекурсивную подзадачу, она может остановить работу над основной задачей,
использовать свои физические детали для решения подзадачи, а затем
продолжить остановленное вычисление.

Содержимое регистров внутри подзадачи будет отличаться от их значения в
главной задаче. (В нашем случае регистр @code{n} уменьшается на
единицу.) Чтобы суметь продолжить остановленное вычисление, машина
должна сохранить содержимое всех регистров, которые ей понадобятся после
того, как подзадача будет решена, а затем восстановить их, прежде чем
возобновить работу. В случае с факториалом мы сохраним старое значение
@code{n} и восстановим его, когда закончим вычисление факториала от
уменьшенного значения регистра @code{n}.@footnote{Казалось бы, незачем
сохранять старое @code{n}; после того, как мы его уменьшим на единицу и
решим подзадачу, можно эту единицу добавить и восстановить старое
значение. Такая стратегия работает для факториала, но в общем случае
она работать не может, поскольку старое значение регистра не всегда
можно вычислить на основании нового.}

Поскольку нет никакого априорного ограничения на число вложенных
рекурсивных вызовов, нам может понадобиться хранить произвольное число
значений регистров. Значения эти требуется восстанавливать в порядке,
обратном порядку их сохранения, поскольку в гнезде рекурсий последняя
начатая подзадача должна завершаться первой. Поэтому требуется
использовать для сохранения значений регистров (stack), или структуру
данных вида <<последним вошел, первым вышел>>. Можно расширить язык
регистровых машин и добавить в него стек, если ввести два новых вида
команд: значения заносятся на стек командой и снимаются со стека при
помощи команды @code{restore}. После того, как последовательность
значений сохранена на стеке, последовательность команд @code{restore}
восстановит их в обратном порядке.@footnote{В разделе @ref{5.3} мы увидим,
как стек можно реализовать на основе более элементарных операций.}

С помощью стека можно использовать для всех подзадач-факториалов единую
копию путей данных факториальной машины. Имеется подобная проблема и при
использовании последовательности команд контроллера, который управляет
путями данных. Чтобы запустить новое вычисление факториала, контроллер
не может просто перейти в начало последовательности, как в итеративном
процессе, поскольку после решения подзадачи поиска @math{(n-1)!} машине
требуется еще домножить результат на @math{n}. Контроллер должен
остановить вычисление @math{n!}, решить подзадачу поиска @math{(n-1)!} и
затем продолжить вычисление @math{n!}. Такой взгляд на вычисление
факториала приводит к использованию механизма подпрограмм из
раздела @ref{5.1.3}, при котором контроллер с помощью
регистра @code{continue} переходит к той части последовательности
команд, которая решает подзадачу, а затем продолжает с того места, где
он остановился в главной задаче. Мы можем таким образом написать
факториальную подпрограмму, которая возвращается к точке входа,
сохраненной в регистре @code{continue}. При каждом вызове подпрограммы
мы сохраняем и восстанавливаем регистр @code{continue} подобно регистру
@code{n}, поскольку все <<уровни>> вычисления факториала используют один
и тот же регистр @code{continue}. Так что факториальная подпрограмма
должна записать в @code{continue} новое значение, когда она вызывает
сама себя для решения подзадачи, но для возврата в место, откуда она
была вызвана для решения подзадачи, ей потребуется старое значение
@code{continue}.

На рисунке @ref{Рисунок 5.11} показаны пути данных и контроллер
машины, реализующей рекурсивную процедуру @code{factorial}. В этой
машине имеются стек и три регистра с именами @code{n}, @code{val} и
@code{continue}. Чтобы упростить диаграмму путей данных, мы не стали
давать имена кнопкам присваивания регистров, и поименовали только кнопки
работы со стеком --- @code{sc} и @code{sn} для сохранения регистров,
@code{rc} и @code{rn} для их восстановления. В начале работы мы
кладем в регистр @code{n} число, факториал которого желаем вычислить, и
запускаем машину. Когда машина достигает состояния @code{fact-done},
вычисление закончено и результат находится в регистре @code{val}. В
последовательности команд контроллера @code{n} и @code{continue}
сохраняются перед каждым рекурсивным вызовом и восстанавливаются при
возврате из этого вызова. Возврат из вызова происходит путем перехода к
месту, хранящемуся в @code{continue}. В начале работы машины
@code{continue} получает такое значение, что последний возврат переходит
в @code{fact-done}. Регистр @code{val}, где хранится результат
вычисления факториала, не сохраняется перед рекурсивным вызовом,
поскольку после возврата из подпрограммы его старое содержимое не нужно.
Используется только новое значение @code{val}, то есть результат
подвычисления.

@float[tp]
@c @quotation
@anchor{Рисунок 5.11}
@ifinfo
@strong{Рисунок 5.11:} A recursive factorial machine.

@example
                             ___
                            /   \
    +----------*-----------|  =  |
    |          |            \___/
   (X)         |              ^
    |          |              |
    V          |          +---+---+   sn    +-------+
+-------+      |          |       +---(X)-->|       |
|  val  |<-(X)-|----------+   n   |         | stack |
+-----+-+      |          |       |<--(X)---+       |
  ^   |        |          +-------+   rn    +-+-----+
  |   |        |            ^                 |   ^
 (X)  |        |            |                 |   |
  |   |   +----|--------*  (X)                |  (X) sc
  |   |   |    |        |   |             rc (X)  |
  |   |   |    *----.   |   |                 |   |
  |   V   V    |    V   V   |                 V   |
  |  -------   |   -------  |              +------+-+
  |  \  *  /   |   \  -  /  |              |continue+--> controller
  |   --+--    |    --+--   |              +--------+
  |     |      |      |     |               ^      ^
  +-----+      |      +-----+               |      |
               |                           (X)    (X)
               |                            |      |
              / \                   after- / \    / \  fact-
             /_1_\                  fact  /___\  /___\ done
@end example

@smalllisp
(controller
   (assign continue (label fact-done))     @r{; установить адрес} 
   @r{; окончательного возврата}
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   @r{;; Подготовиться к рекурсивному вызову, сохраняя @code{n} и @code{continue}.}
   @r{;; Установить  @code{continue} так, что вычисление продолжится }
   @r{;; с @code{after-fact} после возврата из подпрограммы.}
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)

   (assign val (op *) (reg n) (reg val))  @r{; теперь @code{val} содержит} @math{n(n-1)!}
   (goto (reg continue))                  @r{; возврат в вызывающую программу}
 base-case
 (assign val (const 1))                   @r{; базовый случай: $1! = 1$}
   (goto (reg continue))                  @r{; возврат в вызывающую программу}
 fact-done)
@end smalllisp

@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap5/Fig5.11a,106mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 5.11:} A recursive factorial machine.}
@center @caption{@strong{Рисунок 5.11:} Рекурсивная факториальная машина.}
@sp 0.0
@end iftex
@c @end quotation
@end float

Несмотря на то, что в принципе вычисление факториала требует
бесконечной машины, машина на рисунке @ref{Рисунок 5.11} конечна, за
исключением стека, который потенциально неограничен. Однако любая
конкретная физическая реализация стека будет иметь конечный размер и
таким образом будет ограничивать возможную глубину рекурсивных вызовов,
которые машина сможет делать. Такая реализация факториала иллюстрирует
общую стратегию реализации рекурсивных алгоритмов в виде обыкновенных
регистровых машин, дополненных стеком. Когда нам требуется решить
рекурсивную подзадачу, мы сохраняем на стеке регистры, текущее значение
которых потребуется после решения этой подзадачи, решаем ее, затем
восстанавливаем сохраненные регистры и продолжаем выполнение главной
задачи. Регистр @code{continue} следует сохранять всегда. Нужно ли
сохранять другие регистры, зависит от конкретной машины, поскольку не
все рекурсивные вычисления нуждаются в исходных значениях регистров во
время решения подзадачи (см. упражнение @ref{Упражнение 5.4}).

@comment @subsubheading A double recursion
@subsubheading Двойная рекурсия
Рассмотрим более сложный рекурсивный процесс --- древовидную рекурсию
при вычислении чисел Фибоначчи, описанную в
разделе @ref{1.2.2}:

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
@end lisp

@noindent
Как и в случае с факториалом, рекурсивное вычисление чисел Фибоначчи
можно реализовать в виде регистровой машины с регистрами @code{n},
@code{val} и @code{continue}. Машина более сложна, чем факториальная,
поскольку в последовательности команд контроллера здесь два места, где
нам нужно произвести рекурсивный вызов --- один раз для вычисления
@math{{\rm Fib}(n-1)}, а другой для вычисления
@math{{\rm Fib}(n-2)}. При подготовке к этим вызовам мы сохраняем
регистры, чье значение нам потребуется позже, устанавливаем в регистр
@code{n} число, Fib от которого нам требуется
вычислить (@math{n-1} или @math{n-2}), и присваиваем регистру
@code{continue} точку входа в главной последовательности, куда нужно
вернуться (соответственно, @code{afterfib-n-1} или @code{afterfib-n-2}).
Затем мы переходим к метке @code{fib-loop}. При возврате из рекурсивного
вызова ответ содержится в @code{val}. На рисунке @ref{Рисунок 5.12}
показана последовательность команд контроллера для этой машины.

@strong{@anchor{Рисунок 5.12}Figure 5.12:} @math{\downarrow} Контроллер машины для вычисления чисел Фибоначчи.

@lisp
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   @r{;; готовимся вычислить Fib@math{(n-1)}}
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                          @r{; сохранить старое значение @code{n}}
   (assign n (op -) (reg n) (const 1))@r{; записать в @code{n} @code{n-1}}
   (goto (label fib-loop))        @r{; произвести рекурсивный вызов}
 afterfib-n-1                     @r{; при возврате @code{val} содержит Fib@math{(n-1)}}
   (restore n)
   (restore continue)
   @r{;; готовимся вычислить Fib@math{(n-2)}}
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                    @r{; сохранить Fib@math{(n-1)}}
   (goto (label fib-loop))
 afterfib-n-2                    @r{; при возврате @code{val} содержит Fib@math{(n-2)}}
   (assign n (reg val))          @r{; теперь @code{n} содержит Fib@math{(n-2)}}
   (restore val)                 @r{; теперь @code{val} содержит Fib@math{(n-1)}}
   (restore continue)
   (assign val                   @r{;Fib@math{(n-1)} + Fib@math{(n-2)}}
           (op +) (reg val) (reg n)) 
   (goto (reg continue))         @r{; возврат, ответ в @code{val}}
 immediate-answer
   (assign val (reg n))          @r{; базовый случай: Fib@math{(n) = n}}
   (goto (reg continue))
 fib-done)
@end lisp

@direntry
@lisp
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   @r{;; set up to compute Fib@math{(n-1)}}
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                 @r{; save old value of @code{n}}
   (assign n (op -) (reg n) (const 1)) @r{; clobber @code{n} to @code{n-1}}
   (goto (label fib-loop))  @r{; perform recursive call}
 afterfib-n-1     @r{; upon return, @code{val} contains Fib@math{(n-1)}}
   (restore n)
   (restore continue)
   @r{;; set up to compute Fib@math{(n - 2)}}
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)               @r{; save Fib@math{(n-1)}}
   (goto (label fib-loop))
 afterfib-n-2     @r{; upon return, @code{val} contains Fib@math{(n-2)}}
   (assign n (reg val))     @r{; @code{n} now contains Fib@math{(n-2)}}
   (restore val)            @r{; @code{val} now contains Fib@math{(n-1)}}
   (restore continue)
   (assign val              @r{; Fib@math{(n-1)} + Fib@math{(n-2)}}
           (op +) (reg val) (reg n))
   (goto (reg continue))    @r{; return to caller, answer is in @code{val}}
 immediate-answer
   (assign val (reg n))     @r{; base case: Fib@math{(n) = n}}
   (goto (reg continue))
 fib-done)
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.4}Упражнение 5.4:} Опишите регистровые машины для реализации каждой из следующих
процедур. Для каждой из этих машин напишите последовательность команд
контроллера и нарисуйте диаграмму, показывающую пути данных.

@enumerate a.

@item
Рекурсивное возведение в степень:

@lisp
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
@end lisp

@item
Итеративное возведение в степень:

@lisp
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))
@end lisp

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.5}Упражнение 5.5:} Смоделируйте вручную работу факториальной машины и машины
Фибоначчи с каким-нибудь нетривиальным значением на входе (чтобы
потребовался хотя бы один рекурсивный вызов). Покажите содержимое
стека в каждый момент выполнения.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.6}Упражнение 5.6:} Бен Битобор утверждает, что последовательность команд машины
Фибоначчи содержит одну лишнюю команду @code{save} и одну лишнюю
@code{restore}, которые можно убрать и получить более быструю машину.
Что это за команды?
@end quotation

@comment @subsection Instruction Summary
@subsection Обзор системы команд
@node	5.1.5,  , 5.1.4, 5.1

Команда контроллера в нашей регистровой машине имеет одну из следующих
форм, причем каждый
@math{\langle}@var{input}@math{_i\rangle} --- это @code{(reg
@math{\langle}@var{register-name}@math{\rangle})} либо, @code{(const @math{\langle}@var{constant-value}@math{\rangle})}.  Команды, введенные в разделе @ref{5.1.1}:

@lisp
(assign @math{\langle}@var{register-name}@math{\rangle} (reg @math{\langle}@var{register-name}@math{\rangle}))
(assign @math{\langle}@var{register-name}@math{\rangle} (const @math{\langle}@var{constant-value}@math{\rangle}))
(assign @math{\langle}@var{register-name}@math{\rangle}
        (op @math{\langle}@var{operation-name}@math{\rangle})
        @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(perform (op @math{\langle}@var{operation-name}@math{\rangle}) @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(test (op @math{\langle}@var{operation-name}@math{\rangle}) @math{\langle}@var{input}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{input}@math{_{\monoit{n}}\rangle})
(branch (label @math{\langle}@var{label-name}@math{\rangle}))
(goto (label @math{\langle}@var{label-name}@math{\rangle}))
@end lisp

@noindent
Использование регистров для хранения меток, введенное в разделе @ref{5.1.3}:

@lisp
(assign @math{\langle}@var{register-name}@math{\rangle} (label @math{\langle}@var{label-name}@math{\rangle}))
(goto (reg @math{\langle}@var{register-name}@math{\rangle}))
@end lisp

@noindent
Команды для работы со стеком, введенные в разделе @ref{5.1.4}:

@lisp
(save @math{\langle}@var{register-name}@math{\rangle})
(restore @math{\langle}@var{register-name}@math{\rangle})
@end lisp

@noindent
До сих пор единственный вид
@math{\langle}@var{constant-value}@math{\rangle}, который нам
встречался, --- числа, но в дальнейшем мы будем использовать строки,
символы и списки. Например, 

@lisp
(const "abc") @r{представляет строку} "abc",
(const abc) @r{представляет символ} abc,
(const (a b c)) @r{список} (a b c),
@r{and} (const ()) @r{пустой список.}
@end lisp

@comment @section A Register-Machine Simulator
@section Программа моделирования регистровых машин
@node	5.2, 5.3, 5.1, Chapter 5

Чтобы как следует разобраться в работе регистровых машин, нам нужно
уметь тестировать проектируемые нами машины и проверять, работают ли
они в соответствии с ожиданиями. Один из способов проверки проекта
состоит в ручном моделировании работы контроллера, как в
упражнении @ref{Упражнение 5.5}. Однако этот способ подходит только для
совсем простых машин. В этом разделе мы строим программу имитационного
моделирования, (simulator), для машин, задаваемых на языке описания
регистровых машин. Имитатор представляет собой программу на Scheme с
четырьмя интерфейсными процедурами. Первая из них на основе описания
регистровой машины строит ее модель (структуру данных, части которой
соответствуют частям имитируемой машины), а остальные три позволяют
имитировать машину, работая с этой моделью:

@quotation

@lisp
(make-machine @math{\langle}@var{register-names}@math{\rangle} @math{\langle}@var{operations}@math{\rangle} @math{\langle}@var{controller}@math{\rangle})
@end lisp

@noindent
строит и возвращает модель машины с указанными регистрами, операциями и
контроллером.

@lisp
(set-register-contents! @math{\langle\kern0.08em}@var{machine-model}@math{\rangle}
                        @math{\langle}@var{register-name}@math{\rangle}
                        @math{\langle}@var{value}@math{\rangle})
@end lisp

@noindent
записывает значение в имитируемый регистр указанной машины.

@lisp
(get-register-contents @math{\langle\kern0.08em}@var{machine-model}@math{\rangle} @math{\langle}@var{register-name}@math{\rangle})
@end lisp

@noindent
возвращает содержимое имитируемого регистра указанной машины.

@lisp
(start @math{\langle\kern0.08em}@var{machine-model}@math{\rangle})
@end lisp

имитирует работу данной машины. Машина запускается с начала последовательности команд
контроллера и останавливается, когда достигнут конец этой последовательности.
@end quotation

@noindent
В качестве примера того, как используются эти процедуры, можно
определить переменную @code{gcd-machine} как модель машины НОД из
раздела @ref{5.1.1} следующим образом:

@lisp
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
       gcd-done)))
@end lisp

Первым аргументом @code{make-machine} является список имен регистров.
Второй аргумент --- таблица (список двухэлементных списков),
связывающая каждое имя операции с процедурой Scheme, которая эту
операцию реализует (то есть порождает тот же результат на тех же входных
значениях). Последний аргумент описывает контроллер в виде списка из
меток и машинных команд, как в разделе @ref{5.1}.

Чтобы вычислить НОД двух чисел с помощью этой машины, мы заносим
значения во входные регистры, запускаем машину, а когда имитация ее
работы завершается, считываем результат:

@lisp
(set-register-contents! gcd-machine 'a 206)
@i{done}
(set-register-contents! gcd-machine 'b 40)
@i{done}
(start gcd-machine)
@i{done}
(get-register-contents gcd-machine 'a)
@i{2}
@end lisp

@noindent
Эта модель будет работать значительно медленнее, чем процедура
@code{gcd}, написанная на Scheme, поскольку она имитирует низкоуровневые
команды машины, например, @code{assign}, с помощью значительно более
сложных операций.

@quotation
@strong{@anchor{Упражнение 5.7}Упражнение 5.7:} Проверьте на имитаторе машины, построенные Вами в
упражнении @ref{Упражнение 5.4}.
@end quotation

@menu
* 5-2-1::            Модель машины
* 5-2-2::            Ассемблер
* 5-2-3::            Порождение исполнительных процедур для команд
* 5-2-4::            Отслеживание производительности машины
@end menu

@comment @subsection The Machine Model
@subsection Модель машины
@node	5.2.1, 5.2.2, 5.2, 5.2

Модель машины, которую порождает @code{make-machine}, представляется в
виде процедуры с внутренним состоянием при помощи методов передачи
сообщений, разработанных в главе @ref{Глава 3}.
При построении модели @code{make-machine} прежде всего вызывает
процедуру @code{make-new-machine}, порождающую те части модели, которые
у всех регистровых машин одинаковые. Эта базовая модель машины,
создаваемая @code{make-new-machine}, является, в сущности, контейнером
для нескольких регистров и стека, а кроме того, содержит механизм
выполнения, который обрабатывает команды контроллера одну за другой.

Затем @code{make-machine} расширяет эту базовую модель (посылая ей
сообщения) и добавляет в нее регистры, операции и контроллер для
конкретной определяемой машины. Сначала она выделяет в новой машине по
регистру на каждое из данных имен регистров и встраивает в нее
указанные операции. Затем она с помощью (assembler) (описанного в
разделе @ref{5.2.2}) преобразует список контроллера в
команды новой машины и устанавливает их ей в качестве
последовательности команд. В качестве результата @code{make-machine}
возвращает модифицированную модель машины.

@lisp
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each
     (lambda (register-name)
       ((machine 'allocate-register) register-name))
     register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
@end lisp

@comment @subsubheading Registers
@subsubheading Регистры

Мы будем представлять регистры в виде процедур с внутренним состоянием,
как в главе @ref{Глава 3}. Процедура @code{make-register} создает регистр.
Регистр содержит значение, которое можно считать или изменить.

@lisp
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request: REGISTER" message))))
    dispatch))
@end lisp

@noindent
Для доступа к регистрам используются следующие процедуры:

@lisp
(define (get-contents register) (register 'get))
(define (set-contents! register value)
  ((register 'set) value))
@end lisp

@comment @subsubheading The stack
@subsubheading Стек

Стек также можно представить в виде процедуры с внутренним состоянием.
Процедура @code{make-stack} создает стек, внутреннее состояние которого
состоит из списка элементов на стеке. Стек принимает сообщение
@code{push}, кладущее элемент на стек, сообщение @code{pop}, снимающее
со стека верхний элемент и возвращающее его, и сообщение
@code{initialize}, которое дает стеку начальное пустое значение.

@lisp
(define (make-stack)
  (let ((s '()))
    (define (push x) (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request: STACK" message))))
    dispatch))
@end lisp

@noindent
Для доступа к стеку используются следующие процедуры:

@lisp
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))
@end lisp

@comment @subsubheading The basic machine
@subsubheading Базовая машина

Процедура @code{make-new-machine}, приведенная на
рисунке @ref{Рисунок 5.13}, порождает объект, внутреннее состояние
которого состоит из стека, изначально пустой последовательности команд,
списка операций, где с самого начала присутствует операция инициализации
стека, а также (register table), в которой изначально содержатся два
регистра, @code{flag} и @code{pc} (от @emph{program counter}, <<счетчик
программы>>). Внутренняя процедура @code{allocate-register} добавляет в
таблицу новый элемент, а внутренняя процедура @code{lookup-register}
ищет регистр в таблице.

Регистр @code{flag} используется для управления переходами в
имитируемой машине. Команды @code{test} присваивают ему результат теста
(истину или ложь). Команды @code{branch} определяют, нужно ли делать
переход, в зависимости от значения регистра @code{flag}.

Регистр @code{pc} определяет порядок выполнения команд при работе
машины. Этот порядок реализуется внутренней процедурой @code{execute}. В
нашей имитационной модели каждая команда является структурой данных, в
которой есть процедура без аргументов, называемая (instruction execution
procedure). Вызов этой процедуры имитирует выполнение команды. Во время
работы модели @code{pc} указывает на часть последовательности команд,
начинающуюся со следующей подлежащей исполнению команды. Процедура
@code{execute} считывает эту команду, выполняет ее при помощи вызова
исполнительной процедуры, и повторяет этот процесс, пока имеется команды
для выполнения (то есть пока @code{pc} не станет указывать на конец
последовательности команд).

@quotation
@strong{@anchor{Рисунок 5.13}Figure 5.13:} @math{\downarrow} The @code{make-new-machine}
procedure, which implements the basic machine model.

@direntry
@lisp
(define (make-new-machine)\index{ru}{make-new-machine||||pd|}
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Многократно определенный регистр: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Неизвестный регистр:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Неизвестная операция -- MACHINE" message))))
      dispatch)))
@end lisp
@end direntry

@lisp
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register)
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request: MACHINE"
                           message))))
      dispatch)))
@end lisp
@end quotation

@noindent
В процессе работы каждая исполнительная процедура изменяет @code{pc} и
указывает, какую следующую команду надо выполнить. Команды @code{branch}
и @code{goto} присваивают регистру @code{pc} значение, указывающее на
новый адрес. Все остальные команды просто продвигают @code{pc} так,
чтобы он указывал на следующую команду в последовательности. Заметим,
что каждый вызов @code{execute} снова зовет @code{execute}, но это не
приводит к бесконечному циклу, поскольку запуск исполнительной процедуры
команды изменяет содержимое @code{pc}.

@code{make-new-machine} возвращает процедуру @code{dispatch}, которая
дает доступ к внутреннему состоянию на основе передачи сообщений. Запуск
машины осуществляется путем установки @code{pc} в начало
последовательности команд и вызова @code{execute}.

Ради удобства мы предоставляем альтернативный процедурный интерфейс для
операции @code{start} регистровой машины, а также процедуры для доступа
к содержимому регистров и их изменения, как указано в начале
раздела @ref{5.2}:

@lisp
(define (start machine) (machine 'start))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name)
                 value)
  'done)
@end lisp

@noindent
Все эти процедуры (а также многие процедуры из разделов @ref{5.2.2} и @ref{5.2.3})
следующим образом ищут регистр с данным именем в данной машине:

@lisp
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
@end lisp

@comment @subsection The Assembler
@subsection Ассемблер
@node	5.2.2, 5.2.3, 5.2.1, 5.2

Ассемблер переводит последовательность выражений контроллера машины в
соответствующий ей список машинных команд, каждая со своей
исполнительной процедурой. По общему строению ассемблер подобен
интерпретаторам, которые мы изучали в главе @ref{Глава 4} ---
имеется входной язык (в этом случае язык регистровых машин), и нам нужно
выполнить некоторое действие для каждого типа выражений этого языка.

Методика порождения исполнительной процедуры для каждой команды в
точности та же, которой мы пользовались в разделе @ref{4.1.7},
чтобы ускорить интерпретацию путем отделения синтаксического анализа от
выполнения. Как мы видели в главе @ref{Глава 4},
существенную часть полезного анализа выражений Scheme можно провести, не
зная конкретных значений переменных. Подобным образом и здесь
существенную часть анализа выражений машинного языка можно провести, не
зная конкретного содержимого регистров машины. Например, можно заменить
имена регистров указателями на объекты-регистры, а имена меток ---
указателями на те места в последовательности команд, которые метками
обозначаются.

Прежде чем порождать исполнительные процедуры команд, ассемблер должен
знать, куда указывают все метки, так что вначале он просматривает текст
контроллера и отделяет метки от команд. При просмотре текста он строит
список команд и таблицу, которая связывает каждую метку с указателем
внутрь этого списка. Затем ассемблер дополняет список команд,
вставляя в каждую команду исполнительную процедуру.

Процедура @code{assemble} --- основной вход в ассемблер. Она
принимает в качестве аргументов текст контроллера и модель машины, а
возвращает последовательность команд, которую нужно сохранить в модели.
@code{assemble} вызывает @code{extract-labels}, чтобы построить из
данного ей списка контроллера исходный список команд и таблицу меток.
Вторым аргументом @code{extract-labels} служит процедура, которую
следует позвать для обработки этих результатов: эта процедура зовет
@code{update-insts!}, чтобы породить исполнительные процедуры для команд
и вставить их в командный список, а затем возвращает модифицированный
список команд.

@lisp
(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
@end lisp

@noindent
@code{extract-labels} принимает на входе список @code{text}
(последовательность выражений, обозначающих команды контроллера) и
процедуру @code{receive}. @code{receive} будет вызвана с двумя
аргументами: (1) списком @code{insts} структур данных, каждая из которых
содержит команду из @code{text}; и (2) таблицей под названием
@code{labels}, связывающей каждую метку из @code{text} с позицией в
списке @code{insts}, которую эта метка обозначает.

@lisp
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
@end lisp

@noindent
Работа @code{extract-labels} заключается в последовательном просмотре
элементов @code{text} и сборке @code{insts} и @code{labels}. Если
очередной элемент является символом (то есть меткой), соответствующий
вход добавляется в таблицу @code{labels}. В противном случае элемент
добавляется к списку @code{insts}.@footnote{Процедура @code{receive}
используется здесь, в сущности, для того, чтобы заставить
@code{extract-labels} вернуть два значения --- @code{labels} и
@code{insts}, --- не создавая специально структуры данных для их
хранения. Альтернативная реализация, которая явным образам возвращает
пару значений, выглядит так:

@lisp
(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
@end lisp

@noindent
Вызывать ее из @code{assemble} следовало бы таким образом:

@lisp
(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
@end lisp

Можно считать, что использование @code{receive} показывает изящный
способ вернуть несколько значений, а можно считать, что это просто
оправдание для демонстрации программистского трюка. Аргумент, который,
как @code{receive}, является процедурой, вызываемой в конце, называется
<<продолжением>>. Напомним, что мы уже использовали продолжения для
того, чтобы реализовать управляющую структуру перебора с возвратом в
разделе @ref{4.3.3}.}

@code{update-insts!} модифицирует командный список, который сначала
содержит только текст команд, так, чтобы в нем имелись соответствующие
исполнительные процедуры:

@lisp
(define (update-insts! insts labels machine) 
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
@end lisp

@noindent
Структура данных для машинной команды просто сочетает текст команды с
соответствующей исполнительной процедурой. Когда @code{extract-labels}
создает команду, исполнительной процедуры еще нет, и она вставляется
позже из процедуры @code{update-insts!}:

@lisp
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
@end lisp

@noindent
Текст команды не используется в имитаторе, но сохраняется в целях
отладки (см. упражнение @ref{Упражнение 5.16}).

Элементы таблицы меток --- это пары:

@lisp
(define (make-label-entry label-name insts)
  (cons label-name insts))
@end lisp

@noindent
Записи в таблице можно искать через

@lisp
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label: ASSEMBLE"
               label-name))))
@end lisp

@direntry
@lisp
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Неопределенная метка -- ASSEMBLE"
               label-name))))
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.8}Упражнение 5.8:} Следующий код для регистровой
машины неоднозначен, поскольку метка @code{here} определена более одного раза:

@lisp
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
@end lisp

Каково будет содержимое регистра @code{a} в нашем имитаторе, когда
управление достигнет @code{there}? Измените процедуру
@code{extract-labels} так, чтобы ассемблер сообщал об ошибке в случае,
когда одно и то же имя метки обозначает две различных точки в коде.
@end quotation

@comment @subsection Generating Execution Procedures@* for Instructions
@subsection Порождение исполнительных процедур для команд
@node	5.2.3, 5.2.4, 5.2.2, 5.2

Чтобы породить для команды исполнительную процедуру, ассемблер зовет
@code{make-execution-procedure}. Как и процедура @code{analyze} в
интерпретаторе из раздела @ref{4.1.7},
она делает выбор на основе типа команды и порождает соответствующую
исполнительную процедуру.

@lisp
(define (make-execution-procedure
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else
         (error "Unknown instruction type: ASSEMBLE"
                inst))))
@end lisp

@direntry
@lisp
(define (make-execution-procedure
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Неизвестный тип команды -- ASSEMBLE"
                     inst))))
@end lisp
@end direntry

@noindent
Для каждого типа команд языка регистровых машин имеется
процедура-генератор, которая порождает исполнительные процедуры. Детали
порождаемых процедур определяют как синтаксис, так и семантику отдельных
команд машинного языка. Мы изолируем с помощью абстракции данных
конкретный синтаксис выражений языка регистровых машин от общего
механизма вычисления, подобно тому, как мы это делали для интерпретатора
из раздела @ref{},
и для считывания и классификации частей команды используем
синтаксические процедуры.
Команды @code{assign}
Процедура @code{make-assign} обрабатывает команды @code{assign}:

@lisp
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()     @r{; исполнительная процедура для @code{assign}}
        (set-contents! target (value-proc))
        (advance-pc pc)))))
@end lisp

@code{make-assign} извлекает имя целевого регистра (второй элемент
команды) и выражение-значение (остаток списка, представляющего команду)
из команды @code{assign} с помощью селекторов

@lisp
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
@end lisp

@noindent
По имени регистра с помощью @code{get-register} находится объект-целевой
регистр. Выражение-значение передается в @code{make-operation-exp}, если
значение является результатом операции, и в
@code{make-primitive-exp} в противном случае. Эти процедуры
(приведенные ниже) рассматривают выражение-значение и порождают
исполнительную процедуру для вычисления этого выражения. Это процедура
без аргументов, называемая , которая будет вызвана во время работы
имитатора и породит значение, которое требуется присвоить регистру.
Заметим, что поиск регистра по имени и разбор выражения-значения
происходят только один раз во время ассемблирования, а не каждый раз
при выполнении команды. Именно ради такой экономии работы мы используем
исполнительные процедуры, и этот выигрыш прямо соответствует экономии,
полученной путем отделения синтаксического анализа от выполнения в
интерпретаторе из раздела @ref{4.1.7}.

Результат, возвращаемый @code{make-assign} --- это исполнительная
процедура для команды @code{assign}. Когда эта процедура вызывается (из
процедуры @code{execute} модели), она записывает в целевой регистр
результат, полученный при выполнении @code{value-proc}. Затем она
передвигает @code{pc} на следующую команду с помощью процедуры

@lisp
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
@end lisp

@noindent
@code{advance-pc} вызывается в конце исполнения всех команд, кроме
@code{branch} и @code{goto}.

@comment @subsubheading @code{test}, @code{branch}, and @code{goto} instructions
@subsubheading Команды @code{test}, @code{branch} и @code{goto}

@code{make-test} обрабатывает команду @code{test} похожим образом. Эта
процедура извлекает выражение, которое определяет подлежащее проверке
условие, и порождает для него исполнительную процедуру. Во время работы
модели эта процедура для условия вызывается, результат ее сохраняется в
регистре @code{flag}, и @code{pc} передвигается на шаг:

@lisp
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction: ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
@end lisp

@direntry
@lisp
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Плохая команда TEST -- ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
@end lisp
@end direntry

@noindent
Исполнительная процедура для команды @code{branch} проверяет содержимое
регистра @code{flag} и либо записывает в содержимое @code{pc} целевой
адрес (если переход происходит), либо просто продвигает @code{pc} (если
переход не происходит). Заметим, что указанная точка назначения для
команды @code{branch} обязана быть меткой, и процедура
@code{make-branch} это проверяет. Заметим также, что поиск метки
происходит во время ассемблирования, а не при каждом исполнении команды
@code{branch}.

@lisp
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label
                labels
                (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction: ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
@end lisp

@direntry
@lisp
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Плохая команда BRANCH -- ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
@end lisp
@end direntry

Команда @code{goto} подобна @code{branch}, но только здесь в качестве
целевого адреса может быть указана либо метка, либо регистр, и не надо
проверять никакого условия --- в @code{pc} всегда записывается новый
адрес.

@lisp
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts (lookup-label
                         labels
                         (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg (get-register
                       machine
                       (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
@end lisp

@direntry
@lisp
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Плохая команда GOTO -- ASSEMBLE"
                       inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
@end lisp
@end direntry

@comment @subsubheading Other instructions
@subsubheading Остальные команды

Команды работы со стеком @code{save} и @code{restore} просто используют
стек и указанный регистр, а затем продвигают @code{pc}:

@lisp
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
@end lisp

Последний тип команды, обрабатываемый процедурой @code{make-perform},
порождает исполнительную процедуру для требуемого действия. Во время
работы имитатора действие выполняется и продвигается @code{pc}.

@lisp
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda () (action-proc) (advance-pc pc)))
        (error "Bad PERFORM instruction: ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
@end lisp

@direntry
@lisp
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Плохая команда PERFORM -- ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
@end lisp
@end direntry

@comment @subsubheading Execution procedures for subexpressions
@subsubheading Исполнительные процедуры для подвыражений

Значение выражения @code{reg}, @code{label} или @code{const} может
потребоваться для присваивания регистру (@code{make-assign}) или как
аргумент операции (@code{make-operation-exp}, далее). Следующая
процедура порождает исполнительные процедуры, которые вычисляют во время
выполнения значения этих выражений:

@lisp
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts (lookup-label
                       labels
                       (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else (error "Unknown expression type: ASSEMBLE" exp))))
@end lisp

@direntry
@lisp
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Неизвестный тип выражения -- ASSEMBLE" exp))))
@end lisp
@end direntry

@noindent
Синтаксис выражений @code{reg}, @code{label} и @code{const} определяется
так:

@lisp
(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))
@end lisp

Команды @code{assign}, @code{test} и @code{perform} могут включать в
себя применение машинной операции (определяемой выражением @code{op}) к
нескольким операндам (определяемым выражениями @code{reg} или
@code{const}). Следующая процедура порождает исполнительную процедуру
для <<выражения-операции>> --- списка, состоящего из выражений внутри
команды, обозначающих операцию и операнды.

@lisp
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp)
                         operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
@end lisp

@noindent
Синтаксис выражений-операций определяется через

@lisp
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
@end lisp

Заметим, что обработка выражений-операций очень напоминает обработку
вызовов процедур процедурой @code{analyze-application} интерпретатора из раздела
@ref{4.1.7}, поскольку там и тут мы порождаем исполнительные процедуры для каждого
операнда. Во время работы мы вызываем эти процедуры для операндов и
применяем процедуру Scheme, которая имитирует операцию, к полученным
значениям. Имитирующая процедура получается путем поиска имени
операции в таблице операций регистровой машины:

@lisp
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE"
               symbol))))
@end lisp

@direntry
@lisp
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Неизвестная операция -- ASSEMBLE" symbol))))
@end lisp
@end direntry

@quotation
@strong{@anchor{Упражнение 5.9}Упражнение 5.9:} Приведенная в тексте обработка позволяет машинным операциям
принимать в качестве аргументов не только константы и содержимое
регистров, но и метки. Измените процедуры, обрабатывающие выражения, и
обеспечьте выполнение условия, что операции можно применять
исключительно к регистрам и константам.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.10}Упражнение 5.10:} Придумайте новый синтаксис для команд регистровой машины и
измените имитатор так, чтобы он использовал Ваш новый синтаксис. Можете
ли Вы реализовать свой синтаксис, ничего не трогая, кроме синтаксических
процедур из этого раздела?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.11}Упражнение 5.11:} Когда мы в
разделе @ref{5.1.4} определяли
@code{save} и @code{restore}, мы не указали, что произойдет, если
попытаться восстановить значение не в том регистре, который был
сохранен последним, как в последовательности команд

@lisp
(save y) (save x) (restore y)
@end lisp

Есть несколько разумных вариантов значения @code{restore}:

@enumerate a.

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
на стеке, независимо от того, откуда это значение взялось. Так работает
наш имитатор. Покажите, как с помощью такого поведения убрать одну
команду из машины Фибоначчи (раздел @ref{5.1.4}, рисунок @ref{Рисунок 5.12}).

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
на стеке, но только в том случае, когда это значение происходит из
регистра @code{y}; иначе возникает сообщение об ошибке. Модифицируйте
имитатор и заставьте его вести себя таким образом. Придется изменить
@code{save} так, чтобы он сохранял имя регистра вместе со значением.

@item
@code{(restore y)} переносит в @code{y} последнее значение, сохраненное
из @code{y}, независимо от того, какие другие регистры были сохранены и
не восстановлены после @code{y}. Модифицируйте имитатор так, чтобы он
вел себя таким образом. С каждым регистром придется связать свой
собственный стек. Операция @code{initialize-stack} должна
инициализировать стеки всех регистров.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.12}Упражнение 5.12:} При помощи имитатора можно определять пути данных, которые
требуются для реализации машины с данным контроллером. Расширьте
ассемблер и заставьте его хранить следующую информацию о модели машины:

@itemize

@item
список всех команд, с удаленными дубликатами, отсортированный по типу
команды (@code{assign}, @code{goto} и так далее).

@item
список (без дубликатов) регистров, в которых хранятся точки входа (это
те регистры, которые упоминаются в командах @code{goto}).

@item
Список (без дубликатов) регистров, к которым применяются команды
@code{save} или @code{restore}.

@item
Для каждого регистра, список (без дубликатов) источников, из которых ему
присваивается значение (например, для регистра @code{val} в
факториальной машине на рисунке @ref{Рисунок 5.11} источниками
являются @code{(const 1)} и @code{((op *) (reg n) (reg val))}).

@end itemize

Расширьте интерфейс сообщений машины и включите в него доступ к новой
информации. Чтобы проверить свой анализатор, примените его к машине
Фибоначчи с рисунка @ref{Рисунок 5.12} и рассмотрите получившиеся
списки.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.13}Упражнение 5.13:} Модифицируйте имитатор так, чтобы он определял, какие
регистры присутствуют в машине, из последовательности команд
контроллера, а не принимал список регистров в качестве аргумента
@code{make-machine}. Вместо того, чтобы выделять регистры в
@code{make-machine} заранее, их можно создавать по одному, когда они
встречаются в первый раз при ассемблировании команд.
@end quotation

@comment @subsection Monitoring Machine Performance
@subsection Отслеживание производительности машины
@node	5.2.4,  , 5.2.3, 5.2

Имитационное моделирование может служить не только для проверки
правильности проекта машины, но и для измерения ее производительности. К
примеру, можно установить в нашу машину <<счетчик>>, измеряющий
количество операций со стеком, задействованных при вычислении. Для этого
мы изменяем моделируемый стек и следим, сколько раз регистры сохраняются
на стеке, регистрируем максимальную глубину, которой он достигает, а
также добавляем к интерфейсу стека сообщение, которое распечатывает
статистику, как показано ниже. Кроме того, мы добавляем к базовой машине
операцию для распечатки статистики, устанавливая значение @code{the-ops}
в @code{make-new-machine} в

@lisp
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
@end lisp

@noindent
Вот новая версия @code{make-stack}:

@lisp
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else (error "Unknown request: STACK" message))))
    dispatch))
@end lisp

@direntry
@lisp
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Пустой стек -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Неизвестная операция -- STACK" message))))
    dispatch))
@end lisp
@end direntry

В упражнениях от @ref{Упражнение 5.15} до @ref{Упражнение 5.19}
описываются другие полезные возможности для сбора информации и отладки,
которые можно добавить к имитатору регистровых машин.

@quotation
@strong{@anchor{Упражнение 5.14}Упражнение 5.14:} Измерьте количество сохранений и максимальную глубину
стека, требуемую для вычисления @math{n!} при различных малых значениях
@math{n} с помощью факториальной машины, показанной на
рисунке @ref{Рисунок 5.11}. По этим данным определите формулы в
зависимости от @math{n} для числа сохранений и максимальной глубины
стека, требуемых для вычисления @math{n!} при любом @math{n > 1}.
Обратите внимание, что это линейные функции от @math{n}, и они
определяются двумя константами. Чтобы увидеть статистику, Вам придется
добавить к факториальной машине команды для инициализации стека и
распечатки статистики. Можно также заставить машину в цикле считывать
@code{n}, вычислять факториал и печатать результат (как для машины НОД с
рисунка @ref{Рисунок 5.4}), так, чтобы не нужно было все время
вызывать @code{get-register-contents}, @code{set-register-contents!} и
@code{start}.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.15}Упражнение 5.15:} Добавьте к модели регистровой машины (instruction
counting). Это значит, что машина должна подсчитывать число выполненных
ею команд. Расширьте интерфейс модели и добавьте новое сообщение,
которое печатает счетчик команд и переустанавливает его в ноль.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.16}Упражнение 5.16:} Добавьте к имитатору (instruction tracing).  А именно,
перед тем, как выполнить каждую команду, имитатор должен распечатывать
ее текст. Заставьте модель принимать сообщения @code{trace-on} и
@code{trace-off}, которые включают и выключают трассировку.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.17}Упражнение 5.17:} Расширьте трассировку команд из
упражнения @ref{Упражнение 5.16} так, чтобы перед тем, как печатать
команду, имитатор распечатывал метки, которые стоят в
последовательности контроллера непосредственно перед этой командой.
Постарайтесь при этом не помешать подсчету команд
(упражнение @ref{Упражнение 5.15}). Придется заставить имитатор
хранить необходимую информацию о метках.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.18}Упражнение 5.18:} Измените процедуру @code{make-register} из раздела
@ref{5.2.1}, так, чтобы можно было трассировать
регистры. Регистры должны принимать сообщения, которые включают и
выключают трассировку. Когда регистр подвергается трассировке,
присваивание ему значения должно вызывать распечатку имени регистра,
старого его содержимого и нового, которое ему присваивается. Расширьте
интерфейс модели и дайте пользователю возможность включать и выключать
трассировку для указанных регистров машины.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.19}Упражнение 5.19:} Лиза П. Хакер хочет добавить в имитатор (breakpoints)
для облегчения отладки проектов машин. Вас наняли для реализации такой
возможности. Лиза хочет, чтобы в последовательности команд контроллера
можно было указать место, где имитатор остановится и позволит ей
исследовать состояние машины. Вам нужно реализовать процедуру

@lisp
(set-breakpoint @math{\langle\kern0.08em}@var{machine}@math{\rangle} @math{\langle}@var{label}@math{\rangle} @math{\langle}@var{n}@math{\rangle})
@end lisp

@noindent
которая устанавливает контрольную точку перед @math{n}-й командой,
следующей за указанной меткой. Например,

@lisp
(set-breakpoint gcd-machine 'test-b 4)
@end lisp

@noindent
установит контрольную точку в @code{gcd-machine} непосредственно перед
присваиванием регистру @code{a}. Когда моделирование достигает
контрольной точки, имитатор должен распечатать метку и смещение
точки, а затем прекратить выполнение команд. Тогда Лиза может с помощью
@code{get-register-contents} и @code{set-register-contents!} исследовать
и изменять состояние имитируемой машины. Затем она должна быть способна
продолжить выполнение, сказав

@lisp
(proceed-machine @math{\langle\kern0.08em}@var{machine}@math{\rangle})
@end lisp

Кроме того, необходимо иметь возможность удалить контрольную точку с
помощью

@lisp
(cancel-breakpoint @math{\langle\kern0.08em}@var{machine}@math{\rangle} @math{\langle}@var{label}@math{\rangle} @math{\langle}@var{n}@math{\rangle})
@end lisp

@noindent
и удалить все контрольные точки с помощью

@lisp
(cancel-all-breakpoints @math{\langle\kern0.08em}@var{machine}@math{\rangle})
@end lisp
@end quotation

@comment @section Storage Allocation and Garbage Collection
@section Выделение памяти и сборка мусора
@node	5.3, 5.4, 5.2, Chapter 5

В разделе @ref{5.4} мы покажем, как
реализовать вычислитель для Scheme в виде регистровой машины. Для того,
чтобы упростить обсуждение, мы будем предполагать, что наши машины
обладают (@newterm{list-structured memory}), в которой основные операции по
работе с данными списковой структуры элементарны. Постулирование такой
памяти --- удобная абстракция, если мы хотим сконцентрировать внимание
на механизмах управления в интерпретаторе Scheme, однако она не дает
реалистической картины того, как на самом деле устроены элементарные
операции с данными в современных компьютерах. Для того, чтобы получить
более полное понимание работы Лисп-системы, требуется исследовать, как
списковую структуру можно представить способом, совместимым с
устройством памяти обыкновенных компьютеров.

При реализации списковой структуры возникает два вопроса. Первый
относится только к способу представления: как изобразить структуру
<<ячеек и указателей>>, присущую лисповским парам, используя только
механизмы хранения и адресации, которыми обладает обыкновенная
компьютерная память. Второй вопрос связан с управлением памятью по мере
того, как вычисление развивается. Работа Лисп-системы существенным
образом зависит от ее способности постоянно создавать новые объекты
данных. Сюда включаются как объекты, которые явным образом выделяются в
интерпретируемых Лисп-процедурах, так и структуры, создаваемые самим
интерпретатором, например окружения и списки аргументов. Несмотря на то,
что постоянное создание новых объектов данных не вызвало бы проблемы на
компьютере с бесконечным количеством быстродействующей памяти, в
настоящих компьютерах объем доступной памяти ограничен (к сожалению).
Поэтому Лисп-системы реализуют @emph{автоматическое распределение
памяти} (@newterm{automatic storage allocation}), которое поддерживает иллюзию
бесконечной памяти. Когда объект данных перестает быть нужным, занятая
под него память автоматически освобождается и используется для
построения новых объектов данных. Имеются различные методы реализации
такого автоматического распределителя памяти. Метод, обсуждаемый нами в
этом разделе, называется (@newterm{garbage collection}).

@menu
* 5-3-1::            Память как векторы::
* 5-3-2::            Иллюзия бесконечной памяти::
@end menu

@comment @subsection Memory as Vectors
@subsection Память как векторы
@node	5.3.1, 5.3.2, 5.3, 5.3

Обыкновенную память компьютера можно рассматривать как массив клеток,
каждая из которых может содержать кусочек информации. У каждой клетки
имеется собственное имя, которое называется ее (@newterm{address}). Типичная
система памяти предоставляет две элементарные операции: одна считывает
данные, хранящиеся по указанному адресу, а вторая записывает по
указанному адресу новые данные. Адреса памяти можно складывать с целыми
числами и получать таким образом последовательный доступ к некоторому
множеству клеток. Если говорить более общо, многие важные операции с
данными требуют, чтобы адреса памяти рассматривались как данные, которые
можно записывать в ячейки памяти, и которыми можно манипулировать в
регистрах машины. Представление списковой структуры --- одно из
применений такой (@newterm{address arithmetic}).

@endpage
Для моделирования памяти компьютера мы используем новый вид структуры
данных, называемый @emph{вектором} (@newterm{vector}). С абстрактной точки зрения,
вектор представляет собой составной объект, к отдельным элементам
которого можно обращаться при помощи целочисленного индекса за время,
независимое от величины индекса.@footnote{Можно было бы представить
память в виде списка ячеек. Однако тогда время доступа не было бы
независимым от индекса, поскольку доступ к @math{n}-му элементу списка
требует @math{n-1} операций @code{cdr}.} Чтобы описать операции с
памятью, мы пользуемся двумя элементарными процедурами Scheme для работы
с векторами:

@itemize @bullet

@item
@code{(vector-ref @math{\langle}@var{vector}@math{\rangle} @math{\langle}@var{n}@math{\rangle})} возвращает @math{n}-ый элемент вектора.

@item
@code{(vector-set! @math{\langle}@var{vector}@math{\rangle} @math{\langle}@var{n}@math{\rangle} @math{\langle}@var{value}@math{\rangle})}
устанавливает @math{n}-ый элемент вектора в указанное значение.

@end itemize

@noindent
Например, если @code{v} --- вектор, то @code{(vector-ref v 5)} получает
его пятый элемент, а @code{(vector-set! v 5 7)} устанавливает значение
его пятого элемента равным 7.@footnote{Полноты ради, надо было бы указать
еще операцию @code{make-vector}, которая создает вектора. Однако в
текущем приложении мы используем вектора исключительно для моделирования
заранее заданных участков компьютерной памяти.} В памяти компьютера
такой доступ можно было бы организовать через адресную арифметику,
сочетая (@newterm{base address}), который указывает на начальное положение вектора
в памяти, с (@newterm{index}), который указывает смещение определенного элемента
вектора.

@comment @subsubheading Representing Lisp data
@subsubheading Представление лисповских данных

С помощью списков можно реализовать пары --- основные объекты данных,
нужные для памяти со списковой структурой. Представим, что память
разделена на два вектора: и @code{the-cdrs}. Списковую структуру мы
будем представлять следующим образом: указатель на пару есть индекс,
указывающий внутрь этих двух векторов. Содержимое элемента
@code{the-cars} с указанным индексом является @code{car} пары, а
содержимое элемента @code{the-cdrs} с тем же индексом является
@code{cdr} пары. Кроме того, нам нужно представление для объектов помимо
пар (например, чисел и символов) и способ отличать один тип данных от
другого. Есть много способов этого добиться, но все они сводятся к
использованию (@newterm{typed pointers}) --- то есть понятие <<указатель>>
расширяется и включает в себя тип данных.@footnote{Это в точности
понятие <<помеченных данных>>, которое мы ввели в главе @ref{Глава 2}
для работы с обобщенными операциями. Однако здесь типы данных вводятся
на элементарном машинном уровне, а не конструируются через списки.}
Тип данных позволяет системе отличить указатель на пару (который состоит
из метки типа данных <<пара>> и индекса в вектора памяти) от указателей
на другие типы данных (которые состоят из метки какого-то другого типа и
того, что используется для представления значений этого типа). Два
объекта данных считаются равными (@code{eq?}), если равны указатели на
них.@footnote{Информация о типе может быть представлена различными
способами, в зависимости от деталей машины, на которой реализована
Лисп-система. Эффективность выполнения Лисп-программ будет сильно
зависеть от того, насколько разумно сделан этот выбор, однако правила
проектирования, определяющие, какой выбор хорош, сформулировать трудно.
Самый простой способ реализации типизированных указателей состоит в
том, чтобы в каждом указателе выделить несколько бит как (@newterm{type field})
(или (type tag)) которое кодирует тип. При этом требуется решить
следующие важные вопросы: сколько требуется битов для поля типа? Как
велики должны быть индексы векторов? Насколько эффективно можно
использовать элементарные команды машины для работы с полями типа в
указателях? Про машины, в которых имеется специальная аппаратура для
эффективной обработки полей типа, говорят, что они обладают (tagged
architecture).} На рисунке @ref{Рисунок 5.14} показано, как с
помощью этого метода представляется список @code{((1 2) 3 4)}, а также
дана его стрелочная диаграмма. Информацию о типах мы обозначаем через
буквенные префиксы. Например, указатель на пару с индексом 5
обозначается @code{p5}, пустой список обозначается @code{e0}, а
указатель на число 4 обозначается @code{n4}. На стрелочной диаграмме
мы в левом нижнем углу каждой пары ставим индекс вектора, который
показывает, где хранятся @code{car} и @code{cdr} пары. Пустые клетки в
@code{the-cars} и @code{the-cdrs} могут содержать части других структур
(которые нам сейчас неинтересны).

Указатель на число, например @code{n4}, может состоять из метки,
указывающей, что это число, и собственно представления числа
4.@footnote{Решение о представлении чисел определяет, можно ли сравнивать
числа через @code{eq?}, который проверяет одинаковость указателей. Если
указатель содержит само число, то равные числа будут иметь одинаковые
указатели. Однако если в указателе содержится индекс ячейки, в которой
хранится само число, то у равных чисел будут одинаковые указатели
только в том случае, если нам удастся никогда не хранить одно и то же
число в двух местах.} Для того, чтобы работать с числами, не
умещающимися в ограниченном объеме, отводимом под указатель, может
иметься особый тип данных (@newterm{bignum}), для которого указатель обозначает
список, где хранятся части числа.@footnote{Это представление очень похоже
на запись числа в виде последовательности цифр, только каждая <<цифра>>
является числом между 0 и максимальным значением, которое можно
уместить в указателе.}

@float
@quotation
@anchor{Рисунок 5.14}
@ifinfo
@strong{Рисунок 5.14:} Box-and-pointer and memory-vector representations of the list @code{((1 2) 3 4)}.

@example
               +---+---+               +---+---+    +---+---+
((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
               +-|-+---+               +-|-+---+    +-|-+---+
              1  |                    2  |         4  |
                 V                       V            V
               +---+---+    +---+---+  +---+        +---+
               | * | *-+--->| * | / |  | 3 |        | 4 |
               +-|-+---+    +-|-+---+  +---+        +---+
              5  |         7  |
                 V            V
               +---+        +---+
               | 1 |        | 2 |
               +---+        +---+

   Index   0    1    2    3    4    5    6    7    8    ...
         +----+----+----+----+----+----+----+----+----+----
the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
         +----+----+----+----+----+----+----+----+----+----
the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
         +----+----+----+----+----+----+----+----+----+----
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap5/Fig5.14a,91mm,,,.pdf}
@sp 0.6
@comment @caption{@strong{Рисунок 5.14:} Box-and-pointer and memory-vector representations of the list @code{((1 2) 3 4)}.}
@caption{@strong{Рисунок 5.14:} Представления списка @code{((1 2) 3 4)} в виде стрелочной диаграммы и~в виде вектора памяти.}
@sp 0.9
@end iftex
@end quotation
@end float

Символ можно представить как типизированный указатель, обозначающий
последовательность знаков, из которых состоит печатное представление
символа. Эта последовательность создается процедурой чтения Лиспа, когда
строка-представление в первый раз встречается при вводе. Поскольку мы
хотим, чтобы два экземпляра символа всегда были <<одинаковы>> в смысле
@code{eq?}, а @code{eq?} должно быть простым сравнением указателей, нам
нужно обеспечить, чтобы процедура чтения, когда она видит ту же строку
второй раз, использовала тот же самый указатель (к той же
последовательности знаков) для представления обоих вхождений символа.
Ради этого процедура чтения содержит таблицу, которая по традиции
называется (obarray), и в ней хранит все когда-либо встреченные
символы. Когда процедура видит строку и готова создать символ, она
проверяет в обмассиве, не было ли уже ранее такой же строки. Если нет,
она строит новый символ со встретившейся строкой в качестве имени
(типизированный указатель на последовательность знаков) и включает
его в обмассив. Если же процедура уже встречала указанную строку, она
возвращает указатель на символ, хранимый в обмассиве. Процесс замены
строк печатных знаков указателями без повторения называется (@newterm{interning})
символов.

@comment @subsubheading Implementing the primitive list operations
@subsubheading Реализация элементарных списковых операций

Имея вышеописанную схему представления, можно заменить каждую
<<элементарную>> списковую операцию регистровой машины одной или более
элементарной векторной операцией. Мы будем обозначать векторы памяти
двумя регистрами и @code{the-cdrs}, и предположим, что операции
@code{vector-ref} и @code{vector-set!} даны как элементарные. Кроме
того, предположим, что численные операции с указателями (добавление
единицы, индексирование вектора с помощью указателя на пару и сложение
чисел) используют только индексную часть типизированного указателя.

Например, можно заставить регистровую машину поддерживать команды

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op car) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op cdr) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
если мы реализуем их, соответственно, как

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op vector-ref) (reg the-cars) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op vector-ref) (reg the-cdrs) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
Команды

@lisp
(perform (op set-car!) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform (op set-cdr!) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
реализуются как

@lisp
(perform
 (op vector-set!) (reg the-cars) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform
 (op vector-set!) (reg the-cdrs) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
@end lisp

@noindent
При выполнении @code{cons} выделяется неиспользуемый индекс, и аргументы
@code{cons} записываются в @code{the-cars} и @code{the-cdrs} в ячейках
с выделенным индексом. Мы предполагаем, что имеется особый регистр
@code{free}, в котором всегда содержится указатель на следующую
свободную пару, и что мы можем его увеличить и получить следующую
свободную ячейку.@footnote{Имеются и другие способы поиска свободной
памяти. Например, можно было бы связать все неиспользуемые пары в (free
list). Наши свободные ячейки идут подряд, поскольку мы пользуемся
сжимающим сборщиком мусора, как будет описано в разделе @ref{5.3.2}.}
Например, команда

@lisp
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (op cons) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{3}}\rangle}))
@end lisp

@noindent
реализуется как следующая последовательность векторных
операций:@footnote{В сущности, это реализация @code{cons} через
@code{set-car!} и @code{set-cdr!}, как описано в разделе @ref{3.3.1}.
Операция @code{get-new-pair}, которая там используется, здесь
реализуется через указатель @code{free}.}

@lisp
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg @math{\langle}@var{reg}@math{_{\mono{3}}\rangle}))
(assign @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} (reg free))
(assign free (op +) (reg free) (const 1))
@end lisp

@noindent
Операция @code{eq?}

@lisp
(op eq?) (reg @math{\langle}@var{reg}@math{_{\mono{1}}\rangle}) (reg @math{\langle}@var{reg}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
попросту проверяет равенство всех полей регистров, а предикаты вроде
@code{pair?}, @code{null?}, @code{symbol?} и @code{number?} смотрят
только на поле типа.

@comment @subsubheading Implementing stacks
@subsubheading Реализация стеков

Хотя наши регистровые машины используют стеки, нам ничего специально
здесь делать не надо, поскольку стеки можно смоделировать на основе
списков. Стек может быть списком сохраненных значений, на которые
указывает особый регистр @code{the-stack}. Таким образом,
@code{(save @math{\langle}@var{reg}@math{\rangle})} может реализовываться как

@lisp
(assign the-stack (op cons) (reg @math{\langle}@var{reg}@math{\rangle}) (reg the-stack))
@end lisp

@noindent
Подобным образом,  @code{(restore @math{\langle}@var{reg}@math{\rangle})}
можно реализовать как

@lisp
(assign @math{\langle}@var{reg}@math{\rangle} (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
@end lisp

@noindent
а @code{(perform (op initialize-stack))} реализуется как

@lisp
(assign the-stack (const ()))
@end lisp

@noindent
Все эти операции можно далее расшифровать в терминах векторных
операций, как показано выше. Однако в традиционных компьютерных
архитектурах обычно удобно выделять стек в виде отдельного вектора. В
таком случае сохранение на стеке и снятие с него реализуются через
увеличение и уменьшение индекса, указывающего в этот вектор.

@quotation
@strong{@anchor{Упражнение 5.20}Упражнение 5.20:} Нарисуйте стрелочную диаграмму и представление в виде
вектора (как на рисунке @ref{Рисунок 5.14}) списка, который порождается кодом

@lisp
(define x (cons 1 2))
(define y (list x x))
@end lisp

если вначале указатель @code{free} равен @code{p1}. Чему равно значение
@code{free} после исполнения кода? Какие указатели представляют значения
@code{x} и @code{y}?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.21}Упражнение 5.21:} Реализуйте регистровые машины для следующих процедур.
Считайте, что операции с памятью, реализующие списковую структуру,
имеются в машине как примитивы.

@enumerate a.

@item
Рекурсивная @code{count-leaves}:

@lisp
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
@end lisp

@item
Рекурсивная @code{count-leaves} с явным счетчиком:

@lisp
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
@end lisp
@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.22}Упражнение 5.22:} В упражнении @ref{Упражнение 3.12} из
раздела @ref{3.3.1} были
представлены процедура @code{append}, которая добавляет два списка друг
к другу и получает третий, и процедура @code{append!}, которая склеивает
два списка вместе. Спроектируйте регистровые машины, которые реализуют
каждую из этих процедур. Предполагайте, что операции с памятью,
реализующие списковую структуру, являются примитивами.
@end quotation

@comment @subsection Maintaining the Illusion of Infinite Memory
@subsection Иллюзия бесконечной памяти
@node	5.3.2,  , 5.3.1, 5.3

Метод представления, намеченный в разделе @ref{5.3.1}, решает задачу реализации
списковой структуры при условии, что у нас бесконечное количество
памяти. В настоящем компьютере у нас в конце концов кончится свободное
место, где можно строить новые пары.@footnote{На самом деле и это может
быть неправдой, поскольку размеры памяти могут стать настолько большими,
что свободная память просто не успеет исчерпаться за время жизни
компьютера. Например, в году примерно @math{3\cdot10^{13}} секунд,
так что если мы будем вызывать @code{cons} один раз в микросекунду, и у
нас будет примерно @math{10^{15}} ячеек памяти, то мы построим машину,
которая сможет работать 30 лет, пока память не кончится. По теперешним
понятиям такое количество памяти кажется абсурдно большим, однако
физически оно вполне возможно. С другой стороны, процессоры становятся
быстрее, и может быть, что в компьютерах будущего будет по многу
процессоров, работающих параллельно в единой памяти, так что память
можно будет расходовать намного быстрее, чем мы сейчас предполагаем.}
Однако большинство пар, порождаемых во время типичного вычисления,
используются только для хранения промежуточных результатов. После того,
как эти результаты обработаны, пары больше не нужны --- они становятся
(@newterm{garbage}). Например, при выполнении


@lisp
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
@end lisp

создается два списка: перечисление и результат его фильтрации. После
того, как проводится накопление, эти списки больше не нужны, и
выделенную под них память можно освободить. Если нам удастся
периодически собирать весь мусор, и память будет таким образом
освобождаться приблизительно с той же скоростью, с которой мы строим
новые пары, мы сможем поддерживать иллюзию, что у нас бесконечное
количество памяти.

Для того, чтобы освобождать пары, нужен способ определять, какие из
выделенных пар больше не нужны (в том смысле, что их содержимое не может
уже повлиять на будущее вычисления). Метод, с помощью которого мы этого
добиваемся, называется (@newterm{garbage collection}). Сборка мусора основана на
наблюдении, что в каждый момент при интерпретации Лисп-программы на
будущую судьбу вычисления могут повлиять только те объекты, до которых
можно добраться с помощью какой-нибудь последовательности операций
@code{car} и @code{cdr}, начиная с указателей, хранимых в этот момент в
регистрах машины.@footnote{Здесь мы предполагаем, что стек
представляется в виде списка, как описано в
разделе @ref{5.3.1}, так что элементы стека доступны
через указатель, хранящейся в стековом регистре.} Любую ячейку памяти,
до которой так добраться нельзя, можно освободить.

Есть множество способов сборки мусора. Метод, который мы опишем здесь,
называется @emph{остановка с копированием} (@newterm{stop-and-copy}). Основная
идея состоит в том, чтобы разделить память на две половины: <<рабочую
память>> и <<свободную память>>. Когда @code{cons} строит пары, он это
делает в рабочей памяти. Когда рабочая память заполняется, проводится
сборка мусора: мы отыскиваем все используемые пары в рабочей памяти и
копируем их в последовательные ячейки свободной памяти. (Используемые
пары ищутся просмотром всех указателей @code{car} и @code{cdr}, начиная
с машинных регистров.) Поскольку мусор мы не копируем, предполагается,
что при этом появится дополнительная свободная память, где можно
выделять новые пары. Кроме того, в рабочей памяти не осталось ничего
нужного, поскольку все полезные пары из нее скопированы в свободную
память. Таким образом, если мы поменяем роли рабочей и свободной памяти,
мы можем продолжить работу; новые пары будут выделяться в новой рабочей
памяти (бывшей свободной). Когда она заполнится, мы можем скопировать
используемые пары из нее в новую свободную память (старую
рабочую).@footnote{Эта идея была придумана и впервые реализована Минским,
как часть реализации Лиспа для машины PDP-1 в Исследовательской
лаборатории Электроники в MIT. Ее дополнили Феничель и Йохельсон
(Fenichel and Yochelson 1969) для реализации Лиспа в системе разделения
времени Multics. Позднее Бейкер (Baker 1978) разработал версию для
<<реального времени>>, в которой не требуется останавливать вычисления
на время сборки. Идею Бейкера расширили Хьюитт, Либерман и Мун
(Lieberman and Hewitt 1983), использовав то, что часть структуры более
подвижна, а часть более постоянна.

Второй часто используемый метод сборки мусора --- это (mark-sweep). Он
состоит в том, что все структуры, доступные из машинных регистров,
просматриваются и помечаются. Затем вся память просматривается, и всякий
непомеченный участок <<вычищается>> как мусор и объявляется свободным.
Полное обсуждение метода пометки с очисткой можно найти в Allen 1978.

В системах с большой памятью, как правило, используется алгоритм
Минского-Феничеля-Йохельсона, поскольку он просматривает только
используемую часть памяти. Напротив, при методе пометки с очисткой фаза
очистки должна проверять всю память. Второе преимущество остановки с
копированием состоит в том, что это (compacting) сборщик мусора. Это
означает, что в конце фазы сборки мусора все используемые данные
оказываются в последовательной области памяти, а весь мусор <<выжат>>.
На машинах с виртуальной памятью это может давать весьма большой выигрыш
в производительности, поскольку доступ к сильно различающимся адресам в
памяти может приводить к дополнительной подкачке страниц.}

@comment @subsubheading Implementation of a stop-and-copy garbage collector
@subsubheading Реализация сборщика мусора методом остановки с копированием

Теперь мы можем с помощью языка регистровых машин описать алгоритм
остановки с копированием более подробно. Предположим, что имеется
регистр @code{root}, и в нем хранится указатель на корневой объект ---
структуру, которая (через перенаправления) указывает на все доступные
данные. Такой конфигурации можно добиться, если переместить содержимое
всех регистров машины в заранее выделенный список, на который и будет
указывать @code{root}, непосредственно перед запуском сборщика
мусора@footnote{Этот список регистров не включает в себя регистры,
которые используются подсистемой выделения памяти --- @code{root},
@code{the-cars}, @code{the-cdrs} и еще несколько регистров, которые
будут введены в этом разделе.}. Кроме того, мы предполагаем, что помимо
текущей рабочей памяти имеется свободная память, в которую мы можем
копировать используемые данные. Текущая рабочая память состоит из
векторов, базовые адреса которых хранятся в регистрах @code{the-cars} и
@code{the-cdrs}, а свободная память доступна через регистры
@code{new-cars} и @code{new-cdrs}.

Сборка мусора запускается, когда кончаются свободные ячейки в текущей
рабочей памяти, то есть когда операция @code{cons} пытается сдвинуть
указатель @code{free} за пределы вектора памяти. По завершении сборки
мусора указатель @code{root} будет указывать на новую память, все
объекты, доступные через @code{root}, будут перемещены в новую
память, а указатель @code{free} будет указывать на место в новой
памяти, начиная с которого можно выделять новые пары. Кроме того,
поменяются местами роли рабочей памяти и свободной памяти --- новые
пары будут выделяться в новой памяти, начиная с места, на которое
показывает @code{free}, а (предыдущая) рабочая память будет доступна в
качестве новой памяти для следующей сборки мусора. На
рисунке @ref{Рисунок 5.15} показано устройство памяти непосредственно
перед сборкой мусора и сразу после нее.

@float[tp]
@anchor{Рисунок 5.15}
@ifinfo
@quotation
@strong{Рисунок 5.15:} Reconfiguration of memory by the garbage-collection process.

@example
             Just before garbage collection

         +------------------------------------+
the-cars |                                    | working
         | mixture of useful data and garbage | memory
the-cdrs |                                    |
         +------------------------------------+
                                            ^
                                            | free

         +------------------------------------+
new-cars |                                    | free
         |            free memory             | memory
new-cdrs |                                    |
         +------------------------------------+

             Just after garbage collection

         +------------------------------------+
new-cars |                                    | new
         |          discarded memory          | free
new-cdrs |                                    | memory
         +------------------------------------+

         +------------------+-----------------+
the-cars |                  |                 | new
         |   useful data    |    free area    | working
the-cdrs |                  |                 | memory
         +------------------+-----------------+
                              ^
                              | free
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap5/Fig5.15a,91mm,,,.pdf}
@sp 0.6
@comment @center @caption{@strong{Рисунок 5.15:} Reconfiguration of memory by the garbage-collection process.}
@center @caption{@strong{Рисунок 5.15:} Перестройка памяти~в процессе сборки мусора.}
@sp 0.0
@end iftex
@end float

Состояние процесса сборки мусора управляется содержимым двух регистров:
@code{free} и @code{scan}. Оба они сначала указывают на начало новой
памяти. При запуске алгоритма пара, на которую указывает @code{root},
переносится в начало новой памяти. Пара копируется, регистр @code{root}
переставляется в новое место, а указатель @code{free} увеличивается на
единицу. В дополнение к этому в старом месте, где хранилась пара,
делается пометка, которая говорит, что содержимое перенесено. Отметка
делается так: в позицию @code{car} мы помещаем особое значение,
показывающее, что объект перемещен. (По традиции, такой объект
называется (@newterm{broken heart}).)@footnote{Термин @emph{разбитое сердце}
придумал Дэвид Кресси, когда он писал сборщик мусора для MDL, диалекта
Лиспа, разработанного в MIT в начале 70-х годов.} В позицию @code{cdr}
мы помещаем (@newterm{forwarding address}), который указывает на место, куда
перемещен объект.

После того, как перемещен корневой объект, сборщик мусора входит в
основной цикл. На каждом шаге алгоритма регистр @code{scan} (вначале он
указывает на перемещенный корневой объект) содержит адрес пары, которая
сама перемещена в новую память, но @code{car} и @code{cdr} которой
по-прежнему указывают на объекты в старой памяти. Каждый из этих
объектов перемещается, а затем регистр @code{scan} увеличивается на
единицу. При перемещении объекта (например, того, на который указывает
@code{car} сканируемой пары) мы прежде всего проверяем, не перемещен ли
он уже (об этом нам говорит разбитое сердце в позиции @code{car}
объекта). Если объект еще не перемещен, мы переносим его в место, на
которое указывает @code{free}, увеличиваем @code{free}, записываем
разбитое сердце по старому местоположению объекта, и обновляем указатель
на объект (в нашем случае, @code{car} пары, которую мы сканируем) так,
чтобы он показывал на новое место. Если же объект уже был перемещен, то
его перенаправляющий адрес (он находится в позиции @code{cdr} разбитого
сердца) подставляется на место указателя в сканируемой паре. В конце
концов все доступные объекты окажутся перемещены и просканированы. В
этот момент указатель @code{scan} догонит указатель @code{free}, и
процесс завершится.

Алгоритм остановки с копированием можно описать как последовательность
команд регистровой машины. Базовый шаг, состоящий в перемещении объекта,
проделывается подпрограммой @code{relocate-old-result-in-new}. Эта
подпрограмма принимает свой аргумент, указатель на объект, подлежащий
перемещению, в регистре @code{old}. Она перемещает данный объект (по
пути обновляя @code{free}), помещает указатель на перемещенный объект в
регистр @code{new}, и возвращается, переходя на точку входа, хранимую в
регистре @code{relocate-continue}. В начале процесса сборки мы с помощью
этой подпрограммы перемещаем указатель @code{root}, после инициализации
@code{free} и @code{scan}. Когда @code{root} перемещен, мы записываем
новый указатель в регистр @code{root} и входим в основной цикл
сборщика мусора.

@lisp
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
@end lisp

@noindent
В основном цикле сборщика мусора нам нужно определить, есть ли еще
подлежащие сканированию объекты. Для этого мы проверяем, совпадает ли
указатель @code{scan} с указателем @code{free}. Если указатели равны,
значит, все доступные объекты перемещены, и мы переходим на
@code{gc-flip}. По этому адресу расположены восстановительные действия,
после которых можно продолжить прерванные вычисления. Если же еще есть
пары, которые требуется просканировать, мы зовем подпрограмму
перемещения для @code{car} следующей пары (при вызове мы помещаем
указатель @code{car} в регистр @code{old}). Регистр
@code{relocate-continue} устанавливается таким образом, чтобы при
возврате мы могли обновить указатель @code{car}.

@lisp
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
@end lisp

На метке @code{update-car} мы изменяем указатель @code{car} сканируемой
пары. После этого мы перемещаем ее @code{cdr}, а затем возвращаемся на
метку @code{update-cdr}. Наконец, когда @code{cdr} перемещен и обновлен,
сканирование пары закончено, и мы продолжаем главный цикл.

@lisp
update-car
  (perform (op vector-set!)
           (reg new-cars)
           (reg scan)
           (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))
update-cdr
  (perform (op vector-set!)
           (reg new-cdrs)
           (reg scan)
           (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
@end lisp

@noindent
Подпрограмма @code{relocate-old-result-in-new} перемещает объекты
следующим образом: если перемещаемый объект (на него указывает
@code{old}) не является парой, мы возвращаем указатель на него
неизменным (в регистре @code{new}). (К примеру, мы можем сканировать
пару, в @code{car} которой находится число 4. Если значение в
@code{car} представляется как @code{n4}, как описано в
разделе @ref{5.3.1}, то нам нужно, чтобы
<<перемещенный>> @code{car} по-прежнему равнялся @code{n4}.) В противном
случае требуется произвести перемещение. Если позиция @code{car}
перемещаемой пары содержит метку разбитого сердца, значит, сама пара уже
перенесена, и нам остается только взять перенаправляющий адрес (из
позиции @code{cdr} разбитого сердца) и вернуть его в регистре
@code{new}. Если же регистр @code{old} указывает на еще пе перенесенную
пару, то мы ее переносим в первую пустую ячейку новой памяти (на нее
указывает @code{free}), а затем строим разбитое сердце, записывая в
старой ячейке метку разбитого сердца и перенаправляющий адрес. Процедура
@code{relocate-old-result-in-new} хранит @code{car} или @code{cdr}
объекта, на который указывает @code{old}, в регистре
@code{oldcr}.@footnote{Сборщик мусора использует низкоуровневый предикат
@code{pointer-to-pair?} вместо обыкновенного @code{pair?}, поскольку в
настоящей системе могут иметься различные объекты, которые с точки
зрения сборщика будут являться парами. Например, в системе, которая
соответствует стандарту Scheme IEEE, объект-процедура может
реализовываться особого рода <<парой>>, которая не удовлетворяет
предикату @code{pair?}. В нашем имитаторе можно реализовать
@code{pointer-to-pair?} как @code{pair?}.}

@lisp
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) @r{; новое место для пары }
  @r{;; Обновить указатель @code{free} }
  (assign free (op +) (reg free) (const 1))
  @r{;; Скопировать @code{car} и @code{cdr} в новую память }
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  @r{;; Построить разбитое сердце }
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
@end lisp

В самом конце процесса сборки мусора мы меняем ролями старую и новую
память, обменивая указатели: @code{cars} меняется с @code{new-cars}, а
@code{cdrs} с @code{new-cdrs}. Теперь мы готовы запустить следующую
сборку, когда память опять кончится.

@lisp
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
@end lisp

@comment @section The Explicit-Control Evaluator
@section Вычислитель с явным управлением
@node	5.4, 5.5, 5.3, Chapter 5

В разделе @ref{5.1} мы видели, как простые
программы на Scheme можно преобразовывать в описания регистровых машин.
Теперь мы проделаем такое преобразование с более сложной программой ---
метациклическим интерпретатором из разделов @ref{4.1.1}--@ref{4.1.4},
который показал нам, как поведение процедур Scheme можно описать через
процедуры @code{eval} и @code{apply}. (explicit-control evaluator),
который мы разработаем в этом разделе, демонстрирует, как механизмы
вызова процедур и передачи параметров, используемые в процессе
вычисления, могут быть описаны в терминах действий, производимых над
регистрами и стеками. В дополнение к этому вычислитель с явным
управлением может служить реализацией интерпретатора Scheme, написанной
на языке, весьма близком к машинному языку обыкновенных компьютеров.
Этот вычислитель можно выполнить на имитаторе регистровых машин из
раздела @ref{5.2}. С другой стороны, его
можно использовать как основу для построения вычислителя Scheme,
написанного на машинном языке, или даже специализированной машины для
вычисления выражений на Scheme. На рисунке @ref{Рисунок 5.16}
показана такая аппаратная реализация: кремниевый чип, который работает
как вычислитель Scheme. Проектировщики чипа начали с описания путей
данных и контроллера, подобного вычислителю из этого раздела, а затем с
помощью программ автоматизированного проектирования построили разводку
интегральной микросхемы.@footnote{Информацию о микросхеме и методе ее
проектирования можно найти в Batali et al. 1982.}

@float
@quotation
@anchor{Рисунок 5.16}
@ifinfo
@strong{Рисунок 5.16:} A silicon-chip implementation of an evaluator for Scheme.

[A photograph of chip layout]

@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap5/chip,91mm,,,.jpg}
@sp 0.6
@comment @caption{@strong{Рисунок 5.16:} A silicon-chip implementation of an evaluator for Scheme.}
@caption{@strong{Рисунок 5.16:} Реализация вычисления на кремниевом чипе для Scheme.}
@sp 0.6
@end iftex
@end quotation
@end float

@comment @subsubheading Registers and operations
@subsubheading Регистры и операции

При проектировании вычислителя с явным управлением требуется указать
операции, которые будут использоваться в нашей регистровой машине.
Метациклический интерпретатор мы описали, используя абстрактный
синтаксис, с процедурами вроде @code{quoted?} и @code{make-procedure}.
При реализации регистровой машины мы могли бы развернуть эти процедуры в
последовательности элементарных операций с памятью, работающих со
списковой структурой, и уже эти операции реализовать в нашей
регистровой машине. Однако при этом вычислитель получился бы слишком
длинным, а его структура была бы загромождена мелкими деталями. Для
большей ясности представления мы будем считать элементарными операциями
регистровой машины синтаксические процедуры из раздела @ref{4.1.2}, а
также процедуры для представления окружений и прочих данных
интерпретатора из разделов @ref{4.1.3} и @ref{4.1.4}.
Для того, чтобы полностью описать вычислитель, который можно было бы
запрограммировать на машинном языке низкого уровня или реализовать
аппаратно, пришлось бы заменить эти операции более примитивными на
основе реализации списковой структуры, которую мы описали в
разделе @ref{5.3}.

Наша регистровая машина-вычислитель Scheme имеет стек и семь регистров:
@code{exp}, @code{env}, @code{val}, @code{continue}, @code{proc},
@code{argl} и @code{unev}. В регистре @code{exp} хранится выражение,
подлежащее вычислению, а в регистре @code{env} окружение, в котором
нужно это вычисление произвести. В конце вычисления @code{val} содержит
значение, полученное при вычислении выражения в указанном окружении.
Регистр @code{continue} используется для реализации рекурсии, как
описано в разделе @ref{5.1.4}.
(Вычислитель вызывает сам себя рекурсивно, поскольку вычисление
выражения требует вычисления его подвыражений.) Регистры @code{proc},
@code{argl} и @code{unev} используются при работе с комбинациями.

Мы не будем ни рисовать диаграмму путей данных, показывающую, как
связаны между собой регистры и операции, ни давать полный список
машинных операций. Эти данные можно получить из текста контроллера,
который будет представлен полностью.

@menu
* 5-4-1::            Ядро вычислителя с явным управлением
* 5-4-2::            Вычисление последовательностей и хвостовая рекурсия
* 5-4-3::            Условные выражения присваивания и определения
* 5-4-4::            Запуск вычислителя
@end menu

@comment @subsection The Core of the Explicit-Control Evaluator
@subsection Ядро вычислителя с явным управлением
@node	5.4.1, 5.4.2, 5.4, 5.4

Центральным элементом вычислителя является последовательность команд,
расположенная по метке @code{eval-dispatch}. Она соответствует процедуре
@code{eval} метациклического интерпретатора из раздела @ref{4.1.1}.
Начиная с @code{eval-dispatch}, контроллер вычисляет выражение,
хранящееся в @code{exp}, в окружении, которое содержится в @code{env}.
Когда вычисление заканчивается, контроллер переходит на точку входа,
которая хранится в @code{continue}, а значение выражения при этом
находится в @code{val}. Как и в метациклическом @code{eval}, структура
@code{eval-dispatch} представляет собой анализ случаев по
синтаксическому типу выполняемого выражения@footnote{В нашем контроллере
анализ случаев написан как последовательность команд @code{test} и
@code{branch}. Можно было бы написать его и в стиле программирования,
управляемого данными (в реальной системе так, скорее всего, и было бы
сделано). При этом исчезла бы необходимость проводить последовательные
проверки, и легче было бы определять новые типы выражений. Машина,
рассчитанная на выполнение Лисп-программ, скорее всего, имела бы команду
@code{dispatch-on-type}, которая бы эффективно выполняла выбор,
управляемый данными.}.

@lisp
eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
@end lisp

@comment @subsubheading Evaluating simple expressions
@subsubheading Вычисление простых выражений

В числах и строках (значением которых являются они сами), переменных,
закавыченных выражениях и выражениях @code{lambda} не содержится
подлежащих вычислению подвыражений. В этих случаях вычислитель попросту
помещает нужное значение в регистр @code{val} и продолжает работу с
точки, указанной в регистре @code{continue}. Вычисление простых
выражений производится следующим кодом контроллера:

@lisp
ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
  (goto (reg continue))
@end lisp

@noindent
Обратите внимание, как @code{ev-lambda} пользуется регистрами
@code{unev} и @code{exp} для параметров и тела лямбда-выражения, которые
наряду с окружением в регистре @code{env} требуется передать операции
@code{make-procedure}.

@comment @subsubheading Evaluating procedure applications
@subsubheading Вычисление вызовов процедур

Вызов процедуры описывается комбинацией, состоящей из оператора и
операндов. Оператор --- подвыражение, значением которого является
процедура, а операнды --- подвыражения, значения которых являются
аргументами, к которым процедуру следует применить. Метациклический
@code{eval} при обработке вызовов зовет себя рекурсивно и вычисляет
таким образом все элементы комбинации, а затем передает результаты в
@code{apply}, которая и осуществляет собственно применение процедуры.
Вычислитель с явным управлением ведет себя точно так же; рекурсивные
вызовы осуществляются командами @code{goto}, и при этом на стеке
сохраняются регистры, значения которых нужно восстановить после возврата
из рекурсивного вызова. Перед каждым вызовом мы тщательно смотрим, какие
именно регистры требуется сохранить (поскольку их значения потребуются
позже).@footnote{Это важная, но сложная деталь при переводе алгоритмов из
процедурного языка типа Лиспа на язык регистровой машины. В качестве
альтернативы сохранению только нужных регистров мы могли бы сохранять их
все (кроме @code{val}) перед каждым рекурсивным вызовом. Такая тактика
называется (framed-stack discipline). Она работает, но при этом
сохраняется больше регистров, чем нужно; в системе, где стековые
операции дороги, это может оказаться важным. Кроме того, сохранение
регистров, с ненужными значениями может привести к удлиннению жизни
бесполезных данных, которые в противном случае освободились бы при
сборке мусора.}

В начале обработки процедурного вызова мы вычисляем оператор и получаем
процедуру, которую позже надо будет применить к вычисленным операндам.
Для того, чтобы вычислить оператор, мы переносим его в регистр
@code{exp} и переходим на @code{eval-dispatch}. В регистре @code{env}
уже находится то окружение, в котором оператор требуется вычислить.
Однако мы сохраняем @code{env}, поскольку его значение нам еще
потребуется для вычисления операндов. Кроме того, мы переносим
операнды в регистр @code{unev} и сохраняем его на стеке. Регистр
@code{continue} мы устанавливаем так, чтобы после вычисления оператора
работа продолжилась с @code{ev-appl-did-operator}. Однако перед этим мы
сохраняем старое значение @code{continue}, поскольку оно говорит нам,
куда требуется перейти после вычисления вызова.

\enlargethispage{\baselineskip}

@lisp
ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
@end lisp

После того, как вычислено значение подвыражения-оператора, мы вычисляем
операнды комбинации и собираем их значения в список, хранимый в
регистре @code{argl}. Прежде всего мы восстанавливаем невычисленные
операнды и окружение. Мы заносим пустой список в @code{argl} как
начальное значение. Затем заносим в регистр @code{proc} процедуру,
порожденную при вычислении оператора. Если операндов нет, мы напрямую
идем в @code{apply-dispatch}. В противном случае сохраняем @code{proc}
на стеке и запускаем цикл вычисления операндов:@footnote{К процедурам
работы со структурой данных вычислителя из раздела @ref{4.1.3} мы
добавляем следующие процедуры для работы со списками аргументов:

@smalllisp
(define (empty-arglist) '())
(define (adjoin-arg arg arglist) (append arglist (list arg)))
@end smalllisp

Кроме того, мы проверяем, является ли аргумент в комбинации последним,
при помощи дополнительной синтаксической процедуры:

@smalllisp
(define (last-operand? ops)
  (null? (cdr ops)))
@end smalllisp

}

@lisp
ev-appl-did-operator
  (restore unev)                  @r{; операнды }
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))         @r{; оператор }
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
@end lisp

При каждом проходе цикла вычисления аргументов вычисляется один
аргумент, и его значение добавляется к @code{argl}. Для того, чтобы
вычислить операнд, мы помещаем его в регистр @code{exp} и переходим к
@code{eval-dispatch}, установив предварительно @code{continue} так,
чтобы вычисление продолжилось на фазе сбора аргументов. Но еще до этого
мы сохраняем уже собранные аргументы (из @code{argl}), окружение (из
@code{env}) и оставшиеся операнды, подлежащие вычислению (из
@code{unev}). Вычисление последнего операнда считается особым случаем и
обрабатывается кодом по метке @code{ev-appl-last-arg}.

@lisp
ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
@end lisp

@noindent
После того, как аргумент вычислен, его значение подсоединяется в конец
списка, который хранится в @code{argl}. Затем операнд убирается из
списка невычисленных операндов в @code{unev}, и продолжается цикл
вычисления аргументов.

@lisp
ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
@end lisp

Последний аргумент обрабатывается отдельно. Здесь нет необходимости
сохранять окружение и список невычисленных операндов перед переходом в
@code{eval-dispatch}, поскольку после вычисления последнего операнда они
не понадобятся. Поэтому после вычисления мы возвращаемся к метке
@code{ev-appl-accum-last-arg}, где восстанавливается список аргументов,
на него наращивается новый (последний) аргумент, восстанавливается
сохраненная процедура, и, наконец, происходит переход к применению
процедуры.@footnote{Оптимизация при обработке последнего аргумента
известна как (evlis tail recursion) (см. Wand 1980). Можно было бы
особым образом обрабатывать еще и первый аргумент и получить некоторую
дополнительную выгоду. Это позволило бы отложить инициализацию
@code{argl} до того времени, когда будет вычислен первый операнд, и
избежать в этом случае сохранения @code{argl}. Компилятор в
разделе @ref{5.5} проделывает эту оптимизацию. (Сравните с
процедурой @code{construct-arglist} из
раздела @ref{5.5.3}.)}

@lisp
ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
@end lisp

Детали цикла вычисления аргументов определяют порядок, в котором
интерпретатор вычисляет операнды комбинации (то есть справа налево или
слева направо --- см. упражнение @ref{Упражнение 3.8}). Этот порядок
оставался неопределенным в метациклическом интерпретаторе, который
наследует свою управляющую структуру из нижележащей Scheme, на которой
он написан.@footnote{Порядок вычисления операндов в метациклическом
интерпретаторе определяется порядком вычисления аргументов
@code{cons} в процедуре @code{list-of-values} из раздела @ref{4.1.1}
(см. упражнение @ref{Упражнение 4.1}).} Поскольку селектор
@code{first-operand} (который используется в @code{ev-appl-operand-loop}
для последовательного извлечения операндов из @code{unev}) реализован
как @code{car}, а селектор @code{rest-operands} реализуется как
@code{cdr}, вычислитель с явным управлением будет вычислять операнды
комбинации в порядке слева направо.

@comment @subsubheading Procedure application
@subsubheading Применение процедур

Точка входа @code{apply-dispatch} соответствует процедуре @code{apply}
метациклического интерпретатора. К тому времени, когда мы попадаем в
@code{apply-dispatch}, в регистре @code{proc} содержится подлежащая
применению процедура, а в регистре @code{argl} список вычисленных
аргументов, к которым ее требуется применить. Сохраненное значение
@code{continue} (исходно оно передается подпрограмме
@code{eval-dispatch}, а затем сохраняется внутри @code{ev-application}),
которое определяет, куда нам надо вернуться с результатом применения
процедуры, находится на стеке. Когда вызов вычислен, контроллер передает
управление в точку входа, указанную в сохраненном @code{continue}, а
результат при этом хранится в @code{val}. Подобно метациклическому
@code{apply}, нужно рассмотреть два случая. Либо применяемая процедура
является примитивом, либо это составная процедура.

@lisp
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
@end lisp

Мы предполагаем, что все примитивы реализованы так, что они ожидают
аргументы в регистре @code{argl}, а результат возвращают в
@code{val}. Чтобы описать, как машина обрабатывает примитивы, нам
пришлось бы дать последовательность команд, которая реализует каждый
примитив, и заставить @code{primitive-apply} переходить к этим
командам в зависимости от содержимого @code{proc}. Поскольку нас
интересуют не детали примитивов, а структура процесса вычисления, мы
вместо этого будем просто использовать операцию
@code{apply-primitive-procedure}, которая применяет процедуру,
содержащуюся в @code{proc}, к аргументам, содержащимся в @code{argl}.
Чтобы смоделировать вычислитель имитатором из раздела @ref{5.2}, мы используем
процедуру @code{apply-primitive-procedure}, которая исполняет процедуру
с помощью нижележащей Scheme-системы, как мы это делали и в
метациклическом интерпретаторе из раздела @ref{4.1.4}.
После того, как элементарная процедура вычислена, мы восстанавливаем
регистр @code{continue} и переходим на указанную точку входа.

@lisp
primitive-apply  
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
@end lisp

Чтобы применить составную процедуру, мы действуем так же, как и в
метациклическом интерпретаторе. Мы строим кадр, который связывает
параметры процедуры с ее аргументами, расширяем этим кадром окружение,
хранимое в процедуре, и в этом расширенном окружении вычисляем
последовательность выражений, которая представляет собой тело процедуры.
Подпрограмма @code{ev-sequence}, описанная ниже в разделе @ref{5.4.2}, проводит
вычисление последовательности.

@lisp
compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
@end lisp

@noindent
Подпрограмма @code{compound-apply} --- единственное место в
интерпретаторе, где регистру @code{env} присваивается новое значение.
Подобно метациклическому интерпретатору, новое окружение строится из
окружения, хранимого в процедуре, а также списка аргументов и
соответствующего ему списка связываемых переменных.

@subsection Вычисление последовательностей и хвостовая рекурсия

Сегмент кода вычислителя с явным управлением, начинающийся с метки
@code{ev-sequence}, соответствует процедуре @code{eval-sequence}
метациклического интерпретатора. Он обрабатывает последовательности
выражений в телах процедур, а также явные выражения @code{begin}.

Явные выражения @code{begin} обрабатываются так: последовательность
подлежащих выполнению выражений помещается в @code{unev}, регистр
@code{continue} сохраняется на стеке, а затем происходит переход на
@code{ev-sequence}.

@lisp
ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
@end lisp

Неявные последовательности в телах процедур обрабатываются переходом на
@code{ev-sequence} из @code{compound-apply}, причем @code{continue} в
этот момент уже находится на стеке, поскольку он был сохранен в
@code{ev-application}.

Метки @code{ev-sequence} и @code{ev-sequence-continue} образуют цикл,
который по очереди вычисляет все выражения в последовательности. Список
невычисленных пока выражений хранится в @code{unev}. Прежде, чем
вычислять каждое выражение, мы смотрим, есть ли в последовательности
после него еще выражения, подлежащие вычислению. Если да, то мы
сохраняем список невычисленных выражений (из регистра @code{unev}) и
окружение, в котором их надо вычислить (из @code{env}), а затем
вызываем @code{eval-dispatch}, чтобы вычислить выражение. После того,
как вычисление закончено, два сохраненных регистра восстанавливаются на
метке @code{ev-sequence-continue}.

Последнее выражение в последовательности обрабатывается особым образом,
на метке @code{ev-sequence-last-exp}. Поскольку после этого выражения
никаких других вычислять не требуется, не нужно и сохранять @code{unev}
и @code{env} перед переходом на @code{eval-dispatch}. Значение всей
последовательности равно значению последнего выражения, так что после
вычисления последнего выражения требуется только продолжить вычисление
по адресу, который хранится на стеке (помещенный туда из
@code{ev-application} или @code{ev-begin}). Мы не устанавливаем
@code{continue} так, чтобы вернуться в текущее место, восстановить
@code{continue} со стека и продолжить с хранящейся в нем точки входа, а
восстанавливаем @code{continue} со стека перед переходом на
@code{eval-dispatch}, так что после вычисления выражения
@code{eval-dispatch} передаст управление по этому адресу.

@lisp
ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
@end lisp

Хвостовая рекурсия
В
главе @ref{Глава 1}
мы говорили, что процесс, который описывается процедурой вроде

@lisp
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
@end lisp

итеративен. Несмотря на то, что синтаксически процедура рекурсивна
(определена через саму себя), вычислителю нет логической необходимости
сохранять информацию при переходе от одного вызова @code{sqrt-iter} к
другому@footnote{В разделе @ref{5.1} мы
видели, как такие процессы можно реализовывать с помощью регистровой
машины, не имеющей стека; состояние машины хранилось в ограниченном
количестве регистров.}. Про вычислитель, который способен вычислить
процедуру типа @code{sqrt-iter}, не требуя дополнительной памяти по мере
ее рекурсивных вызовов, говорят, что он обладает свойством (tail
recursion). Метациклическая реализация вычислителя из
главы @ref{Глава 4} не
указывает, обладает ли вычислитель хвостовой рекурсией, поскольку он
наследует механизм сохранения состояния из нижележащей Scheme. Однако в
случае вычислителя с явным управлением мы можем проследить процесс
вычисления и увидеть, когда вызовы процедур приводят к росту информации
на стеке.

Наш вычислитель обладает хвостовой рекурсией, поскольку при вычислении
последнего выражения последовательности мы напрямую переходим к
@code{eval-dispatch}, никакую информацию не сохраняя на стеке.
Следовательно, при вычислении последнего выражения
последовательности --- даже если это рекурсивный вызов (как в
@code{sqrt-iter}, где выражение @code{if}, последнего выражения в теле
процедуры, сводится к вызову @code{sqrt-iter}) --- не происходит
никакого роста глубины стека@footnote{Наша реализация хвостовой рекурсии
в @code{ev-sequence} --- вариант хорошо известного метода оптимизации,
используемого во многих компиляторах. При компиляции процедуры, которая
заканчивается вызовом процедуры, можно заменить вызов переходом на
начало вызываемой процедуры. Встраивание такой стратегии в
интерпретатор (как сделано в этом разделе) единым образом
распространяет эту оптимизацию на весь язык.}.

Мы использовали тот факт, что сохранять информацию необязательно. Если
бы мы до этого не додумались, можно было бы реализовать
@code{eval-sequence} так, что все выражения в последовательности
обрабатываются одинаково --- сохранение регистров, вычисление
выражения, возврат с сохранением регистров, и повторение до тех пор,
пока не вычислятся все выражения@footnote{Можно определить
@code{no-more-exps?} как

@lisp
(define (no-more-exps? seq) (null? seq))
@end lisp

}.

@lisp
ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
@end lisp

Может показаться, что это мелкое изменение в предыдущем коде для
выполнения последовательности: единственная разница состоит в том, что
мы проходим через цикл сохранения-восстановления для последнего
выражения последовательности так же, как и для остальных. Интерпретатор
по-прежнему будет возвращать для всех выражений то же самое значение.
Однако такое изменение теряет свойство хвостовой рекурсии, поскольку
теперь после вычисления последнего выражения в последовательности нам
придется возвращаться и отменять (бесполезные) сохранения регистров. Эти
дополнительные сохранения будут накапливаться в гнезде рекурсивных
вызовов. Следовательно, процессы вроде @code{sqrt-iter} потребуют памяти
пропорционально количеству итераций, а не фиксированного объема. Такая
разница может быть существенна. Например, при наличии хвостовой рекурсии
можно выразить бесконечный цикл с помощью одного только механизма вызова
процедур:

@lisp
(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
@end lisp

Без хвостовой рекурсии такая процедура рано или поздно исчерпает место в
стеке, а итерацию придется выражать с помощью какого-то другого
механизма помимо вызовов процедур.

@comment @subsection Conditionals, Assignments, and Definitions
@subsection Условные выражения, присваивания и определения
@node	5.4.3, 5.4.4, 5.4.2, 5.4

Как и в метациклическом интерпретаторе, особые формы обрабатываются
путем частичного выполнения частей выражения. В выражении @code{if} нам
нужно вычислить предикат, а затем на основании его значения решить,
требуется нам выполнять следствие или альтернативу.

Прежде чем вычислять предикат, мы сохраняем само выражение @code{if},
поскольку позже из него потребуется извлекать следствие либо
альтернативу. Кроме того, мы сохраняем окружение, которое потребуется
при вычислении следствия или альтернативы, и @code{continue}, который
потребуется нам при возврате значения выражению, ждущему результата
@code{if}.

@lisp
ev-if
  (save exp)                    @r{; сохраняем выражение}
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  @r{; вычисляем предикат}
@end lisp

Вернувшись после вычисления предиката, мы смотрим, является ли его
значение истиной или ложью, в зависимости от этого переносим в регистр
@code{exp} следствие либо альтернативу, и идем на @code{eval-dispatch}.
Заметим, что после восстановления @code{env} и @code{continue}
@code{eval-dispatch} будет выполняться в правильном окружении и
вернется после вычисления выражения в правильное место.

@lisp
ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
@end lisp

\enlargethispage{\baselineskip}

@comment @subsubheading Assignments and definitions
@subsubheading Присваивания и определения

Присваивания обрабатываются по метке @code{ev-assignment}, на которую
переход происходит из @code{eval-dispatch} с выражением-присваиванием в
регистре @code{exp}. Код @code{ev-assignment} сначала вычисляет значение
присваиваемого выражения, а затем заносит это значение в окружение.
Предполагается, что @code{set-variable-value!} дана как машинная
операция.

@lisp
ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                  @r{; сохранить переменную}
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch)) @r{; вычислить присваиваемое значение}
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
@end lisp

Подобным образом обрабатываются и определения:

@lisp
ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   @r{; сохранить переменную}
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  @r{; вычислить значение переменной}
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
@end lisp

@quotation
@strong{@anchor{Упражнение 5.23}Упражнение 5.23:} Расширьте вычислитель так, чтобы обрабатывались
производные выражения @code{cond}, @code{let} и тому подобные (раздел @ref{4.1.2}).
Можно <<сжульничать>> и считать, что синтаксические трансформации вроде
@code{cond->if} имеются как машинные операции.@footnote{На самом деле это
не жульничество. В настоящей реализации, построенной с нуля, мы бы на
синтаксическом этапе, происходящем раньше собственно выполнения,
интерпретировали при помощи вычислителя с явным управлением
Scheme-программу, которая производит трансформации исходного кода вроде
@code{cond->if}.}
@end quotation

@quotation
@strong{@anchor{Упражнение 5.24}Упражнение 5.24:} Реализуйте @code{cond} как новую особую форму, не сводя
его к @code{if}. Придется организовать цикл, проверяющий предикаты
последовательных ветвей @code{cond}, пока один не окажется истинным, а
затем с помощью @code{ev-sequence} выполнять действия этой ветви.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.25}Упражнение 5.25:} Измените вычислитель так, чтобы он использовал нормальный
порядок вычислений, на основе ленивого интерпретатора из раздела @ref{4.2}.
@end quotation

@comment @subsection Running the Evaluator
@subsection Запуск вычислителя
@node	5.4.4,  , 5.4.3, 5.4

Реализовав вычислитель с явным управлением, мы подходим к концу сюжета,
начатого в главе @ref{Глава 1} ---
построения все более точных моделей для процесса вычисления. Мы начали с
относительно неформальной подстановочной модели, затем в главе @ref{Глава 3}
расширили ее до модели с окружениями, позволившей работать с состоянием
и его изменением. В метациклическом интерпретаторе из главы @ref{Глава 4}
мы, используя как язык саму Scheme, сделали более явной структуру
окружений, которые строятся при вычислении выражения. Теперь, рассмотрев
регистровые машины, мы внимательнее исследовали механизмы вычислителя
для работы с памятью, передачи аргументов и управления. На каждом новом
уровне нам приходилось сталкиваться с вопросами и разрешать неясности,
которые не были заметны при предыдущем, менее строгом описании
вычислений. Для того, чтобы понять поведение вычислителя с явным
управлением, мы можем построить его имитационную модель и рассмотреть ее
работу.

Введем в нашу машину-вычислитель управляющий цикл. Он играет роль
процедуры @code{driver-loop} из раздела @ref{4.1.4}.
Вычислитель будет в цикле печатать подсказку, считывать выражение,
выполнять его с помощью перехода на @code{eval-dispatch}, и печатать
результат. Следующая группа команд стоит в начале последовательности
команд контроллера в вычислителе с явным управлением.@footnote{Мы
предполагаем, что @code{read} и различные операции печати имеются как
элементарные машинные операции. Такое предположение разумно в целях
имитации, но на практике совершенно нереалистично. Эти операции
чрезвычайно сложны. На практике они реализовывались бы с помощью
низкоуровневых операций ввода-вывода, например, посимвольного ввода и
вывода печатных знаков на устройство.

Для поддержки операции @code{get-global-environment} мы определяем

@lisp
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
@end lisp
}

@lisp
read-eval-print-loop 
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
print-result  
  (perform
   (op announce-output) (const ";;; Значение EC-Eval:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
@end lisp

@noindent
Когда мы сталкиваемся с ошибкой (например, с ошибкой <<неизвестный тип
процедуры>> из @code{apply-dispatch}), мы печатаем сообщение об ошибке и
возвращаемся в управляющий цикл.@footnote{Хотелось бы обрабатывать и
другие типы ошибок, но этого не так легко добиться.
См. упражнение @ref{Упражнение 5.30}.}

@lisp
unknown-expression-type 
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
unknown-procedure-type 
  (restore continue)    @r{; очистить стек (после @code{apply-dispatch})}
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
signal-error 
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
@end lisp

Для целей имитации мы каждый раз в начале прохождения управляющего
цикла инициализируем стек, поскольку после того, как ошибка (например,
неопределенная переменная) прерывает вычисление, он может не быть
пуст@footnote{Можно было бы инициализировать стек только после ошибок,
однако если мы это делаем в управляющем цикле, оказывается удобнее
следить за производительностью вычислителя, как это описано ниже.}.

Если мы соберем все фрагменты кода, представленные в разделах @ref{5.4.1}--@ref{5.4.4},
то можно создать модель машины-вычислителя, которая запускается
имитатором регистровых машин из раздела @ref{5.2}.

@lisp
(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
  '(read-eval-print-loop
    @math{\langle}@emph{контроллер машины, как описано выше}@math{\rangle})))
@end lisp

Требуется определить процедуры Scheme, имитирующие операции, которые
считаются элементарными в вычислителе. Это те же операции, которые
использовались в метациклическом интерпретаторе из раздела @ref{4.1},
а также несколько дополнительных, определенных в примечаниях к разделу @ref{5.4}.

@lisp
(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        @math{\langle}@emph{полный список операций машины-вычислителя}@math{\rangle}
@end lisp

Наконец, мы можем проинициализировать глобальное окружение и запустить
вычислитель:

@lisp
(define the-global-environment (setup-environment))
(start eceval)
@i{;;; Ввод EC-Eval:}
(define (append x y)
  (if (null? x) y
      (cons (car x)
            (append (cdr x) y))))
@i{;;; Значение EC-Eval:}
@i{ok}
@i{;;; Ввод EC-Eval:}
(append '(a b c) '(d e f))
@i{;;; Значение EC-Eval:}
@i{(a b c d e f)}
@end lisp

Разумеется, вычисление выражений таким образом занимает намного больше
времени, чем если их вводить напрямую в Scheme, по причине многослойной
имитации. Наши выражения выполняются регистровой машиной-вычислителем с
явным управлением, которая имитируется программой на Scheme, которая, в
свою очередь, выполняется интерпретатором Scheme.

@comment @subsubheading Monitoring the performance of the evaluator
@subsubheading Отслеживание производительности вычислителя

Имитационное моделирование может служить мощным инструментом,
помогающим в реализации вычислителей. С помощью имитации легко можно не
только исследовать варианты построения регистровых машин, но и
отслеживать производительность имитируемого вычислителя. Например, один
из важных параметров производительности состоит в том, насколько
эффективно вычислитель использует стек. Можно отследить количество
стековых операций, которые требуются для вычисления различных выражений,
если взять версию имитатора, которая собирает статистику по
использованию стека (раздел @ref{5.2.4}) и добавить на точку входа
@code{print-result} дополнительную команду, распечатывающую эту статистику:

@lisp
print-result  
  (perform (op print-stack-statistics)) @r{; добавленная команда}
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  @dots{} @r{; как и раньше}
@end lisp

Теперь работа с вычислителем выглядит так:

@lisp
@i{;;; Ввод EC-Eval:}
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
@i{(total-pushes = 3 maximum-depth = 3)}
@i{;;; Значение EC-Eval:}
@i{ok}

@i{;;; Ввод EC-Eval:}
(factorial 5)
@i{(total-pushes = 144 maximum-depth = 28)}
@i{;;; Значение EC-Eval:}
@i{120}
@end lisp

Заметим, что управляющий цикл вычислителя на каждом проходе заново
инициализирует стек, так что печатаемая статистика будет относиться
только к стековым операциям, произведенным при выполнении последнего
выражения.

@quotation
@strong{@anchor{Упражнение 5.26}Упражнение 5.26:} С помощью отслеживания стека исследуйте хвостовую
рекурсию в нашем вычислителе (раздел @ref{5.4.2}). Запустите
вычислитель и определите итеративную процедуру @code{factorial} из
раздела @ref{1.2.1}:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp

Запустите эту процедуру с несколькими небольшими значениями @math{n}.
Для каждого из этих значений запишите максимальную глубину стека и
количество операций сохранения, потребных для вычисления @math{n!}.

@enumerate a.

@item
Вы увидите, что максимальная глубина стека, нужная для вычисления
@math{n!}, от @math{n} не зависит. Какова эта глубина?

@item
Составьте на основе своих данных формулу в зависимости от @math{n} числа
операций сохранения, необходимых для вычисления @math{n!} для любого
@math{n \ge 1}. Обратите внимание, что число операций --- линейная
функция от @math{n} и, следовательно, определяется двумя константами.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.27}Упражнение 5.27:} Для сравнения с упражнением @ref{Упражнение 5.26},
изучите поведение следующей процедуры для рекурсивного вычисления
факториала:

@lisp
(define (factorial n)
  (if (= n 1) 1
      (* (factorial (- n 1)) n)))
@end lisp

Запуская эту процедуру и отслеживая поведение стека, определите как
функции от @math{n} максимальную глубину стека и общее число сохранений,
требуемых для вычисления @math{n!}, при @math{n \ge
1}. (Эти функции также будут линейны.) Опишите общие результаты
экспериментов, записав в следующую таблицу соответствующие выражения
как формулы, зависящие от @math{n}:
@ifinfo

@example
               Maximum depth       Number of pushes

Recursive
factorial

Iterative
factorial
@end example

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut 	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil \cr

				& Maximum depth & Number of pushes \cr
	\noalign{\hrule}
	Recursive 		&  		&  \cr
	factorial 		&  		&  \cr
	\noalign{\hrule}
	Iterative 		&  		&  \cr
	factorial 		&  		&  \cr
}
}$$
@end tex
Максимальная глубина служит мерой объема памяти, используемой
вычислителем при обработке выражения, а количество сохранений хорошо
коррелирует со временем вычисления.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.28}Упражнение 5.28:} Измените в определении вычислителя @code{eval-sequence}
так, как описано в разделе @ref{5.4.2}, чтобы
вычислитель перестал обладать хвостовой рекурсией. Заново проведите
эксперименты из упражнений @ref{Упражнение 5.26} и
@ref{Упражнение 5.27} и покажите, что теперь обе версии процедуры
@code{factorial} требуют количества памяти, которое линейно зависит от
значения аргумента.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.29}Упражнение 5.29:} Проследите за использованием стека в вычислении чисел
Фибоначчи с помощью древовидной рекурсии:

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
@end lisp

@enumerate a.

@item
Дайте формулу, зависящую от @math{n}, для максимальной глубины стека,
требуемой при вычислении @math{\mathop{\rm Fib}(n)} при @math{n \ge 2}.
Подсказка: в разделе @ref{1.2.2} мы
утверждали, что требуемый объем памяти линейно зависит от @math{n}.

@item
Постройте формулу для количества сохранений, требуемых при вычислении
@math{{\rm Fib}(n)}, если @math{n \ge 2}. Вы увидите,
что количество сохранений (которое хорошо коррелирует со
временем исполнения) экспоненциально растет с ростом @math{n}.
Подсказка: пусть при вычислении @math{{\rm Fib}(n)} требуется
@math{S(n)} сохранений. Нужно показать, что имеется формула, которая
выражает @math{S(n)} в зависимости от @math{S(n-1)}, @math{S(n-2)} и
некоторой фиксированной <<дополнительной>> константы @math{k},
независимой от @math{n}. Приведите эту формулу и найдите, чему равно
@code{k}. Покажите теперь, что @math{S(n)} выражается как
@math{a\mathop{\rm Fib}(n+1) + b} и укажите значения @math{a} и @math{b}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.30}Упражнение 5.30:} Наш вычислитель отлавливает только два вида ошибок (и
сообщает о них) --- неизвестные типы выражений и неизвестные типы
процедур. При других ошибках он будет выпадать из управляющего цикла.
Когда мы запускаем вычислитель с помощью имитатора регистровых машин,
эти ошибки будут пойманы нижележащей Scheme-системой. Это похоже на
<<падение>> компьютера в случае ошибки пользовательской
программы@footnote{К сожалению, в обычных компиляторных языковых системах,
например, C, это обычное дело. В @acronym{UNIX}(tm) система <<кидает дамп>>, в
@acronym{DOS}/Windows(tm) впадает в кататонию. Macintosh(tm), если повезет,
рисует на экране взрывающуюся бомбу и предлагает перегрузиться.}. Построить настоящую
систему обработки ошибок --- большой проект, но понимание, что за
вопросы здесь возникают, стоит затраченных усилий.
 
@enumerate a.

@item
При ошибках, возникающих в процессе вычисления, например, при попытке
получить значение неопределенной переменной, можно заставить операцию
просмотра окружения возвращать особый код ошибки, который не может
служить значением пользовательской переменной. Тогда вычислитель может
проверять этот код и организовывать переход на @code{signal-error}.
Найдите в вычислителе все места, где нужно провести подобные изменения,
и исправьте их. (Потребуется много работы.)

@item
Значительно тяжелее проблема, которую представляют ошибки,
возникающие в элементарных процедурах, например, попытки поделить на
ноль или взять @code{car} символа. В профессионально написанной системе
высокого качества всякий вызов примитива проверяется на безопасность
внутри процедуры-примитива. Например, при всяком вызове @code{car}
требуется проверить, что аргумент --- пара. Если аргумент не является
парой, вызов вернет особый код ошибки, который вычислитель может
проверить и сообщить об ошибке. В нашем имитаторе регистровых машин
этого можно было бы добиться, если бы мы проверяли в каждой
элементарной процедуре правильность аргументов и при необходимости
возвращали соответствующий код. В таком случае код
@code{primitive-apply} мог бы проверять этот код и, если надо,
переходить на @code{signal-error}. Постройте такую структуру и заставьте
ее работать. (Это большой проект.)

@end enumerate
@end quotation

@comment @section Compilation
@section Компиляция
@node	5.5,  , 5.4, Chapter 5

Вычислитель с явным управлением из раздела @ref{5.4} --- регистровая
машина, контроллер которой исполняет Scheme-программы. В этом разделе мы
увидим, как выполнять программы на Scheme с помощью регистровой машины,
контроллер которой не является интерпретатором Scheme.

Машина-вычислитель с явным управлением универсальна --- она способна
выполнить любой вычислительный процесс, который можно описать на Scheme.
Контроллер вычислителя выстраивает использование своих путей данных так,
чтобы исполнялось нужное вычисление. Таким образом, пути данных
вычислителя универсальны: они достаточны для того, чтобы выполнить любое
необходимое нам вычисление, если снабдить их подходящим
контроллером@footnote{Это теоретическое утверждение. Мы не говорим, что
пути данных вычислителя как-то особенно удобны или эффективны для
компьютера общего назначения. Например, они не слишком хороши для
реализации высокоскоростных вычислений с плавающей точкой или для
вычислений, интенсивно работающих с битовыми векторами.}.

Коммерческие компьютеры общего назначения представляют собой регистровые
машины, построенные на множестве регистров и операций, составляющем
эффективный и удобный набор путей данных. Контроллер машины общего
назначения --- это интерпретатор языка регистровых машин, подобный
нашему. Язык называется (@newterm{native language}) машины, или попросту
(@newterm{machine language}). Программы, написанные на машинном языке --- это
последовательности команд, использующих пути данных машины. Например,
последовательность команд вычислителя с явным управлением можно
рассматривать как программу на машинном языке компьютера общего
назначения, а не как контроллер специализированной
машины-интерпретатора.

Есть две стратегии борьбы с разрывом между языками высокого и низкого
уровня. Вычислитель с явным управлением иллюстрирует стратегию
интерпретации. Интерпретатор, написанный на внутреннем языке машины,
конфигурирует машину так, что она начинает исполнять программы на языке
(называемом (@newterm{source language)}), который может отличаться от внутреннего
языка машины, производящей вычисление. Элементарные процедуры исходного
языка реализуются в виде библиотеки подпрограмм, написанных на
внутреннем языке данной машины. Интерпретируемая программа (называемая
(@newterm{source program)}) представляется как структура данных. Интерпретатор
просматривает эту структуру и анализирует исходную программу. В процессе
анализа он имитирует требуемое поведение исходной программы, вызывая
соответствующие элементарные подпрограммы из библиотеки.

В этом разделе мы исследуем альтернативную стратегию --- (@newterm{compilation}).
Компилятор для данного исходного языка и данной машины переводит
исходную программу в эквивалентную ей программу (называемую (@newterm{object program)}),
написанную на внутреннем языке машины. Компилятор, который мы
реализуем в этом разделе, переводит программы, написанные на Scheme, в
последовательности команд, которые подлежат исполнению с помощью путей
данных машины-вычислителя с явным управлением@footnote{На самом деле,
машина, исполняющая скомпилированный код, может быть проще, чем
машина-интерпретатор, поскольку регистры @code{exp} и @code{unev} мы
использовать не будем. В интерпретаторе они использовались для хранения
невычисленных выражений. Однако при использовании компилятора эти
выражения встраиваются в компилируемый код, который будет выполняться
на регистровой машине. По той же причине нам не нужны машинные операции,
работающие с синтаксисом выражений. Однако скомпилированный код будет
использовать некоторые дополнительные машинные операции (представляющие
скомпилированные объекты-процедуры), которых не было в
машине-вычислителе с явным управлением.}.

По сравнению с интерпретацией, компиляция может дать большой выигрыш в
эффективности исполнения программы. Это будет объяснено ниже, при обзоре
компилятора. С другой стороны, интерпретатор предоставляет более мощную
среду для интерактивной разработки программы и отладки, поскольку
исполняемая исходная программа присутствует во время выполнения, и ее
можно исследовать и изменять. В дополнение к этому, поскольку библиотека
примитивов присутствует целиком, во время отладки можно конструировать и
добавлять в систему новые программы.

Исходя из взаимно дополнительных преимуществ компиляции и интерпретации,
современные среды разработки программ следуют смешанной стратегии. Как
правило, интерпретаторы Лиспа устроены таким образом, что
интерпретируемые и скомпилированные процедуры могут вызывать друг друга.
Это позволяет программисту компилировать те части программы, которые он
считает отлаженными, пользуясь при этом преимуществом в эффективности,
предоставляемом компиляцией, но при этом сохранять интерпретационный
режим выполнения для тех частей программы, которые находятся в гуще
интерактивной разработки и отладки. В разделе @ref{5.5.7}, после
того, как компилятор будет разработан, мы покажем, как построить его
взаимодействие с нашим интерпретатором и получить интегрированную
систему разработки, состоящую из компилятора и интерпретатора.

@comment @subsubheading An overview of the compiler
@subsubheading Обзор компилятора

Наш компилятор во многом похож на наш интерпретатор, как по структуре,
так и по функции, которую он осуществляет. Соответственно, механизмы
анализа выражений, используемые компилятором, будут подобны тем же
механизмам для интерпретатора. Более того, чтобы упростить
взаимодействие компилируемого и интерпретируемого кода, мы построим
компилятор так, чтобы порождаемый им код следовал тем же соглашениям,
что и интерпретатор: окружение будет храниться в регистре @code{env},
списки аргументов будут собираться в @code{argl}, применяемая
процедура --- в @code{proc}, процедуры будут возвращать свое
значение в @code{val}, а место, куда им следует вернуться, будет
храниться в регистре @code{continue}. В общем, компилятор переводит
исходную программу в объектную программу, которая проделывает, в
сущности, те же самые операции с регистрами, которые провел бы
интерпретатор при выполнении той же самой исходной программы.

Это описание подсказывает стратегию для реализации примитивного
компилятора: разбирать выражение таким же образом, как это делает
интерпретатор. Когда мы встречаем команду работы с регистром, которую
интерпретатор выполнил бы при работе с выражением, мы эту команду не
выполняем, а добавляем к порождаемой нами последовательности.
Полученная последовательность команд и будет объектным кодом. Отсюда
видно преимущество в эффективности, которое компиляция имеет перед
интерпретацией. Каждый раз, когда интерпретатор выполняет выражение ---
например, @code{(f 48 96)}, --- он проделывает работу по распознаванию
выражения (определение того, что это вызов процедуры) и проверке, не
кончился ли список операндов (определение того, что операндов два). В
случае с компилятором выражение анализируется только один раз, когда во
время компиляции порождается последовательность команд. Объектный код,
порожденный компилятором, содержит только команды, которые вычисляют
оператор и два операнда, собирают список аргументов и применяют
процедуру (из @code{proc}) к аргументам (из @code{argl}).

Это тот же самый вид оптимизации, который мы применяли в анализирующем
интерпретаторе из раздела @ref{4.1.7}.
Однако в случае компиляции имеются дополнительные возможности повысить
эффективность. Интерпретатор при работе следует процессу, который обязан
быть приложимым к любому выражению языка. В противоположность этому,
всякий данный сегмент скомпилированного кода должен вычислять только
одно выражение. Это может приводить к большой разнице, например, при
использовании стека для сохранения регистров. Интерпретатор, выполняя
выражение, должен быть готов к любым неожиданностям. При вычислении
подвыражения он сохраняет все регистры, которые понадобятся в
дальнейшем, поскольку в подвыражении могут содержаться произвольные
действия. Напротив, компилятор может пользоваться структурой конкретного
выражения и порождать код, который избегает лишних операций со стеком.

Рассмотрим в качестве примера выражение @code{(f 84 96)}.
Интерпретатор, прежде чем вычислять оператор комбинации,
подготавливается к этому вычислению и сохраняет регистры с операндами и
окружением, чьи значения ему потребуются позже. Затем интерпретатор
вычисляет оператор, получая значение в @code{val}, восстанавливает
сохраненные регистры, и, наконец, переносит @code{val} в @code{proc}.
Однако в данном конкретном вычислении оператором служит символ
@code{f}, и его вычисление осуществляется командой
@code{lookup-variable-value}, которая никаких регистров не изменяет.
Компилятор, который мы разработаем в этом разделе, пользуется этим
фактом и порождает код для вычисления оператора командой

@lisp
(assign proc (op lookup-variable-value) (const f) (reg env))
@end lisp

Этот код не только избегает ненужных сохранений и восстановлений, но и
записывает значение переменной напрямую в регистр @code{proc}, в то
время как интерпретатор сначала получает его в @code{val}, а уж затем
переносит в @code{proc}.

Кроме того, компилятор может оптимизировать доступ к среде. Во многих
случаях при анализе кода компилятор может определять, в каком кадре
будет находиться конкретная переменная, и обращаться к этому кадру
напрямую, а не через поиск @code{lookup-variable-value}. Мы рассмотрим,
как реализуется такой доступ к переменным, в
разделе @ref{5.5.6}. До тех пор, впрочем, мы
сосредоточим внимание на оптимизациях доступа к регистрам и стеку,
описанным выше. Имеются и другие виды оптимизаций, которые может
производить компилятор: например, <<вставка>> кода элементарных операций
вместо общего механизма @code{apply}
(см. упражнение @ref{Упражнение 5.38}); однако эти оптимизации мы
здесь рассматривать не будем. В этом разделе наша цель ---
проиллюстрировать процесс компиляции в упрощенном (но все же интересном)
контексте.

@menu
* 5-5-1::            Структура компилятора
* 5-5-2::            Компиляция выражений
* 5-5-3::            Компиляция комбинаций
* 5-5-4::            Сочетание последовательностей команд
* 5-5-5::            Пример скомпилированного кода
* 5-5-6::            Лексическая адресация
* 5-5-7::            Связь скомпилированного кода с вычислителем
@end menu

@comment @subsection Structure of the Compiler
@subsection Структура компилятора
@node	5.5.1, 5.5.2, 5.5, 5.5

В разделе @ref{4.1.7} мы модифицировали исходный метациклический интерпретатор
и отделили анализ от выполнения. При анализе каждого выражения порождалась
исполнительная процедура, которая в качестве аргумента принимала
окружение и проделывала требуемые операции. В компиляторе мы будем
проводить, в сущности, такой же анализ. Однако вместо исполнительных
процедур мы будем порождать последовательности команд, предназначенных
для исполнения на нашей регистровой машине.

Процедура @code{compile} проводит в компиляторе анализ верхнего уровня.
Она соответствует процедуре @code{eval} из раздела @ref{4.1.1},
процедуре @code{analyze} из раздела @ref{4.1.7}
и точке входа @code{eval-dispatch} вычислителя с явным управлением из
раздела @ref{5.4.1}.
Подобно интерпретаторам, компилятор использует процедуры разбора
синтаксиса выражений из раздела @ref{4.1.2}@footnote{Заметим,
однако, что наш компилятор является программой на Scheme, и для анализа
синтаксиса он использует те же процедуры на Scheme, которые использовал
метациклический интерпретатор. Для вычислителя с явным управлением мы,
наоборот, предполагали, что эквивалентные синтаксические операции
присутствуют как примитивы в регистровой машине. (Разумеется, когда мы
имитировали эту машину на Scheme, в модели регистровой машины мы
использовали эти же процедуры Scheme.)}. Процедура @code{compile}
проводит разбор по случаям на основе синтаксического типа выражения,
подлежащего компиляции. Для каждого типа выражения она вызывает
специальный (code generator).

@lisp
(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type: COMPILE" exp))))
@end lisp

@comment @subsubheading Targets and linkages
@subsubheading Целевые регистры и типы связи

@code{compile} и вызываемые оттуда генераторы кода принимают, помимо
подлежащего компиляции выражения, еще два аргумента. Во-первых,
(@newterm{target}), в который компилируемый код должен поместить значение
выражения. Во-вторых, (@newterm{linkage descriptor}), который описывает, что код,
который получается при компиляции, должен делать после того, как он
закончит выполняться. Описатель типа связи может потребовать одного из
трех следующих действий:

@itemize @bullet

@item
продолжить со следующей команды в последовательности (на это указывает
описатель типа связи @code{next}),

@item
вернуться из компилируемой процедуры (на это указывает описатель типа
связи @code{return}), или

@item
перейти на указанную метку (на это указывает использование метки в
качестве описателя связи).

@end itemize

@noindent
Например, компиляция выражения @code{5} (значение которого равно ему
самому) с целевым регистром @code{val} и типом связи @code{next} должна
породить команду

@lisp
(aasign val (const 5))
@end lisp

Компиляция того же самого выражения с типом связи @code{return} должна
породить команды

@lisp
(assign val (const 5))
(goto (reg continue))
@end lisp

В первом случае выполнение продолжится на следующей команде
последовательности. Во втором мы вернемся из процедуры. В обоих случаях
значение выражения будет помещено в целевой регистр @code{val}.

@comment @subsubheading Instruction sequences and stack usage
@subsubheading Последовательности команд и использование стека

Каждый генератор кода возвращает (@newterm{instruction sequence}), содержащую
порожденный для выражения объектный код. Порождение кода для составных
выражений достигается путем сочетания более простых сегментов,
порожденных генераторами кода для подвыражений, так же, как вычисление
составного выражения проходит через вычисление подвыражений.

Простейший способ сочетания последовательностей команд --- процедура под
названием @code{append-instruction-sequences}. Она принимает в качестве
аргументов произвольное число последовательностей команд, которые надо
выполнить одну за другой. Процедура склеивает их и возвращает полученную
последовательность.  а именно, если
@math{\langle}@var{seq}@math{_1\rangle} и @math{\langle}@var{seq}@math{_2\rangle} ---
последовательности команд, то вычисление

@lisp
(append-instruction-sequences @math{\langle}@var{seq}@math{_{\mono{1}}\rangle} @math{\langle}@var{seq}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
вернет последовательность

@lisp
@math{\langle}@var{seq}@math{_{\mono{1}}\rangle}
@math{\langle}@var{seq}@math{_{\mono{2}}\rangle}
@end lisp

@noindent
Когда требуется сохранять регистры, генераторы кода используют
@code{preserving}, более сложный метод сочетания последовательностей
команд. @code{Preserving} принимает три аргумента: множество регистров и
две последовательности, которые требуется выполнить одна за другой. Эта
процедура склеивает последовательности таким образом, что содержимое
всех регистров из множества сохраняется во время выполнения первой
последовательности, если оно нужно при выполнении второй. Таким образом,
если первая последовательность изменяет регистр, а второй
последовательности нужно его исходное содержимое, @code{preserving}
оборачивает вокруг первой последовательности команды @code{save} и
@code{restore} для этого регистра, прежде чем склеить
последовательности. В противном случае она просто возвращает склеенные
последовательности команд. Так, например,

@lisp
(preserving (list @math{\langle}@var{reg}@math{_{\mono{1}}\rangle} @math{\langle}@var{reg}@math{_{\mono{2}}\rangle}) @math{\langle}@var{seq}@math{_{\mono{1}}\rangle} @math{\langle}@var{seq}@math{_{\mono{2}}\rangle})
@end lisp

@noindent
порождает одну из следующих четырех последовательностей команд, в
зависимости от того, как
@math{\langle}@var{seq}@math{_1\rangle} и @math{\langle}@var{seq}@math{_2\rangle} используют
@math{\langle}@var{reg}@math{_1\rangle} и @math{\langle}@var{reg}@math{_2\rangle}:
@ifinfo

@smallexample
<seq_1> | (save <reg_1>)    | (save <reg_2>)    | (save <reg_2>)
<seq_2> | <seq_1>           | <seq_1>           | (save <reg_1>)
        | (restore <reg_1>) | (restore <reg_2>) | <seq_1>
        | <seq_2>           | <seq_2>           | (restore <reg_1>)
        |                   |                   | (restore <reg_2>)
        |                   |                   | <seq_2>
@end smallexample

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut 	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil \cr

  $\langle{\mathit{seq}_1}\rangle$
& \hbox{\tt (save} $\langle{\mathit{reg}_1}\rangle${\tt)}
& \hbox{\tt (save} $\langle{\mathit{reg}_2}\rangle${\tt)}
& \hbox{\tt (save} $\langle{\mathit{reg}_2}\rangle${\tt)} \cr

  $\langle{\mathit{seq}_2}\rangle$
& $\langle{\mathit{seq}_1}\rangle$
& $\langle{\mathit{seq}_1}\rangle$
& \hbox{\tt (save} $\langle{\mathit{reg}_1}\rangle${\tt)} \cr

& \hbox{\tt (restore} $\langle{\mathit{reg}_1}\rangle${\tt)}
& \hbox{\tt (restore} $\langle{\mathit{reg}_2}\rangle${\tt)}
& $\langle{\mathit{seq}_1}\rangle$ \cr

& $\langle{\mathit{seq}_2}\rangle$
& $\langle{\mathit{seq}_2}\rangle$
& \hbox{\tt (restore} $\langle{\mathit{reg}_1}\rangle${\tt)} \cr

&  &
& \hbox{\tt (restore} $\langle{\mathit{reg}_2}\rangle${\tt)} \cr

&  &
& $\langle{\mathit{seq}_2}\rangle$ \cr
}
}$$
@end tex

@noindent
Сочетая последовательности команд с помощью @code{preserving},
компилятор избегает лишних операций со стеком. Кроме того, при этом
забота о том, стоит ли порождать @code{save} и @code{restore}, целиком
оказывается заключенной в процедуре @code{preserving} и отделяется от
забот, которые будут нас волновать при написании отдельных генераторов
кода. В сущности, ни одна команда @code{save} или @code{restore} не
порождается генераторами кода явно.

В принципе мы могли бы представлять последовательность команд просто как
список отдельных команд. В таком случае
@code{append-instruction-sequences} могла бы склеивать
последовательности с помощью обычного @code{append} для списков. Однако
тогда @code{preserving} оказалась бы более сложной операцией, поскольку
ей пришлось бы исследовать каждую последовательность команд и выяснять,
как там используются регистры. @code{Preserving} была бы при этом
сложной и неэффективной, поскольку она анализировала бы каждый из своих
аргументов-последовательностей, при том, что сами эти последовательности
могли быть созданы вызовами @code{preserving}, и в этом случае их части
были бы уже проанализированы. Чтобы избежать такого многократного
анализа, мы с каждой последовательностью команд будем связывать
некоторую информацию о том, как она использует регистры. При порождении
элементарной последовательности мы будем указывать эту информацию явно,
а процедуры, сочетающие последовательности, будут выводить информацию об
использовании регистров для составной последовательности из информации,
связанной с ее последовательностями-компонентами.

Последовательность команд будет содержать три вида информации:

@itemize @bullet

@item
множество регистров, которые должны быть инициализированы, прежде чем
выполняются команды из последовательности (говорится, что
последовательность (needs) в этих регистрах),

@item
множество регистров, значения которых последовательность изменяет, и

@item
сами команды (называемые также (statements)) в последовательности.

@end itemize

@noindent
Мы будем представлять последовательность команд в виде списка из трех
частей. Таким образом, конструктор для последовательностей команд таков:

@lisp
(define (make-instruction-sequence
         needs modifies statements)
  (list needs modifies statements))
@end lisp

@noindent
Например, последовательность из двух команд, которая ищет значение
переменной @code{x} в текущем окружении, присваивает его @code{val}, а
затем возвращается, требует, чтобы были проинициализированы регистры
@code{env} и @code{continue}, и изменяет регистр @code{val}.
Следовательно, эту последовательность можно построить так:

@lisp
(make-instruction-sequence
 '(env continue)
 '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
@end lisp

@noindent
Иногда нам нужно будет строить последовательность без команд:

@lisp
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
@end lisp

@noindent
Процедуры для сочетания последовательностей команд приведены в
разделе @ref{5.5.4}.

@quotation
@strong{@anchor{Упражнение 5.31}Упражнение 5.31:} Во время вычисления вызова процедуры вычислитель с явным
управлением всегда сохраняет и восстанавливает регистр @code{env} при
вычислении оператора, сохраняет и восстанавливает @code{env} при
вычислении каждого операнда (кроме последнего), сохраняет и
восстанавливает @code{argl} при вычислении каждого операнда, а также
сохраняет и восстанавливает @code{proc} при вычислении
последовательности операндов. Для каждой из следующих комбинаций
скажите, какие из этих операций @code{save} и @code{restore} излишни и
могут быть исключены с помощью механизма @code{preserving}:

@lisp
(f 'x 'y)
((f) 'x 'y)
(f (g 'x) y)
(f (g 'x) 'y)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.32}Упражнение 5.32:} С помощью механизма @code{preserving} компилятор сможет
избежать сохранения и восстановления @code{env} при вычислении оператора
комбинации в случае, если это символ. Такие оптимизации можно было бы
встроить и в интерпретатор. В сущности, вычислитель с явным управлением
из раздела @ref{5.4} уже проводит одну
подобную оптимизацию, поскольку рассматривает комбинацию без операндов
как особый случай.

@enumerate a.

@item
Расширьте вычислитель с явным управлением так, чтобы он как особый
случай рассматривал комбинации, в которых оператором является символ, и
при вычислении таких выражений использовал это свойство оператора.

@item
Лиза П. Хакер говорит, что если заставить интерпретатор рассматривать
все больше особых случаев, то можно включить в него все оптимизации
компилятора, и при этом все преимущество компиляции пропадет. Каково
Ваше мнение?

@end enumerate
@end quotation

@comment @subsection Compiling Expressions
@subsection Компиляция выражений
@node	5.5.2, 5.5.3, 5.5.1, 5.5

В этом и следующем разделе мы реализуем генераторы кода, на которые
ссылается процедура @code{compile}.

@comment @subsubheading Compiling linkage code
@subsubheading Компиляция связующего кода

В общем случае результат работы каждого генератора кода будет
заканчиваться командами --- порожденными процедурой
@code{compile-linkage}, --- которые реализуют требуемый тип связи. Если
это тип @code{return}, то нам надо породить команду
@code{(goto (reg continue))}. Она нуждается в регистре @code{continue}
и никаких регистров не меняет. Если тип связи @code{next}, то никаких
дополнительных команд порождать не надо. В остальных случаях тип
связи --- переход по метке, и мы порождаем команду @code{goto} на эту
метку, команду, которая ни в чем не нуждается и не изменяет никакие
регистры@footnote{В этой процедуре используется конструкция Лиспа,
называемая (backquote) или (quasiquote), с помощью которой удобно
строить списки. Обратная кавычка перед списком работает почти так же,
как обычная, но при этом все выражения внутри списка, перед которыми
стоит запятая, вычисляются.

Например, если значение @code{linkage} равно символу @code{branch25}, то
результатом выражения

@lisp
`((goto (label ,linkage)))
@end lisp

@noindent
будет список

@lisp
((goto (label branch25)))
@end lisp

@noindent
Подобным образом, если значением @code{x} является список @code{(a b c)}, то

@lisp
`(1 2 ,(car x))
@end lisp

@noindent
дает при вычислении список

@lisp
(1 2 a).
@end lisp
}

@c For example, if the value of @code{linkage} is the symbol@* @code{branch25},
@c then the expression@* @code{`((goto (label ,linkage)))}@* evaluates to the
@c list@* @code{((goto (label branch25)))}.@* Similarly, if the value of @code{x}
@c is the list @code{(a b c)}, then@* @code{`(1 2 ,(car x))}@* evaluates to the
@c list@* @code{(1 2 a)}.}

@lisp
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
@end lisp

Связующий код добавляется к последовательности команд с сохранением
через @code{preserving} регистра @code{continue}, поскольку связь
@code{return} нуждается в этом регистре: если данная последовательность
команд изменяет @code{continue}, а связующий код в нем нуждается,
@code{continue} будет сохранен и восстановлен.

@lisp
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
@end lisp

@comment @subsubheading Compiling simple expressions
@subsubheading Компиляция простых выражений

Генераторы кода для самовычисляющихся выражений, кавычек и переменных
строят последовательности команд, которые присваивают нужное значение
целевому регистру, а затем ведут себя в соответствии с описателем
связи.

@lisp
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
@end lisp

Все эти последовательности команд изменяют целевой регистр, а для
поиска значения переменной требуется регистр @code{env}.

Присваивания и определения обрабатываются во многом так же, как в
интерпретаторе. Мы рекурсивно порождаем код, вычисляющий значение,
которое следует присвоить переменной, и присоединяем его к
последовательности из двух команд, которая собственно присваивает
значение переменной или определяет ее, а затем заносит в целевой
регистр значение всего выражения (символ @code{ok}). Рекурсивная
компиляция вызывается с целевым регистром @code{val} и типом связи
@code{next}, так что порождаемый код положит результат в регистр
@code{val}, а затем продолжит выполнение с той последовательности,
которая идет за ним. При объединении кода сохраняется @code{env},
поскольку для определения и присваивания переменной требуется
окружение, а код, вычисляющий значение переменной, может оказаться
сложным выражением, которое изменяет регистры произвольным образом.

@lisp
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Двухкомандная последовательность в конце нуждается в @code{env} и
@code{val} и изменяет свой целевой регистр. Заметим, что мы сохраняем в
последовательности @code{env}, но не сохраняем @code{val}, поскольку
@code{get-value-code} для того и нужна, чтобы поместить в @code{val}
результат, которым затем воспользуется эта последовательность. (На самом
деле сохранение @code{val} было бы ошибкой, поскольку тогда сразу после
выполнения @code{get-value-code} восстановилось бы старое значение
@code{val}.)

@comment @subsubheading Compiling conditional expressions
@subsubheading Компиляция условных выражений

Код для выражения @code{if} с указанными целевым регистром и типом связи
имеет форму

@lisp
@math{\langle}@emph{скомпилированный код для предиката с целевым регистром @emph{val} и типом связи @emph{next}}@math{\rangle}
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
@math{\langle}@emph{скомпилированный код для следствия с указанным целевым регистром и указанным типом связи либо @emph{after-if}}@math{\rangle}
false-branch
@math{\langle}@emph{скомпилированный код для альтернативы с указанными целевым регистром и типом связи}@math{\rangle}
after-if
@end lisp

@noindent
Для того, чтобы породить этот код, мы компилируем предикат, следствие и
альтернативу, а затем сочетаем то, что получилось, с командами,
проверяющими значение предиката и со свежепорожденными метками, которые
отмечают истинную ветвь, ложную ветвь и конец условного
выражения@footnote{Просто использовать метки @code{true-branch},
@code{false-branch} и @code{after-if} нельзя, потому что в программе
может быть больше одного @code{if}. Компьютер порождает метки при помощи
процедуры @code{make-label}. Она принимает символ в качестве аргумента
и возвращает новый символ, имя которого начинается с данного. Например,
последовательные вызовы @code{(make-label 'a)} будут возвращать
@code{a1}, @code{a2} и так далее. Процедуру @code{make-label} можно
написать аналогично тому, как порождаются новые имена переменных в языке
запросов, а именно:

@lisp
(define label-counter 0)
(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)
(define (make-label name)
  (string->symbol 
    (string-append (symbol->string name)
                   (number->string (new-label-number)))))
@end lisp

}. В этом блоке кода нам требуется обойти истинную ветвь, если предикат
ложен. Единственная небольшая сложность состоит в том, какой тип связи
нужно указывать для истинной ветви. Если тип связи условного выражения
@code{return} или метка, то и истинная, и ложная ветка будут этот тип и
использовать. Если же тип связи @code{next}, то истинная ветвь
заканчивается переходом, обходящим код для ложной ветви, на метку,
которая стоит в конце условного выражения.

@lisp
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))                    
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
@end lisp

@noindent
При вычислении предиката сохраняется @code{env}, поскольку он может
потребоваться в истинной и ложной ветке, и @code{continue}, поскольку
он может потребоваться связующему коду в этих ветвях. Код для истинной
и ложной ветви (которые не выполняются последовательно) склеивается с
помощью особого комбинатора @code{parallel-instruction-sequences},
описанного в разделе @ref{5.5.4}.

Заметим, что поскольку @code{cond} является производным выражением, для
его обработки компилятор должен только запустить преобразование
@code{cond->if} (@ref{4.1.2}), а затем скомпилировать получившееся выражение
@code{if}.

@comment @subsubheading Compiling sequences
@subsubheading Компиляция последовательностей

Компиляция последовательностей (тел процедур и явных выражений
@code{begin}) происходит так же, как их выполнение. Компилируется каждое
из выражений последовательности --- последнее с типом связи, который
указан для всей последовательности, а остальные с типом связи
@code{next} (для того, чтобы потом выполнялись остальные выражения
последовательности). Последовательности команд для отдельных выражений
склеиваются и образуют единую последовательность, при этом сохраняются
@code{env} (необходимый для остатка последовательности) и
@code{continue} (возможно, требуемый для связи в конце
последовательности).

@lisp
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving
        '(env continue)
        (compile (first-exp seq) target 'next)
        (compile-sequence (rest-exps seq) target linkage))))
@end lisp

@comment @subsubheading Compiling @code{lambda} expressions
@subsubheading Компиляция выражений @code{lambda}

Выражения @code{lambda} строят процедуры. Объектный код для выражения
@code{lambda} должен иметь вид

@lisp
@math{\langle}@emph{построить процедурный объект и присвоить его целевому регистру}@math{\rangle}
@math{\langle}@emph{связь}@math{\rangle}
@end lisp

Компилируя выражения @code{lambda}, мы одновременно генерируем код для
тела процедуры. Несмотря на то, что во время построения процедурного
объекта тело исполняться не будет, удобно вставить его в код сразу
после кода для @code{lambda}. Если связь для выражения
@code{lambda} --- метка или @code{return}, никаких сложностей при этом
не возникает. Если же у нас тип связи @code{next}, то нужно обойти код
для тела процедуры, использовав связь, которая переходит на метку,
вставляемую сразу вслед за телом. Таким образом, объектный код принимает
вид

@lisp
@math{\langle}@emph{построить процедурный объект и присвоить его целевому регистру}@math{\rangle}
 @math{\langle}@emph{код для указанной связи}@math{\rangle} @emph{либо} @code{(goto (label after-lambda))}
 @math{\langle}@emph{скомпилированное тело процедуры}@math{\rangle}
after-lambda
@end lisp

Процедура @code{compile-lambda} порождает код, строящий процедурный
объект, вслед за которым идет код тела процедуры. Процедурный объект
порождается во время выполнения путем сочетания текущего окружения
(окружения, в котором исполняется определение) и точки входа для
скомпилированного тела процедуры (свежесгенерированной
метки)@footnote{@anchor{Footnote 38} Нам потребуются машинные операции, которые
реализуют структуру данных, представляющую скомпилированные процедуры,
аналогичную структуре для составных процедур, описанной в
разделе @ref{4.1.3}:

@lisp
(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))
(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))
(define (compiled-procedure-entry c-proc) (cadr c-proc))
(define (compiled-procedure-env c-proc) (caddr c-proc))
@end lisp
}.

@lisp
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
@end lisp

@noindent
В @code{compile-lambda} для того, чтобы добавить тело процедуры к коду
@code{lambda}-выражения, используется специальный комбинатор
@code{tack-on-instruction-sequence} (раздел @ref{5.5.4}), а не
обыкновенный @code{append-instruction-sequences}, поскольку тело
процедуры не является частью последовательности команд, выполняемой при
входе в общую последовательность; оно стоит в последовательности только
потому, что его удобно было сюда поместить.

Процедура @code{compile-lambda-body} строит код для тела процедуры. Этот
код начинается с метки для точки входа. Затем идут команды, которые
заставят машину во время выполнения войти в правильное окружение для
вычисления тела --- то есть окружение, где определена процедура,
расширенное связываниями формальных параметров с аргументами, с которыми
она вызвана. Затем следует код для последовательности выражений,
составляющих тело процедуры. Последовательность эта компилируется с
типом связи @code{return} и целевым регистром @code{val}, так что она
закончится возвратом из процедуры с результатом в регистре @code{val}.

@lisp
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
@end lisp

@comment @subsection Compiling Combinations
@subsection Компиляция комбинаций
@node	5.5.3, 5.5.4, 5.5.2, 5.5

Соль процесса компиляции заключается в компилировании вызовов процедур.
Код для комбинации, скомпилированный с данными целевым регистром и типом
связи, имеет вид

@lisp
@math{\langle}@emph{скомпилированный код оператора с целевым регистром @emph{proc} и типом}
@emph{связи @emph{next}}@math{\rangle}
@math{\langle}@emph{вычисление операндов и построение списка аргументов в @emph{argl}}@math{\rangle}
@math{\langle}@emph{скомпилированный код вызова процедуры с указанными целевым}
@emph{регистром и типом связи}@math{\rangle}
@end lisp

@noindent
Во время вычисления оператора и операндов может потребоваться сохранить
и восстановить регистры @code{env}, @code{proc} и @code{argl}. Заметим,
что это единственное место в компиляторе, где указывается целевой
регистр, отличный от @code{val}.

Требуемый код порождается процедурой @code{compile-application}. Она
рекурсивно компилирует оператор, порождая код, который помещает
подлежащую вызову процедуру в @code{proc}, и операнды, порождая код,
который по одному вычисляет операнды процедурного вызова.
Последовательности команд для операндов собираются (в процедуре
@code{construct-arglist}) вместе с кодом, который строит список
аргументов в регистре @code{argl}, а полученный код для порождения
списка аргументов склеивается с кодом вычисления процедуры и кодом,
который производит собственно вызов (он порождается с помощью
@code{compile-procedure-call}). При склеивании последовательностей
команд требуется сохранить регистр @code{env} на время вычисления
оператора (поскольку в это время @code{env} может измениться, а он еще
потребуется во время вычисления операндов), а регистр @code{proc}
требуется сохранить на время построения списка аргументов (при
вычислении операндов @code{proc} может измениться, а он потребуется во
время собственно вызова процедуры). Наконец, все время следует сохранять
@code{continue}, поскольку этот регистр нужен для связующего кода.

@lisp
(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
@end lisp

@noindent
Код для построения списка аргументов вычисляет каждый операнд, помещая
результат в @code{val}, а затем с помощью @code{cons} прицепляет его к
списку аргументов, собираемому в @code{argl}. Поскольку мы по очереди
нацепляем аргументы на @code{argl} через @code{cons}, нам нужно начать с
последнего аргумента и закончить первым, чтобы в получившемся списке
аргументы стояли в порядке от первого к последнему. Чтобы не тратить
команду на инициализацию @code{argl} пустым списком, прежде чем начать
последовательность вычислений, мы строим исходное значение
@code{argl} в первом участке кода. Таким образом, общая форма
построения списка аргументов такова:

@lisp
@math{\langle}@emph{компиляция последнего операнда с целью @emph{val}}@math{\rangle}
(assign argl (op list) (reg val))
@math{\langle}@emph{компиляция следующего аргумента с целью @emph{val}}@math{\rangle}
(assign argl (op cons) (reg val) (reg argl))
@dots{}
@math{\langle}@emph{компиляция первого аргумента с целью @emph{val}}@math{\rangle}
(assign argl (op cons) (reg val) (reg argl))
@end lisp

Нужно сохранять @code{argl} при вычислении всех операндов, кроме как в
самом начале (чтобы уже набранные аргументы не потерялись), а при
вычислении всех операндов, кроме как в самом конце, нужно сохранять
@code{env} (его могут использовать последующие вычисления операндов).

Компилировать код для аргументов довольно сложно, поскольку особым
образом обрабатывается первый вычисляемый операнд, и в различных местах
требуется сохранять @code{argl} и @code{env}. Процедура
@code{construct-arglist} принимает в качестве аргументов участки кода,
которые вычисляют отдельные операнды. Если никаких операндов нет вообще,
она попросту порождает команду

@lisp
(assign argl (const ()))
@end lisp

В остальных случаях @code{construct-arglist} порождает код, инициализирующий
@code{argl} последним аргументом, и добавляет к нему код, который по очереди
вычисляет остальные аргументы и добавляет их к @code{argl}. Для того,
чтобы аргументы обрабатывались от конца к началу, нам следует обратить
список последовательностей кода для операндов, подаваемый из
@code{compile-application}.

@lisp
(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
@end lisp

@endpage
@comment @subsubheading Applying procedures
@subsubheading Применение процедур

После того, как элементы комбинации вычислены, скомпилированный код
должен применить процедуру из регистра @code{proc} к аргументам из
регистра @code{argl}. Этот код рассматривает, в сущности, те же самые
случаи, что и процедура @code{apply} из метациклического
интерпретатора в разделе @ref{4.1.1} или точка входа @code{apply-dispatch}
из вычислителя с явным управлением в разделе @ref{5.4.1}.
Нужно проверить какая процедура применяется --- элементарная или
составная. В случае элементарной процедуры используется
@code{apply-primitive-procedure}; как ведется работа с составными
процедурами, мы скоро увидим. Код применения процедуры имеет такую
форму:

@lisp
(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 @math{\langle}@emph{код для применения скомпилированной процедуры с указанной целью}
 @emph{и подходящим типом связи}@math{\rangle}
primitive-branch
 (assign @math{\langle}@var{целевой регистр}@math{\rangle}
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 @math{\langle}@var{связующий код}@math{\rangle}
after-call
@end lisp

Заметим, что если выбрана ветвь для скомпилированной процедуры, машина
должна обойти ветвь для элементарной процедуры. Следовательно, если тип
связи для исходного вызова процедуры был @code{next}, ветвь для
составной процедуры должна использовать связь с переходом на метку,
стоящую после ветви для элементарной процедуры. (Подобным образом
работает связь для истинной ветви в @code{compile-if}.)

@lisp
(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
@end lisp

Ветви для элементарных и составных процедур, подобно истинной и ложной
ветвям в @code{compile-if}, склеиваются через
@code{parallel-instruction-sequences}, а не обыкновенной
@code{append-instruction-sequences}, поскольку они не выполняются
последовательно.

@comment @subsubheading Applying compiled procedures
@subsubheading Применение скомпилированных процедур

Код, обрабатывающий применение процедур, --- наиболее тонко устроенная
часть компилятора, при том, что он порождает очень короткие
последовательности команд. У скомпилированной процедуры (порожденной с
помощью @code{compile-lambda}) имеется точка входа, то есть метка,
указывающая, где начинается тело процедуры. Код, расположенный по этой
метке, вычисляет результат, помещая его в @code{val}, а затем
возвращается, исполняя команду @code{(goto (reg continue))}. Таким
образом, если в качестве связи выступает метка, мы можем ожидать, что
код для вызова скомпилированной процедуры (порождаемый с помощью
@code{compile-proc-appl}) с указанным целевым регистром будет выглядеть
так:

@lisp
(assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign @math{\langle}@var{целевой регистр}@math{\rangle} (reg val)) @r{; включается, если целевой регистр не @code{val}}
 (goto (label @math{\langle}@var{связующий код}@math{\rangle}))               @r{; связующий код}
@end lisp

либо, если тип связи @code{return}, так:

@lisp
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign @math{\langle}@var{целевой регистр}@math{\rangle} (reg val)) @r{; включается, если целевой регистр не @code{val}}
 (restore continue)
 (goto (label @math{\langle}@var{связующий код}@math{\rangle}))               @r{; связующий код}
@end lisp

Этот код устанавливает @code{continue} так, чтобы процедура вернулась на
метку @code{proc-return}, а затем переходит на входную точку процедуры.
Код по метке @code{proc-return} переносит результат процедуры из
@code{val} в целевой регистр (если нужно), а затем переходит в место,
определяемое типом связи. (Связь всегда @code{return} или метка,
поскольку процедура @code{compile-procedure-call} заменяет связь
@code{next} для ветви составной процедуры на переход к метке
@code{after-call}.)

На самом деле, если целевой регистр не равен @code{val}, то именно такой
код наш компилятор и породит@footnote{Мы сообщаем об ошибке, если
целевой регистр не @code{val}, а тип связи @code{return}, поскольку
единственное место, где мы требуем связи @code{return} --- это
компиляция процедур, а по нашему соглашению процедуры возвращают
значение в регистре @code{val}.}. Однако чаще всего целевым регистром
является @code{val} (единственное место, в котором компилятор
заказывает другой целевой регистр --- это когда вычисление оператора
имеет целью @code{proc}), так что результат процедуры помещается прямо в
целевой регистр, и возвращаться в особое место, где он копируется,
незачем. Вместо этого мы упрощаем код, так устанавливая @code{continue},
что процедура <<возвращается>> прямо на то место, которое указано типом
связи вызывающего кода:

@lisp
@math{\langle}@emph{установить @code{continue} в соответствии с типом вызова}@math{\rangle}
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

Если в качестве связи указана метка, мы устанавливаем @code{continue}
так, что возврат происходит на эту метку. (Таким образом, в приведенной
выше @code{proc-return}, команда @code{(goto (reg continue))}, которой
кончается процедура, оказывается равносильной
@code{(goto (label @math{\langle}@var{связь}@math{\rangle}))}.)

@lisp
(assign continue (label @math{\langle}@var{связь}@math{\rangle}))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

Если тип связи у нас @code{return}, нам вообще ничего не надо делать с
@code{continue}: там уже хранится нужное место возврата. (То есть
команда @code{(goto (reg continue))}, которой заканчивается процедура,
переходит прямо туда, куда перешла бы @code{(goto (reg-continue))},
расположенная по метке @code{proc-return}.)

@lisp
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
@end lisp

При такой реализации типа связи @code{return} компилятор порождает код,
обладающий свойством хвостовой рекурсии. Вызов процедуры, если это
последнее действие в теле процедуры, приводит к простой передаче
управления, когда на стек ничего не кладется.

Предположим, однако, что мы реализовали случай вызова процедуры с типом
связи @code{return} и целевым регистром @code{val} так, как показано
выше для случая с целью не-@code{val}. Хвостовая рекурсия оказалась бы
уничтожена. Наша система по-прежнему вычисляла бы то же значение для
всех выражений. Однако при каждом вызове процедур мы сохраняли бы
@code{continue}, а после вызова возвращались бы для (ненужного)
восстановления. В гнезде рекурсивных вызовов эти дополнительные
сохранения накапливались бы@footnote{Казалось бы, заставить компилятор
порождать код с хвостовой рекурсией --- естественная идея. Однако
большинство компиляторов для распространенных языков, включая C и
Паскаль, так не делают, и, следовательно, в этих языках итеративный
процесс нельзя представить только через вызовы процедур. Сложность с
хвостовой рекурсией в этих языках состоит в том, что их реализации
сохраняют на стеке не только адрес возврата, но еще и аргументы процедур
и локальные переменные. Реализации Scheme, описанные в этой книге,
хранят аргументы и переменные в памяти и подвергают их сборке мусора.
Причина использования стека для переменных и аргументов --- в том, что
при этом можно избежать сборки мусора в языках, которые не требуют ее
по другим причинам, и вообще считается, что так эффективнее. На самом
деле изощренные реализации Лиспа могут хранить аргументы на стеке, не
уничтожая хвостовую рекурсию. (Описание можно найти в Hanson 1990.)
Кроме того, ведутся споры о том, правда ли, что выделение памяти на
стеке эффективнее, чем сборка мусора, но тут результат, кажется, зависит
от тонких деталей архитектуры компьютера. (См. Appel 1987 и Miller and
Rozas 1994, где по этому вопросу высказываются противоположные
мнения.)}.

При порождении вышеописанного кода для применения процедуры
@code{compile-proc-appl} рассматривает четыре случая, в зависимости от
того, является ли @code{val} целевым регистром, и от того, дан ли нам
тип связи @code{return}. Обратите внимание: указано, что эти
последовательности команд изменяют все регистры, поскольку при
выполнении тела процедуры регистрам разрешено меняться как
угодно@footnote{Значением переменной @code{all-regs} является список
имен всех регистров:

@lisp
(define all-regs '(env proc val argl continue))
@end lisp
}. Заметим, кроме того, что в случае с целевым регистром @code{val} и
типом связи @code{return} говорится, что участок кода нуждается в
@code{continue}: хотя в этой двухкомандной последовательности
@code{continue} явно не упоминается, нам нужно знать, что при входе в
скомпилированную процедуру @code{continue} будет содержать правильное
значение.

@lisp
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "Тип связи return, цель не val -- COMPILE"
                target))))
@end lisp

@comment @subsection Combining Instruction Sequences
@subsection Сочетание последовательностей команд
@node	5.5.4, 5.5.5, 5.5.3, 5.5

В этом разделе в деталях описывается представление последовательностей
команд и их сочетание друг с другом. Напомним, что в
разделе @ref{5.5.1} мы решили, что
последовательность представляется в виде списка, состоящего из
множества требуемых регистров, множества изменяемых регистров, и
собственно кода. Кроме того, мы будем считать метку (символ) особым
случаем последовательности, которая не требует и не изменяет никаких
регистров. Таким образом, для определения регистров, в которых нуждается
и которые изменяет данная последовательность, мы пользуемся селекторами

@lisp
(define (registers-needed s)
  (if (symbol? s) '() (car s)))
(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
@end lisp

а для того, чтобы выяснить, нуждается ли последовательность в регистре
и изменяет ли она его, используются предикаты

@lisp
(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
@end lisp

С помощью этих селекторов и предикатов мы можем реализовать все
многочисленные комбинаторы последовательностей команд, которые
используются в тексте компилятора.

Основным комбинатором является @code{append-instruction-sequences}. Он
принимает как аргументы произвольное число последовательностей команд,
которые следует выполнить последовательно, а возвращает
последовательность команд, предложениями которой служат предложения всех
последовательностей, склеенные вместе. Сложность состоит в том, чтобы
определить регистры, которые требуются, и регистры, которые
изменяются в получаемой последовательности. Изменяются те регистры,
которые изменяются в какой-либо из подпоследовательностей; требуются те
регистры, которые должны быть проинициализированы прежде, чем можно
запустить первую подпоследовательность (регистры, требуемые первой
подпоследовательностью), а также регистры, которые требует любая из
оставшихся подпоследовательностей, не измененные (проинициализированные)
одной из подпоследовательностей, идущих перед ней.

Последовательности сливаются по две процедурой @code{append-2-sequences}.
Она берет две последовательности команд
@code{seq1} и @code{seq2}, и возвращает последовательность команд, в
которой предложениями служат предложения @code{seq1}, а затем в конце
добавлены предложения @code{seq2}. Ее изменяемые регистры --- те,
которые изменяет либо @code{seq1}, либо @code{seq2}, а требуемые
регистры --- те, что требует @code{seq1} плюс те, что требует
@code{seq2} и не изменяет @code{seq1}. (В терминах операций над
множествами, новое множество требуемых регистров является объединением
множества требуемых регистров @code{seq1} с множественной разностью
требуемых регистров @code{seq2} и изменяемых регистров @code{seq1}.)
Таким образом, @code{append-instruction-sequences} реализуется так:

@lisp
(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
@end lisp

В этой процедуре используются некоторые операции для работы с
множествами, представленными в виде списков, подобные
(неотсортированному) представлению множеств, описанному в разделе @ref{2.3.3}:

@lisp
(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
@end lisp

@noindent
Второй основной комбинатор последовательностей команд,
@code{preserving}, принимает список регистров @code{regs} и две
последовательности команд @code{seq1} и @code{seq2}, которые следует
выполнить последовательно. Он возвращает последовательность команд, чьи
предложения --- это предложения @code{seq1}, за которыми идут
предложения @code{seq2}, с командами @code{save} и @code{restore} вокруг
@code{seq1}, для того, чтобы защитить регистры из множества @code{regs},
изменяемые в @code{seq1}, но требуемые в @code{seq2}. Для того, чтобы
построить требуемую последовательность, сначала @code{preserving}
создает последовательность, содержащую требуемые команды @code{save},
команды из @code{seq1} и команды @code{restore}. Эта последовательность
нуждается в регистрах, которые подвергаются
сохранению/восстановлению, а также регистрах, требуемых @code{seq1}.
Она изменяет регистры, которые меняет @code{seq1}, за исключением тех,
которые сохраняются и восстанавливаются. Затем эта дополненная
последовательность и @code{seq2} сочетаются обычным образом. Следующая
процедура реализует эту стратегию рекурсивно, двигаясь по списку
сохраняемых регистров@footnote{Заметим, что @code{preserving} зовет
@code{append} с тремя аргументами. Хотя определение @code{append},
приводимое в этой книге, принимает только два аргумента, в стандарте
Scheme имеется процедура @code{append}, принимающая любое их
количество.}:

@lisp
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
@end lisp

@noindent
Еще один комбинатор последовательностей,
@code{tack-on-instruction-sequence}, используется в
@code{compile-lambda} для того, чтобы добавить тело процедуры к другой
последовательности. Поскольку тело процедуры не находится <<в потоке
управления>> и не должно выполняться как часть общей последовательности,
используемые им регистры никак не влияют на регистры, используемые
последовательностью, в которую оно включается. Таким образом, когда мы
добавляем тело процедуры к другой последовательности, мы игнорируем его
множества требуемых и изменяемых регистров.

@lisp
(define (tack-on-instruction-sequence seq body-seq) 
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
@end lisp

В процедурах @code{compile-if} и @code{compile-procedure-call}
используется специальный комбинатор
@code{parallel-instruction-sequences}, который склеивает две
альтернативные ветви, следующие за тестом. Эти две ветви никогда не
исполняются одна за другой; при каждом исполнении теста будет запущена
либо одна, либо другая ветвь. Поэтому регистры, требуемые во второй
ветви, по-прежнему требуются составной последовательности, даже если
первая ветвь их изменяет.

@lisp
(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
@end lisp

@comment @subsection An Example of Compiled Code
@subsection Пример скомпилированного кода
@node	5.5.5, 5.5.6, 5.5.4, 5.5

Теперь, когда мы рассмотрели все элементы компилятора, можно разобрать
пример скомпилированного кода и увидеть, как сочетаются его элементы. Мы
скомпилируем определение рекурсивной процедуры @code{factorial} с
помощью вызова @code{compile}:

@lisp
(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
@end lisp

Мы указали, что значение выражения @code{define} требуется поместить в
регистр @code{val}. Нам неважно, что будет делать скомпилированный код
после того, как будет выполнено @code{define}, так что выбор
@code{next} в качестве типа связи произволен.

Процедура @code{compile} распознает выражение как определение, так что
она зовет @code{compile-definition}, чтобы породить код для вычисления
присваиваемого значения (с целью @code{val}), затем код для внесения
определения в среду, затем код, который помещает значение @code{define}
(символ @code{ok}) в целевой регистр, и, наконец, связующий код. При
вычислении значения сохраняется @code{env}, поскольку этот регистр
требуется, чтобы внести определение в среду. Поскольку тип связи у нас
@code{next}, никакого связующего кода не порождается. Таким образом,
скелет скомпилированного кода таков:

@lisp
@math{\langle}@emph{сохранить @emph{env}, если его изменяет код для вычисления значения}@math{\rangle}
@math{\langle}@emph{скомпилированный код для значения определения, цель @emph{val}, связь @emph{next}}@math{\rangle}
@math{\langle}@emph{восстановить @emph{env}, если он сохранялся}@math{\rangle}
(perform (op define-variable!)
         (const factorial)
         (reg val)
         (reg env))
(assign val (const ok))
@end lisp

@noindent
Выражение, которое нужно скомпилировать, чтобы получить значение
переменной @code{factorial} --- это выражение @code{lambda}, и
значением его является процедура, вычисляющая факториалы. @code{Compile}
обрабатывает его путем вызова @code{compile-lambda}.
@code{Compile-lambda} компилирует тело процедуры, снабжает его меткой
как новую точку входа и порождает команду, которая склеит тело процедуры
по новой метке с окружением времени выполнения и присвоит значение
регистру @code{val}. Затем порожденная последовательность перепрыгивает
через скомпилированный код, который вставляется в этом месте. Сам код
процедуры начинается с того, что окружение, где процедура определена,
расширяется кадром, в котором формальный параметр @code{n} связывается
с аргументом процедуры. Затем идет собственно тело процедуры. Поскольку
код для определения значения переменной не изменяет регистр @code{env},
команды @code{save} и @code{restore}, которые показаны выше как
возможные, не порождаются. (В этот момент не выполняется код процедуры
по метке @code{entry2}, так что детали его работы с @code{env} значения
не имеют.) Следовательно, наш скелет скомпилированного кода становится
таким:

@lisp
(assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  @math{\langle}@emph{скомпилированный код тела процедуры}@math{\rangle}
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
@end lisp

Тело процедуры всегда компилируется (в @code{compile-lambda-body}) как
последовательность команд с целевым регистром @code{val} и типом связи
@code{return}. В данном случае в последовательности одно выражение
@code{if}:

@lisp
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
@end lisp

@code{сompile-if} порождает код, который сначала вычисляет предикат (с
целью @code{val}), затем проверяет его значение и, если предикат ложен,
обходит истинную ветвь. При вычислении предиката сохраняются @code{env}
и @code{continue}, поскольку они могут потребоваться в оставшейся части
выражения @code{if}. Поскольку выражение @code{if} последнее (и
единственное) в последовательности, составляющей тело процедуры, оно
имеет цель @code{val} и тип связи @code{return}, так что и истинная, и
ложная ветви компилируются с целью @code{val} и типом связи
@code{return}. (Это значит, что значение условного выражения, которое
вычисляется одной из его ветвей, является значением процедуры.)

@lisp
@math{\langle}@emph{сохранить @emph{continue}, @emph{env}, если они изменяются предикатом и требуются в ветвях}@math{\rangle}
  @math{\langle}@emph{скомпилированный код предиката, цель @emph{val}, связь @emph{next}}@math{\rangle}
  @math{\langle}@emph{восстановить @emph{continue}, @emph{env}, если они сохранялись}@math{\rangle}
  (test (op false?) (reg val))
  (branch (label false-branch4)
true-branch5
  @math{\langle}@emph{скомпилированный код истинной ветви, цель @emph{val}, связь @emph{return}}@math{\rangle}
false-branch4
  @math{\langle}@emph{скомпилированный код ложной ветви, цель @emph{val}, связь @emph{return}}@math{\rangle}
after-if3
@end lisp

Предикат @code{(= n 1)} является вызовом процедуры. Он ищет в окружении
оператор (символ @code{=}) и помещает его значение в @code{proc}. Затем
он собирает аргументы --- @code{1} и значение @code{n}, --- в
@code{argl}. Затем он проверяет, лежит ли в @code{proc} примитив или
составная процедура, и соответствующим образом переходит на ветвь
элементарной или составной процедуры. Обе ветви приводят к метке
@code{after-call}. Требование сохранять регистры при вычислении
оператора и операндов не приводит ни к каким операциям сохранения,
поскольку в этом случае вычисления не трогают нужные регистры.

@lisp
(assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call15
@end lisp

Истинная ветвь, константа 1, компилируется (с целевым регистром
@code{val} и типом связи @code{return}) в

@lisp
(assign val (const 1))
  (goto (reg continue))
@end lisp

Код для ложной ветви является еще одним вызовом процедуры, где
процедурой служит значение символа @code{}, а аргументами --- @code{n}
и значение еще одного вызова (вызова @code{factorial}). Каждый из этих
вызовов устанавливает значения @code{proc} и @code{argl}, а также свои
собственные ветви для элементарных и составных процедур. На
рисунке @ref{Рисунок 5.17} показан полный скомпилированный код для
определения процедуры @code{factorial}. Заметим, что возможные команды
@code{save} и @code{restore} для @code{continue} и @code{env} при
вычислении предиката, указанные выше, на самом деле порождаются,
поскольку эти регистры изменяются во время вызова процедуры в предикате
и нужны для вызова процедуры и связи @code{return} в ветвях.

@quotation
@strong{@anchor{Упражнение 5.33}Упражнение 5.33:} Рассмотрим следующее определение процедуры для вычисления
факториала, которое незначительно отличается от рассмотренного в тексте:

@lisp
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
@end lisp

Скомпилируйте эту процедуру и сравните получившийся код с кодом для
@code{factorial}. Объясните обнаруженные различия. Есть ли разница в
эффективности программ?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.34}Упражнение 5.34:} Скомпилируйте итеративную процедуру вычисления факториала:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
@end lisp

Прокомментируйте полученный код и покажите существенное различие между
кодом для итеративной и рекурсивной версий @code{factorial}, благодаря
которому один процесс наращивает глубину стека, а второй выполняется при
фиксированной глубине.
@end quotation

@quotation
@strong{@anchor{Рисунок 5.17}Figure 5.17:} @math{\downarrow} Скомпилированный код определения процедуры @code{factorial}. Окончание.

@smalllisp
@r{;; построить процедуру и обойти ее тело}
  (assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
entry2     @r{; вызовы @code{factorial} будут попадать сюда}
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env 
          (op extend-environment) (const (n)) (reg argl) (reg env))
@r{;; начинается собственно тело процедуры}
  (save continue)
  (save env)
@r{;; вычислить @code{(= n 1)}}
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto reg val)
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call15   @r{; здесь @code{val} содержит результат @code{(= n 1)}}
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  @r{; вернуть 1 }
  (assign val (const 1))
  (goto (reg continue))
false-branch4
@r{;; вычислить и вернуть  @code{(* (factorial (- n 1) n))}}
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   @r{; сохранить процедуру @code{ *}}
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   @r{; сохранить частичный список аргументов для @code{ *}}
@r{;; вычислить  @code{(factorial (- n 1))}, еще один аргумент @code{ *}}
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  @r{; сохранить процедуру @code{ factorial}}
@r{;; вычислить @code{ (- n 1)}, аргумент @code{ factorial}}
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call6   @r{; теперь в @code{val} содержится результат @code{(- n 1)}}
  (assign argl (op list) (reg val))
  (restore proc)  @r{; восстановить @code{factorial}}
@r{;; применить @code{factorial}}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call9       @r{; теперь @code{val} содержит результат @code{(factorial (- n 1))}}
  (restore argl)  @r{; восстановить частичный список аргументов для @code{*}}
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)  @r{; восстановить @code{*}}
  (restore continue)
@r{;; применить @code{*} и вернуть}
@r{;; его результат}
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
@r{;; обратите внимание:} 
@r{;; скомпилированная процедура здесь зовется}
@r{;; с хвостовой рекурсией}
(assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
@r{;; присвоить процедуру переменной @code{factorial}}
  (perform 
        (op define-variable!)
        (const factorial)
        (reg val)
        (reg env))
  (assign val (const ok))
@end smalllisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.35}Упражнение 5.35:} При компиляции какого выражения был получен код на
рисунке @ref{Рисунок 5.18}?
@end quotation

@quotation
@strong{@anchor{Рисунок 5.18}Figure 5.18:} @math{\downarrow} Пример вывода компилятора. Смотри @ref{Exercise 5.35}.

@smalllisp
(assign val
        (op make-compiled-procedure)
        (label entry16)
        (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment)
          (const (x))
          (reg argl)
          (reg env))
  (assign proc
          (op lookup-variable-value)
          (const +)
          (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc
          (op lookup-variable-value)
          (const g)
          (reg env))
  (save proc)
  (assign proc
          (op lookup-variable-value)
          (const +)
          (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value)
          (const x)
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val
          (op lookup-variable-value)
          (const x)
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!)
           (const f)
           (reg val)
           (reg env))
  (assign val (const ok))
@end smalllisp

@end quotation

@quotation
@strong{@anchor{Упражнение 5.36}Упражнение 5.36:} Какой порядок вычисления задает наш компилятор для
операндов комбинации --- слева направо, справа налево, или какой-либо
иной? Где в компиляторе задается этот порядок? Измените компилятор так,
чтобы он порождал какой-нибудь другой порядок вычисления. (См.
обсуждение порядка вычисления для вычислителя с явным управлением из
раздела @ref{5.4.1}.) Как
смена порядка вычисления операндов влияет на эффективность кода, который
строит список аргументов?
@end quotation

@quotation
@strong{@anchor{Упражнение 5.37}Упражнение 5.37:} Вот один из способов понять, как механизм
@code{preserving} оптимизирует использование стека: рассмотреть, какие
дополнительные операции порождались бы, если бы мы этот механизм не
использовали. Измените @code{preserving} так, чтобы операции @code{save}
и @code{restore} порождались всегда. Скомпилируйте несколько простых
выражений и отметьте ненужные операции со стеком, которые станут
порождаться. Сравните этот код с тем, который порождается, если механизм
@code{preserving} присутствует.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.38}Упражнение 5.38:} Наш компилятор тщательно избегает ненужных операций со
стеком, но с точки зрения перевода вызовов элементарных процедур
языка в операции машины он очень слаб. Рассмотрим, например, сколько
кода порождается для вычисления @code{(+ a 1)}: код порождает список
аргументов в @code{argl}, помещает элементарную процедуру сложения
(которую он находит через поиск символа @code{+} в окружении) в
@code{proc}, затем проверяет, является ли эта процедура элементарной или
составной. Компилятор всегда порождает код этой проверки, а также код
для ветви элементарной процедуры и ветви составной процедуры (из которых
только одна будет выполняться). Мы не показали ту часть контроллера,
которая реализует примитивы, но мы предполагаем, что эти команды
используют элементарные арифметические операции в путях данных машины.
Рассмотрим, насколько меньше кода будет порождаться, если компилятор
сможет вставлять примитивы в виде (@newterm{open coding}) --- то есть порождать
код, который прямо использует эти машинные операции. Выражение
@code{(+ a 1)} можно было бы скомпилировать в простую
последовательность вроде@footnote{Здесь мы одним символом @code{+}
обозначаем и процедуру исходного языка, и машинную операцию. В общем
случае может не быть однозначного соответствия примитивов исходного
языка примитивам машины.}

@lisp
(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
@end lisp

В этом упражнении мы расширим компилятор так, чтобы он поддерживал явное
кодирование отдельных примитивов. При обращениях к этим примитивам будет
порождаться специально написанный код, а не общий код для вызова
процедуры. Для того, чтобы поддержать такую работу, мы дополним машину
специальными регистрами для аргументов @code{arg1} и @code{arg2}.
Элементарные арифметические операции машины будут принимать свои
аргументы в @code{arg1} и @code{arg2}. Они могут помещать результаты в
@code{val}, @code{arg1} или @code{arg2}.

Компилятор должен уметь распознавать вызов явно кодируемого примитива в
исходной программе. Мы дополним распознаватель в процедуре
@code{compile}, так, чтобы он узнавал имена этих примитивов в
дополнение к зарезервированным словам (особым формам), которые он узнаёт
сейчас@footnote{Вообще говоря, превращение примитивов в
зарезервированные слова --- плохая идея, потому что тогда пользователь
не может связать эти имена с другими процедурами. Более того, если мы
добавим зарезервированные слова в компилятор, который уже используется,
перестанут работать существующие программы, которые определяют процедуры
с такими именами. Идеи, как можно избежать этой проблемы, можно найти в
упражнении @ref{Упражнение 5.44}.}. Для каждой особой формы в
компиляторе есть свой генератор кода. В этом упражнении мы построим
семью генераторов кода для явно кодируемых примитивов.

@enumerate a.

@item
В отличие от особых форм, явно кодируемые примитивы требуют, чтобы их
аргументы вычислялись. Напишите генератор кода @code{spread-arguments},
который будут использовать генераторы явного кода.
@code{Spread-arguments} должен принимать список операндов и
компилировать данные ему операнды, направляя их в последовательные
аргументные регистры. Заметим, что операнд может содержать вызов явно
кодируемого примитива, так что во время вычисления операндов придется
сохранять аргументные регистры.

@item
Для каждой из элементарных процедур @code{=}, @code{}, @code{-} и
@code{+} напишите по генератору кода, который принимает комбинацию,
содержащую этот оператор вместе с целевым регистром и описателем связи,
и порождает код, который раскидывает аргументы по регистрам, а затем
проводит операцию с данным целевым регистром и указанным типом связи.
Достаточно обрабатывать только выражения с двумя операндами. Заставьте
@code{compile} передавать управление этим генераторам кода.

@item
Опробуйте обновленный компилятор на примере с процедурой
@code{factorial}. Сравните полученный результат с результатом, который
получается без открытого кодирования.

@item
Расширьте свои генераторы кода для @code{+} и @code{} так, чтобы они
могли обрабатывать выражения с произвольным числом операндов.
Выражение, в котором операндов больше двух, придется компилировать в
последовательность операций, каждая из которых работает с двумя входами.

@end enumerate
@end quotation

@comment @subsection Lexical Addressing
@subsection Лексическая адресация
@node	5.5.6, 5.5.7, 5.5.5, 5.5

Одна из наиболее часто встречающихся в компиляторах оптимизаций связана
с поиском переменных. В нынешнем виде наш компилятор использует операцию
@code{lookup-variable-value} машины-вычислителя. Эта операция ищет
переменную, сравнивая ее со всеми переменными, связанными в данный
момент, и проходя кадр за кадром по окружению, имеющемуся во время
выполнения. Если кадр глубоко вложен или если имеется много переменных,
этот поиск может оказаться дорогим. Рассмотрим, например, задачу поиска
значения @code{x} при вычислении выражения @code{(* x y z)} внутри
процедуры, возвращаемой при вычислении

\enlargethispage{\baselineskip}

@lisp
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
@end lisp

Поскольку выражение @code{let} --- всего лишь синтаксический сахар для
комбинации @code{lambda}, это выражение равносильно

@lisp
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
@end lisp

Каждый раз, когда @code{lookup-variable-value} ищет @code{x}, она должна
убедиться, что символ @code{x} не равен (через @code{eq?}) ни @code{y},
ни @code{z} (в первом кадре), ни @code{a}, @code{b}, @code{c}, @code{d},
ни @code{e} (во втором). Предположим, временно, что в наших программах
не используется @code{define} --- что переменные связываются только
через @code{lambda}. Поскольку в нашем языке лексическая сфера действия,
во время выполнения окружение любого выражения будет иметь структуру,
параллельную лексической структуре программы, в которой это выражение
встречается@footnote{Это не так, если мы разрешаем внутренние
определения и если мы от них не избавляемся.
См. упражнение @ref{Упражнение 5.43}.}. Таким образом, компилятор при
анализе вышеуказанного выражения может узнать, что каждый раз, когда
процедура применяется, переменная @code{x} в @code{(* x y z)} будет найдена на два
кадра выше текущего, и в этом кадре будет первая.

Мы можем это использовать и ввести новый вид операции поиска переменной,
@code{lexical-address-lookup}, который в качестве аргументов берет
окружение и (@newterm{lexical address}), состоящий из двух чисел: (@newterm{frame number}),
который показывает, сколько кадров надо пропустить, и (displacement
number), которое показывает, сколько переменных нужно пропустить в этом
кадре. @code{Lexical-address-lookup} будет возвращать значение
переменной, которая имеет указанный лексический адрес по отношению к
текущему окружению. Добавив в свою машину
@code{lexical-address-lookup}, мы можем научить компилятор порождать
код, который обращается к переменным через эту операцию, а не через
@code{lookup-variable-value}. Подобным образом, скомпилированный код
может использовать новую операцию @code{lexical-address-set!} вместо
@code{set-variable-value!}.

Для того, чтобы порождать такой код, компилятор должен уметь определять
лексический адрес переменной, ссылку на которую он намерен
скомпилировать. Лексический адрес переменной зависит от того, где она
находится в коде. Например, в следующей программе адрес @code{x} в
выражении @math{\langle}@var{e1}@math{\rangle} есть (2,0) --- на два
кадра назад и первая переменная в кадре. В этом же месте @code{y} имеет
адрес (0,0), а @code{c} --- адрес (1,2). В выражении
@math{\langle}@var{e2}@math{\rangle} @code{x} имеет адрес (1,0),
@code{y} адрес (1,1), а @code{c} адрес (0,2).

@lisp
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) @math{\langle}@var{e1}@math{\rangle})
      @math{\langle}@var{e2}@math{\rangle}
      (+ c d x))))
 3
 4)
@end lisp

Один из способов породить в компиляторе код, который использует
лексическую адресацию, состоит в поддержании структуры данных,
называемой (compile-time environment). Она следит за тем, какие
переменные в каких позициях и в каких кадрах будут находиться в
окружении времени выполнения, когда будет выполняться определенная
операция доступа к переменной. Окружение времени компиляции представляет
собой список кадров, каждый из которых содержит список переменных.
(Разумеется, с переменными не будет связано никаких значений, поскольку
во время компиляции значения не вычисляются.) Окружение времени
компиляции становится дополнительным аргументом процедуры @code{compile}
и передается всем генераторам кода. Вызов @code{compile} верхнего уровня
использует пустое окружение времени компиляции. Когда компилируется тело
@code{lambda}, @code{compile-lambda-body} расширяет это окружение
кадром, содержащим параметры процедуры, так что последовательность,
которая является телом, компилируется в этом расширенном окружении. В
каждой точке компиляции @code{compile-variable} и
@code{compile-assignment} используют окружение времени компиляции для
порождения соответствующих лексических адресов.

Упражнения с @ref{Упражнение 5.39} по @ref{Упражнение 5.43} описывают,
как завершить этот набросок лексической адресации и включить в
компилятор лексический поиск. В упражнении @ref{Упражнение 5.44}
описывается еще один способ использовать окружение времени компиляции.

@quotation
@strong{@anchor{Упражнение 5.39}Упражнение 5.39:} Напишите процедуру @code{lexical-address-lookup}, которая
реализует новую операцию поиска. Она должна брать два аргумента ---
лексический адрес и окружение времени выполнения, --- и возвращать
значение переменной, находящейся по указанному лексическому адресу.
@code{Lexical-address-lookup} должна сообщать об ошибке, если значением
переменной является символ @code{unassigned*}@footnote{Эта
модификация в поиске переменной требуется в том случае, если мы
реализуем просмотр текста и уничтожение внутренних определений
(упражнение @ref{Упражнение 5.43}). Чтобы лексическая адресация
работала, их следует уничтожить.}. Кроме того, напишите процедуру
@code{lexical-address-set!}, реализующую операцию, которая изменяет
значение переменной по указанному лексическому адресу.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.40}Упражнение 5.40:} Модифицируйте компилятор так, чтобы он поддерживал
окружение времени компиляции, как описано выше.  а именно, добавьте
аргумент-окружение к @code{compile} и всем генераторам кода, и
расширяйте его в @code{compile-lambda-body}.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.41}Упражнение 5.41:} Напишите процедуру @code{find-variable}, которая в
качестве аргументов принимает переменную и окружение времени
компиляции, а возвращает лексический адрес переменной по отношению к
этому окружению. Например, во фрагменте программы, который приведен
выше, окружение времени компиляции при обработке выражения
@math{\langle}@var{e1}@math{\rangle} равно
@code{((y z) (a b c d e) (x y))}. @code{find-variable} должна давать

@lisp
(find-variable 'c '((y z) (a b c d e) (x y)))
@i{(1 2)}
(find-variable 'x '((y z) (a b c d e) (x y)))
@i{(2 0)}
(find-variable 'w '((y z) (a b c d e) (x y)))
@i{not-found}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.42}Упражнение 5.42:} С помощью @code{find-variable} из
упражнения @ref{Упражнение 5.41} перепишите @code{compile-variable} и
@code{compile-assignment} так, чтобы они порождали команды лексической
адресации. В случаях, когда @code{find-variable} возвращает
@code{not-found} (то есть, когда переменной нет в окружении времени
компиляции), нужно заставлять генераторы кода использовать, как и
раньше, операции вычислителя для поиска связывания. (Единственное место,
где может оказаться переменная, не найденная во время компиляции ---
это глобальное окружение, которое является частью окружения времени
выполнения, но не окружения времени компиляции@footnote{Для доступа к
переменным в глобальном окружении нельзя использовать лексические
адреса, поскольку эти имена можно определять и переопределять
интерактивно когда угодно. Если внутренние определения вычищены, как в
упражнении @ref{Упражнение 5.43}, то компилятор видит только
определения верхнего уровня, которые действуют на глобальное окружение.
Компиляция определения не приводит к тому, что определяемое имя
вводится в окружение времени компиляции.}. Поэтому, если хотите, можете
заставить операции вычислителя искать сразу в глобальном окружении,
которое можно получить с помощью операции
@code{(op get-global-environment)}, а не в полном локальном окружении,
которое хранится в @code{env}.) Проверьте измененный компилятор на
нескольких простых примерах, например, на вложенной комбинации
@code{lambda} из начала этого раздела.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.43}Упражнение 5.43:} В разделе @ref{4.1.6} мы
показали, что определения внутри блочной структуры не следует
рассматривать как <<настоящие>> @code{define}. Вместо этого тело
процедуры следует интерпретировать так, как будто внутренние переменные,
определяемые через @code{define}, были введены как обыкновенные
переменные @code{lambda}, а их настоящее значение было им присвоено
через @code{set!}. В разделе @ref{4.1.6} и
упражнении @ref{Упражнение 4.16} показывалось, как можно изменить
метациклический интерпретатор и добиться этого просмотром внутренних
определений. Измените компилятор так, чтобы он проводил такое же
преобразование, прежде чем компилировать тело процедуры.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.44}Упражнение 5.44:} В этом разделе мы в основном говорили о том, как с
помощью окружения времени компиляции порождать лексические адреса.
Однако такие окружения можно использовать и другими способами.
Например, в упражнении @ref{Упражнение 5.38} мы повысили
эффективность скомпилированного кода путем явного кодирования
элементарных процедур. Наша реализация обрабатывала имена явно
кодируемых процедур как зарезервированные слова. Если бы какая-либо
программа переопределяла такое имя, механизм, описанный в
упражнении @ref{Упражнение 5.38}, продолжал бы явно кодировать его как
примитив и игнорировал бы новое связывание. Рассмотрим, например,
процедуру

@lisp
(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
@end lisp

которая вычисляет линейную комбинацию @code{x} и @code{y}. Мы могли бы
вызвать такую процедуру с аргументами @code{+matrix}, @code{matrix} и
четырьмя матрицами, но явно кодирующий компилятор по-прежнему вставлял
бы код для @code{+} и @code{} в @code{(+ (* a x) (* b y))} как для
примитивов @code{+} и @code{}. Измените компилятор с явным кодированием
так, чтобы он проверял окружение времени компиляции и на его основе
порождал правильный код для выражений, в которых встречаются имена
элементарных процедур. (Код будет работать правильно, пока программа не
применяет к этим именам @code{define} или @code{set!}.)
@end quotation

@endpage
@comment @subsection Interfacing Compiled Code to the Evaluator
@subsection Связь скомпилированного кода с вычислителем
@node	5.5.7,  , 5.5.6, 5.5

Пока что мы не объяснили, как загружать скомпилированный код в
машину-вычислитель и как его запускать. Предположим, что
машина-вычислитель с явным управлением определена как в
разделе @ref{5.4.4} с дополнительными операциями
из примечания @ref{Примечание 5.38}. Мы реализуем процедуру
@code{compile-and-go}, которая компилирует выражение на Scheme,
загружает получившийся код в машину-вычислитель, а затем заставляет
машину исполнить код в глобальном окружении вычислителя, напечатать
результат и войти в управляющий цикл. Вычислитель мы изменим так, чтобы
интерпретируемые выражения могли вызывать не только интерпретируемые, но
и скомпилированные процедуры. После этого мы можем поместить
скомпилированную процедуру в машину и вызвать ее с помощью
интерпретатора:

@lisp
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
@i{;;; Значение EC-Eval:}
@i{ok}

@i{;;; Ввод EC-Eval:}
(factorial 5)
@i{;;; Значение EC-Eval:}
@i{120}
@end lisp

Для того, чтобы вычислитель мог обрабатывать скомпилированные процедуры
(например, выполнить вызов @code{factorial}, как показано выше), нужно
изменить код @code{apply-dispatch} (раздел @ref{5.4.1}), чтобы
он распознавал их (в отличие от составных и элементарных процедур) и
передавал управление прямо во входную точку скомпилированного
кода@footnote{Разумеется, скомпилированные процедуры являются составными
(неэлементарными) точно так же, как и интерпретируемые. Однако ради
совместимости с терминологией, которая используется при обсуждении
вычислителя с явным управлением, мы в этом разделе будем считать, что
слово <<составная>> означает <<интерпретируемая>> (а не
скомпилированная).}:

@lisp
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))  
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
@end lisp

Обратите внимание на восстановление @code{continue} в
@code{compiled-apply}. Вспомним, что вычислитель был так устроен, что
при выполнении @code{apply-dispatch} продолжение находилось на вершине
стека. С другой стороны, входная точка скомпилированного кода ожидает,
что продолжение будет находиться в @code{continue}, так что этот регистр
надо восстановить, прежде чем передать управление скомпилированному
коду.

Для того, чтобы позволить нам запускать скомпилированный код при запуске
вычислителя, мы в начало машины добавляем команду @code{branch},
которая переводит машину на новую точку входа, если установлен регистр
@code{flag}@footnote{Теперь, когда код вычислителя начинается с
@code{branch}, нам перед запуском машины всегда нужно устанавливать
значение @code{flag}. Для того, чтобы запустить машину в обычном
управляющем цикле, можно использовать

@lisp
(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
@end lisp
}.

@lisp
(branch (label external-entry))    @r{; переход, если установлен @code{flag}}
read-eval-print-loop
  (perform (op initialize-stack))
  @dots{}
@end lisp

\enlargethispage{\baselineskip}

@noindent
@code{external-entry} предполагает, что при запуске машины регистр
@code{val} содержит местоположение последовательности команд, которая
помещает результат в @code{val} и заканчивается командой
@code{(goto (reg continue))}. Запуск машины с этой точки входа приводит
к переходу в место, куда показывает @code{val}, но сначала
@code{continue} устанавливается в @code{print-result}, которая
распечатает значение @code{val}, а затем направится в начало
управляющего цикла вычислителя@footnote{Поскольку скомпилированная
процедура является объектом, который система может попытаться
напечатать, нужно еще изменить системную операцию печати
@code{user-print} (из раздела @ref{4.1.4}),
чтобы она не пыталась печатать компоненты скомпилированной процедуры:

@lisp
(define (user-print object) 
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((compiled-procedure? object)
         (display '<compiled-procedure>))
        (else (display object))))
@end lisp
}.

@lisp
external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
@end lisp

@noindent
Теперь с помощью следующей процедуры можно скомпилировать определение,
выполнить скомпилированный код и войти в управляющий цикл, откуда мы
можем процедуру оттестировать. Поскольку мы хотим, чтобы
скомпилированная процедура возвращалась в место, указанное
@code{continue}, со значением в @code{val}, мы компилируем выражение с
целевым регистром @code{val} и типом связи @code{return}. Чтобы
преобразовать объектный код, порождаемый компилятором, в исполняемые
команды регистровой машины-вычислителя, мы пользуемся процедурой
@code{assemble} из имитатора регистровых машин
(раздел @ref{5.2.2}). Затем мы устанавливаем @code{val},
чтобы он указывал на список команд, устанавливаем @code{flag}, чтобы
вычислитель пошел на @code{external-entry}, и запускаем вычислитель.

@lisp
(define (compile-and-go expression)
  (let ((instructions
         (assemble (statements
                    (compile expression 'val 'return))
                   eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
@end lisp

@noindent
Если мы установим отслеживание стека, как в конце раздела @ref{5.4.4}, то
сможем исследовать использование стека скомпилированным кодом:

@lisp
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))

@i{(total-pushes = 0 maximum-depth = 0)}
@i{;;; Значение EC-Eval:}
@i{ok}
@i{;;; Ввод EC-Eval:}
(factorial 5)
@i{(total-pushes = 31 maximum-depth = 14)}
@i{;;; Значение EC-Eval:}
@i{120}
@end lisp

Сравните этот пример с вычислением @code{(factorial 5)} с помощью
интерпретируемой версии той же самой процедуры, приведенным в конце
раздела @ref{5.4.4}. В интерпретируемой версии
потребовалось 144 сохранения и максимальная глубина стека 28. Это
показывает, какую оптимизацию удалось получить с помощью нашей стратегии
компиляции.

@comment @subsubheading Interpretation and compilation
@subsubheading Интерпретация и компиляция

При помощи программ из этого раздела мы можем проводить эксперименты с
различными стратегиями выполнения: интерпретацией и
компиляцией@footnote{Можно добиться даже большего, если расширить
компилятор так, чтобы скомпилированный код мог вызывать интерпретируемые
процедуры. См. упражнение @ref{Упражнение 5.47}.}. Интерпретатор
поднимает машину до уровня пользовательской программы; компилятор
опускает пользовательскую программу до уровня машинного языка. Можно
рассматривать язык Scheme (или любой язык программирования) как
согласованную систему абстракций, построенных поверх машинного языка.
Интерпретаторы хороши для интерактивной разработки программ и их
отладки, поскольку шаги выполнения программы организованы в терминах
этих абстракций, и, следовательно, лучше понятны программисту.
Скомпилированный код может работать быстрее, поскольку шаги выполнения
программы организованы в терминах машинного языка, и компилятор может
проводить оптимизации, которые нарушают абстракции верхнего
уровня@footnote{Независимо от стратегии выполнения, мы сталкиваемся с
существенным замедлением, если требуем, чтобы ошибки, возникающие при
выполнении пользовательской программы, были обнаружены и отмечены, а не
приводили к смерти системы или к неверным результатам работы. Например,
индексирование за границы массива можно обнаружить, если перед
обращением к массиву проверить правильность индекса. Однако затраты на
проверку могут быть во много раз больше, чем стоимость самого обращения,
и программисту приходится взвешивать преимущества скорости и
безопасности, когда он решает, нужна ли такая проверка. Хороший
компилятор должен уметь порождать код с проверками, избегать лишних
проверок и позволять программистам управлять количеством и видами
проверок на ошибки в скомпилированном коде.

Компиляторы для популярных языков программирования, вроде C или C++,
почти никаких проверок в работающий код не помещают, чтобы программы
выполнялись как можно быстрее. В результате программистам приходится
самим проводить проверку на ошибки. К сожалению, многие этим
пренебрегают, даже в критических приложениях, где скорость не является
существенным ограничением. Их программы ведут бурную и опасную жизнь.
Например, знаменитый <<Червь>>, который парализовал Интернет в 1988
году, использовал то, что операционная система @acronym{UNIX}(tm) не
проверяла переполнение буфера в демоне @code{finger}. (См. Spafford 1989.)}.

Компиляция и интерпретация также ведут к различным стратегиям при
переносе языков на новые компьютеры. Предположим, что нам надо
реализовать Лисп для новой машины. Одна стратегия будет состоять в том,
чтобы взять вычислитель с явным управлением из раздела @ref{5.4} и перевести его
команды в команды новой машины. Вторая --- в том, чтобы начать с
компилятора и изменить генераторы кода так, чтобы они порождали код
новой машины. Вторая стратегия позволяет запускать на новой машине любую
программу на Лиспе, если сначала скомпилировать ее компилятором, который
работает на исходной Лисп-системе, а затем связать со скомпилированной
версией рабочей библиотеки@footnote{Разумеется, как при интерпретации,
так и при компиляции придется еще реализовать для новой машины
управление памятью, ввод и вывод, а также все операции, которые мы
считали <<элементарными>> при обсуждении интерпретатора и компилятора.
Один из способов минимизировать эту работу заключается в том, чтобы как
можно большее число этих операций написать на Лиспе, а затем
скомпилировать для новой машины. В конце концов все сводится к простому
ядру (например, сборка мусора и механизм для применения настоящих
машинных примитивов), которое кодируется для новой машины вручную.}.
Более того, мы можем скомпилировать сам компилятор, и, запустив его на
новой машине, компилировать другие программы на Лиспе@footnote{Такая
стратегия приводит к забавным проверкам корректности компилятора. Можно,
например, сравнить, совпадает ли результат компиляции программы на новой
машине, с помощью скомпилированного компилятора, с результатом
компиляции той же программы на исходной Лисп-системе. Поиск причин
расхождения --- занятие интересное, но зачастую довольно сложное,
поскольку результат может зависеть от микроскопических деталей.}. Либо
же мы можем скомпилировать один из интерпретаторов из раздела @ref{4.1}
и получить интерпретатор, который работает на новой машине.

@quotation
@strong{@anchor{Упражнение 5.45}Упражнение 5.45:} Сравнивая статистику операций со стеком, порождаемую
скомпилированным кодом, с такой же статистикой для интерпретатора,
ведущего то же самое вычисление, можно определить, насколько компилятор
оптимизирует работу со стеком, как по скорости (уменьшая общее число
стековых операций), так и по памяти (уменьшая максимальную глубину
стека). Сравнение той же статистики с результатами работы
специализированной машины, предназначенной для того же вычисления, дает
некоторое представление о качестве компилятора.

@enumerate a.

@item
В упражнении @ref{Упражнение 5.27} от Вас требовалось определить как
функцию от @math{n} число сохранений и максимальную глубину стека,
которые требуются вычислителю для того, чтобы получить @math{n!} с
помощью указанной факториальной процедуры. В
упражнении @ref{Упражнение 5.14} Вас просили провести те же измерения
для специализированной факториальной машины, показанной на
рисунке @ref{Рисунок 5.11}. Проведите теперь тот же анализ для
скомпилированной процедуры @code{factorial}.

Возьмем отношение числа сохранений в скомпилированной версии к числу
сохранений в интерпретируемой версии и проделаем то же для максимальной
глубины стека. Поскольку число операций и глубина стека при вычислении
@math{n!} линейно зависят от @math{n}, эти отношения должны приближаться
к константам при росте @math{n}. Чему равны эти константы? Найдите также
отношения показателей использования стека в специализированной машине к
показателям интерпретируемой версии.

Сравните отношения специализированной версии к интерпретируемой и
отношения скомпилированной версии к интерпретируемой. Вы должны увидеть,
что специализированная машина работает намного лучше скомпилированного
кода, поскольку настроенный вручную код контроллера должен быть намного
лучше, чем результаты работы нашего рудиментарного компилятора общего
назначения.

@item
Можете ли Вы предложить изменения в компиляторе, помогающие ему
порождать код, который приблизится к показателям версии, построенной
вручную?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 5.46}Упражнение 5.46:} Проведите анализ, подобный анализу из
упражнения @ref{Упражнение 5.45}, и определите эффективность
компиляции для процедуры Фибоначчи с древовидной рекурсией

@lisp
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
@end lisp

@noindent
по сравнению с эффективностью работы специализированной машины Фибоначчи
с рисунка @ref{Рисунок 5.12}. (Измерения интерпретируемой версии
см. в упражнении @ref{Упражнение 5.29}.) Для процедуры Фибоначчи
время растет в нелинейной зависимости от @math{n}; следовательно,
отношение числа стековых операций не будет приближаться к независимому
от @math{n} пределу.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.47}Упражнение 5.47:} В этом разделе рассказывалось, как модифицировать
вычислитель с явным управлением и позволить интерпретируемому коду
вызывать скомпилированные процедуры. Покажите, как можно изменить
компилятор и позволить скомпилированным процедурам вызывать не только
элементарные и скомпилированные процедуры, но и интерпретируемые. При
этом придется изменить @code{compile-procedure-call} так, чтобы
обрабатывался случай составных (интерпретируемых) процедур. Проследите,
чтобы обрабатывались все те же сочетания @code{target} и @code{linkage},
что и в @code{compile-proc-appl}. Для того, чтобы произвести собственно
применение процедуры, код должен переходить на точку входа
@code{compound-apply} вычислителя. На эту метку нельзя напрямую
ссылаться из объектного кода (потому что ассемблер требует, чтобы все
метки, на которые явно ссылается объектный код, в нем и определялись),
так что придется добавить в машину-вычислитель специальный регистр
@code{compapp}, в котором будет храниться эта точка входа, и команду
для его инициализации:

@lisp
(assign compapp (label compound-apply))
(branch (label external-entry))   @r{; переход, если установлен @code{flag}}
read-eval-print-loop @dots{}
@end lisp

Чтобы проверить свой код, для начала определите процедуру @code{f},
которая вызывает процедуру @code{g}. С помощью @code{compile-and-go}
скомпилируйте определение @code{f} и запустите вычислитель. Теперь,
вводя код для интерпретации, определите @code{g} и попробуйте вызвать
@code{f}.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.48}Упражнение 5.48:} Интерфейс @code{compile-and-go}, реализованный в этом
разделе, неудобен, поскольку компилятор можно вызвать только один раз
(при запуске машины-вычислителя). Дополните интерфейс между компилятором
и интерпретатором, введя примитив @code{compile-and-run}, который можно
будет вызывать из вычислителя с явным управлением так:

@lisp
@i{;;; Ввод EC-Eval:}
(compile-and-run
 '(define (factorial n)
    (if (= n 1) 1 (* (factorial (- n 1)) n))))
@i{;;; Значение EC-Eval:}
@i{ok}
@i{;;; Ввод EC-Eval:}
(factorial 5)
@i{;;; Значение EC-Eval:}
@i{120}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 5.49}Упражнение 5.49:} В качестве альтернативы циклу ввод-выполнение-печать
вычислителя с явным управлением, спроектируйте регистровую машину,
которая работала бы в цикле ввод-компиляция-выполнение-печать. А
именно, машина должна работать в цикле, при каждой итерации которого
она считывает выражение, компилирует его, ассемблирует и исполняет
получившийся код, и печатает результат. В нашей имитируемой среде это
легко устроить, поскольку мы можем заставить @code{compile} и
@code{assemble} работать как <<операции регистровой машины>>.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.50}Упражнение 5.50:} С помощью компилятора
оттранслируйте метациклический интерпретатор из раздела @ref{4.1}
и запустите эту программу через имитатор регистровых машин. (Чтобы
скомпилировать за раз более одного определения, можно упаковать
определения в @code{begin}.) Получившийся интерпретатор будет работать
очень медленно из-за многочисленных уровней интерпретации, однако
заставить все детали работать --- полезное упражнение.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.51}Упражнение 5.51:} Разработайте рудиментарную реализацию Scheme на C (или на
другом низкоуровневом языке по Вашему выбору), переведя на C вычислитель
с явными управлением из раздела @ref{5.4}. Для того, чтобы
запустить этот код, Вам потребуется предоставить также функции для
выделения памяти и прочую поддержку времени выполнения.
@end quotation

@quotation
@strong{@anchor{Упражнение 5.52}Упражнение 5.52:} В качестве обратной задачи к
упражнению @ref{Упражнение 5.51}, измените компилятор так, чтобы он
компилировал процедуры Scheme в последовательности команд C.
Скомпилируйте метациклический интерпретатор из раздела @ref{4.1}
и получите интерпретатор Scheme, написанный на C.
@end quotation


\backmatter

@unnumbered References
@node    References, List of Exercises, Chapter 5, Top

\fontspec[Numbers={OldStyle},StylisticSet=6]{Linux Libertine O}

\phantomsection @anchor{Abelson et al. 1992}
@b{Abelson}, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,
Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The Supercomputer
Toolkit: A general framework for special-purpose computing.
@cite{International Journal of High-Speed Electronics} 3(3): 337-361.
@url{http://www.hpl.hp.com/techreports/94/HPL-94-30.html, –›}

\phantomsection @anchor{Allen 1978}
@b{Allen}, John.  1978.  @cite{Anatomy of Lisp}. New York: McGraw-Hill.

\phantomsection @anchor{ANSI 1994}
@acronym{@b{ANSI}} @acronym{X}3.226-1994. @cite{American National Standard for Information
Sys\-tems---Programming Language---Common Lisp}.

\phantomsection @anchor{Appel 1987}
@b{Appel}, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  @cite{Information Processing Letters} 25(4): 275-279.
@url{https://www.cs.princeton.edu/~appel/papers/45.ps, –›}

\phantomsection @anchor{Backus 1978}
@b{Backus}, John.  1978.  Can programming be liberated from the von Neumann style?
@cite{Communications of the @acronym{ACM}} 21(8): 613-641.
@url{http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf, –›}

\phantomsection @anchor{Baker (1978)}
@b{Baker}, Henry G., Jr.  1978.  List processing in real time on a serial computer.
@cite{Communications of the @acronym{ACM}} 21(4): 280-293.
@url{http://dspace.mit.edu/handle/1721.1/41976, –›}

\phantomsection @anchor{Batali et al. 1982}
@b{Batali}, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.
1982.  The Scheme-81 architecture---System and chip.  In @cite{Proceedings of
the @acronym{MIT} Conference on Advanced Research in @acronym{VLSI}}, edited by
Paul Penfield, Jr. Dedham, @acronym{MA}: Artech House.

\phantomsection @anchor{Borning (1977)}
@b{Borning}, Alan.  1977.  ThingLab---An object-oriented system for building
simulations using constraints. In @cite{Proceedings of the 5th International
Joint Conference on Artificial Intelligence}.
@url{http://ijcai.org/Past%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf, –›}

\phantomsection @anchor{Borodin and Munro (1975)}
@b{Borodin}, Alan, and Ian Munro.  1975.  @cite{The Computational Complexity of
Algebraic and Numeric Problems}. New York: American Elsevier.

\phantomsection @anchor{Chaitin 1975}
@b{Chaitin}, Gregory J.  1975.  Randomness and mathematical proof.
@cite{Scientific American} 232(5): 47-52.
@url{https://www.cs.auckland.ac.nz/~chaitin/sciamer.html, –›}

\phantomsection @anchor{Church (1941)}
@b{Church}, Alonzo.  1941.  @cite{The Calculi of Lambda-Conversion}.  Princeton,
N.J.: Princeton University Press.

\phantomsection @anchor{Clark (1978)}
@b{Clark}, Keith L.  1978.  Negation as failure.  In @cite{Logic and Data Bases}.
New York: Plenum Press, pp. 293-322.
@url{http://www.doc.ic.ac.uk/~klc/neg.html, –›}

\phantomsection @anchor{Clinger (1982)}
@b{Clinger}, William.  1982.  Nondeterministic call by need is neither lazy nor by
name. In @cite{Proceedings of the @acronym{ACM} Symposium on Lisp and
Functional Programming}, pp. 226-234.

\phantomsection @anchor{Clinger and Rees 1991}
@b{Clinger}, William, and Jonathan Rees.  1991.  Macros that work.  In
@cite{Proceedings of the 1991 @acronym{ACM} Conference on Principles of
Programming Languages}, pp. 155-162.
@url{http://mumble.net/~jar/pubs/macros_that_work.ps, –›}

\phantomsection @anchor{Colmerauer et al. 1973}
@b{Colmerauer} A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst@`eme de
communication homme-machine en fran@,{c}ais.  Technical report, Groupe
Intelligence Artificielle, Universit@'e d'Aix Marseille, Luminy.
@url{http://alain.colmerauer.free.fr/alcol/ArchivesPublications/HommeMachineFr/HoMa.pdf, –›}

\phantomsection @anchor{Cormen et al. 1990}
@b{Cormen}, Thomas, Charles Leiserson, and Ronald Rivest.  1990. @cite{Introduction
to Algorithms}. Cambridge, @acronym{MA}: @acronym{MIT} Press.

\phantomsection @anchor{Darlington et al. 1982}
@b{Darlington}, John, Peter Henderson, and David Turner.  1982.  @cite{Functional
Programming and Its Applications}. New York: Cambridge University Press.

\phantomsection @anchor{Dijkstra 1968a}
@b{Dijkstra}, Edsger W. 1968a.  The structure of the ``@acronym{THE}''
multiprogramming system.  @cite{Communications of the @acronym{ACM}}
11(5): 341-346.
@url{http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF, –›}

\phantomsection @anchor{Dijkstra 1968b}
@b{Dijkstra}, Edsger W. 1968b.  Cooperating sequential processes.  In
@cite{Programming Languages}, edited by F. Genuys. New York: Academic Press,
pp.  43-112.
@url{http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF, –›}

\phantomsection @anchor{Dinesman 1968}
@b{Dinesman}, Howard P.  1968.  @cite{Superior Mathematical Puzzles}.  New York:
Simon and Schuster.

\phantomsection @anchor{deKleer et al. 1977}
@b{deKleer}, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
@acronym{AMORD}: Explicit control of reasoning.  In @cite{Proceedings of the
@acronym{ACM} Symposium on Artificial Intelligence and Programming Languages},
pp.  116-125.
@url{http://dspace.mit.edu/handle/1721.1/5750, –›}

\phantomsection @anchor{Doyle (1979)}
@b{Doyle}, Jon. 1979. A truth maintenance system. @cite{Artificial Intelligence}
12: 231-272.
@url{http://dspace.mit.edu/handle/1721.1/5733, –›}

\phantomsection @anchor{Feigenbaum and Shrobe 1993}
@b{Feigenbaum}, Edward, and Howard Shrobe. 1993. The Japanese National Fifth
Generation Project: Introduction, survey, and evaluation.  In @cite{Future
Generation Computer Systems}, vol. 9, pp. 105-117.
@url{https://saltworks.stanford.edu/assets/kv359wz9060.pdf, –›}

\phantomsection @anchor{Feeley (1986)}
@b{Feeley}, Marc.  1986.  Deux approches @`a l'implantation du language
Scheme.  Masters thesis, Universit@'e de Montr@'eal.
@url{http://www.iro.umontreal.ca/~feeley/papers/FeeleyMSc.pdf, –›}

\phantomsection @anchor{Feeley and Lapalme 1987}
@b{Feeley}, Marc and Guy Lapalme.  1987.  Using closures for code generation.
@cite{Journal of Computer Languages} 12(1): 47-66.
@url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978, –›}

@b{Feller}, William.  1957.  @cite{An Introduction to Probability Theory and Its
Applications}, volume 1. New York: John Wiley \& Sons.

\phantomsection @anchor{Fenichel and Yochelson (1969)}
@b{Fenichel}, R., and J. Yochelson.  1969.  A Lisp garbage collector for virtual
memory computer systems.  @cite{Communications of the @acronym{ACM}}
12(11): 611-612.
@url{https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf, –›}

\phantomsection @anchor{Floyd (1967)}
@b{Floyd}, Robert. 1967. Nondeterministic algorithms. @cite{@acronym{JACM}},
14(4): 636-644.
@url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.36, –›}

\phantomsection @anchor{Forbus and deKleer 1993}
@b{Forbus}, Kenneth D., and Johan deKleer.  1993. @cite{Building Problem
Solvers}. Cambridge, @acronym{MA}: @acronym{MIT} Press.

\phantomsection @anchor{Friedman and Wise (1976)}
@b{Friedman}, Daniel P., and David S. Wise.  1976.  @acronym{CONS} should not
evaluate its arguments. In @cite{Automata, Languages, and Programming: Third
International Colloquium}, edited by S. Michaelson and R.  Milner, pp. 257-284.
@url{https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44, –›}

\phantomsection @anchor{Friedman et al. 1992}
@b{Friedman}, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
@cite{Essentials of Programming Languages}.  Cambridge, @acronym{MA}: @acronym{MIT}
Press/ McGraw-Hill.

\phantomsection @anchor{Gabriel 1988}
@b{Gabriel}, Richard P. 1988.  The Why of @emph{Y}.  @cite{Lisp Pointers}
2(2): 15-25.
@url{http://www.dreamsongs.com/Files/WhyOfY.pdf, –›}

@b{Goldberg}, Adele, and David Robson.  1983.  @cite{Smalltalk-80: The Language and
Its Implementation}. Reading, @acronym{MA}: Addison-Wesley.
@url{http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf, –›}

\phantomsection @anchor{Gordon et al. 1979}
@b{Gordon}, Michael, Robin Milner, and Christopher Wadsworth.  1979.
@cite{Edinburgh @acronym{LCF}}. Lecture Notes in Computer Science, volume 78. New York:
Springer-Verlag.

\phantomsection @anchor{Gray and Reuter 1993}
@b{Gray}, Jim, and Andreas Reuter. 1993. @cite{Transaction Processing: Concepts and
Models}. San Mateo, @acronym{CA}: Morgan-Kaufman.

\phantomsection @anchor{Green 1969}
@b{Green}, Cordell.  1969.  Application of theorem proving to problem solving.  In
@cite{Proceedings of the International Joint Conference on Artificial
Intelligence}, pp. 219-240.
@url{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820, –›}

\phantomsection @anchor{Green and Raphael (1968)}
@b{Green}, Cordell, and Bertram Raphael.  1968.  The use of theorem-proving
techniques in question-answering systems.  In @cite{Proceedings of the
@acronym{ACM} National Conference}, pp. 169-181.
@url{http://www.kestrel.edu/home/people/green/publications/green-raphael.pdf, –›}

\phantomsection @anchor{Griss 1981}
@b{Griss}, Martin L.  1981.  Portable Standard Lisp, a brief overview.  Utah
Symbolic Computation Group Operating Note 58, University of Utah.

\phantomsection @anchor{Guttag 1977}
@b{Guttag}, John V.  1977.  Abstract data types and the development of data
structures.  @cite{Communications of the @acronym{ACM}} 20(6): 396-404.
@url{http://www.unc.edu/~stotts/comp723/guttagADT77.pdf, –›}

\phantomsection @anchor{Hamming 1980}
@b{Hamming}, Richard W.  1980.  @cite{Coding and Information Theory}.  Englewood
Cliffs, N.J.: Prentice-Hall.

\phantomsection @anchor{Hanson 1990}
@b{Hanson}, Christopher P.  1990.  Efficient stack allocation for tail-recur\-sive
languages.  In @cite{Proceedings of @acronym{ACM} Conference on Lisp and
Functional Programming}, pp. 106-118.
@url{https://groups.csail.mit.edu/mac/ftpdir/users/cph/links.ps.gz, –›}

\phantomsection @anchor{Hanson 1991}
@b{Hanson}, Christopher P.  1991.  A syntactic closures macro facility.  @cite{Lisp
Pointers}, 4(3).
@url{http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps, –›}

\phantomsection @anchor{Hardy 1921}
@b{Hardy}, Godfrey H.  1921.  Srinivasa Ramanujan.  @cite{Proceedings of the London
Mathematical Society} @acronym{XIX}(2).

\phantomsection @anchor{Hardy and Wright 1960}
@b{Hardy}, Godfrey H., and E. M. Wright.  1960.  @cite{An Introduction to the
Theory of Numbers}.  4th edition.  New York: Oxford University Press.
@url{https://archive.org/details/AnIntroductionToTheTheoryOfNumbers-4thEd-G.h.HardyE.m.Wright, –›}

\phantomsection @anchor{Havender (1968)}
@b{Havender}, J. 1968. Avoiding deadlocks in multi-tasking systems. @cite{@acronym{IBM}
Systems Journal} 7(2): 74-84.

\phantomsection @anchor{Hearn 1969}
@b{Hearn}, Anthony C.  1969.  Standard Lisp.  Technical report @acronym{AIM}-90,
Artificial Intelligence Project, Stanford University.
@url{http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf, –›}

\phantomsection @anchor{Henderson 1980}
@b{Henderson}, Peter. 1980.  @cite{Functional Programming: Application and
Implementation}. Englewood Cliffs, N.J.: Prentice-Hall.

\phantomsection @anchor{Henderson 1982}
@b{Henderson}, Peter. 1982. Functional Geometry. In @cite{Conference Record of the
1982 @acronym{ACM} Symposium on Lisp and Functional Programming}, pp. 179-187.
@url{http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf, –›},
@url{http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf, 2002 version –›}

\phantomsection @anchor{Hewitt (1969)}
@b{Hewitt}, Carl E.  1969.  @acronym{PLANNER}: A language for proving
theorems in robots.  In @cite{Proceedings of the International Joint
Conference on Artificial Intelligence}, pp. 295-301.
@url{http://dspace.mit.edu/handle/1721.1/6171, –›}

\phantomsection @anchor{Hewitt (1977)}
@b{Hewitt}, Carl E.  1977.  Viewing control structures as patterns of passing
messages.  @cite{Journal of Artificial Intelligence} 8(3): 323-364.
@url{http://dspace.mit.edu/handle/1721.1/6272, –›}

\phantomsection @anchor{Hoare (1972)}
@b{Hoare}, C. A. R. 1972.  Proof of correctness of data representations.
@cite{Acta Informatica} 1(1).

\phantomsection @anchor{Hodges 1983}
@b{Hodges}, Andrew. 1983.  @cite{Alan Turing: The Enigma}. New York: Simon and
Schuster.

\phantomsection @anchor{Hofstadter 1979}
@b{Hofstadter}, Douglas R.  1979.  @cite{G@"odel, Escher, Bach: An Eternal Golden
Braid}. New York: Basic Books.

\phantomsection @anchor{Hughes 1990}
@b{Hughes}, R. J. M.  1990.  Why functional programming matters.  In @cite{Research
Topics in Functional Programming}, edited by David Turner.  Reading, @acronym{MA}:
Addison-Wesley, pp. 17-42.
@url{http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf, –›}

\phantomsection @anchor{IEEE 1990}
@acronym{@b{IEEE}} Std 1178-1990.  1990.  @cite{@acronym{IEEE} Standard for the
Scheme Programming Language}.

\enlargethispage{\baselineskip}

\phantomsection @anchor{Ingerman et al. 1960}
@b{Ingerman}, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by
M. Lind, Herbert Kanner, and Robert Floyd.  1960.  @acronym{THUNKS}: A way of
compiling procedure statements, with some comments on procedure declarations.
Unpublished manuscript.  (Also, private communication from Wallace Feurzeig.)

\phantomsection @anchor{Kaldewaij 1990}
@b{Kaldewaij}, Anne. 1990.  @cite{Programming: The Derivation of Algorithms}. New
York: Prentice-Hall.

\phantomsection @anchor{Knuth (1973)}
@b{Knuth}, Donald E.  1973.  @cite{Fundamental Algorithms}. Volume 1 of @cite{The
Art of Computer Programming}.  2nd edition. Reading, @acronym{MA}: Addison-Wesley.

\phantomsection @anchor{Knuth 1981}
@b{Knuth}, Donald E.  1981.  @cite{Seminumerical Algorithms}. Volume 2 of @cite{The
Art of Computer Programming}.  2nd edition. Reading, @acronym{MA}: Addison-Wesley.

\phantomsection @anchor{Kohlbecker 1986}
@b{Kohlbecker}, Eugene Edmund, Jr. 1986.  Syntactic extensions in the programming
language Lisp.  Ph.D. thesis, Indiana University.
@url{http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf, –›}

\phantomsection @anchor{Konopasek and Jayaraman 1984}
@b{Konopasek}, Milos, and Sundaresan Jayaraman.  1984.  @cite{The TK!Solver Book: A
Guide to Problem-Solving in Science, Engineering, Business, and
Education}. Berkeley, @acronym{CA}: Osborne/McGraw-Hill.

\phantomsection @anchor{Kowalski (1973; 1979)}
@b{Kowalski}, Robert.  1973.  Predicate logic as a programming language.  Technical
report 70, Department of Computational Logic, School of Artificial
Intelligence, University of Edinburgh.
@url{http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf, –›}

@b{Kowalski}, Robert.  1979.  @cite{Logic for Problem Solving}. New York:
North-Holland.
@url{http://www.doc.ic.ac.uk/%7Erak/papers/LogicForProblemSolving.pdf, –›}

\phantomsection @anchor{Lamport (1978)}
@b{Lamport}, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  @cite{Communications of the @acronym{ACM}} 21(7): 558-565.
@url{http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf, –›}

\phantomsection @anchor{Lampson et al. 1981}
@b{Lampson}, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.  Popek.
1981.  Report on the programming language Euclid.  Technical report, Computer
Systems Research Group, University of Toronto.
@url{http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf, –›}

\phantomsection @anchor{Landin (1965)}
@b{Landin}, Peter.  1965.  A correspondence between Algol 60 and Church's lambda
notation: Part I.  @cite{Communications of the @acronym{ACM}} 8(2): 89-101.

\phantomsection @anchor{Lieberman and Hewitt 1983}
@b{Lieberman}, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based
on the lifetimes of objects. @cite{Communications of the @acronym{ACM}}
26(6): 419-429.
@url{http://dspace.mit.edu/handle/1721.1/6335, –›}

\phantomsection @anchor{Liskov and Zilles (1975)}
@b{Liskov}, Barbara H., and Stephen N. Zilles.  1975.  Specification techniques for
data abstractions.  @cite{@acronym{IEEE} Transactions on Software Engineering}
1(1): 7-19.
@url{http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf, –›}

\phantomsection @anchor{McAllester (1978; 1980)}
@b{McAllester}, David Allen.  1978.  A three-valued truth-maintenance system.  Memo
473, @acronym{MIT} Artificial Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/6296, –›}

@b{McAllester}, David Allen.  1980.  An outlook on truth maintenance.  Memo 551,
@acronym{MIT} Artificial Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/6327, –›}

\phantomsection @anchor{McCarthy 1960}
@b{McCarthy}, John.  1960.  Recursive functions of symbolic expressions and their
computation by machine.  @cite{Communications of the @acronym{ACM}}
3(4): 184-195.
@url{http://www-formal.stanford.edu/jmc/recursive.pdf, –›}

\phantomsection @anchor{McCarthy 1963}
@b{McCarthy}, John.  1963.  A basis for a mathematical theory of computation.  In
@cite{Computer Programming and Formal Systems}, edited by P. Braffort and
D. Hirschberg.  North-Holland.
@url{http://www-formal.stanford.edu/jmc/basis.html, –›}

\phantomsection @anchor{McCarthy 1978}
@b{McCarthy}, John.  1978.  The history of Lisp.  In @cite{Proceedings of the
@acronym{ACM} @acronym{SIGPLAN} Conference on the History of Programming
Languages}.
@url{http://www-formal.stanford.edu/jmc/history/lisp/lisp.html, –›}

\phantomsection @anchor{McCarthy et al. 1965}
@b{McCarthy}, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.  Levin.
1965.  @cite{Lisp 1.5 Programmer's Manual}.  2nd edition.  Cambridge, @acronym{MA}:
@acronym{MIT} Press.
@url{http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Prog@/rammers%20Manual.pdf/view, –›}

\phantomsection @anchor{McDermott and Sussman (1972)}
@b{McDermott}, Drew, and Gerald Jay Sussman.  1972. Conniver reference manual.
Memo 259, @acronym{MIT} Artificial Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/6203, –›}

\phantomsection @anchor{Miller 1976}
@b{Miller}, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
@cite{Journal of Computer and System Sciences} 13(3): 300-317.
@url{http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html, –›}

\phantomsection @anchor{Miller and Rozas 1994}
@b{Miller}, James S., and Guillermo J. Rozas. 1994.  Garbage collection is fast,
but a stack is faster.  Memo 1462, @acronym{MIT} Artificial Intelligence
Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/6622, –›}

\phantomsection @anchor{Moon 1978}
@b{Moon}, David.  1978.  MacLisp reference manual, Version 0.  Technical report,
@acronym{MIT} Laboratory for Computer Science.
@url{http://www.softwarepreservation.org/projects/@/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view, –›}

\phantomsection @anchor{Moon and Weinreb 1981}
@b{Moon}, David, and Daniel Weinreb.  1981.  Lisp machine manual.  Technical
report, @acronym{MIT} Artificial Intelligence Laboratory.
@url{http://www.unlambda.com/lmman/index.html, –›}

\enlargethispage{\baselineskip}

\phantomsection @anchor{Morris et al. 1980}
@b{Morris}, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience with an
applicative string processing language.  In @cite{Proceedings of the 7th Annual
@acronym{ACM} @acronym{SIGACT}/@acronym{SIGPLAN} Symposium on the Principles of
Programming Languages}.

\phantomsection @anchor{Phillips 1934}
@b{Phillips}, Hubert.  1934. @cite{The Sphinx Problem Book}.  London: Faber and
Faber.

\phantomsection @anchor{Pitman 1983}
@b{Pitman}, Kent. 1983. The revised MacLisp Manual (Saturday evening edition).
Technical report 295, @acronym{MIT} Laboratory for Computer Science.
@url{http://maclisp.info/pitmanual, –›}

\phantomsection @anchor{Rabin 1980}
@b{Rabin}, Michael O. 1980. Probabilistic algorithm for testing primality.
@cite{Journal of Number Theory} 12: 128-138.

\phantomsection @anchor{Raymond 1993}
@b{Raymond}, Eric.  1993. @cite{The New Hacker's Dictionary}. 2nd edition.
Cambridge, @acronym{MA}: @acronym{MIT} Press.
@url{http://www.catb.org/jargon/, –›}

@b{Raynal}, Michel. 1986. @cite{Algorithms for Mutual Exclusion}.  Cambridge, @acronym{MA}:
@acronym{MIT} Press.

\phantomsection @anchor{Rees and Adams 1982}
@b{Rees}, Jonathan A., and Norman I. Adams @acronym{IV}. 1982.  T: A dialect of Lisp or,
lambda: The ultimate software tool.  In @cite{Conference Record of the 1982
@acronym{ACM} Symposium on Lisp and Functional Programming}, pp.  114-122.
@url{http://people.csail.mit.edu/riastradh/t/adams82t.pdf, –›}

@b{Rees}, Jonathan, and William Clinger (eds). 1991.  The @math{\rm revised^4} report on the
algorithmic language Scheme.  @cite{Lisp Pointers}, 4(3).
@url{http://people.csail.mit.edu/jaffer/r4rs.pdf, –›}

\phantomsection @anchor{Rivest et al. (1977)}
@b{Rivest}, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for obtaining
digital signatures and public-key cryptosystems. Technical memo @acronym{LCS}/@acronym{TM82},
@acronym{MIT} Laboratory for Computer Science.
@url{http://people.csail.mit.edu/rivest/Rsapaper.pdf, –›}

\phantomsection @anchor{Robinson 1965}
@b{Robinson}, J. A. 1965.  A machine-oriented logic based on the resolution
principle.  @cite{Journal of the @acronym{ACM}} 12(1): 23.

\phantomsection @anchor{Robinson 1983}
@b{Robinson}, J. A. 1983.  Logic programming---Past, present, and future.
@cite{New Generation Computing} 1: 107-124.

\phantomsection @anchor{Spafford 1989}
@b{Spafford}, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
@cite{Communications of the @acronym{ACM}} 32(6): 678-688.
@url{http://citeseerx.ist.psu.edu/viewdoc/download?@/doi=10.1.1.123.8503&rep=rep1&type=pdf, –›}

\phantomsection @anchor{Steele 1977}
@b{Steele}, Guy Lewis, Jr.  1977.  Debunking the ``expensive procedure call'' myth.
In @cite{Proceedings of the National Conference of the @acronym{ACM}},
pp. 153-62.
@url{http://dspace.mit.edu/handle/1721.1/5753, –›}

\pagebreak

\phantomsection @anchor{Steele 1982}
@b{Steele}, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In
@cite{Proceedings of the @acronym{ACM} Symposium on Lisp and Functional
Programming}, pp. 98-107.

\phantomsection @anchor{Steele 1990}
@b{Steele}, Guy Lewis, Jr.  1990.  @cite{Common Lisp: The Language}. 2nd edition.
Digital Press.
@url{http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html, –›}

\phantomsection @anchor{Steele and Sussman 1975}
@b{Steele}, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An interpreter
for the extended lambda calculus.  Memo 349, @acronym{MIT} Artificial
Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/5794, –›}

\phantomsection @anchor{Steele et al. 1983}
@b{Steele}, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.  Crispin,
Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  @cite{The Hacker's
Dictionary}. New York: Harper \& Row.
@url{http://www.dourish.com/goodies/jargon.html, –›}

\phantomsection @anchor{Stoy 1977}
@b{Stoy}, Joseph E.  1977.  @cite{Denotational Semantics}. Cambridge, @acronym{MA}:
@acronym{MIT} Press.

\phantomsection @anchor{Sussman and Stallman 1975}
@b{Sussman}, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic techniques in
computer-aided circuit analysis.  @cite{@acronym{IEEE} Transactions on Circuits
and Systems} @acronym{CAS}-22(11): 857-865.
@url{http://dspace.mit.edu/handle/1721.1/5803, –›}

\phantomsection @anchor{Sussman and Steele 1980}
@b{Sussman}, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints---A language
for expressing almost-hierachical descriptions.  @cite{AI Journal} 14: 1-39.
@url{http://dspace.mit.edu/handle/1721.1/6312, –›}

\phantomsection @anchor{Sussman and Wisdom 1992}
@b{Sussman}, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the solar
system.  @cite{Science} 257: 256-262.
@url{http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf, –›}

\phantomsection @anchor{Sussman et al. (1971)}
@b{Sussman}, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.  Microplanner
reference manual.  Memo 203@acronym{A}, @acronym{MIT} Artificial Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/6184, –›}

\phantomsection @anchor{Sutherland (1963)}
@b{Sutherland}, Ivan E.  1963.  @acronym{SKETCHPAD}: A man-machine graphical
communication system.  Technical report 296, @acronym{MIT} Lincoln Laboratory.
@url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf, –›}

\phantomsection @anchor{Teitelman 1974}
@b{Teitelman}, Warren.  1974.  Interlisp reference manual.  Technical report, Xerox
Palo Alto Research Center.
@url{http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf/view, –›}

\phantomsection @anchor{Thatcher et al. 1978}
@b{Thatcher}, James W., Eric G. Wagner, and Jesse B. Wright. 1978.  Data type
specification: Parameterization and the power of specification techniques. In
@cite{Conference Record of the Tenth Annual @acronym{ACM} Symposium on Theory
of Computing}, pp. 119-132.

\phantomsection @anchor{Turner 1981}
@b{Turner}, David.  1981.  The future of applicative languages.  In
@cite{Proceedings of the 3rd European Conference on Informatics}, Lecture Notes
in Computer Science, volume 123. New York: Springer-Verlag, pp.  334-348.

\phantomsection @anchor{Wand 1980}
@b{Wand}, Mitchell.  1980.  Continuation-based program transformation strategies.
@cite{Journal of the @acronym{ACM}} 27(1): 164-180.
@url{http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf, –›}

\phantomsection @anchor{Waters (1979)}
@b{Waters}, Richard C.  1979.  A method for analyzing loop programs.
@cite{@acronym{IEEE} Transactions on Software Engineering} 5(3): 237-247.

@b{Winograd}, Terry.  1971.  Procedures as a representation for data in a computer
program for understanding natural language.  Technical report @acronym{AI TR}-17,
@acronym{MIT} Artificial Intelligence Laboratory.
@url{http://dspace.mit.edu/handle/1721.1/7095, –›}

\phantomsection @anchor{Winston 1992}
@b{Winston}, Patrick. 1992. @cite{Artificial Intelligence}.  3rd edition.  Reading,
@acronym{MA}: Addison-Wesley.

\phantomsection @anchor{Zabih et al. 1987}
@b{Zabih}, Ramin, David McAllester, and David Chapman.  1987.  Non-deterministic
Lisp with dependency-directed backtracking.  @cite{@acronym{AAAI}-87},
pp. 59-64.
@url{http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf, –›}

\phantomsection @anchor{Zippel (1979)}
@b{Zippel}, Richard.  1979.  Probabilistic algorithms for sparse polynomials.
Ph.D. dissertation, Department of Electrical Engineering and Computer Science,
@acronym{MIT}.

\phantomsection @anchor{Zippel 1993}
@b{Zippel}, Richard.  1993.  @cite{Effective Polynomial Computation}.  Boston, @acronym{MA}:
Kluwer Academic Publishers.

\fontspec[Numbers={Lining}]{Linux Libertine O}

@unnumbered List of Exercises
@node    List of Exercises, List of Figures, References, Top

@c @include exercises.texi
\input{exercises}

@unnumbered List of Figures
@node    List of Figures, Index, List of Exercises, Top

@c @include figures.texi
\input{figures}

@ifinfo
@unnumbered Index
@node    Index, Colophon, List of Figures, Top

@sp 0.8

@quotation
Any inaccuracies in this index may be explained by the fact@*
that it has been prepared with the help of a computer.

---Donald E. Knuth, @cite{Fundamental Algorithms}@*
(Volume 1 of @cite{The Art of Computer Programming})
@end quotation

@sp 1.7
@end ifinfo

\setindexprenote{\normalsize \begin{quote} Any inaccuracies in this index may be explained by the fact
that it has been prepared with the help of a computer.

---Donald E. Knuth, \textit{Fundamental Algorithms}\\
(Volume 1 of \textit{The Art of Computer Programming}) \end{quote}}

@printindex cp

@unnumbered Colophon
@node    Colophon, , Index, Top

\lettrine[lraise=-0.03,loversize=0.08]{O}{n the cover page} is Agostino Ramelli's bookwheel mechanism from 1588. It could be seen as an early hypertext navigation aid. This image of the engraving is hosted by J. E. Johnson of @url{http://newgottland.com/2012/02/09/before-the-ereader-there-was-the-wheelreader/ramelli_bookwheel_1032px/, New Gottland}.

The typefaces are Linux Libertine for body text and Linux Biolinum for headings, both by Philipp H. Poll. Typewriter face is Inconsolata created by Raph Levien and supplemented by Dimosthenis Kaponis and Takashi Tanigawa in the form of Inconsolata @acronym{LGC}. The cover page typeface is Alegreya, designed by Juan Pablo del Peral.

Graphic design and typography are done by Andres Raba. Texinfo source is converted to LaTeX by a Perl script and compiled to @acronym{PDF} by XeLaTeX. Diagrams are drawn with Inkscape.

@bye
