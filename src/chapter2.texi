@comment @chapter Building Abstractions with Data
@chapter Построение абстракций с помощью данных
@node    Глава 2, Глава 3, Глава 1, Вверх

@quotation
Теперь мы подходим к решающему шагу в математической абстракции: мы
забываем, что обозначают наши символы. ...[Математик] не должен стоять
на месте: есть много операций, которые он может производить с этими
символами, не обращая внимания на те вещи, которые они обозначают.

---Hermann Weyl, @cite{The Mathematical Way of Thinking}
@end quotation

@c @sp 1.0

@noindent
\lettrine[findent=1pt]{М}{ы сконцентрировали} внимание в @ref{Главе 1}
на вычислительных процессах и роли процедур
в проектировании программ. Мы рассмотрели, как использовать простейшие
данные (числа) и простейшие операции (арифметические), как сочетать
процедуры и получать составные процедуры с помощью композиции, условных
выражений и использования параметров, а также как строить абстрактные
процедуры при помощи @code{define}. Мы убедились, что процедуру можно
рассматривать как схему локального развития процесса; мы
классифицировали некоторые общие схемы процессов, воплощенные в
процедурах, строили о них умозаключения и производили их простейший
алгоритмический анализ. Кроме того, мы увидели, что процедуры высших
порядков увеличивают выразительную силу нашего языка, позволяя
оперировать общими методами вычисления, а следовательно, и проводить
рассуждения в их терминах. Это во многом и составляет сущность
программирования.

В этой главе мы будем рассматривать более сложные данные. Все процедуры
главы 1 работают с простыми численными данными, а простых численных данных
часто бывает недостаточно для тех задач, которые мы хотим решать с помощью
вычислений. Программы, как правило, пишут, чтобы моделировать сложные
явления, и чаще всего приходится строить вычислительные объекты,
состоящие из нескольких частей, чтобы смоделировать многосторонние
явления реального мира. Таким образом, в отличие от
главы 1, где наше внимание было в основном направлено на создание абстракций
с помощью сочетания процедур и построения составных процедур, в этой главе
мы обращаемся к другой важной характеристике всякого языка
программирования: тем средствам, которые он предоставляет для создания
абстракций с помощью сочетания объектов данных и построения (compound
data).

Для чего в языке программирования нужны составные данные? По тем же
причинам, по которым нужны составные процедуры: мы хотим повысить
понятийный уровень, на котором мы проектируем программы, хотим сделать
наши проекты более модульными и увеличить выразительную силу языка.
Точно так же, как способность определять процедуры дает возможность
работать с процессами на более высоком содержательном уровне, чем
уровень элементарных операций языка, способность конструировать
составные объекты данных позволяет работать с данными на более высоком
понятийном уровне, чем уровень элементарных данных нашего языка.

\enlargethispage{\baselineskip}

Рассмотрим задачу проектирования системы для арифметических вычислений с
рациональными числами. Мы можем представить себе операцию
@code{add-rat}, которая принимает два рациональных числа и вычисляет их
сумму. В терминах простейших данных, рациональное число можно
рассматривать как два целых числа: числитель и знаменатель. Таким
образом, мы могли бы сконструировать программу, в которой всякое
рациональное число представлялось бы как пара целых (числитель и
знаменатель) и @code{add-rat} была бы реализована как две процедуры
(одна из которых вычисляла бы числитель суммы, а другая знаменатель).
Однако это было бы крайне неудобно, поскольку нам приходилось бы
следить, какие числители каким знаменателям соответствуют. Если бы
системе требовалось производить большое количество операций над большим
количеством рациональных чисел, такие служебные детали сильно затемняли
бы наши программы, не говоря уже о наших мозгах. Было бы намного проще,
если бы мы могли <<склеить>> числитель со знаменателем и получить пару
--- (@newterm{compound data object}), --- с которой наши программы могли бы
обращаться способом, соответствующим нашему представлению о рациональном
числе как о едином понятии.

Кроме того, использование составных данных позволяет увеличить
модульность программ. Если бы мы могли обрабатывать рациональные числа
непосредственно как объекты, то можно было бы отделить ту часть
программы, которая работает собственно с рациональными числами, от
деталей представления рационального числа в виде пары целых. Общий метод
отделения частей программы, которые имеют дело с представлением объектов
данных, от тех частей, где эти объекты данных используются, --- это
мощная методология проектирования, называемая (@newterm{data abstraction}). Мы
увидим, как с помощью абстракции данных программы становится легче
проектировать, поддерживать и изменять.

Использование составных данных ведет к настоящему увеличению
выразительной силы нашего языка программирования. Рассмотрим идею
порождения <<линейной комбинации>> @math{ax + by}. Нам может
потребоваться процедура, которая принимала бы как аргументы @math{a},
@math{b}, @math{x} и @math{y} и возвращала бы значение @math{ax + by}.
Если аргументы являются числами, это не представляет никакой трудности,
поскольку мы сразу можем определить процедуру

@lisp
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))
@end lisp

@noindent
Предположим, однако, что нас интересуют не только числа. Предположим,
что нам хотелось бы выразить в процедурных терминах идею о том, что
можно строить линейные комбинации всюду, где определены сложение и
умножение --- для рациональных и комплексных чисел, многочленов и
многого другого. Мы могли бы выразить это как процедуру в следующей
форме:

@lisp
(define (linear-combination a b x y)
  (add (mul a x) (mul b y)))
@end lisp

@noindent
где @code{add} и @code{mul} --- не элементарные процедуры @code{+} и
@code{*}, а более сложные устройства, которые проделывают соответствующие
операции, какие бы типы данных мы ни передавали как аргументы @code{a},
@code{b}, @code{x} и @code{y}. Здесь важнейшая деталь состоит в том, что
единственное, что требуется знать процедуре @code{linear-combination} об
@code{a}, @code{b}, @code{x} и @code{y} --- это то, что процедуры
@code{add} и @code{mul} проделывают соответствующие действия. С точки
зрения процедуры @code{linear-combination} несущественно, что такое
@code{a}, @code{b}, @code{x} и @code{y}, и еще менее существенно, как
они могут быть представлены через более простые данные. Этот же пример
показывает, почему так важно, чтобы в нашем языке программирования была
возможность прямо работать с составными объектами: иначе у процедур,
подобных @code{linear-combination}, не было бы способа передать
аргументы в @code{add} и @code{mul}, не зная деталей их
устройства.@footnote{Способность прямо оперировать процедурами
увеличивает выразительную силу нашего языка программирования подобным же
образом. Например, в разделе @ref{1.3.1} мы
ввели процедуру @code{sum}, которая принимает в качестве аргумента
процедуру @code{term} и вычисляет сумму значений @code{term} на
некотором заданном интервале. Чтобы определить @code{sum}, нам
необходимо иметь возможность говорить о процедуре типа @code{term} как о
едином целом, независимо от того, как она выражена через более простые
операции. Вообще говоря, не имей мы понятия <<процедуры>>, вряд ли мы и
думать могли бы о возможности определения такой операции, как
@code{sum}. Более того, пока мы размышляем о суммировании, детали того,
как @code{term} может быть составлен из более простых операций,
несущественны.}

Мы начинаем эту главу с реализации описанной выше системы арифметики
рациональных чисел. Это послужит основанием для обсуждения составных
данных и абстракции данных. Как и в случае с составными процедурами,
основная мысль состоит в том, что абстракция является методом
ограничения сложности, и мы увидим, как абстракция данных позволяет нам
возводить полезные (@newterm{abstraction barriers}) между разными частями
программы.

Мы увидим, что главное в работе с составными данными --- то, что язык
программирования должен предоставлять нечто вроде <<клея>>, так, чтобы
объекты данных могли сочетаться, образуя более сложные объекты данных.
Существует множество возможных типов клея. На самом деле мы обнаружим,
что составные данные можно порождать вообще без использования каких-либо
специальных операций, относящихся к <<данным>> --- только с помощью
процедур. Это еще больше размоет границу между <<процедурами>> и
<<данными>>, которая уже к концу
главы 1 оказалась весьма тонкой. Мы также исследуем некоторые общепринятые
методы представления последовательностей и деревьев. Важная идея в
работе с составными данными --- понятие (@newterm{closure}): клей для сочетания
объектов данных должен позволять нам склеивать не только элементарные
объекты данных, но и составные. Еще одна важная идея состоит в том, что
составные объекты данных могут служить (@newterm{conventional interfaces}), так,
чтобы модули программы могли сочетаться методом подстановки. Некоторые
из этих идей мы продемонстрируем с помощью простого графического языка,
использующего замыкание.

\enlargethispage{\baselineskip}

Затем мы увеличим выразительную мощность нашего языка путем введения
(@newterm{symbolic expressions}) --- данных, элементарные части которых могут
быть произвольными символами, а не только числами. Мы рассмотрим
различные варианты представления множеств объектов. Мы обнаружим, что,
подобно тому, как одна и та же числовая функция может вычисляться
различными вычислительными процессами, существует множество способов
представить некоторую структуру данных через элементарные объекты, и
выбор представления может существенно влиять на запросы манипулирующих
этими данными процессов к памяти и ко времени. Мы исследуем эти идеи в
контексте символьного дифференцирования, представления множеств и
кодирования информации.

После этого мы обратимся к задаче работы с данными, которые по-разному
могут быть представлены в различных частях программы. Это ведет к
необходимости ввести (@newterm{generic operations}), которые обрабатывают много
различных типов данных. Поддержка модульности в присутствии обобщенных
операций требует более мощных барьеров абстракции, чем тех, что
получаются с помощью простой абстракции данных. А именно, мы вводим
(@newterm{data-directed programming}) как метод, который позволяет проектировать
представления данных отдельно, а затем сочетать их (@newterm{additively}) (т. е.,
без модификации). Чтобы проиллюстрировать силу этого подхода к
проектированию систем, в завершение главы мы применим то, чему в ней
научились, к реализации пакета символьной арифметики многочленов,
коэффициенты которых могут быть целыми, рациональными числами,
комплексными числами и даже другими многочленами.

@menu
* 2-1::              Введение в абстракцию данных
* 2-2::              Иерархические данные и свойство замыкания
* 2-3::              Символьные данные
* 2-4::              Множественные представления для абстрактных данных
* 2-5::              Системы с обобщенными операциями
@end menu

@comment @section Introduction to Data Abstraction
@section Введение в абстракцию данных
@node	 2.1, 2.2, Глава 2, Глава 2

В разделе @ref{1.1.8}
мы заметили, что процедура, которую мы используем как элемент при
создании более сложной процедуры, может рассматриваться не только как
последовательность определенных операций, но и как процедурная
абстракция: детали того, как процедура реализована, могут быть скрыты, и
сама процедура может быть заменена на другую с подобным поведением.
Другими словами, мы можем использовать абстракцию для отделения способа
использования процедуры от того, как эта процедура реализована в
терминах более простых процедур. Для составных данных подобное понятие
называется (@newterm{data abstraction}). Абстракция данных --- это методология,
которая позволяет отделить способ использования составного объекта
данных от деталей того, как он составлен из элементарных данных.

Основная идея абстракции данных состоит в том, чтобы строить программы,
работающие с составными данными, так, чтобы иметь дело с <<абстрактными
данными>>. То есть, используя данные, наши программы не должны делать о
них никаких предположений, кроме абсолютно необходимых для выполнения
поставленной задачи. В то же время <<конкретное>> представление данных
определяется независимо от программ, которые эти данные используют.
Интерфейсом между двумя этими частями системы служит набор процедур,
называемых (@newterm{selectors}) и (@newterm{constructors}), реализующих
абстрактные данные в терминах конкретного представления. Чтобы
проиллюстрировать этот метод, мы рассмотрим, как построить набор процедур
для работы с рациональными числами.

@menu
* 2-1-1::             Пример арифметические операции над рациональными числами
* 2-1-2::             Барьеры абстракции
* 2-1-3::             Что значит слово <<данные>>?
* 2-1-4::             Расширенный пример интервальная арифметика
@end menu

@comment @subsection Example: Arithmetic Operations@* for Rational Numbers
@subsection Пример: арифметические операции над рациональными числами
@node	2.1.1, 2.1.2, 2.1, 2.1

Допустим, нам нужно работать с рациональной арифметикой. Нам требуется
складывать, вычитать, умножать и делить рациональные числа, а также
проверять, равны ли два рациональных числа друг другу.

Для начала предположим, что у нас уже есть способ построить рациональное
число из его числителя и знаменателя. Кроме того, мы предполагаем, что
имея рациональное число, мы можем получить его числитель и знаменатель.
Допустим также, что эти конструктор и два селектора доступны нам в виде
процедур:

@itemize @bullet

@item
@math{\hbox{\tt(make-rat}\;\langle{n}\rangle\;\langle{d}\kern0.06em\rangle\hbox{\tt)}} возвращает рациональное число, числитель которого целое @math{\langle{n}\rangle} а знаменатель --- целое @math{\langle{d}\kern0.06em\rangle}.

@item
@math{\hbox{\tt(numer}\;\;\langle{x}\rangle\hbox{\tt)}} возвращает числитель рационального числа
@math{\langle{x}\rangle}.

@item
@math{\hbox{\tt(denom}\;\;\langle{x}\rangle\hbox{\tt)}} возвращает знаменатель рационального
@math{\langle{x}\rangle}.

@end itemize

@noindent
Здесь мы используем мощную стратегию синтеза: (@newterm{wishful thinking}).
Пока что мы не сказали, как представляется рациональное число и как должны
реализовываться процедуры @code{numer}, @code{denom} и @code{make-rat}.
Тем не менее, если бы эти процедуры у нас были, мы могли бы складывать,
вычитать, умножать, делить и проверять на равенство с помощью следующих
отношений:
@ifinfo

@example
n_1   n_2   n_1 d_2 + n_2 d_1
--- + --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 d_2 - n_2 d_1
--- - --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 n_2
--- * --- = -------
d_1   d_2   d_1 d_2

n_1 / d_1   n_1 d_2
--------- = -------
n_2 / d_2   d_1 n_2

n_1   n_2
--- = ---  тогда и только тогда, когда if n_1 d_2 = n_2 d_1
d_1   d_2
@end example
@end ifinfo
\begin{align*}
  {n_1 \over d_1} + {n_2 \over d_2} 	&= {n_1 d_2 + n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} - {n_2 \over d_2} 	&= {n_1 d_2 - n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} \cdot {n_2 \over d_2}	&= {n_1 n_2 \over d_1 d_2}, \\
  {n_1 / d_1} \over {n_2 / d_2} 	&= {n_1 d_2 \over d_1 n_2}, \\
  {n_1 \over d_1} 			&= {n_2 \over d_2}
\end{align*}
тогда и только тогда, когда:
\begin{align*}
   n_1 d_2 = n_2 d_1.
\end{align*}
@noindent
Мы можем выразить эти правила в процедурах:

@lisp
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
@end lisp

Теперь у нас есть операции над рациональными числами, определенные в
терминах процедур --- селекторов и конструкторов @code{numer},
@code{denom} и @code{make-rat}. Однако сами эти процедуры мы еще не
написали. Нам нужен какой-нибудь способ склеить вместе числитель и
знаменатель, чтобы получить рациональное число.

@comment @subsubheading Pairs
@subsubheading Пары

Для реализации конкретного уровня абстракции данных в нашем языке
имеется составная структура, называемая (@newterm{pair}), и она создается с
помощью элементарной процедуры @code{cons}. Эта процедура принимает два
аргумента и возвращает объект данных, который содержит эти два аргумента
в качестве частей. Имея пару, мы можем получить ее части с помощью
элементарных процедур @code{ car} и @code{cdr}.@footnote{@code{cons}
означает @emph{construct} (построить, сконструировать, собрать). Имена
@code{car} и @code{cdr} происходят из исходной реализации Лиспа на IBM
704. Схема адресации этой машины позволяла обращаться к <<адресной>> и
<<декрементной>> частям ячейки памяти. @code{car} означает
@emph{Contents of Address Part of Register} (содержимое адресной части
регистра), а @code{cdr} (произносится <<куддер>>) означает
@emph{Contents of Decrement Part of Register} (содержимое декрементной
части регистра).} Таким образом, использовать @code{cons}, @code{car} и
@code{cdr} можно так:

@lisp
(define x (cons 1 2))
(car x)
@i{1}
(cdr x)
@i{2}
@end lisp

@noindent
Заметим, что пара является объектом, которому можно дать имя и работать
с ним, подобно элементарному объекту данных. Более того, можно
использовать @code{cons} для создания пар, элементы которых сами пары, и
так далее:

@lisp
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
@i{1}
(car (cdr z))
@i{3}
@end lisp

@noindent
В разделе @ref{2.2} мы
увидим, что из этой возможности сочетать пары следует возможность их
использовать как строительные блоки общего назначения при создании любых
сложных структур данных. Один-единственный примитив составных данных
@emph{пара}, реализуемый процедурами @code{cons}, @code{car} и
@code{cdr}, --- вот и весь клей, который нам нужен. Объекты данных,
составленные из пар, называются (@newterm{list-structured data}).

\enlargethispage{\baselineskip}

@comment @subsubheading Representing rational numbers
@subsubheading Представление рациональных чисел

Пары позволяют нам естественным образом завершить построение системы
рациональных чисел. Будем просто представлять рациональное число в виде
пары двух целых чисел: числителя и знаменателя. Тогда @code{make-rat},
@code{numer} и @code{denom} немедленно реализуются следующим
образом:@footnote{Другой способ определить селекторы и конструктор был бы

@lisp
(define make-rat cons)
(define numer car)
(define denom cdr)
@end lisp

Первое определение связывает имя @code{make-rat} со значением выражения
@code{cons}, то есть элементарной процедурой, которая строит пары. Таким
образом, @code{make-rat} и @code{cons} становятся именами для одного и
того же элементарного конструктора.

Такое определение конструкторов и селекторов эффективно: вместо того,
чтобы заставлять @code{make-rat} @emph{вызывать} @code{cons}, мы делаем
@code{make-rat} и @code{cons} @emph{одной и той же процедурой}, так что
когда вызывается @code{make-rat}, происходит вызов только одной
процедуры, а не двух. С другой стороны, это не дает работать отладочным
средствам, которые отслеживают вызовы процедур или устанавливают на них
контрольные точки: Вам может потребоваться следить за вызовами
@code{make-rat}, но Вы уж точно никогда не захотите отслеживать каждый
вызов @code{cons}.

В этой книге мы решили не использовать такой стиль определений.}

@lisp
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
@end lisp

@noindent
Кроме того, когда нам требуется выводить результаты вычислений, мы
печатаем рациональное число, сначала выводя его числитель, затем косую
черту и затем знаменатель:@footnote{--- элементарная процедура языка
Scheme для печати данных. Другая элементарная процедура, @code{newline},
переводит строку при печати. Эти процедуры не возвращают никакого
полезного значения, так что в примерах использования @code{print-rat}
ниже, мы показываем только то, что печатает @code{print-rat}, а не то,
что интерпретатор выводит как значение @code{print-rat}.}

@lisp
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
@end lisp

@noindent
Теперь мы можем опробовать процедуры работы с рациональными числами:

@lisp
(define one-half (make-rat 1 2))
(print-rat one-half)
@i{1/2}
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
@i{5/6}
(print-rat (mul-rat one-half one-third))
@i{1/6}
(print-rat (add-rat one-third one-third))
@i{6/9}
@end lisp

@noindent
Как показывает последний пример, наша реализация рациональных чисел не
приводит их к наименьшему знаменателю. Мы можем исправить это упущение,
изменив @code{make-rat}. Если у нас есть процедура @code{gcd},
вычисляющая наибольший общий делитель двух целых чисел, вроде той,
которая описана в разделе @ref{1.2.5 }, мы
можем с помощью @code{gcd} сокращать числитель и знаменатель, прежде,
чем построить пару:

@lisp
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
@end lisp

@noindent
Теперь мы имеем

@lisp
(print-rat (add-rat one-third one-third))
@i{2/3}
@end lisp

@noindent
как нам того и хотелось. Эта модификация была произведена путем
изменения конструктора @code{make-rat}, и мы не тронули ни одну из
процедур (скажем, @code{add-rat} или @code{mul-rat}), которые реализуют
сами операции.

@quotation
@strong{@anchor{Упражнение 2.1}Упражнение 2.1:}
Определите улучшенную версию @code{make-rat}, которая
принимала бы как положительные, так и отрицательные аргументы.
@code{make-rat} должна нормализовывать знак так, чтобы в случае, если
рациональное число положительно, то и его числитель, и знаменатель были
бы положительны, а если оно отрицательно, то чтобы только его числитель
был отрицателен.
@end quotation

@comment @subsection Abstraction Barriers
@subsection Барьеры абстракции
@node	2.1.2, 2.1.3, 2.1.1, 2.1

Прежде чем мы перейдем к другим примерам работы с составными данными и
абстракцией данных, рассмотрим несколько вопросов, относящихся к примеру
с рациональными числами. Мы определили операции над рациональными
числами через конструктор @code{make-rat} и селекторы @code{numer} и
@code{denom}. В общем случае основная идея абстракции данных состоит в
том, чтобы определить для каждого типа объектов данных набор базовых
операций, через которые будут выражаться все действия с объектами этого
типа, и затем при работе с данными использовать только этот набор
операций.

@float
@anchor{Рисунок 2.1}
@ifinfo
@quotation
@strong{Рисунок 2.1:} Data-abstraction barriers in the rational-number package.

@example
        +------------------------------------+
--------| Programs that use rational numbers |--------
        +------------------------------------+
          Rational numbers in problem domain
            +---------------------------+
------------|   add-rat  sub-rat  ...   |-------------
            +---------------------------+
   Rational numbers as numerators and denominators
              +------------------------+
--------------| make-rat  numer  denom |--------------
              +------------------------+
              Rational numbers as pairs
                  +----------------+
------------------| cons  car  cdr |------------------
                  +----------------+
            However pairs are implemented
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap2/Fig2.1c,91mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.1:} Data-abstraction barriers in the rational-number package.}
@sp 0.6
@end iftex
@end float

Мы можем представить себе структуру системы работы с рациональными
числами так, как это показано на @ref{Рисунок 2.1}.
Горизонтальные линии обозначают (@newterm{abstraction barriers}), которые отделяют
различные <<уровни>> системы друг от друга. На каждом из этих уровней
барьер отделяет программы, которые используют абстрактные данные
(сверху) от программ, которые реализуют эту абстракцию данных (внизу).
Программы, использующие рациональные числа, работают с ними
исключительно в терминах процедур, которые пакет работы с рациональными
числами предоставляет <<для общего пользования>>: @code{add-rat},
@code{sub-rat}, @code{mul-rat}, @code{div-rat} и @code{equal-rat?}. В
свою очередь, эти процедуры используют только конструктор и селекторы
@code{make-rat}, @code{numer} и @code{denom}, которые сами реализованы
при помощи пар. Детали реализации пар не имеют значения для остальной
части пакета работы с рациональными числами; существенно только, что с
парами можно работать при помощи @code{cons}, @code{car} и @code{cdr}.
По существу, процедуры на каждом уровне являются интерфейсами, которые
определяют барьеры абстракции и связывают различные уровни.

У этой простой идеи много преимуществ. Одно из них состоит в том, что
программы становится намного проще поддерживать и изменять. Любая
сложная структура может быть представлена через элементарные структуры
данных языка программирования многими способами. Разумеется, выбор
представления влияет на программы, работающие с этим представлением; так
что, если когда-нибудь позднее его нужно будет изменить, соответственно
придется изменить и все эти программы. В случае больших программ эта
задача может быть весьма трудоемкой и дорогой, если зависимость от
представления не будет при проектировании ограничена несколькими
программными модулями.

Например, другим способом решения задачи приведения рациональных чисел к
наименьшему знаменателю было бы производить сокращение не тогда, когда
мы конструируем число, а каждый раз, как мы к нему обращаемся. При этом
потребуются другие конструктор и селекторы:

@lisp
(define (make-rat n d) (cons n d))
(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
@end lisp

@noindent
Разница между этой реализацией и предыдущей состоит в том, когда мы
вычисляем НОД с помощью @code{gcd}. Если при типичном использовании
рациональных чисел к числителю и знаменателю одного и того же
рационального числа мы обращаемся по многу раз, вычислять НОД лучше
тогда, когда рациональное число конструируется. Если нет, нам может быть
выгодно подождать с его вычислением до времени обращения. В любом
случае, когда мы переходим от одной реализации к другой, нам ничего не
нужно менять в процедурах @code{add-rat}, @code{sub-rat} и прочих.

То, что мы ограничиваем зависимость от представления несколькими
интерфейсными процедурами, помогает нам и проектировать программы, и
изменять их, поскольку таким образом мы сохраняем гибкость и получаем
возможность рассматривать другие реализации. Продолжая наш простой
пример, представим себе, что мы строим пакет работы с рациональными
числами и не можем сразу решить, вычислять ли НОД при построении числа
или при обращении к нему. Методология абстракции данных позволяет нам
отложить это решение, не теряя возможности продолжать разработку
остальных частей системы.

@quotation
@strong{@anchor{Упражнение 2.2}Упражнение 2.2:}
Рассмотрим задачу представления отрезков прямой на плоскости.
Каждый отрезок представляется как пара точек: начало и конец. Определите
конструктор @code{make-segment} и селекторы @code{start-segment} и
@code{end-segment}, которые определяют представление отрезков в терминах
точек. Далее, точку можно представить как пару чисел: координата
@math{x} и координата @math{y}. Соответственно, напишите конструктор
@code{make-@/point} и селекторы @code{x-point} и @code{y-point}, которые
определяют такое представление. Наконец, используя свои селекторы и
конструктор, напишите процедуру @code{midpoint-segment}, которая
принимает отрезок в качестве аргумента и возвращает его середину (точку,
координаты которой являются средним координат концов отрезка). Чтобы
опробовать эти процедуры, Вам потребуется способ печатать координаты
точек:

@endpage
@lisp
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.3}Упражнение 2.3:}
Реализуйте представление прямоугольников на плоскости.
(Подсказка: Вам могут потребоваться результаты
упражнения @ref{Упражнение 2.2}.) Определите в терминах своих
конструкторов и селекторов процедуры, которые вычисляют периметр и
площадь прямоугольника. Теперь реализуйте другое представление для
прямоугольников. Можете ли Вы спроектировать свою систему с подходящими
барьерами абстракции так, чтобы одни и те же процедуры вычисления
периметра и площади работали с любым из Ваших представлений?
@end quotation

@comment @subsection What Is Meant by Data?
@subsection Что значит слово <<данные>>?
@node	2.1.3, 2.1.4, 2.1.2, 2.1

Свою реализацию рациональных чисел в разделе @ref{2.1.1} мы начали с
определения операций над рациональными числами @code{add-rat},
@code{sub-rat} и так далее в терминах трех неопределенных процедур:
@code{make-rat}, @code{numer} и @code{denom}. В этот момент мы могли
думать об операциях как определяемых через объекты данных ---
числители, знаменатели и рациональные числа, --- поведение которых
определялось тремя последними процедурами.

Но что в точности означает слово (@newterm{data})? Здесь недостаточно просто
сказать <<то, что реализуется некоторым набором селекторов и
конструкторов>>. Ясно, что не любой набор из трех процедур может служить
основой для реализации рациональных чисел. Нам нужно быть уверенными в
том, что если мы конструируем рациональное число @code{x} из пары целых
@code{n} и @code{d}, то получение @code{numer} и @code{denom} от
@code{x} и деление их друг на друга должно давать тот же результат, что
и деление @code{n} на @code{d}. Другими словами, @code{make-rat},
@code{numer} и @code{denom} должны удовлетворять следующему условию: для
каждого целого числа @code{n} и не равного нулю целого @code{d}, если
@code{x} есть @code{(make-rat n d)}, то
@ifinfo

@example
(numer x)    n
--------- = ---
(denom x)    d
@end example

@end ifinfo
@tex
$$ {\hbox{\tt(numer x)} \over \hbox{\tt(denom x)}} = {{\tt n} \over {\tt d}}\,.  $$
@end tex
Это на самом деле единственное
условие, которому должны удовлетворять @code{make-rat}, @code{numer} и
@code{denom}, чтобы служить основой для представления рациональных
чисел. В общем случае можно считать, что данные --- это то, что
определяется некоторым набором селекторов и конструкторов, а также
некоторыми условиями, которым эти процедуры должны удовлетворять, чтобы
быть правильным представлением.@footnote{Как ни странно, эту мысль очень
трудно строго сформулировать. Существует два подхода к такой
формулировке. Один, начало которому положил Ч. А. Р. Хоар @ref{Hoare 1972},
известен как метод (@newterm{abstract models}). Он формализует спецификацию вида
<<процедуры плюс условия>> вроде описанной выше в примере с
рациональными числами. Заметим, что условие на представление
рациональных чисел было сформулировано в терминах утверждений о целых
числах (равенство и деление). В общем случае абстрактные модели
определяют новые типы объектов данных в терминах типов данных,
определенных ранее. Следовательно, утверждения об объектах данных могут
быть проверены путем сведения их к утверждениям об объектах данных,
которые были определены ранее. Другой подход, который был введен
Зиллесом из MIT, Гогеном, Тэтчером, Вагнером и Райтом из IBM (см.
@ref{Thatcher et al. 1978}) и Гаттэгом из университета Торонто
(см. @ref{Guttag 1977}), называется (@newterm{algebraic specification}).
Этот подход рассматривает <<процедуры>> как элементы абстрактной алгебраической
системы, чье поведение определяется аксиомами, соответствующими нашим
<<условиям>>, и использует методы абстрактной алгебры для проверки
утверждений об объектах данных. Оба этих метода описаны в статье Лисков
и Зиллеса @ref{Liskov and Zilles (1975)}.}

Эта точка зрения может послужить для определения не только
<<высокоуровневых>> объектов данных, таких как рациональные числа, но и
объектов низкого уровня. Рассмотрим понятие пары, с помощью которого мы
определили наши рациональные числа. Мы ведь ни разу не сказали, что
такое пара, и указывали только, что для работы с парами язык дает нам
процедуры @code{cons}, @code{car} и @code{cdr}. Но единственное, что нам
надо знать об этих процедурах --- это что если мы склеиваем два объекта
при помощи @code{cons}, то с помощью @code{car} и @code{cdr} мы можем
получить их обратно. То есть эти операции удовлетворяют условию, что для
любых объектов @code{x} и @code{y}, если @code{z} есть
@code{(cons x y)}, то @code{(car z)} есть @code{x}, а @code{(cdr z)}
есть @code{y}. Действительно, мы упомянули, что три эти процедуры
включены в наш язык как примитивы. Однако любая тройка процедур, которая
удовлетворяет вышеуказанному условию, может использоваться как основа
реализации пар. Эта идея ярко иллюстрируется тем, что мы могли бы
реализовать @code{cons}, @code{car} и @code{cdr} без использования
каких-либо структур данных, а только при помощи одних процедур. Вот эти
определения:

@lisp
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
@end lisp

@noindent
Такое использование процедур совершенно не соответствует нашему
интуитивному понятию о том, как должны выглядеть данные. Однако для
того, чтобы показать, что это законный способ представления пар,
требуется только проверить, что эти процедуры удовлетворяют
вышеуказанному условию.

Тонкость здесь состоит в том, чтобы заметить, что значение, возвращаемое
@code{cons}, есть процедура, --- а именно процедура @code{dispatch},
определенная внутри @code{cons}, которая принимает один аргумент и
возвращает либо @code{x}, либо @code{y} в зависимости от того, равен ли
ее аргумент 0 или 1. Соответственно, @code{(car z)} определяется как
применение @code{z} к 0. Следовательно, если @code{z} есть процедура,
полученная из @code{(cons x y)}, то @code{z}, примененная к 0, вернет
@code{x}. Таким образом, мы показали, что @code{(car (cons x y))}
возвращает @code{x}, как нам и хотелось. Подобным образом
@code{(cdr (cons x y))} применяет процедуру, возвращаемую
@code{(cons x y)}, к 1, что дает нам @code{y}. Следовательно, эта
процедурная реализация пар законна, и если мы обращаемся к парам только
с помощью @code{cons}, @code{car} и @code{cdr}, то мы не сможем отличить
эту реализацию от такой, которая использует <<настоящие>> структуры
данных.

Демонстрировать процедурную реализацию имеет смысл не для того, чтобы
показать, как работает наш язык (Scheme, и вообще Лисп-системы,
реализуют пары напрямую из соображений эффективности), а в том, чтобы
показать, что он мог бы работать и так. Процедурная реализация, хотя она
и выглядит трюком, --- совершенно адекватный способ представления пар,
поскольку она удовлетворяет единственному условию, которому должны
соответствовать пары. Кроме того, этот пример показывает, что
способность работать с процедурами как с объектами автоматически дает
нам возможность представлять составные данные. Сейчас это может
показаться курьезом, но в нашем программистском репертуаре процедурные
представления данных будут играть центральную роль. Такой стиль
программирования часто называют (@newterm{message passing}), и в
главе @ref{Глава 3},
при рассмотрении вопросов моделирования, он будет нашим основным
инструментом.

@quotation
@strong{@anchor{Упражнение 2.4}Упражнение 2.4:}
Вот еще одно процедурное представление для пар. Проверьте для
этого представления, что при любых двух объектах @code{x} и @code{y}
@code{(car (cons x y))} возвращает @code{x}.

@lisp
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
@end lisp

Каково соответствующее определение @code{cdr}? (Подсказка: Чтобы
проверить, что это работает, используйте подстановочную модель из
раздела @ref{1.1.5}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.5}Упражнение 2.5:}
Покажите, что можно представлять пары неотрицательных целых
чисел, используя только числа и арифметические операции, если
представлять пару @math{a} и @math{b} как произведение @math{2^a 3^b}.
Дайте соответствующие определения процедур @code{cons}, @code{car} и
@code{cdr}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.6}Упражнение 2.6:}
Если представление пар как процедур было для Вас еще
недостаточно сумасшедшим, то заметьте, что в языке, который способен
манипулировать процедурами, мы можем обойтись и без чисел (по крайней
мере, пока речь идет о неотрицательных числах), определив 0 и операцию
прибавления 1 так:

@lisp
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
@end lisp

Такое представление известно как (@newterm{Church numerals}), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал
@math{\lambda}-исчисление.

Определите @code{one} (единицу) и @code{two} (двойку) напрямую (не через
@code{zero} и @code{add-1}). (Подсказка: вычислите @code{(add-1 zero)} с
помощью подстановки.) Дайте прямое определение процедуры сложения
@code{+} (не в терминах повторяющегося применения @code{add-1}).
@end quotation

@comment @subsection Extended Exercise: Interval Arithmetic
@subsection Расширенный пример: интервальная арифметика
@node	2.1.4,  , 2.1.3, 2.1

Лиза П. Хакер проектирует систему, которая помогала бы в решении
технических задач. Одна из возможностей, которые она хочет реализовать в
своей системе, --- способность работать с неточными величинами
(например, измеренные параметры физических устройств), обладающими
известной погрешностью, так что когда с такими приблизительными
величинами производятся вычисления, результаты также представляют собой
числа с известной погрешностью.

Инженеры-электрики будут с помощью Лизиной системы вычислять
электрические величины. Иногда им требуется вычислить сопротивление
@math{R_p} параллельного соединения двух резисторов @math{R_1} и
@math{R_2} по формуле
@ifinfo

@example
            1
R_p = -------------
      1/R_1 + 1/R_2
@end example

@end ifinfo
@tex
$$ R_p = {1 \over 1 / R_1 + 1 / R_2}.  $$
@end tex
Обычно
сопротивления резисторов известны только с некоторой точностью, которую
гарантирует их производитель. Например, покупая резистор с надписью
<<6.8 Ом с погрешностью 10%>>, Вы знаете только то, что сопротивление
резистора находится между @math{6.8 - 0.68 = 6.12} и
@math{6.8 + 0.68 = 7.48} Ом. Так что если резистор в 6.8 Ом с
погрешностью 10% подключен параллельно резистору в 4.7 Ом с погрешностью
5%, то сопротивление этой комбинации может быть примерно от 2.58 Ом
(если оба резистора находятся на нижней границе интервала допустимых
значений) до 2.97 Ом (если оба резистора находятся на верхней границе).

Идея Лизы состоит в том, чтобы реализовать <<интервальную арифметику>>
как набор арифметических операций над <<интервалами>> (объектами,
которые представляют диапазоны возможных значений неточной величины).
Результатом сложения, вычитания, умножения или деления двух интервалов
также будет интервал, который представляет диапазон возможных значений
результата.

Лиза постулирует существование абстрактного объекта, называемого
<<интервал>>, у которого есть два конца: верхняя и нижняя границы. Кроме
того, она предполагает, что имея два конца интервала, мы можем
сконструировать его при помощи конструктора @code{make-interval}.
Сначала Лиза пишет процедуру сложения двух интервалов. Она рассуждает
так: минимальное возможное значение суммы равно сумме нижних границ
интервалов, а максимальное возможное значение сумме верхних границ
интервалов.

@lisp
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
@end lisp

@noindent
Кроме того, она вычисляет произведение двух интервалов путем нахождения
минимума и максимума произведений концов интервалов и использования в
качестве границ интервала-результата. (@code{min} и @code{max} ---
примитивы, которые находят минимум и максимум при любом количестве
аргументов.)

@lisp
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
@end lisp

@noindent
При делении двух интервалов Лиза умножает первый из них на интервал,
обратный второму. Заметим, что границами обратного интервала являются
числа, обратные верхней и нижней границе исходного интервала, именно в
таком порядке.

@lisp
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.7}Упражнение 2.7:}
Программа Лизы неполна, поскольку она не определила, как
реализуется абстракция интервала. Вот определение конструктора
интервала:

@lisp
(define (make-interval a b) (cons a b))
@end lisp

Завершите реализацию, определив селекторы @code{upper-bound} и
@code{lower-bound}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.8}Упражнение 2.8:}
Рассуждая в духе Лизы, опишите, как можно вычислить разность
двух интервалов. Напишите соответствующую процедуру вычитания,
называемую @code{sub-interval}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.9}Упражнение 2.9:}
Радиус (@newterm{width}) интервала определяется как половина
расстояния между его верхней и нижней границами. Радиус является мерой
неопределенности числа, которое обозначает интервал. Есть такие
математические операции, для которых радиус результата зависит только от
радиусов интервалов-аргументов, а есть такие, для которых радиус
результата не является функцией радиусов аргументов. Покажите, что
радиус суммы (или разности) двух интервалов зависит только от радиусов
интервалов, которые складываются (или вычитаются). Приведите примеры,
которые показывают, что для умножения или деления это не так.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.10}Упражнение 2.10:}
Бен Битобор, системный программист-эксперт, смотрит через
плечо Лизы и замечает: неясно, что должно означать деление на интервал,
пересекающий ноль. Модифицируйте код Лизы так, чтобы программа проверяла
это условие и сообщала об ошибке, если оно возникает.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.11}Упражнение 2.11:}
Проходя мимо, Бен делает туманное замечание: <<Если
проверять знаки концов интервалов, можно разбить @code{mul-interval} на
девять случаев, из которых только в одном требуется более двух
умножений>>. Перепишите эту процедуру в соответствии с предложением
Бена.

Отладив программу, Лиза показывает ее потенциальному пользователю, а тот
жалуется, что она решает не ту задачу. Ему нужна программа, которая
работала бы с числами, представленными в виде срединного значения и
аддитивной погрешности; например, ему хочется работать с интервалами
вида @math{3.5 \pm 0.15}, а не [3.35, 3.65]. Лиза
возвращается к работе и исправляет этот недочет, добавив дополнительный
конструктор и дополнительные селекторы:

@lisp
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
@end lisp

К сожалению, большая часть Лизиных пользователей --- инженеры. В
реальных технических задачах речь обычно идет об измерениях с небольшой
погрешностью, которая измеряется как отношение радиуса интервала к его
средней точке. Инженеры обычно указывают в параметрах устройств
погрешность в процентах, как в спецификациях резисторов, которые мы
привели в пример выше.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.12}Упражнение 2.12:}
Определите конструктор @code{make-center-percent}, который
принимает среднее значение и погрешность в процентах и выдает требуемый
интервал. Нужно также определить селектор @code{percent}, который для
данного интервала выдает погрешность в процентах. Селектор @code{center}
остается тем же, что приведен выше.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.13}Упражнение 2.13:}
Покажите, что, если предположить, что погрешность
составляет малую долю величины интервала, то погрешность в процентах
произведения двух интервалов можно получить из погрешности в процентах
исходных интервалов по простой приближенной формуле. Задачу можно
упростить, если предположить, что все числа положительные.

После долгой работы Лиза П. Хакер сдает систему пользователям. Несколько
лет спустя, уже забыв об этом, она получает жалобу от разгневанного
пользователя Дайко Поправича. Оказывается, Дайко заметил, что формулу
для параллельных резисторов можно записать двумя алгебраически
эквивалентными способами:
@ifinfo

@example
 R_1 R_2
---------
R_1 + R_2
@end example

@end ifinfo
@tex
$$ R_1 R_2 \over R_1 + R_2 $$
@end tex
@noindent
и
@ifinfo

@example
      1
-------------
1/R_1 + 1/R_2
@end example

@end ifinfo
@tex
$$ {1 \over 1 / R_1 + 1 / R_2}. $$
@end tex
Он написал следующие две программы, каждая из
которых считает формулу для параллельных резисторов своим способом:

@lisp
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
@end lisp

@lisp
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
@end lisp
@sp 0.3

Дайко утверждает, что для двух способов вычисления Лизина программа дает
различные результаты. Это серьезное нарекание.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.14}Упражнение 2.14:}
Покажите, что Дайко прав. Исследуйте поведение системы на
различных арифметических выражениях. Создайте несколько интервалов
@math{A} и @math{B} и вычислите с их помощью выражения @math{A/A} и
@math{A/B}. Наибольшую пользу Вы получите, если будете использовать
интервалы, радиус которых составляет малую часть от среднего значения.
Исследуйте результаты вычислений в форме центр/проценты (см.
упражнение @ref{Упражнение 2.12}).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.15}Упражнение 2.15:}
Ева Лу Атор, другой пользователь Лизиной программы, тоже
заметила, что алгебраически эквивалентные, но различные выражения могут
давать разные результаты. Она говорит, что формула для вычисления
интервалов, которая использует Лизину систему, будет давать более узкие
границы погрешности, если ее удастся записать так, чтобы ни одна
переменная, представляющая неточную величину, не повторялась. Таким
образом, говорит она, @code{par2} <<лучше>> как программа для
параллельных резисторов, чем @code{par1}. Права ли она? Почему?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.16}Упражнение 2.16:}
Объясните в общем случае, почему эквивалентные
алгебраические выражения могут давать разные результаты. Можете ли Вы
представить себе пакет для работы с интервальной арифметикой, который бы
не обладал этим недостатком, или такое невозможно? (Предупреждение: эта
задача очень сложна.)
@end quotation


@comment @section Hierarchical Data and the Closure Property
@section Иерархические данные и свойство замыкания
@node	2.2, 2.3, 2.1, Глава 2

Как мы уже видели, пары служат элементарным <<клеем>>, с помощью
которого можно строить составные объекты данных. На
рис. @ref{Рисунок 2.2} показан стандартный способ рисовать пару --- в
данном случае, пару, которая сформирована выражением @code{(cons 1 2)}.
В этом представлении, которое называется (box-and-pointer notation),
каждый объект изображается в виде (pointer), указывающей на какую-нибудь
ячейку. Ячейка, изображающая элементарный объект, содержит представление
этого объекта. Например, ячейка, соответствующая числу, содержит
числовую константу. Изображение пары состоит из двух ячеек, причем левая
из них содержит (указатель на) @code{car} этой пары, а правая --- ее
@code{cdr}.

Мы уже видели, что @code{cons} способен соединять не только числа, но и
пары. (Вы использовали это свойство, или, по крайней мере, должны были
использовать, когда выполняли @ref{Упражнение 2.2} и
@ref{Упражнение 2.3}). Как следствие этого, пары являются универсальным
материалом, из которого можно строить любые типы структур данных. На
@ref{Рисунок 2.3} показаны два способа соединить числа 1, 2, 3 и 4
при помощи пар.

@float
@quotation
@anchor{Рисунок 2.2}
@ifinfo
@strong{Рисунок 2.2:} Box-and-pointer representation of @code{(cons 1 2)}.

@example
     +---+---+     +---+
---->| * | *-+---->| 2 |
     +-|-+---+     +---+
       |
       V
     +---+
     | 1 |
     +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.2c,34mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 2.2:} Box-and-pointer representation of @code{(cons 1 2)}.}
@sp 1
@end iftex
@end quotation
@end float

@float
@quotation
@anchor{Рисунок 2.3}
@ifinfo
@strong{Рисунок 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.

@example
     +---+---+     +---+---+         +---+---+     +---+
---->| * | *-+---->| * | * |    ---->| * | *-+---->| 4 |
     +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
       |             |   |             |
       V             V   V             V
   +---+---+      +---+ +---+      +---+---+     +---+---+
   | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
   +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
     |   |                           |             |   |
     V   V                           V             V   V
  +---+ +---+                      +---+        +---+ +---+
  | 1 | | 2 |                      | 1 |        | 2 | | 3 |
  +---+ +---+                      +---+        +---+ +---+

  (cons (cons 1 2)                 (cons (cons 1
        (cons 3 4))                            (cons 2 3))
                                         4)
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.3c,96mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.}
@sp 0.7
@end iftex
@end quotation
@end float

Возможность создавать пары, элементы которых сами являются парами,
определяет значимость списковой структуры как средства представления
данных. Мы называем эту возможность (@newterm{closure property})
для @code{cons}.
В общем случае, операция комбинирования объектов данных обладает
свойством замыкания в том случае, если результаты соединения объектов с
помощью этой операции сами могут соединяться этой же
операцией.@footnote{Такое употребление слова <<замыкание>> происходит из
абстрактной алгебры. Алгебраисты говорят, что множество замкнуто
относительно операции, если применение операции к элементам этого
множества дает результат, который также является элементом множества. К
сожалению, в сообществе программистов, пишущих на Лиспе, словом
<<замыкание>> обозначается еще и совершенно другое понятие: замыканием
называют способ представления процедур, имеющих свободные переменные. В
этом втором смысле мы слово <<замыкание>> в книге не используем.}
Замыкание --- это ключ к выразительной силе для любого средства
комбинирования, поскольку оно позволяет строить (@newterm{hierarchical})
структуры, то есть структуры, которые составлены из частей, которые сами
составлены из частей, и так далее.

С самого начала главы @ref{Глава 1}
мы существенным образом использовали свойство замыкания при работе с
процедурами, поскольку все программы, кроме самых простых, опираются на
то, что элементы комбинации сами могут быть комбинациями. В этом разделе
мы рассмотрим, какое значение замыкание имеет для составных данных. Мы
опишем несколько распространенных методов использования пар для
представления последовательностей и деревьев, а также построим
графический язык, который наглядно иллюстрирует замыкание.@footnote{Идея,
что средство комбинирования должно удовлетворять условию замыкания,
очень проста. К сожалению, такие средства во многих популярных языках
программирования либо не удовлетворяют этому условию, либо делают
использование замыканий неудобным. В Фортране и Бейсике элементы данных
обычно группируются путем создания массивов --- но массивы, элементы
которых сами являются массивами, строить нельзя. Паскаль и Си позволяют
иметь структуры, члены которых являются структурами. Однако при этом
требуется, чтобы программист напрямую работал с указателями и соблюдал
ограничение, по которому каждое поле структуры может содержать только
элементы заранее заданной формы. В отличие от Лиспа с его парами, в этих
языках нет встроенного универсального клея, который позволял бы легко
работать с составными данными единым способом. Это ограничение дало
Алану Перлису повод сказать в предисловии к этой книге: <<В Паскале
обилие объявляемых структур данных ведет к специализации функций,
которая сдерживает и наказывает случайное взаимодействие между ними.
Лучше иметь 100 функций, которые работают с одной структурой данных, чем
10 функций, работающих с 10 структурами>>.}

@menu
* 2-2-1::            Представление последовательностей
* 2-2-2::            Иерархические структуры
* 2-2-3::            Последовательности как стандартные интерфейсы
* 2-2-4::            Пример язык описания изображений
@end menu

@comment @subsection Representing Sequences
@node	2.2.1, 2.2.2, 2.2, 2.2

Одна из полезных структур, которые можно построить с помощью пар ---
это (sequence), то есть упорядоченная совокупность объектов данных.
Разумеется, существует много способов представления последовательностей
при помощи пар. Один, особенно простой, показан на
рисунке @ref{Рисунок 2.4}, где последовательность 1, 2, 3, 4
представлена как цепочка пар. В каждой паре @code{car} --- это
соответствующий член цепочки, а @code{cdr} --- следующая пара цепочки.
@code{Cdr} последней пары указывает на особое значение, не являющееся
парой, которое на диаграммах изображается как диагональная линия, а в
программах как значение переменной @code{nil}. Вся последовательность
порождается несколькими вложенными операциями @code{cons}:

@lisp
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
@end lisp

@float
@quotation
@anchor{Рисунок 2.4}
@ifinfo
@strong{Рисунок 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.

@example
     +---+---+     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+     +-|-+---+
       |             |             |             |
       V             V             V             V
     +---+         +---+         +---+         +---+
     | 1 |         | 2 |         | 3 |         | 4 |
     +---+         +---+         +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.4c,76mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.}
@sp 0.8
@end iftex
@end quotation
@end float

Такая последовательность пар, порождаемая вложенными @code{cons}-ами,
называется (@newterm{list}). В Scheme имеется примитив, который называется
@code{ list} и помогает строить списки@footnote{В этой книге термин
всегда означает цепочку пар, которая завершается маркером конца списка.
Напротив, термин (@newterm{list structure}) относится к любой структуре данных,
составленной из пар, а не только к спискам.}. Вышеуказанную
последовательность можно было бы получить с помощью
@code{(list 1 2 3 4)}. В общем случае

@lisp
(list @math{\langle}@var{a}@math{_{\mono{1}}\rangle} @math{\langle}@var{a}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{a}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
эквивалентно

@lisp
(cons @math{\langle}@var{a}@math{_{\mono{1}}\rangle}
      (cons @math{\langle}@var{a}@math{_{\mono{2}}\rangle}
            (cons @dots{}
                  (cons @math{\langle}@var{a}@math{_{\monoit{n}}\rangle}
                        nil)@dots{})))
@end lisp

@noindent
По традиции, Лисп-системы печатают списки в виде последовательности их
элементов, заключенной в скобки. Таким образом, объект данных с
рисунка @ref{Рисунок 2.4} выводится как @code{(1 2 3 4)}:

@lisp
(define one-through-four (list 1 2 3 4))
one-through-four
@i{(1 2 3 4)}
@end lisp

@noindent
Внимание: не путайте выражение @code{(list 1 2 3 4)} со списком
@code{(1 2 3 4)}, который является результатом вычисления этого
выражения. Попытка вычислить выражение @code{(1 2 3 4)} приведет к
сообщению об ошибке, когда интерпретатор попробует применить процедуру 1
к аргументам 2, 3 и 4.

Мы можем считать, что процедура @code{car} выбирает первый элемент из
списка, а @code{cdr} возвращает подсписок, состоящий из всех элементов,
кроме первого. Вложенные применения @code{car} и @code{cdr} могут
выбрать второй, третий и последующие элементы списка.@footnote{Поскольку
записывать вложенные применения @code{car} и @code{cdr} громоздко, в
диалектах Лиспа существуют сокращения --- например,

@lisp
(cadr @math{\langle}@var{arg}@math{\rangle}) = (car (cdr @math{\langle}@var{arg}@math{\rangle}))
@end lisp

У всех таких процедур имена начинаются с @code{c}, а кончаются на
@code{r}. Каждое @code{a} между ними означает операцию @code{car}, а
каждое @code{d} операцию @code{cdr}, и они применяются в том же порядке,
в каком идут внутри имени. Имена @code{car} и @code{cdr} сохраняются,
поскольку простые их комбинации вроде @code{cadr} нетрудно произнести.}
Конструктор @code{cons} порождает список, подобный исходному, но с
дополнительным элементом в начале.

@lisp
(car one-through-four)
@i{1}
(cdr one-through-four)
@i{(2 3 4)}
(car (cdr one-through-four))
@i{2}
(cons 10 one-through-four)
@i{(10 1 2 3 4)}
(cons 5 one-through-four)
@i{(5 1 2 3 4)}
@end lisp

@noindent
Значение @code{nil}, которым завершается цепочка пар, можно
рассматривать как последовательность без элементов, (@newterm{empty list}). Слово
(@newterm{nil}) произошло от стяжения латинского @emph{nihil}, что значит
<<ничто>>.@footnote{Удивительно, сколько энергии при стандартизации
диалектов Лиспа было потрачено на споры буквально ни о чем: должно ли
слово @code{nil} быть обычным именем? Должно ли значение @code{nil}
являться символом? Должно ли оно являться списком? Парой? В Scheme
@code{nil} --- обычное имя, и в этом разделе мы используем его как
переменную, значение которой --- маркер конца списка (так же, как
@code{true} --- это обычная переменная, значение которой истина).
Другие диалекты Лиспа, включая Common Lisp, рассматривают @code{nil} как
специальный символ. Авторы этой книги пережили слишком много скандалов
со стандартизацией языков и хотели бы не возвращаться к этим вопросам.
Как только в разделе @ref{1.3} мы введем кавычку, мы
станем обозначать пустой список в виде @code{'()}, а от переменной
@code{nil} полностью избавимся.}

@comment @subsubheading List operations
@subsubheading Операции со списками

Использованию пар для представления последовательностей элементов в виде
списков сопутствуют общепринятые методы программирования, которые,
работая со списками, последовательно их <<у@code{cdr}ивают>>. Например,
процедура @code{list-ref} берет в качестве аргументов список и число
@math{n} и возвращает @math{n}-й элемент списка. Обычно элементы списка
нумеруют, начиная с 0. Метод вычисления @code{list-ref} следующий:

@itemize @bullet

@item
Если @math{n = 0}, @code{list-ref} должна вернуть @code{car} списка.

@item
В остальных случаях @code{list-ref} должна вернуть @math{(n - 1)}-й
элемент от @code{cdr} списка.

@end itemize

@lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
@i{16}
@end lisp

@noindent
Часто мы про@code{cdr}иваем весь список. Чтобы помочь нам с этим, Scheme
включает элементарную процедуру , которая определяет, является ли ее
аргумент пустым списком. Процедура , которая возвращает число элементов
в списке, иллюстрирует эту характерную схему использования операций над
списками:

@lisp
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))
(length odds)
@i{4}
@end lisp

@noindent
Процедура @code{length} реализует простую рекурсивную схему. Шаг
редукции таков:

@itemize @bullet

@item
Длина любого списка равняется 1 плюс длина @code{cdr} этого списка

@end itemize

@noindent
Этот шаг последовательно применяется, пока мы не достигнем базового
случая:

@itemize @bullet

@item
Длина пустого списка равна 0.

@end itemize

@noindent
Мы можем вычислить @code{length} и в итеративном стиле:

@lisp
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
@end lisp

@noindent
Еще один распространенный программистский прием состоит в том, чтобы
<<с@code{cons}ить>> результат по ходу у@code{cdr}ивания списка, как это
делает процедура @code{append}, которая берет в качестве аргументов два
списка и составляет из их элементов один общий список:

@lisp
(append squares odds)
@i{(1 4 9 16 25 1 3 5 7)}
(append odds squares)
@i{(1 3 5 7 1 4 9 16 25)}
@end lisp

@noindent
@code{append} также реализуется по рекурсивной схеме. Чтобы соединить
списки @code{list1} и @code{list2}, нужно сделать следующее:

@itemize @bullet

@item
Если список @code{list1} пуст, то результатом является просто
@code{list2}.

@item
В противном случае, нужно соединить @code{cdr} от @code{list1} с
@code{list2}, а к результату прибавить @code{car} от @code{list1} с
помощью @code{cons}:

@end itemize

@lisp
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.17}Упражнение 2.17:}
Определите процедуру @code{last-pair}, которая возвращает
список, содержащий только последний элемент данного (непустого) списка.

@lisp
(last-pair (list 23 72 149 34))
@i{(34)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.18}Упражнение 2.18:}
Определите процедуру @code{reverse}, которая принимает
список как аргумент и возвращает список, состоящий из тех же элементов в
обратном порядке:

@lisp
(reverse (list 1 4 9 16 25))
@i{(25 16 9 4 1)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.19}Упражнение 2.19:}
Рассмотрим программу подсчета способов размена из
раздела @ref{1.2.2}. Было бы приятно иметь
возможность легко изменять валюту, которую эта программа использует,
так, чтобы можно было, например, вычислить, сколькими способами можно
разменять британский фунт. Эта программа написана так, что знание о
валюте распределено между процедурами @code{first-denomination} и
@code{count-change} (которая знает, что существует пять видов
американских монет). Приятнее было бы иметь возможность просто задавать
список монет, которые можно использовать при размене.

Мы хотим переписать процедуру @code{cc} так, чтобы ее вторым аргументом
был список монет, а не целое число, которое указывает, какие монеты
использовать. Тогда у нас могли бы быть списки, определяющие типы валют:

@lisp
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
@end lisp

Можно было бы вызывать @code{cc} следующим образом:

@lisp
(cc 100 us-coins)
@i{292}
@end lisp

Это потребует некоторых изменений в программе @code{cc}. Ее форма
останется прежней, но со вторым аргументом она будет работать иначе, вот
так:

@lisp
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
@end lisp

Определите процедуры @code{first-denomination},
@code{no-more?} и @code{except-first-denomination} в терминах
элементарных операций над списковыми структурами. Влияет ли порядок
списка @code{coin-values} на результат, получаемый @code{cc}? Почему?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.20}Упражнение 2.20:}
Процедуры @code{+}, @code{*} и @code{list} принимают
произвольное число аргументов. Один из способов определения таких
процедур состоит в использовании (@newterm{dotted-tail notation}). В определении
процедуры список параметров с точкой перед именем последнего члена
означает, что, когда процедура вызывается, начальные параметры (если они
есть) будут иметь в качестве значений начальные аргументы, как и обычно,
но значением последнего параметра будет @emph{список} (@newterm{list}) всех оставшихся
аргументов. Например, если дано определение

@lisp
(define (f x y . z) @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
то процедуру @code{f} можно вызывать с двумя и более аргументами. Если
мы вычисляем

@lisp
(f 1 2 3 4 5 6)
@end lisp

@noindent
то в теле @code{f} переменная @code{x} будет равна 1, @code{y} будет
равно 2, а @code{z} будет списком (3 4 5 6). Если дано определение

@lisp
(define (g . w) @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
то процедура @code{g} может вызываться с нулем и более аргументов. Если
мы вычислим

@lisp
(g 1 2 3 4 5 6)
@end lisp

@noindent
то в теле @code{g} значением переменной @code{w} будет список
@code{(1 2 3 4 5 6)}.@footnote{Для того, чтобы определить @code{f} и
@code{g} при помощи @code{lambda}, надо было бы написать

@lisp
(define f (lambda (x y . z) @math{\langle}@var{тело}@math{\rangle}))
(define g (lambda w @math{\langle}@var{тело}@math{\rangle}))
@end lisp
}

Используя эту нотацию, напишите процедуру @code{same-parity}, которая
принимает одно или несколько целых чисел и возвращает список всех тех
аргументов, у которых четность та же, что у первого аргумента. Например,

@lisp
(same-parity 1 2 3 4 5 6 7)
@i{(1 3 5 7)}
(same-parity 2 3 4 5 6 7)
@i{(2 4 6)}
@end lisp
@end quotation

@comment @subsubheading Mapping over lists
@subsubheading Отображение списков

Крайне полезной операцией является применение какого-либо преобразования
к каждому элементу списка и порождение списка результатов. Например,
следующая процедура умножает каждый элемент списка на заданное число.

@lisp
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items)
                        factor))))
(scale-list (list 1 2 3 4 5) 10)
@i{(10 20 30 40 50)}
@end lisp

@noindent
Мы можем выделить здесь общую идею и зафиксировать ее как схему,
выраженную в виде процедуры высшего порядка, в точности как в
разделе @ref{1.3}.
Здесь эта процедура высшего порядка называется @code{map}. @code{map}
берет в качестве аргументов процедуру от одного аргумента и список, а
возвращает список результатов, полученных применением процедуры к
каждому элементу списка:@footnote{@anchor{Сноска 2.12} Стандартная Scheme содержит
более общую процедуру @code{map}, чем описанная здесь. Этот вариант
@code{map} принимает процедуру от @math{n} аргументов и @math{n} списков
и применяет процедуру ко всем первым элементам списков, всем вторым
элементам списков и так далее. Возвращается список результатов.
Например:

@lisp
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
@i{(741 852 963)}
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
@i{(9 12 15)}
@end lisp
}

@lisp
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
@i{(10 2.5 11.6 17)}
(map (lambda (x) (* x x)) (list 1 2 3 4))
@i{(1 4 9 16)}
@end lisp

@noindent
Теперь мы можем дать новое определение @code{scale-list} через
@code{map}:

@lisp
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
@end lisp

@noindent
@code{map} является важным конструктом, не только потому, что она
фиксирует общую схему, но и потому, что она повышает уровень абстракции
при работе со списками. В исходном определении @code{scale-list}
рекурсивная структура программы привлекает внимание к поэлементной
обработке списка. Определение @code{scale-list} через @code{map}
устраняет этот уровень деталей и подчеркивает, что умножение преобразует
список элементов в список результатов. Разница между этими двумя
определениями состоит не в том, что компьютер выполняет другой процесс
(это не так), а в том, что мы думаем об этом процессе по-другому. В
сущности, @code{map} помогает установить барьер абстракции, который
отделяет реализацию процедур, преобразующих списки, от деталей того, как
выбираются и комбинируются элементы списков. Подобно барьерам на
рисунке @ref{Рисунок 2.1}, эта абстракция позволяет нам свободно
изменять низкоуровневые детали того, как реализованы списки, сохраняя
концептуальную схему с операциями, переводящими одни последовательности
в другие. В разделе @ref{2.2.3}
такое использование последовательностей как способ организации программ
рассматривается более подробно.

@quotation
@strong{@anchor{Упражнение 2.21}Упражнение 2.21:}
Процедура @code{square-list} принимает в качестве аргумента
список чисел и возвращает список квадратов этих чисел.

@lisp
(square-list (list 1 2 3 4))
@i{(1 4 9 16)}
@end lisp

Перед Вами два различных определения @code{square-list}. Закончите их,
вставив пропущенные выражения:

@lisp
(define (square-list items)
  (if (null? items)
      nil
      (cons @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
(define (square-list items)
  (map @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle}))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.22}Упражнение 2.22:}
LХьюго Дум пытается переписать первую из процедур
@code{square-list} из упражнения @ref{Упражнение 2.21} так, чтобы она
работала как итеративный процесс:

@lisp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
@end lisp

К сожалению, такое определение @code{square-list} выдает список
результатов в порядке, обратном желаемому. Почему?

Затем Хьюго пытается исправить ошибку, обменяв аргументы @code{cons}:

@lisp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
@end lisp

И так программа тоже не работает. Объясните это.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.23}Упражнение 2.23:}
Процедура @code{for-each} похожа на @code{map}. В качестве
аргументов она принимает процедуру и список элементов. Однако вместо
того, чтобы формировать список результатов, @code{for-each} просто
применяет процедуру по очереди ко всем элементам слева направо.
Результаты применения процедуры к аргументам не используются вообще ---
@code{for-each} применяют к процедурам, которые осуществляют какое-либо
действие вроде печати. Например,

@lisp
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
@i{57}
@i{321}
@i{88}
@end lisp

Значение, возвращаемое вызовом @code{for-each} (оно в листинге не
показано) может быть каким угодно, например истина. Напишите реализацию
@code{for-each}.
@end quotation

@endpage
@comment @subsection Hierarchical Structures
@subsection Иерархические структуры
@node	2.2.2, 2.2.3, 2.2.1, 2.2

Представление последовательностей в виде списков естественно
распространить на последовательности, элементы которых сами могут быть
последовательностями. Например, мы можем рассматривать объект
@code{((1 2) 3 4)}, получаемый с помощью

@lisp
(cons (list 1 2) (list 3 4))
@end lisp

@noindent
как список с тремя членами, первый из которых сам является списком. В
сущности, это подсказывается формой, в которой результат печатается
интерпретатором. Рисунок @ref{Рисунок 2.5} показывает представление
этой структуры в терминах пар.

@float
@quotation
@anchor{Рисунок 2.5}
@ifinfo
@strong{Рисунок 2.5:} Structure formed by @code{(cons (list 1 2) (list 3 4))}.

@example
                                          (3 4)
                                            |
                                            V
((1 2) 3 4)  +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +-|-+---+                  +-|-+---+     +-|-+---+
               |                          |             |
               V                          V             V
      (1 2)  +---+---+     +---+---+    +---+         +---+
        ---->| * | *-+---->| * | / |    | 3 |         | 4 |
             +-|-+---+     +-|-+---+    +---+         +---+
               |             |
               V             V
             +---+         +---+
             | 1 |         | 2 |
             +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.5c,91mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.5:} Structure formed by @code{(cons (list 1 2) (list 3 4))}.}
@sp 0.7
@end iftex
@end quotation
@end float

Еще один способ думать о последовательностях последовательностей ---
(@newterm{trees}). Элементы последовательности являются ветвями дерева, а
элементы, которые сами по себе последовательности --- поддеревьями.
Рисунок @ref{Рисунок 2.6} показывает структуру, изображенную на рис.
@ref{Рисунок 2.5}, в виде дерева.

@float
@quotation
@anchor{Рисунок 2.6}
@ifinfo
@strong{Рисунок 2.6:} The list structure in @ref{Рисунок 2.5} viewed as a tree.

@example
 ((1 2) 3 4)
     /\\
    /  | \
(1 2)  3 4
 / \
 1 2
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.6a,22mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.6:} The list structure in @ref{Рисунок 2.5} viewed as a tree.}
@sp 0.0
@end iftex
@end quotation
@end float

Естественным инструментом для работы с деревьями является рекурсия,
поскольку часто можно свести операции над деревьями к операциям над их
ветвями, которые сами сводятся к операциям над ветвями ветвей, и так
далее, пока мы не достигнем листьев дерева. Например, сравним процедуру
@code{length} из раздела @ref{2.2.1} с
процедурой @code{count-leaves}, которая подсчитывает число листьев
дерева:

@lisp
(define x (cons (list 1 2) (list 3 4)))
(length x)
@i{3}
(count-leaves x)
@i{4}
(list x x)
@i{(((1 2) 3 4) ((1 2) 3 4))}
(length (list x x))
@i{2}
(count-leaves (list x x))
@i{8}
@end lisp

@noindent
Чтобы реализовать @code{count-leaves}, вспомним рекурсивную схему
вычисления @code{length}:

@itemize @bullet

@item
Длина списка @code{x} есть 1 плюс длина @code{cdr} от @code{x}.

@item
Длина пустого списка есть 0.

@end itemize

@noindent
@code{count-leaves} очень похожа на эту схему. Значение для пустого
списка остается тем же:

@itemize @bullet

@item
@code{count-leaves} от пустого списка равна 0.

@end itemize

@noindent
Однако в шаге редукции, когда мы выделяем @code{car} списка, нам нужно
учесть, что @code{car} сам по себе может быть деревом, листья которого
нам требуется сосчитать. Таким образом, шаг редукции таков:

@itemize @bullet

@item
@code{count-leaves} от дерева @code{x} есть @code{count-leaves} от
@code{(car x)} плюс @code{count-leaves} от @code{(cdr x)}.

@end itemize

@noindent
Наконец, вычисляя @code{car}-ы, мы достигаем листьев, так что нам
требуется еще один базовый случай:

@itemize @bullet

@item
@code{count-leaves} от листа равна 1.

@end itemize

@noindent
Писать рекурсивные процедуры над деревьями в Scheme помогает
элементарный предикат @code{pair?}, который проверяет, является ли его
аргумент парой. Вот процедура целиком:@footnote{Порядок первых двух
ветвей существен, поскольку пустой список удовлетворяет предикату
@code{null?} и при этом не является парой.}

@lisp
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.24}Упражнение 2.24:}
Предположим, мы вычисляем выражение
@code{(list 1 (list 2 (list 3 4)))}. Укажите, какой результат напечатает
интерпретатор, изобразите его в виде стрелочной диаграммы, а также его
интерпретацию в виде дерева (как на рисунке @ref{Рисунок 2.6}).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.25}Упражнение 2.25:}
Укажите комбинации @code{car} и @code{cdr}, которые
извлекают 7 из следующих списков:

@lisp
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.26}Упражнение 2.26:}
Допустим, мы определили @code{x} и @code{y} как два списка:

@lisp
(define x (list 1 2 3))
(define y (list 4 5 6))
@end lisp

Какой результат напечатает интерпретатор в ответ на следующие выражения:

@lisp
(append x y)
(cons x y)
(list x y)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.27}Упражнение 2.27:}
Измените свою процедуру @code{reverse} из
упражнения @ref{Упражнение 2.18} так, чтобы получилась процедура
@code{deep-reverse}, которая принимает список в качестве аргумента и
возвращает в качестве значения список, где порядок элементов обратный и
подсписки также обращены. Например:

@lisp
(define x (list (list 1 2) (list 3 4)))
x
@i{((1 2) (3 4))}
(reverse x)
@i{((3 4) (1 2))}
(deep-reverse x)
@i{((4 3) (2 1))}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.28}Упражнение 2.28:}
Напишите процедуру @code{fringe}, которая берет в качестве
аргумента дерево (представленное в виде списка) и возвращает список,
элементы которого --- все листья дерева, упорядоченные слева направо.
Например,

@lisp
(define x (list (list 1 2) (list 3 4)))
(fringe x)
@i{(1 2 3 4)}
(fringe (list x x))
@i{(1 2 3 4 1 2 3 4)}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.29}Упражнение 2.29:}
Бинарный мобиль состоит из двух ветвей, левой и правой.
Каждая ветвь представляет собой стержень определенной длины, с которого
свисает либо гирька, либо еще один бинарный мобиль. Мы можем представить
бинарный мобиль в виде составных данных, соединив две ветви (например, с
помощью @code{list}):

@lisp
(define (make-mobile left right)
  (list left right))
@end lisp

Ветвь составляется из длины @code{length} (которая должна быть числом) и
структуры @code{structure}, которая может быть либо числом
(представляющим простую гирьку), либо еще одним мобилем:

@lisp
(define (make-branch length structure)
  (list length structure))
@end lisp

@enumerate a.

@item
Напишите соответствующие селекторы @code{left-branch} и
@code{right-branch}, которые возвращают левую и правую ветви мобиля, а
также @code{branch-length} и @code{branch-structure}, которые возвращают
компоненты ветви.

@item
С помощью этих селекторов напишите процедуру @code{total-weight},
которая возвращает общий вес мобиля.

@item
Говорят, что мобиль @emph{сбалансирован} (@newterm{balanced}), если момент вращения,
действующий на его левую ветвь, равен моменту вращения, действующему на
правую ветвь (то есть длина левого стержня, умноженная на вес груза,
свисающего с него, равна соответствующему произведению для правой
стороны), и если все подмобили, свисающие с его ветвей, также
сбалансированы. Напишите предикат, который проверяет мобили на
сбалансированность.

@item
Допустим, мы изменили представление мобилей, так что конструкторы теперь
приняли такой вид:

@lisp
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
@end lisp

Как много Вам нужно изменить в программах, чтобы перейти на новое
представление?

@end enumerate
@end quotation

@comment @subsubheading Mapping over trees
@subsubheading Отображение деревьев

Подобно тому, как @code{map} может служить мощной абстракцией для работы
с последовательностями, @code{map}, совмещенная с рекурсией, служит
мощной абстракцией для работы с деревьями. Например, процедура
@code{scale-tree}, аналогичная процедуре @code{scale-list} из
раздела @ref{2.2.1}, принимает в качестве
аргумента числовой множитель и дерево, листьями которого являются числа.
Она возвращает дерево той же формы, где каждое число умножено на
множитель. Рекурсивная схема @code{scale-tree} похожа на схему
@code{count-leaves}:

@lisp
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
@i{(10 (20 (30 40) 50) (60 70))}
@end lisp

@noindent
Другой способ реализации @code{scale-tree} состоит в том, чтобы
рассматривать дерево как последовательность поддеревьев и использовать
@code{map}. Мы отображаем последовательность, масштабируя по очереди
каждое поддерево, и возвращаем список результатов. В базовом случае,
когда дерево является листом, мы просто умножаем:

@lisp
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
@end lisp

@noindent
Многие операции над деревьями могут быть реализованы с помощью такого
сочетания операций над последовательностями и рекурсии.

@quotation
@strong{@anchor{Упражнение 2.30}Упражнение 2.30:}
Определите процедуру @code{square-@/tree}, подобную процедуре
@code{square-list} из упражнения @ref{Упражнение 2.21}. А именно,
@code{square-tree} должна вести себя следующим образом:

@lisp
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
@i{(1 (4 (9 16) 25) (36 49))}
@end lisp

Определите @code{square-tree} как прямо (то есть без использования
процедур высших порядков), так и с помощью @code{map} и рекурсии.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.31}Упражнение 2.31:}
Абстрагируйте свой ответ на
упражнение @ref{Упражнение 2.30}, получая процедуру , так, чтобы
@code{square-tree} можно было определить следующим образом:

@lisp
(define (square-tree tree) (tree-map square tree))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.32}Упражнение 2.32:}
Множество можно представить как список его различных
элементов, а множество его подмножеств как список списков. Например,
если множество равно @code{(1 2 3)}, то множество его подмножеств равно
@code{(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))}. Закончите следующее
определение процедуры, которая порождает множество подмножеств и дайте
ясное объяснение, почему она работает:

@lisp
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map @math{\langle}??@math{\rangle} rest)))))
@end lisp
@end quotation

@comment @subsection Sequences as Conventional Interfaces
@subsection Последовательности как стандартные интерфейсы
@node	2.2.3, 2.2.4, 2.2.2, 2.2

При работе с составными данными мы подчеркивали, что абстракция
позволяет проектировать программы, не увязая в деталях представления
данных, и оставляет возможность экспериментировать с различными
способами представления. В этом разделе мы представляем еще один мощный
принцип проектирования для работы со структурами данных ---
использование (@newterm{conventional interfaces}).

В разделе @ref{1.3}
мы видели, как абстракции, реализованные в виде процедур высших
порядков, способны выразить общие схемы программ, которые работают с
числовыми данными. Наша способность формулировать подобные операции с
составными данными существенным образом зависит от того, в каком стиле
мы манипулируем своими структурами данных. Например, рассмотрим
следующую процедуру, аналогичную @code{count-leaves} из
раздела @ref{2.2.2}. Она принимает в качестве
аргумента дерево и вычисляет сумму квадратов тех из его листьев, которые
являются нечетными числами:

@lisp
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
@end lisp

@noindent
При поверхностном взгляде кажется, что эта процедура очень сильно
отличается от следующей, которая строит список всех четных чисел
Фибоначчи @math{{\rm Fib}(k)}, где @math{k} меньше или равно
данного целого числа @math{n}:

@lisp
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
@end lisp

@noindent
Несмотря на то, что структурно эти процедуры весьма различны, более
абстрактное описание двух процессов вычисления раскрывает немалую долю
сходства. Первая программа

@itemize @bullet

@item
перечисляет листья дерева;

@item
просеивает их, отбирая нечетные;

@item
возводит в квадрат каждое из отобранных чисел; и

@item
накапливает результаты при помощи @code{+}, начиная с 0.

@end itemize

@noindent
Вторая программа

@itemize @bullet

@item
перечисляет числа от 1 до @math{n};

@item
вычисляет для каждого из них число Фибоначчи;

@item
просеивает их, выбирая нечетные; и

@item
собирает их с помощью @code{cons}, начиная с пустого списка.

@end itemize

@float
@anchor{Рисунок 2.7}
@ifinfo
@quotation
@strong{Рисунок 2.7:} The signal-flow plans for the
procedures @code{sum-odd-squares} (top) and @code{even-fibs} (bottom) reveal
the commonality between the two programs.

@example
+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
| tree leaves |   | odd?        |   | square      |   | +, 0        |
+-------------+   +-------------+   +-------------+   +-------------+

+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
| integers    |   | fib         |   | even?       |   | cons, ()    |
+-------------+   +-------------+   +-------------+   +-------------+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap2/Fig2.7d,111mm,,,.pdf}
@c 187mm
@sp 0.4
@quotation
@caption{@strong{Рисунок 2.7:} The signal-flow plans for the procedures @code{sum-@/odd-@/squares} (top) and @code{even-fibs} (bottom) reveal the commonality between the two programs.}
@end quotation
@sp 0.7
@end iftex
@end float

@noindent
Специалисту по обработке сигналов покажется естественным выразить эти
процессы в терминах сигналов, проходящих через ряд стадий, каждая из
которых реализует часть плана программы, как это показано на
рисунке @ref{Рисунок 2.7}. В процедуре @code{sum-odd-squares} мы
начинаем с (@newterm{enumerator}), который порождает <<сигнал>>, состоящий из
листьев данного дерева. Этот сигнал пропускается через (@newterm{filter}), который
удаляет все элементы, кроме нечетных. Получившийся после этого сигнал, в
свою очередь, проходит (@newterm{map}), которое представляет собой
<<преобразователь>>, применяющий к каждому элементу процедуру
@code{square}. Наконец, выход отображения идет в (@newterm{accumulator}), который
собирает элементы при помощи @code{+}, начиная с 0. Для @code{even-fibs}
план аналогичен.

К сожалению, два определения процедур, приведенные выше, не отражают эту
структуру потока сигналов. Например, если мы рассмотрим
@code{sum-oddsquares}, мы обнаружим, что перечисление отчасти
реализуется проверками @code{null?} и @code{pair?}, а отчасти
древовидно-рекурсивной структурой процедуры. Подобным образом,
накопление отчасти происходит в проверках, а отчасти в сложении, которое
выполняется при рекурсивном вызове. Вообще, никакая отдельная часть этих
процедур не соответствует элементу потоковой диаграммы. Наши две
процедуры дробят вычисление другим образом, раскидывая перечисление по
программе и смешивая его с отображением, просеиванием и накоплением.
Если бы мы смогли организовать свои программы так, чтобы структура
обработки потока сигналов была ясно видна в написанных нами процедурах,
то это сделало бы смысл получаемого кода более прозрачным.

@comment @subsubheading Sequence Operations
@subsubheading Операции над последовательностями

Итак, наши программы должны яснее отражать структуру потока сигналов.
Ключевым моментом здесь будет перенос внимания на <<сигналы>>, которые
передаются от одной стадии процесса к другой. Если мы представим эти
сигналы в виде списков, то сможем использовать операции над списками,
чтобы реализовать обработку на каждом этапе. Например, мы можем
реализовать стадии отображения из диаграмм потоков сигналов с помощью
процедуры @code{map} из раздела @ref{2.2.1}:

@lisp
(map square (list 1 2 3 4 5))
@i{(1 4 9 16 25)}
@end lisp

@noindent
Просеивание последовательности, выбирающее только те элементы, которые
удовлетворяют данному предикату, осуществляется при помощи

@lisp
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
@end lisp

@noindent
Например,

@lisp
(filter odd? (list 1 2 3 4 5))
@i{(1 3 5)}
@end lisp

@noindent
Накопление осуществляется посредством

@lisp
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
@i{15}
(accumulate * 1 (list 1 2 3 4 5))
@i{120}
(accumulate cons nil (list 1 2 3 4 5))
@i{(1 2 3 4 5)}
@end lisp

@noindent
Чтобы реализовать диаграммы потока сигналов, нам остается только
перечислить последовательности элементов, с которыми мы будем работать.
Для @code{even-fibs} нужно породить последовательность целых чисел в
заданном диапазоне. Это можно сделать так:

@lisp
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
@i{(2 3 4 5 6 7)}
@end lisp

@noindent
Чтобы перечислить листья дерева, можно использовать такую
процедуру:@footnote{Это в точности процедура @code{fringe} из
упражнения @ref{Упражнение 2.28}. Здесь мы ее переименовали, чтобы
подчеркнуть, что она входит в семейство общих процедур обработки
последовательностей.}

@lisp
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
@i{(1 2 3 4 5)}
@end lisp

@noindent
Теперь мы можем переформулировать @code{sum-odd-squares} и
@code{even-fibs} соответственно тому, как они изображены на диаграммах
потока сигналов. В случае @code{sum-odd-squares} мы вычисляем
последовательность листьев дерева, фильтруем ее, оставляя только
нечетные числа, возводим каждый элемент в квадрат и суммируем
результаты:

@lisp
(define (sum-odd-squares tree)
  (accumulate
   + 0 (map square (filter odd? (enumerate-tree tree)))))
@end lisp

@noindent
В случае с @code{even-fibs} мы перечисляем числа от 0 до @math{n},
порождаем для каждого из них число Фибоначчи, фильтруем получаемую
последовательность, оставляя только четные элементы, и собираем
результаты в список:

@lisp
(define (even-fibs n)
  (accumulate
   cons
   nil
   (filter even? (map fib (enumerate-interval 0 n)))))
@end lisp

@noindent
Польза от выражения программ в виде операций над последовательностями
состоит в том, что эта стратегия помогает нам строить модульные проекты
программ, то есть проекты, которые получаются путем сборки из
относительно независимых частей. Можно поощрять модульное
проектирование, давая разработчику набор стандартных компонент и
унифицированный интерфейс, предназначенный для гибкого соединения этих
компонентов.

Модульное построение является мощной стратегией управления сложностью в
инженерном проектировании. Например, в реальных приложениях по обработке
сигналов проектировщики обычно строят системы путем каскадирования
элементов, которые выбираются из стандартизованных семейств фильтров и
преобразователей. Подобным образом операции над последовательностями
составляют библиотеку стандартных элементов, которые мы можем связывать
и смешивать. К примеру, можно составить куски из процедур
@code{sum-odd-squares} и @code{even-fibs} и получить программу, которая
строит список квадратов первых @code{n+1} чисел Фибоначчи:

@lisp
(define (list-fib-squares n)
  (accumulate
   cons
   nil
   (map square (map fib (enumerate-interval 0 n)))))
(list-fib-squares 10)
@i{(0 1 1 4 9 25 64 169 441 1156 3025)}
@end lisp

@noindent
Можно переставить куски и использовать их, чтобы вычислить произведение
квадратов нечетных чисел в последовательности:

@lisp
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
@i{225}
@end lisp

@noindent
Часто встречающиеся приложения по обработке данных можно также
формулировать в терминах операций над последовательностями. Допустим, у
нас есть последовательность записей о служащих, и нам требуется найти
зарплату самого высокооплачиваемого программиста. Пусть у нас будет
селектор @code{salary}, который возвращает зарплату служащего, и
предикат @code{programmer?}, который проверяет, относится ли запись к
программисту. Тогда мы можем написать:

@lisp
(define (salary-of-highest-paid-programmer records)
  (accumulate max 0 (map salary (filter programmer? records))))
@end lisp

@noindent
Все эти примеры дают лишь слабое представление об огромной области
задач, выразимых в виде операций над
последовательностями.@footnote{Ричард Уотерс @ref{Waters (1979)} разработал
программу, которая анализирует традиционные программы на Фортране,
представляя их в терминах отображений, фильтров и накоплений. Он
обнаружил, что 90 процентов кода в Пакете Научных Подпрограмм на
Фортране хорошо укладывается в эту парадигму. Одна из причин успеха
Лиспа как языка программирования заключается в том, что списки дают
стандартное средство представления упорядоченных множеств, с которыми
можно работать при помощи процедур высших порядков. Язык
программирования APL своей мощности и красоте во многом обязан подобному
же выбору. В APL все данные выражаются как массивы, и существует
универсальный и удобный набор общих операторов для всевозможных действий
над массивами.}

Последовательности, здесь реализованные в виде списков, служат
стандартным интерфейсом, который позволяет комбинировать обрабатывающие
модули. Кроме того, если мы представляем все структуры единым образом
как последовательности, то нам удается локализовать зависимость структур
данных в своих программах в небольшом наборе операций с
последовательностями. Изменяя эти последние, мы можем экспериментировать
с различными способами представления последовательностей, оставляя
неприкосновенной общую структуру своих программ. Этой возможностью мы
воспользуемся в разделе @ref{3.5}, когда обобщим
парадигму обработки последовательностей и введем бесконечные
последовательности.

@quotation
@strong{@anchor{Упражнение 2.33}Упражнение 2.33:}
Заполните пропущенные выражения, так, чтобы получились
определения некоторых базовых операций по работе со списками в виде
накопления:

@lisp
(define (map p sequence)
  (accumulate (lambda (x y) @math{\langle}??@math{\rangle}) nil sequence))
(define (append seq1 seq2)
  (accumulate cons @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle}))
(define (length sequence)
  (accumulate @math{\langle}??@math{\rangle} 0 sequence))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.34}Упражнение 2.34:}
Вычисление многочлена с переменной @math{x} при данном
значении @math{x} можно сформулировать в виде накопления. Мы вычисляем
многочлен

@example
a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0
@end example

@end ifinfo
@tex
$$ a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0 $$
@end tex
@noindent
по известному алгоритму, называемому (@newterm{Horner's rule}), которое переписывает
формулу в виде
@ifinfo

@example
(... (a_n x + a_(n-1)) x + ... + a_1) x + a_0
@end example

@end ifinfo
@tex
$$ (\dots (a_n x + a_{n-1}) x + \dots + a_1) x + a_0. $$
@end tex
@noindent
Другими словами, мы начинаем с @math{a_n}, умножаем его на @math{x},
@math{a_{n-1}}, умножаем его на @math{x}, и так далее, пока не достигнем
@math{a_0}.@footnote{Согласно Кнуту @ref{Knuth 1981}, это правило было
сформулировано У. Г. Горнером в начале
девятнадцатого века, но на самом деле его использовал Ньютон более чем
на сто лет раньше. По схеме Горнера многочлен вычисляется с помощью
меньшего количества сложений и умножений, чем при прямолинейном способе:
вычислить сначала @math{a^n x^n}, затем добавить @math{a_{n-1} x^{n-1}}
и так далее. На самом деле можно доказать, что любой алгоритм для
вычисления произвольных многочленов будет использовать по крайней мере
столько сложений и умножений, сколько схема Горнера, и, таким образом,
схема Горнера является оптимальным алгоритмом для вычисления
многочленов. Это было доказано (для числа сложений) А. М. Островским в
статье 1954 года, которая по существу заложила основы современной науки
об оптимальных алгоритмах. Аналогичное утверждение для числа умножений
доказал В. Я. Пан в 1966 году. Книга Бородина и Мунро @ref{Borodin and
Munro (1975)} дает обзор этих результатов, а также других достижений в области
оптимальных алгоритмов.}

Заполните пропуски в следующей заготовке так,
чтобы получить процедуру, которая вычисляет многочлены по схеме Горнера.
Предполагается, что коэффициенты многочлена представлены в виде
последовательности, от @math{a_0} до @math{a_n}.

@lisp
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) @math{\langle}??@math{\rangle})
              0
              coefficient-sequence))
@end lisp

Например, чтобы вычислить @math{1 + 3x + 5x^3 + x^5} в точке
@math{x = 2}, нужно ввести

@lisp
(horner-eval 2 (list 1 3 0 5 0 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.35}Упражнение 2.35:}
Переопределите @code{count-leaves} из
раздела @ref{2.2.2} в виде накопления:

@lisp
(define (count-leaves t)
  (accumulate @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} (map @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.36}Упражнение 2.36:}
Процедура @code{accumulate-n} подобна @code{accumulate},
только свой третий аргумент она воспринимает как последовательность
последовательностей, причем предполагается, что все они содержат
одинаковое количество элементов. Она применяет указанную процедуру
накопления ко всем первым элементам последовательностей, вторым
элементам последовательностей и так далее, и возвращает
последовательность результатов. Например, если @code{s} есть
последовательность, состоящая из четырех последовательностей,
@code{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}, то значением
@code{(accumulate-n + 0 s)} будет последовательность @code{(22 26 30)}.
Заполните пробелы в следующем определении @code{accumulate-n}:

@lisp
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init @math{\langle}??@math{\rangle})
            (accumulate-n op init @math{\langle}??@math{\rangle}))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.37}Упражнение 2.37:}
Предположим, что мы представляем векторы @math{v =
(v_i)} как последовательности чисел, а матрицы @math{m
=(m_{ij})} как последовательности векторов (рядов матрицы). Например,
матрица
@ifinfo

@example
+-         -+
|  1 2 3 4  |
|  4 5 6 6  |
|  6 7 8 9  |
+-         -+
@end example

@end ifinfo
@tex
$$
\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9
\end{array}
\right)
$$
@end tex
@noindent
представляется в виде последовательности
@code{((1 2 3 4) (4 5 6 6) (6 7 8 9))}. Имея такое представление, мы
можем использовать операции над последовательностями, чтобы кратко
выразить основные действия над матрицами и векторами. Эти операции
(описанные в любой книге по матричной алгебре) следующие:
@ifinfo

@example
                                        __
(dot-product v w)      возвращает сумму >_i v_i w_i

(matrix-*-vector m v)  возвращает вектор t,
                                 __
                       где t_i = >_j m_(ij) v_j

(matrix-*-matrix m n)  возвращает матрицу p,
                                    __
                       где p_(ij) = >_k m_(ik) n_(kj)

(transpose m)          возвращает матрицу n,
                       где n_(ij) = m_(ji)
@end example

@end ifinfo
@tex
$$
\begin{array}{rl}
    \hbox{\tt (dot-product v w)} 		& {\rm возвращает сумму;} \Sigma_i v_i w_i; \\
    \hbox{\tt (matrix-*-vector m v)} 	& {\rm возвращает вектор;} \hbox{\bf t},  \\
        & {\rm где\;} t_i = \Sigma_{\kern-0.1em j} m_{i\!j} v_{\kern-0.1em j};      \\
    \hbox{\tt (matrix-*-matrix m n)} 	& {\rm возвращает матрицу\;} \hbox{\bf p},  \\
        & {\rm где\;} p_{i\!j} = \Sigma_k m_{ik} n_{k\!j};                          \\
    \hbox{\tt (transpose m)} 		& {\rm возвращает матрицу\;} \hbox{\bf n},  \\
        & {\rm где\;} n_{i\!j} = m_{\kern-0.1em ji}.
\end{array}
$$
@end tex
Скалярное произведение мы можем определить так:@footnote{Это определение
использует расширенную версию @code{map}, описанную в сноске
@ref{Сноска 2.12}.}

@lisp
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
@end lisp

Заполните пропуски в следующих процедурах для вычисления остальных
матричных операций. (Процедура @code{accumulate-n} описана в
упражнении @ref{Упражнение 2.36}.)

@lisp
(define (matrix-*-vector m v)
  (map @math{\langle}??@math{\rangle} m))
(define (transpose mat)
  (accumulate-n @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map @math{\langle}??@math{\rangle} m)))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.38}Упражнение 2.38:}
Процедура @code{accumulate} известна также как
@code{fold-right} (правая свертка), поскольку она комбинирует первый
элемент последовательности с результатом комбинирования всех элементов
справа от него. Существует также процедура @code{fold-left} (левая
свертка), которая подобна @code{fold-right}, но комбинирует элементы в
противоположном направлении:

@lisp
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
@end lisp

Каковы значения следующих выражений?

@lisp
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
@end lisp

Укажите свойство, которому должна удовлетворять @code{op}, чтобы для
любой последовательности @code{fold-right} и @code{fold-left} давали
одинаковые результаты.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.39}Упражнение 2.39:}
Закончите следующие определения @code{reverse}
(упражнение @ref{Упражнение 2.18}) в терминах процедур
@code{fold-right} и @code{fold-left} из упражнения @ref{Упражнение 2.38}.

@comment @subsubheading Nested Mappings
@subsubheading Вложенные отображения

Расширив парадигму последовательностей, мы можем включить в нее многие
вычисления, которые обычно выражаются с помощью вложенных
циклов.@footnote{Этот подход к вложенным отображениям нам показал Дэвид
Тёрнер, чьи языки KRC и Миранда обладают изящным формализмом для работы
с такими конструкциями. Примеры из этого раздела (см. также
упражнение @ref{Упражнение 2.42}) адаптированы из @ref{Turner 1981}. В
разделе @ref{3.5.3}
мы увидим, как этот подход можно обобщить на бесконечные
последовательности.} Рассмотрим следующую задачу: пусть дано
положительное целое число @math{n}; найти все такие упорядоченные пары
различных целых чисел @math{i} и @math{j}, где @math{1 \le j < i \le
n}, что @math{i + j} является простым. Например, если @math{n} равно 6,
то искомые пары следующие:
@ifinfo

@example
  i   | 2 3 4 4 5 6 6
  j   | 1 2 1 3 2 1 5
------+---------------
i + j | 3 5 5 7 7 7 11
@end example

@end ifinfo
@tex
$$\vbox{
\offinterlineskip
\halign{
\strut \hfil \quad #\quad \hfil & \vrule
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil &
    \hfil \quad #\quad \hfil \cr

$i$ 	& 2 & 3 & 4 & 4 & 5 & 6 & 6 \cr
$j$ 	& 1 & 2 & 1 & 3 & 2 & 1 & 5 \cr
\noalign{\hrule}
$i + j$	& 3 & 5 & 5 & 7 & 7 & 7 & 11 \cr}
}$$
@end tex
Естественный способ организации этого вычисления состоит в
том, чтобы породить последовательность всех упорядоченных пар
положительных чисел, меньших @math{n}, отфильтровать ее, выбирая те
пары, где сумма чисел простая, и затем для каждой пары @math{(i, j)},
которая прошла через фильтр, сгенерировать тройку @math{(i, j, i+j)}.

Вот способ породить последовательность пар: для каждого целого
@math{i \le n} перечислить целые числа @math{j < i},
и для каждых таких @math{i} и @math{j} породить пару @math{(i, j)}.
В терминах операций над последовательностями, мы производим отображение
последовательности @code{(enumerate-interval 1 n)}. Для каждого @math{i}
из этой последовательности мы производим отображение последовательности
@code{(enumerate-interval 1 (- i 1))}. Для каждого @math{j} в этой
последовательности мы порождаем пару @code{(list i j)}. Это дает нам
последовательность пар для каждого @math{i}. Скомбинировав
последовательности для всех @math{i} (путем накопления через
@code{append}), получаем необходимую нам последовательность
пар:@footnote{Здесь мы представляем пару в виде списка из двух элементов,
а не в виде лисповской пары. Иначе говоря, <<пара>> @math{(i, j)}
представляется как @code{(list i j)}, а не как @code{(cons i j)}.}

@lisp
(accumulate
 append nil (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
@end lisp

@noindent
Комбинация из отображения и накопления через @code{append} в такого рода
программах настолько обычна, что мы ее выразим как отдельную процедуру:

@lisp
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
@end lisp

@noindent
Теперь нужно отфильтровать эту последовательность пар, чтобы найти те из
них, где сумма является простым числом. Предикат фильтра вызывается для
каждой пары в последовательности; его аргументом является пара и он
должен обращаться к элементам пары. Таким образом, предикат, который мы
применяем к каждому элементу пары, таков:

@lisp
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
@end lisp

@noindent
Наконец, нужно породить последовательность результатов, отобразив
отфильтрованную последовательность пар при помощи следующей процедуры,
которая создает тройку, состоящую из двух элементов пары и их суммы:

@lisp
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
@end lisp

@noindent
Сочетание всех этих шагов дает нам процедуру целиком:

@smalllisp
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (flatmap
                           (lambda (i)
                             (map (lambda (j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                           (enumerate-interval 1 n)))))
@end smalllisp

@noindent
Вложенные отображения полезны не только для таких последовательностей,
которые перечисляют интервалы. Допустим, нам нужно перечислить все
перестановки множества @math{S}, то есть все способы упорядочить это
множество. Например, перестановки множества @math{\{1, 2, 3\}} --- это
@math{\{1, 2, 3\}}, @math{\{1, 3, 
2\}}, @math{\{2, 1, 3\}}, @math{\{2, 3, 1\}}, @math{\{3, 1, 2\}} и
@math{\{3, 2, 1\}}. Вот план того, как можно породить все перестановки
@math{S}: Для каждого элемента @math{x} из @math{S}, нужно рекурсивно
породить все множество перестановок @math{S - x},@footnote{Множество
@math{S - x} есть множество, состоящее из всех
элементов @math{S}, кроме @math{x}.} затем добавить @math{x} к началу
каждой из них. Для каждого @math{x} из @math{S} это дает множество всех
перестановок @math{S}, которые начинаются с @math{x}. Комбинация всех
последовательностей для всех @math{x} дает нам все перестановки
@math{S}:@footnote{Точки с запятой в коде на Scheme начинают (comments).
Весь текст, начиная от точки с запятой и заканчивая концом строки,
интерпретатор игнорирует. В этой книге мы мало используем комментарии;
мы стараемся, чтобы программы документировали себя сами при помощи
описательных имен переменных.}

@lisp
(define (permutations s)
  (if (null? s)              @r{; empty set?}
      (list nil)             @r{; sequence containing empty set}
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
@end lisp

@noindent
Заметим, что такая стратегия сводит задачу порождения перестановок
@math{S} к задаче порождения перестановок для множества, которое меньше,
чем @math{S}. В граничном случае мы добираемся до пустого списка,
который представляет множество, не содержащее элементов. Для этого
множества мы порождаем @code{(list nil)}, которое является
последовательностью из одного члена, а именно множества без элементов.
Процедура @code{remove}, которую мы используем внутри
@code{permutations}, возвращает все элементы исходной
последовательности, за исключением данного. Ее можно выразить как
простой фильтр:

@lisp
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.40}Упражнение 2.40:}
Определите процедуру , которая, получая целое число
@math{n}, порождает последовательность пар @math{(i, j)}, таких, что
@math{1 \le j
< i \le n}. С помощью @code{unique-pairs} упростите данное выше
определение @code{prime-sum-pairs}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.41}Упражнение 2.41:}
Напишите процедуру, которая находит все такие упорядоченные
тройки различных положительных целых чисел @math{i}, @math{j} и
@math{k}, меньших или равных данному целому числу @math{n}, сумма
которых равна данному числу @math{s}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.42}Упражнение 2.42:}
В <<задаче о восьми ферзях>> спрашивается, как расставить
на шахматной доске восемь ферзей так, чтобы ни один из них не бил
другого (то есть никакие два ферзя не должны находиться на одной
вертикали, горизонтали или диагонали). Одно из возможных решений
показано на рисунке @ref{Рисунок 2.8}. Один из способов решать эту
задачу состоит в том, чтобы идти поперек доски, устанавливая по ферзю в
каждой вертикали. После того, как @math{k-1} ферзя мы уже разместили,
нужно разместить @math{k}-го в таком месте, где он не бьет ни одного из
тех, которые уже находятся на доске. Этот подход можно сформулировать
рекурсивно: предположим, что мы уже породили последовательность из всех
возможных способов разместить @math{k-1} ферзей на первых @math{k-1}
вертикалях доски. Для каждого из этих способов мы порождаем расширенный
набор позиций, добавляя ферзя на каждую горизонталь @math{k}-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те,
где ферзь на @math{k}-й вертикали не бьется ни одним из остальных.
Продолжая этот процесс, мы породим не просто одно решение, а все решения
этой задачи.

@float
@anchor{Рисунок 2.8}
@ifinfo
@strong{Рисунок 2.8:} A solution to the eight-queens puzzle.

@example
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | Q |   |   |
+---+---+---+---+---+---+---+---+
|   |   | Q |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| Q |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | Q |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   | Q |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   | Q |
+---+---+---+---+---+---+---+---+
|   | Q |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | Q |   |   |   |   |
+---+---+---+---+---+---+---+---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap2/Fig2.8c,48mm,,,.pdf}      @c 73mm
@sp 0.3
@center @caption{@strong{Рисунок 2.8:} A solution to the eight-queens puzzle.}
@sp 0.0
@end iftex
@end float

Это решение мы реализуем в процедуре @code{queens}, которая возвращает
последовательность решений задачи размещения @math{n} ферзей на доске
@math{n \times
n}. В процедуре @code{queens} есть внутренняя процедура
@code{queen-cols}, которая возвращает последовательность всех способов
разместить ферзей на первых @math{k} вертикалях доски.

@lisp

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
@end lisp

В этой процедуре @code{rest-of-queens} есть способ размещения @math{k-1}
ферзя на первых @math{k-1} вертикалях, а @code{new-row} --- это
горизонталь, на которую предлагается поместить ферзя с @math{k}-й
вертикали. Завершите эту программу, реализовав представление множеств
позиций ферзей на доске, включая процедуру @code{adjoin-position},
которая добавляет нового ферзя на определенных горизонтали и вертикали к
заданному множеству позиций, и @code{empty-board}, которая представляет
пустое множество позиций. Еще нужно написать процедуру @code{safe?},
которая для множества позиций определяет, находится ли ферзь с
@math{k}-й вертикали в безопасности от остальных. (Заметим, что нам
требуется проверять только то, находится ли в безопасности новый
ферзь --- для остальных ферзей безопасность друг от друга уже
гарантирована.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.43}Упражнение 2.43:}
У Хьюго Дума ужасные трудности при решении
упражнения @ref{Упражнение 2.42}. Его процедура @code{queens} вроде бы
работает, но невероятно медленно. (Хьюго ни разу не удается дождаться,
пока она решит хотя бы задачу @math{6 \times 6}.) Когда Хьюго просит о
помощи Еву Лу Атор, она указывает, что он поменял местами порядок
вложенных отображений в вызове процедуры @code{flatmap}, записав его в
виде

@lisp
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
@end lisp

Объясните, почему из-за такой перестановки программа работает медленно.
Оцените, насколько долго программа Хьюго будет решать задачу с восемью
ферзями, если предположить, что программа, приведенная в
упражнении @ref{Упражнение 2.42}, решает ее за время @math{T}.

@comment @subsection Example: A Picture Language
@subsection Пример: язык описания изображений
@node	2.2.4,  , 2.2.3, 2.2

В этой главе мы представляем простой язык для рисования картинок,
иллюстрирующий силу абстракции данных и свойства замыкания; кроме того,
он существенным образом опирается на процедуры высших порядков. Язык
этот спроектирован так, чтобы легко было работать с узорами вроде тех,
которые показаны на рисунке @ref{Рисунок 2.9}, составленными из
элементов, которые повторяются в разных положениях и меняют
размер.@footnote{Этот язык описания картинок основан на языке, который
создал Питер Хендерсон для построения изображений, подобных гравюре М.
К. Эшера <<Предел квадрата>> (см. @ref{Henderson 1982}). На гравюре изображен
повторяющийся с уменьшением элемент, подобно картинкам, получающимся при
помощи процедуры @code{square-limit} из этого раздела.} В этом языке
комбинируемые объекты данных представляются не как списковая структура,
а как процедуры. Точно так же, как @code{cons}, которая обладает
свойством замыкания, позволила нам строить списковые структуры
произвольной сложности, операции этого языка, также обладающие свойством
замыкания, позволяют нам строить сколь угодно сложные узоры.

@comment @subsubheading The picture language
@subsubheading Язык описания изображений

Когда в разделе @ref{1.1}
мы начинали изучать программирование, мы подчеркивали важность описания
языка через рассмотрение его примитивов, методов комбинирования и
методов абстракции. Мы будем следовать этой схеме и здесь.

@float
@quotation
@anchor{Рисунок 2.9}
@ifinfo
@strong{Рисунок 2.9:} Designs generated with the picture language.

[two graphic images not included]
@end ifinfo
@end quotation
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.9-bigger,111mm,48mm,,.png}
@sp 0.6
@center @caption{@strong{Рисунок 2.9:} Designs generated with the picture language.}
@sp 0.6
@end iftex
@end float

@float
@quotation
@anchor{Рисунок 2.10}
@ifinfo
@strong{Рисунок 2.10:} Images produced by the @code{wave}
painter, with respect to four different frames.  The frames, shown with dotted
lines, are not part of the images.

[four graphic images not included]
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap2/Fig2.10,50mm,,,.pdf}
@sp 0.6
@caption{@strong{Рисунок 2.10:} Images produced by the @code{wave} painter, with respect to four different frames.  The frames, shown with dotted lines, are not part of the images.}
@sp 0.0
@end iftex
@end quotation
@end float

Одно из элегантных свойств языка описания изображений состоит в том, что
в нем есть только один тип элементов, называемый (@newterm{painter}). Рисовалка
рисует изображение с необходимым смещением и масштабом, чтобы попасть в
указанную рамку в форме параллелограмма. Например, существует
элементарная рисовалка @code{wave}, которая порождает грубую картинку из
линий, как показано на рисунке @ref{Рисунок 2.10}. Форма изображения
зависит от рамки  --- все четыре изображения на
рисунке @ref{Рисунок 2.10} порождены одной и той же рисовалкой
@code{wave}, но по отношению к четырем различным рамкам. Рисовалки могут
быть и более изощренными: элементарная рисовалка по имени @code{rogers}
рисует портрет основателя MIT Уильяма Бартона Роджерса, как показано на
рисунке @ref{Рисунок 2.11}.@footnote{Уильям Бартон Роджерс (1804-1882)
был основателем и первым президентом MIT. Будучи геологом и способным
педагогом, он преподавал в Колледже Вильгельма и Марии, а также в
университете штата Виргиния. В 1859 году он переехал в Бостон, где у
него было больше времени для исследований, разработал план создания
<<политехнического института>> и служил первым Инспектором штата
Массачусетс по газовым счетчикам.

Когда в 1861 году был основан MIT, Роджерс был избран его первым
президентом. Роджерс исповедовал идеал <<полезного обучения>>, отличного
от университетского образования его времени с чрезмерным вниманием к
классике, которое, как он писал, <<стояло на пути более широкого,
высокого и практического обучения и преподавания в естественных и
общественных науках>>. Это образование должно было отличаться и от
узкого образования коммерческих школ. По словам Роджерса:

@quotation
Повсеместно проводимое разделение между практическим и научным
работником совершенно бесполезно, и весь опыт нашего времени показывает
его полную несостоятельность.
@end quotation

Роджерс был президентом MIT до 1870 года, когда он ушел в отставку по
состоянию здоровья. В 1878 году второй президент MIT Джон Ранкл оставил
свой пост из-за финансового кризиса, вызванного биржевой паникой 1873
года, и напряженной борьбы с попытками Гарварда поглотить MIT. Роджерс
вернулся и оставался на посту президента до 1881 года.

Роджерс умер от приступа во время своей речи перед студентами MIT на
выпускной церемонии 1882 года. В речи, посвященной его памяти и
произнесенной в том же году, Ранкл приводит последние его слова:

@quotation
<<Стоя здесь и видя, чем стал Институт, @dots{} я вспоминаю о начале
научных исследований. Я вспоминаю, как сто пятьдесят лет назад Стивен
Хейлс опубликовал статью на тему о светящемся газе, где он утверждал,
что его исследования показали, что 128 гран битумного угля@dots{}>>

<<Битумный уголь>> --- были его последние слова в этом мире. Он
склонился вперед, как будто справляясь со своими заметками, которые
лежали перед ним на столе, затем медленно выпрямился, поднял руки, и был
перенесен со сцены своих земных забот и триумфов в <<завтра смерти>>,
где решены тайны жизни, и бестелесный дух находит неизмеримое
наслаждение в созерцании новых и по-прежнему необъяснимых загадок
бесконечного будущего.
@end quotation

По словам Фрэнсиса А. Уокера (третьего президента MIT):

@quotation
Всю свою жизнь он провел с огромной верой и героизмом, и умер так, как,
наверное, и должен был желать столь превосходный рыцарь, в полном
вооружении, на своем посту, и во время самого акта исполнения
общественных обязанностей.
@end quotation} Четыре изображения на рисунке @ref{Рисунок 2.11}
нарисованы относительно тех же рамок, что и картинки @code{wave} на
рисунке @ref{Рисунок 2.10}.

@float
@quotation
@anchor{Рисунок 2.11}
@ifinfo
@strong{Рисунок 2.11:} Images of William Barton Rogers,
founder and first president of @acronym{MIT}, painted with respect to the same
four frames as in @ref{Рисунок 2.10} (original image reprinted with the
permission of the @acronym{MIT} Museum).

[four graphic images not included]
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.11,48mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 2.11:} Images of William Barton Rogers, founder and first president of @acronym{MIT}, painted with respect to the same four frames as in @ref{Рисунок 2.10} (original image from Wikimedia Commons).}
@sp 0.8
@end iftex
@end quotation
@end float

При комбинировании изображений мы используем различные операции, которые
строят новые рисовалки из рисовалок, полученных в качестве аргументов.
Например, операция @code{beside} получает две рисовалки и порождает
новую составную рисовалку, которая рисует изображение первой рисовалки в
левой половине рамки, а изображение второй рисовалки в правой половине
рамки. Подобным образом, @code{below} принимает две рисовалки и
порождает составную рисовалку, рисующую изображение первого аргумента
под изображением второго аргумента. Некоторые операции преобразуют одну
рисовалку и получают другую. Например, @code{flip-vert} получает
рисовалку и порождает новую, рисующую изображение вверх ногами, а
@code{flip-horiz} порождает рисовалку, рисующую изображение исходной в
зеркальном отображении.

На картинке @ref{Рисунок 2.12} показан результат работы рисовалки,
называемой @code{wave4}, который строится в два этапа, начиная с
@code{wave}:

@lisp
(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
@end lisp

@float
@quotation
@anchor{Рисунок 2.12}
@ifinfo
@strong{Рисунок 2.12:} Creating a complex figure, starting
from the @code{wave} painter of @ref{Рисунок 2.10}.

[two graphic images not included]

@lisp
(define wave2                      (define wave4
  (beside wave (flip-vert wave)))    (below wave2 wave2))
@end lisp
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.12,50mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 2.12:} Creating a complex figure, starting from the @code{wave} painter of @ref{Рисунок 2.10}.}
@sp 0.7
@end iftex
@end quotation
@end float

Строя таким образом составные рисовалки, мы используем тот факт, что
рисовалки замкнуты относительно средств комбинирования нашего языка.
@code{beside} или @code{below} от двух рисовалок само является
рисовалкой; следовательно, мы можем ее использовать как элемент при
построении еще более сложных рисовалок. Так же, как при построении
списковых структур с помощью @code{cons}, замкнутость наших данных
относительно средств комбинирования служит основой способности строить
сложные структуры при помощи всего лишь нескольких операций.

Раз мы можем комбинировать рисовалки, нам хотелось бы уметь выделять
типичные схемы их комбинирования. Операции над рисовалками мы реализуем
как процедуры языка Scheme. Это означает, что нам в языке изображений не
требуется специального механизма абстракции: поскольку средства
комбинирования являются обычными процедурами Scheme, у нас автоматически
есть право делать с операциями над рисовалками все то, что мы можем
делать с процедурами. Например, схему построения @code{wave4} мы можем
абстрагировать в виде

@lisp
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
@end lisp

@noindent
и определить @code{wave4} как пример применения этой схемы:

@lisp
(define wave4 (flipped-pairs wave))
@end lisp

@float
@anchor{Рисунок 2.13}
@ifinfo
@quotation
@strong{Рисунок 2.13:} Recursive plans for @code{right-split} and @code{corner-split}.

@example
+-------------+-------------+    +------+------+-------------+
|             |             |    | up-  | up-  |             |
|             | right-split |    | split| split| corner-split|
|             |             |    |      |      |             |
|             |     n-1     |    |  n-1 |  n-1 |     n-1     |
|             |             |    |      |      |             |
|  identity   +-------------+    +------+------+-------------+
|             |             |    |             | right-split |
|             | right-split |    |             |     n-1     |
|             |             |    |  identity   +-------------+
|             |     n-1     |    |             | right-split |
|             |             |    |             |     n-1     |
+-------------+-------------+    +-------------+-------------+

       right-split n                    corner-split n
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap2/Fig2.13a,111mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.13:} Recursive plans for @code{right-split} and @code{corner-split}. }@short
@sp 0.7
@end iftex
@end float

@noindent
Мы можем определять и рекурсивные операции. Вот пример, который
заставляет рисовалки делиться и ветвиться направо, как показано на
рисунках @ref{Рисунок 2.13} и @ref{Рисунок 2.14}:

@lisp
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
@end lisp

@noindent
Можно порождать сбалансированные узоры, наращивая их не только направо,
но и вверх (см. упражнение @ref{Упражнение 2.44} и
рисунки @ref{Рисунок 2.13} и @ref{Рисунок 2.14}):

@lisp
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
@end lisp

@noindent
Соответствующим образом расположив четыре копии @code{corner-split}, мы
получаем схему под названием @code{square-limit}, применение которой к
@code{wave} и @code{rogers} показано на рисунке @ref{Рисунок 2.9}:

@lisp
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.44}Упражнение 2.44:}
Определите процедуру @code{up-split}, которую использует
@code{corner-@/split}. Она подобна @code{right-split}, но только меняет
местами роли @code{below} и @code{beside}.
@end quotation

@float[tbp]
@quotation
@anchor{Рисунок 2.14}
@ifinfo
@strong{Рисунок 2.14:} The recursive operations @code{right-split} and @code{corner-split} applied to the painters @code{wave} and @code{rogers}.  Combining four @code{corner-split} figures produces symmetric @code{square-limit} designs as shown in @ref{Рисунок 2.9}.

[two graphic images not included]

@lisp
(right-split wave 4)         (right-split rogers 4)
@end lisp

[two graphic images not included]

@lisp
(corner-split wave 4)        (corner-split rogers 4)
@end lisp
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.14b,91mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 2.14:} The recursive operations @code{right-split} and @code{corner-@/split} applied to the painters @code{wave} and @code{rogers}.  Combining four @code{corner-split} figures produces symmetric @code{square-limit} designs as shown in @ref{Рисунок 2.9}.}
@sp 0.0
@end iftex
@end quotation
@end float

@comment @subsubheading Higher-order operations
@subsubheading Операции высших порядков

В дополнение к абстрагированию схем комбинирования рисовалок, мы можем
работать и на более высоком уровне, абстрагируя схемы комбинирования
операций над рисовалками. А именно, мы можем рассматривать операции над
рисовалками в качестве элементов, подлежащих манипуляции, и писать
средства комбинирования этих элементов --- операции, которые принимают
операции над рисовалками как аргументы и создают новые операции.

Например, и @code{flipped-pairs}, и @code{square-limit} располагают
определенным образом в виде квадрата четыре копии порождаемого
рисовалкой изображения; они отличаются только тем, как они ориентируют
эти копии. Один из способов абстрагировать такую схему комбинирования
рисовалок представлен следующей процедурой, которая принимает четыре
одноаргументных операции и порождает операцию над рисовалками, которая
трансформирует данную ей рисовалку с помощью этих четырех операций и
расставляет результаты по квадрату. @code{Tl}, @code{tr}, @code{bl} и
@code{br} --- это трансформации, которые следует применить к верхней
левой, верхней правой, нижней левой и нижней правой копиям,
соответственно.

@lisp
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
@end lisp

@noindent
Тогда в терминах @code{square-of-four} можно определить
@code{flipped-pairs} следующим образом:@footnote{Мы также могли бы
написать

@lisp
(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
@end lisp
}:

@lisp
(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
@end lisp

@noindent
а @code{square-limit} можно выразить как@footnote{@code{Rotate180}
поворачивает рисовалку на 180 градусов (см.
упражнение @ref{Упражнение 2.50}). Вместо @code{rotate180} мы могли бы
сказать @code{(compose flip-vert flip-horiz)}, используя процедуру
@code{compose} из упражнения @ref{Упражнение 1.42}.}

@lisp
(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.45}Упражнение 2.45:}
@code{right-split} и @code{up-split} можно выразить как
разновидности общей операции разделения. Определите процедуру с таким
свойством, что вычисление

@lisp
(define right-split (split beside below))
(define up-split (split below beside))
@end lisp

порождает процедуры @code{right-split} и @code{up-split} с таким же
поведением, как и определенные ранее.
@end quotation

@comment @subsubheading Frames
@subsubheading Рамки

Прежде, чем мы сможем показать, как реализуются рисовалки и средства их
комбинирования, нам нужно рассмотреть рамки. Рамку можно описать как три
вектора --- вектор исходной точки и два вектора краев рамки. Вектор
исходной точки @math{\mbox{\rm Origin}} указывает смещение исходной
точки рамки от некой абсолютной начальной точки, а векторы краев
@math{\mbox{\rm Edge}_1} и @math{\mathop{\rm Edge}_2} указывают смещение
углов рамки от ее исходной точки. Если края перпендикулярны, рамка будет
прямоугольной. В противном случае рамка будет представлять более общий
случай параллелограмма. На рис. @ref{Рисунок 2.15} показаны рамка и
соответствующие ей вектора. В соответствии с принципами абстракции
данных, нам пока незачем указывать, каким образом представляются рамки;
нужно только сказать, что есть конструктор @code{make-frame}, который
принимает три вектора и выдает рамку, и что есть еще три селектора
@code{origin-frame}, @code{edge1-frame} и @code{edge2-frame} (см.
упражнение @ref{Упражнение 2.47}).

@float
@quotation
@anchor{Рисунок 2.15}
@ifinfo
@strong{Рисунок 2.15:} A frame is described by three vectors
-- an origin and two edges.

@example
                         __
                     __--  \
                 __--       \
      __     __--            \   __
     |\  __--                 \__-|
       \-                  __--
frame   \              __--
edge2    \         __--    frame
vector    \    __--        edge1
           \_--            vector
            -   <--+
          frame    |
          origin   +-- (0, 0) point
          vector       on display screen
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.15a,51mm,,,.pdf}
@sp 0.2
@caption{@strong{Рисунок 2.15:} A frame is described by three vectors --- an origin and two edges.}
@sp 0.6
@end iftex
@end quotation
@end float

Для определения изображений мы будем использовать координаты в единичном
квадрате @math{(@newterm{0 \le x, y \le 1})}. Каждой рамке мы
сопоставляем (frame coordinate map), которое будет
использоваться, чтобы сдвигать и масштабировать изображения так, чтобы
они умещались в рамку. Это отображение трансформирует единичный квадрат
в рамку, переводя вектор @math{{\bf v} = (x, y)} в сумму векторов
@ifinfo

@example
Origin(Frame) + x * Edge_1(Frame) + y * Edge_2(Frame)
@end example

@end ifinfo
@tex
$$ {\rm Origin(Frame)} + x \cdot {\rm Edge_1(Frame)} + y \cdot {\rm Edge_2(Frame)}. $$
@end tex
@noindent
Например, (0, 0)
отображается в исходную точку рамки, (1, 1) в вершину, противоположную
исходной точке по диагонали, а (0.5, 0.5) в центр рамки. Мы можем
создать отображение координат рамки при помощи следующей
процедуры:@footnote{@code{Frame-coord-map} использует векторные операции,
определенные ниже в упражнении @ref{Упражнение 2.46}, и мы
предполагаем, что они реализованы для какого-нибудь представления
векторов. Благодаря абстракции данных, неважно, каково это
представление; нужно только, чтобы операции над векторами вели себя
правильно.}

@lisp
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
               (scale-vect (ycor-vect v) (edge2-frame frame))))))
@end lisp

@noindent
Заметим, что применение @code{frame-coord-map} к рамке дает нам
процедуру, которая, получая вектор, возвращает тоже вектор. Если
вектор-аргумент находится в единичном квадрате, вектор-результат
окажется в рамке. Например,

@lisp
((frame-coord-map a-frame) (make-vect 0 0))
@end lisp

@noindent
возвращает тот же вектор, что и

@lisp
(origin-frame a-frame)
@end lisp

@quotation
@strong{@anchor{Упражнение 2.46}Упражнение 2.46:}
Двумерный вектор @math{{\bf v}}, идущий от начала координат
к точке, можно представить в виде пары, состоящей из @math{x}-координаты
и @math{y}-координаты. Реализуйте абстракцию данных для векторов,
написав конструктор @code{make-vect} и соответствующие селекторы
@code{xcor-vect} и @code{ycor-vect}. В терминах своих селекторов и
конструктора реализуйте процедуры @code{add-vect}, @code{sub-vect} и
@code{scale-vect}, которые выполняют операции сложения, вычитания
векторов и умножения вектора на скаляр:
@ifinfo

@example
(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
(x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
             s * (x, y) = (sx, sy)
@end example
@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
    (x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
    (x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
    s \cdot (x, y) 			& (sx, sy).
\end{array}
$$
@end tex
@end quotation

@quotation
@strong{@anchor{Упражнение 2.47}Упражнение 2.47:}
Вот два варианта конструкторов для рамок:

@lisp
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
@end lisp

К каждому из этих конструкторов добавьте соответствующие селекторы, так,
чтобы получить реализацию рамок.
@end quotation

@comment @subsubheading Painters
@subsubheading Рисовалки

Рисовалка представляется в виде процедуры, которая, получая в качестве
аргумента рамку, рисует определенное изображение, отмасштабированное и
сдвинутое так, чтобы уместиться в эту рамку. Это означает, что если есть
рисовалка @code{p} и рамка @code{f}, то мы можем получить изображение,
порождаемое @code{p}, в @code{f}, позвав @code{p} с @code{f} в качестве
аргумента.

Детали того, как реализуются элементарные рисовалки, зависят от
конкретных характеристик графической системы и типа изображения, которое
надо получить. Например, пусть у нас будет процедура @code{draw-line},
которая рисует на экране отрезок между двумя указанными точками. Тогда
мы можем создавать из списков отрезков рисовалки для изображений,
состоящих из этих отрезков, вроде рисовалки @code{wave} с
рисунка @ref{Рисунок 2.10}, таким образом:@footnote{Процедура
@code{segments->painter} использует представление отрезков прямых,
описанное ниже в упражнении @ref{Упражнение 2.48}. Кроме того, она
использует процедуру @code{for-each}, описанную в
упражнении @ref{Упражнение 2.23}.}

@lisp
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame)
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
@end lisp

@noindent
Отрезки даются в координатах по отношению к единичному квадрату. Для
каждого сегмента в списке рисовалка преобразует концы отрезка с помощью
отображения координат рамки и рисует отрезок между точками с
преобразованными координатами.

Представление рисовалок в виде процедур воздвигает в языке построения
изображений мощный барьер абстракции. Мы можем создавать и смешивать
множество типов элементарных рисовалок, в зависимости от имеющихся
возможностей графики. Детали их реализации несущественны. Любая
процедура, если она принимает в качестве аргумента рамку и рисует в ней
что-нибудь должным образом отмасштабированное, может служить
рисовалкой.@footnote{Например, рисовалка @code{rogers} с
рисунка @ref{Рисунок 2.11} была получена из полутонового черно-белого
изображения. Для каждой точки в указанной рамке рисовалка @code{rogers}
определяет точку исходного изображения, которая в нее отображается, и
соответствующим образом ее окрашивает. Разрешая себе иметь различные
типы рисовалок, мы пользуемся идеей абстрактных данных, описанной в
разделе @ref{2.1.3}, где мы говорили, что
представление рациональных чисел может быть каким угодно, пока
соблюдается соответствующее условие. Здесь мы используем то, что
рисовалку можно реализовать как угодно, лишь бы она что-то изображала в
указанной рамке. В разделе @ref{2.1.3}
показывается и то, как реализовать пары в виде процедур. Рисовалки ---
это наш второй пример процедурного представления данных.}

@quotation
@strong{@anchor{Упражнение 2.48}Упражнение 2.48:}
Направленный отрезок на плоскости можно представить в виде
пары векторов: вектор от начала координат до начала отрезка и вектор от
начала координат до конца отрезка. Используйте свое представление
векторов из упражнения @ref{Упражнение 2.46} и определите
представление отрезков с конструктором @code{make-segment} и селекторами
@code{start-segment} и @code{end-segment}.

@end quotation

@quotation
@strong{@anchor{Упражнение 2.49}Упражнение 2.49:}
С помощью @code{segments->painter} определите следующие
элементарные рисовалки:

@enumerate a.

@item
Рисовалку, которая обводит указанную рамку.

@item
Рисовалку, которая рисует <<Х>>, соединяя противоположные концы рамки.

@item
Рисовалку, которая рисует ромб, соединяя между собой середины сторон
рамки.

@item
Рисовалку @code{wave}.

@end enumerate
@end quotation

@comment @subsubheading Transforming and combining painters
@subsubheading Преобразование и комбинирование рисовалок

Операции над рисовалками (@code{flip-vert} или @code{beside}, например)
создают новые рисовалки, которые вызывает исходные рисовалки по
отношению к рамкам, производным от рамок-аргументов. Таким образом,
скажем, @code{flip-vert} не требуется знать, как работает рисовалка,
чтобы перевернуть ее  --- ей нужно только уметь перевернуть рамку вверх
ногами: перевернутая рисовалка просто использует исходную, но в
обращенной рамке.

Операции над рисовалками основываются на процедуре
@code{transform-painter}, которая в качестве аргументов берет рисовалку
и информацию о том, как преобразовать рамку, а возвращает новую
рисовалку. Когда преобразованная рисовалка вызывается по отношению к
какой-либо рамке, она преобразует рамку и вызывает исходную рисовалку по
отношению к ней. Аргументами @code{transform-painter} служат точки
(представленные в виде векторов), указывающие углы новой рамки: будучи
отображенной на рамку, первая точка указывает исходную точку новой
рамки, а две других --- концы краевых векторов. Таким образом,
аргументы, лежащие в пределах единичного квадрата, определяют рамку,
которая содержится внутри исходной рамки.

@lisp
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame
                  new-origin
                  (sub-vect (m corner1) new-origin)
                  (sub-vect (m corner2) new-origin)))))))
@end lisp

@noindent
Вот как перевернуть изображение в рамке вертикально:

@lisp
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   @r{; new @code{origin}}
                     (make-vect 1.0 1.0)   @r{; new end of @code{edge1}}
                     (make-vect 0.0 0.0))) @r{; new end of @code{edge2}}
@end lisp

@noindent
При помощи @code{transform-painter} нам нетрудно будет определять новые
трансформации. Например, можно определить рисовалку, которая рисует
уменьшенную копию исходного изображения в верхней правой четверти рамки:

@lisp
(define (shrink-to-upper-right painter)
  (transform-painter
   painter (make-vect 0.5 0.5)
   (make-vect 1.0 0.5) (make-vect 0.5 1.0)))
@end lisp

@noindent
Вот трансформация, которая поворачивает изображение на 90 градусов
против часовой стрелки:@footnote{@code{Rotate90} представляет собой
чистый поворот только для квадратных рамок, поскольку она еще
растягивает и сплющивает изображение так, чтобы оно уместилось в
повернутой рамке.}

@lisp
(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
@end lisp

@noindent
А эта сжимает изображение по направлению к центру
рамки:@footnote{Ромбовидные изображения на рисунках @ref{Рисунок 2.10}
и @ref{Рисунок 2.11} были получены с помощью @code{squash-inwards},
примененной к @code{wave} и @code{rogers}.}:

@lisp
(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
@end lisp

@noindent
Преобразования рамок являются также основой для определения средств
комбинирования двух или более рисовалок. Например, процедура
@code{beside} берет две рисовалки, трансформирует их так, чтобы они
работали соответственно в левой и правой половинах рамки-аргумента, и
создает новую составную рисовалку. Когда составной рисовалке передается
рамка, она вызывает первую из преобразованных рисовалок над левой
половиной рамки, а вторую над правой половиной:

@lisp
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter
            painter1
            (make-vect 0.0 0.0)
            split-point
            (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter
            painter2
            split-point
            (make-vect 1.0 0.0)
            (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
@end lisp

@noindent
Обратите внимание, как абстракция данных, и особенно представление
рисовалок в виде процедур, облегчает реализацию @code{beside}. Процедуре
@code{beside} не требуется ничего знать о деталях рисовалок-компонент,
кроме того, что каждая из них что-то изобразит в указанной ей рамке.

@quotation
@strong{@anchor{Упражнение 2.50}Упражнение 2.50:}
Определите преобразование @code{flip-horiz}, которое
обращает изображение вокруг горизонтальной оси, а также преобразования,
которые вращают рисовалки против часовой стрелки на 180 и 270 градусов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.51}Упражнение 2.51:}
Определите для рисовалок операцию @code{below}.
@code{Below} принимает в качестве аргументов две рисовалки. Когда
получившейся рисовалке передается рамка, она рисует в нижней ее половине
при помощи первой рисовалки, а в верхней при помощи второй. Определите
@code{below} двумя способами --- один раз аналогично процедуре
@code{beside}, как она приведена выше, а второй раз через @code{beside}
и операции вращения (см. упражнение @ref{Упражнение 2.50}).
@end quotation

@comment @subsubheading Levels of language for robust design
@subsubheading Уровни языка помогают устойчивому проектированию

Язык построения изображений использует некоторые из важнейших введенных
нами идей, относящихся к абстракции процедур и данных. Базовая
абстракция данных, рисовалки, реализуется при помощи процедурного
представления, и благодаря этому наш язык может работать с различными
графическими системами единым образом. Средства комбинирования обладают
свойством замыкания, и это позволяет нам легко возводить сложные
построения. Наконец, все средства абстракции процедур доступны нам для
того, чтобы абстрагировать средства комбинирования рисовалок.

Нам удалось бросить взгляд и еще на одну существеннейшую идею касательно
проектирования языков и программ. Это подход (@newterm{stratified design}),
представление, что сложной системе нужно придавать структуру при помощи
последовательности уровней, которая описывается последовательностью
языков. Каждый из уровней строится путем комбинации частей, которые на
этом уровне рассматриваются как элементарные, и части, которые строятся
на каждом уровне, работают как элементарные на следующем уровне. Язык,
который используется на каждом уровне такого проекта, включает
примитивы, средства комбинирования и абстракции, соответствующие этому
уровню подробности.

Уровневое проектирование пронизывает всю технику построения сложных
систем. Например, при проектировании компьютеров резисторы и транзисторы
сочетаются (и описываются при помощи языка аналоговых схем), и из них
строятся и-, или- элементы и им подобные, служащие основой языка
цифровых схем.@footnote{Один из таких языков описывается в
разделе @ref{3.3.4}.}
Из этих элементов строятся процессоры, шины и системы памяти, которые в
свою очередь служат элементами в построении компьютеров при помощи
языков, подходящих для описания компьютерной архитектуры. Компьютеры,
сочетаясь, дают распределенные системы, которые описываются при помощи
языков описания сетевых взаимодействий, и так далее.

Как миниатюрный пример уровневого подхода, наш язык описания изображений
использует элементарные объекты (элементарные рисовалки), создаваемые
при помощи языка, в котором описываются точки и линии и создаются списки
отрезков для рисовалки @code{segments@/->@/painter} либо градации серого
цвета в рисовалке вроде @code{rogers}. Большей частью наше описание
языка картинок было сосредоточено на комбинировании этих примитивов с
помощью геометрических комбинаторов вроде @code{beside} и @code{below}.
Работали мы и на более высоком уровне, где @code{beside} и @code{below}
рассматривались как примитивы, манипулируемые языком, операции которого,
такие как @code{square-of-four}, фиксируют стандартные схемы сочетания
геометрических комбинаторов.

Уровневое проектирование помогает придать программам (@newterm{robustness}), то
есть повышает вероятность, что небольшое изменение в спецификации
потребует относительно малых изменений в программе. Например,
предположим, что нам нужно изменить картинку, основанную на рисовалке
@code{wave}, которая показана на рисунке @ref{Рисунок 2.9}. Мы можем
работать на самом низком уровне, изменяя конкретный вид элемента
@code{wave}; можем работать на промежуточном уровне и менять то, как
@code{corner-split} воспроизводит @code{wave}; можем на самом высоком
уровне изменять то, как @code{square-limit} расставляет четыре копии по
углам. В общем, каждый уровень такого проекта дает свой словарь для
описания характеристик системы и свой тип возможных изменений.

@quotation
@strong{@anchor{Упражнение 2.52}Упражнение 2.52:}
Измените предел квадрата рисовалки @code{wave}, показанный
на рисунке @ref{Рисунок 2.9}, работая на каждом из вышеописанных
уровней. А именно:

@enumerate a.

@item
Добавьте новые отрезки к элементарной рисовалке @code{wave} из
упражнения @ref{Упражнение 2.49} (например, изобразив улыбку).

@item
Измените шаблон, который порождает @code{corner-split} (например,
используя только одну копию образов @code{up-split} и @code{right-split}
вместо двух).

@item
Измените версию @code{square-limit}, использующую @code{square-of-four},
так, чтобы углы компоновались как-нибудь по-другому. (Например, можно
сделать так, чтобы большой мистер Роджерс выглядывал из каждого угла
квадрата.)

@end enumerate
@end quotation

@comment @section Symbolic Data
@section Символьные данные
@node	2.3, 2.4, 2.2, Глава 2

Все составные объекты данных, которые мы до сих пор использовали,
состояли, в конечном счете, из чисел. В этом разделе мы расширяем
возможности представления нашего языка, разрешая использовать в качестве
данных произвольные символы.

@menu
* 2-3-1::             Кавычки
* 2-3-2::             Пример символьное дифференцирование
* 2-3-3::             Пример представление множеств
* 2-3-4::             Пример деревья кодирования по Хаффману
@end menu

@comment @subsection Quotation
@subsection Кавычки
@node	2.3.1, 2.3.2, 2.3, 2.3

Раз теперь нам можно формировать составные данные, используя символы, мы
можем пользоваться списками вроде

@lisp
(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
@end lisp

@noindent
Списки, содержащие символы, могут выглядеть в точности как выражения
нашего языка:

@lisp
(* (+ 23 45)
   (+ x 9))
(define (fact n)
  (if (= n 1) 1 (* n (fact (- n 1)))))
@end lisp

@noindent
Чтобы работать с символами, нам в языке нужен новый элемент: способность
(@newterm{quote}) объект данных. Допустим, нам хочется построить список
@code{(a b)}. Этого нельзя добиться через @code{(list a b)}, поскольку
это выражение строит список из значений @newterm{values} символов @code{a} и
@code{b}, а не из них самих. Этот вопрос хорошо изучен по отношению к
естественным языкам, где слова и предложения могут рассматриваться либо
как семантические единицы, либо как строки символов (синтаксические
единицы). В естественных языках обычно используют кавычки, чтобы
обозначить, что слово или предложение нужно рассматривать буквально как
строку символов. Например, первая буква <<Джона>> --- разумеется,
<<Д>>. Если мы говорим кому-то <<скажите, как Вас зовут>>, мы ожидаем
услышать имя этого человека. Если же мы говорим кому-то <<скажите ``как
Вас зовут''>>, то мы ожидаем услышать слова <<как Вас зовут>>. Заметьте,
как, для того, чтобы описать, что должен сказать кто-то другой, нам
пришлось использовать кавычки.@footnote{Когда мы разрешаем в языке
кавычки, это разрушает нашу способность говорить о языке в простых
терминах, поскольку становится неверным, что равнозначные выражения
можно подставлять друг вместо друга. Например, три есть два плюс один,
но слово <<три>> не есть слова <<два плюс один>>. Кавычки являются
мощным инструментом, поскольку они дают нам способ строить выражения,
которые работают с другими выражениями (как мы убедимся в
главе @ref{Глава 4},
когда станем писать интерпретатор). Однако как только мы разрешаем в
языке выражения, которые говорят о других выражениях того же языка,
становится очень сложно соблюдать в каком-либо виде принцип <<равное
можно заменить равным>>. Например, если мы знаем, что утренняя и
вечерняя звезда --- одно и то же, то из утверждения <<вечерняя
звезда --- это Венера>> мы можем заключить, что <<утренняя звезда ---
это Венера>>. Однако если нам дано, что <<Джон знает, что вечерняя
звезда --- это Венера>>, мы не можем заключить, что <<Джон знает, что
утренняя звезда --- это Венера>>.}

Чтобы обозначать списки и символы, с которыми нужно обращаться как с
объектами данных, а не как с выражениями, которые нужно вычислить, мы
можем следовать тому же обычаю. Однако наш формат кавычек отличается от
принятого в естественных языках тем, что мы ставим знак кавычки (по
традиции, это символ одинарной кавычки @code{'}) только в начале того
объекта, который надо закавычить. В Scheme это сходит нам с рук,
поскольку для разделения объектов мы полагаемся на пробелы и скобки.
Таким образом, значением одинарной кавычки является требование
закавычить следующий объект.@footnote{Одинарная кавычка отличается от
двойной, которую мы использовали для обозначения строк, выводимых на
печать. В то время как одинарную кавычку можно использовать для
обозначения списков символов, двойная кавычка используется только со
строками, состоящими из печатных знаков. Единственное, для чего такие
строки используются в нашей книге --- это печать.}

Теперь мы можем отличать символы от их значений:

@lisp
(define a 1)
(define b 2)
(list a b)
@i{(1 2)}
(list 'a 'b)
@i{(a b)}
(list 'a b)
@i{(a 2)}
@end lisp

@noindent
Кроме того, кавычки позволяют нам вводить составные объекты, используя
обычное представление для печати списков:@footnote{Строго говоря, то,
как мы используем кавычку, нарушает общее правило, что все сложные
выражения нашего языка должны отмечаться скобками и выглядеть как
списки. Мы можем восстановить эту закономерность, введя особую форму @code{quote},
которая служит тем же целям, что и кавычка. Таким образом, мы можем
печатать @code{(quote a)} вместо @code{'a} и @code{(quote (a b c))}
вместо @code{'(a b c)}. Именно так и работает интерпретатор. Знак
кавычки --- это просто сокращение, означающее, что следующее выражение
нужно завернуть в форму @code{quote} и получить
@math{\hbox{\ttfamily(quote}\;\langle\kern0.06em\hbox{\ttfamily\slshape выражение}\kern0.08em\rangle\hbox{\ttfamily)}}.
Это важно потому, что таким
образом соблюдается принцип, что с любым выражением, которое видит
интерпретатор, можно обращаться как с объектом данных. Например, можно
получить выражение @code{(car '(a b c))}, и это будет то же самое, что и
@code{(car (quote (a b c)))}, вычислив
@code{(list 'car (list 'quote '(a b c)))}.}

@lisp
(car '(a b c))
@i{a}
(cdr '(a b c))
@i{(b c)}
@end lisp

@noindent
Действуя в том же духе, пустой список мы можем получить, вычисляя
@code{'()}, и таким образом избавиться от переменной @code{nil}.

Еще один примитив, который используется при работе с символами --- это
@code{eq?}, который берет в качестве аргументов два символа и проверяет,
совпадают ли они.@footnote{Можно считать, что два символа <<совпадают>>,
если они состоят из одних и тех же печатных знаков в одинаковом порядке.
Такое определение обходит важный вопрос, который мы пока не готовы
обсуждать: значение <<одинаковости>> в языке программирования. К нему мы
вернемся в главе @ref{Глава 3} (раздел @ref{3.1.3}.}
С помощью @code{eq?} можно реализовать полезную процедуру, называемую
@code{memq}. Она принимает два аргумента, символ и список. Если символ
не содержится в списке (то есть, не равен в смысле @code{eq?} ни одному
из элементов списка), то @code{memq} возвращает ложь. В противном случае
она возвращает подсписок списка, начиная с первого вхождения символа:

@lisp
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
@end lisp

@noindent
Например, значение

@lisp
(memq 'apple '(pear banana prune))
@end lisp

@noindent
есть ложь, в то время как значение

@lisp
(memq 'apple '(x (apple sauce) y apple pear))
@end lisp

@noindent
есть @code{(apple pear)}.

@quotation
@strong{@anchor{Упражнение 2.53}Упражнение 2.53:}
Что напечатает интерпретатор в ответ на каждое из следующих выражений?

@lisp
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 2.54}Упражнение 2.54:}
Предикат @code{equal?} для двух списков возвращает истину,
если они содержат одни и те же элементы в одинаковом порядке. Например,

@lisp
(equal? '(this is a list) '(this is a list))
@end lisp

@noindent
истинно, но

@lisp
(equal? '(this is a list) '(this (is a) list))
@end lisp

@noindent
ложно. Более точно, можно определить @code{equal?} рекурсивно в терминах
базового равенства символов @code{eq?}, сказав, что @code{a} равно
@code{b}, если оба они символы и для них выполняется @code{eq?} либо оба
они списки и при этом верно, что @code{(car a)} равняется в смысле
@code{equal?} @code{(car b)}, а @code{(cdr a)} равняется в смысле
@code{equal?} @code{(cdr b)}. Пользуясь этой идеей, напишите
@code{equal?} в виде процедуры.@footnote{На практике программисты
используют @code{equal?} для сравнения не только символов, но и чисел.
Числа не считаются символами. Вопрос о том, выполняется ли @code{eq?}
для двух чисел, которые равны между собой (в смысле @code{=}), очень
сильно зависит от конкретной реализации. Более правильное определение
@code{equal?} (например, то, которое входит в Scheme как элементарная
процедура) должно содержать условие, что если и @code{a}, и @code{b}
являются числами, то @code{equal?} для них выполняется тогда, когда они
численно равны.}
@end quotation

@quotation
@strong{@anchor{Упражнение 2.55}Упражнение 2.55:}
Ева Лу Атор вводит при работе с интерпретатором выражение

@lisp
(car ''abracadabra)
@end lisp

К ее удивлению, интерпретатор печатает @code{quote}. Объясните.

@end quotation

@comment @subsection Example: Symbolic Differentiation
@subsection Пример: символьное дифференцирование
@node	2.3.2, 2.3.3, 2.3.1, 2.3

Как иллюстрацию к понятию символьной обработки, а также как
дополнительный пример абстракции данных, рассмотрим построение
процедуры, которая производит символьное дифференцирование
алгебраических выражений. Нам хотелось бы, чтобы эта процедура принимала
в качестве аргументов алгебраическое выражение и переменную, и чтобы она
возвращала производную выражения по отношению к этой переменной.
Например, если аргументами к процедуре служат @math{ax^2 + bx + c}
и @math{x}, процедура должна возвращать @math{2ax + b}.
Символьное дифференцирование имеет для Лиспа особое историческое
значение. Оно было одним из побудительных примеров при разработке
компьютерного языка для обработки символов. Более того, оно послужило
началом линии исследований, приведшей к разработке мощных систем для
символической математической работы, которые сейчас все больше
используют прикладные математики и физики.

При разработке программы для символьного дифференцирования мы будем
следовать той же самой стратегии абстракции данных, согласно которой мы
действовали при разработке системы рациональных чисел в
разделе @ref{2.1.1}. А именно, сначала
мы разработаем алгоритм дифференцирования, который работает с
абстрактными объектами, такими как <<суммы>>, <<произведения>> и
<<переменные>>, не обращая внимания на то, как они должны быть
представлены. Только после этого мы обратимся к задаче представления.

@comment @subsubheading The differentiation program with abstract data
@subsubheading Программа дифференцирования с абстрактными данными

Чтобы упростить задачу, мы рассмотрим простую программу символьного
дифференцирования, которая работает с выражениями, построенными только
при помощи операций сложения и умножения с двумя аргументами.
Дифференцировать любое такое выражение можно, применяя следующие правила
редукции:
@ifinfo

@example
dc
-- = 0  for c a constant, or a variable different from x
dx

dx
-- = 1
dx

d(u + v)   du   dv
-------- = -- + --
   dx      dx   dx

d(uv)     / dv \     / du \
----- = u | -- | + v | -- |
 dx       \ dx /     \ dx /
@end example

@end ifinfo
@tex
$$
{{\it dc} \over {\it dx}} 		= 0,
    \quad {\rm for\ } c\ {\rm a\ constant\ or\ a\ variable\ different\ from\ } x,
$$
@end tex
@tex
$$
{{\it dx} \over {\it dx}} 		= 1,
$$
@end tex
@tex
$$
{{\it d\,(u + v\,)} \over {\it dx}} 	= {{\it du} \over {\it dx}} + {{\it dv} \over {\it dx}},
$$
@end tex
@tex
$$
{{\it d\,(uv\,)} \over {\it dx}} 	= u {{\it dv} \over {\it dx}} + v {{\it du} \over {\it dx}}.
$$
@end tex
@noindent
Заметим, что два последних правила по сути своей рекурсивны. То есть,
чтобы получить производную суммы, нам сначала нужно получить производные
слагаемых и их сложить. Каждое из них в свою очередь может быть
выражением, которое требуется разложить на составляющие. Разбивая их на
все более мелкие части, мы в конце концов дойдем до стадии, когда все
части являются либо константами, либо переменными, и их производные
будут равны либо 0, либо 1.

Чтобы воплотить эти правила в виде процедуры, мы позволим себе немного
помечтать, подобно тому, как мы делали при реализации рациональных
чисел. Если бы у нас был способ представления алгебраических выражений,
мы могли бы проверить, является ли выражение суммой, произведением,
константой или переменной. Можно было бы извлекать части выражений.
Например, для суммы мы хотели бы уметь получать первое и второе
слагаемое. Еще нам нужно уметь составлять выражения из частей. Давайте
предположим, что у нас уже есть процедуры, которые реализуют следующие
селекторы, конструкторы и предикаты:

@lisp
(variable? e)            @r{Является ли @code{e} переменной?}
(same-variable? v1 v2)   @r{Является ли @code{v1} and @code{v2} одной и той же переменной?}
(sum? e)                 @r{Является ли @code{e} суммой?}
(addend e)               @r{Первое слагаемое суммы @code{e}.}
(augend e)               @r{Второе слагаемое суммы @code{e}.}
(make-sum a1 a2)         @r{Строит сумму @code{a1} и @code{a2}.}
(product? e)             @r{Является ли @code{e} произведением?}
(multiplier e)           @r{Первый множитель произведения@code{e}.}
(multiplicand e)         @r{Второй множитель произведения @code{e}.}
(make-product m1 m2)     @r{Строит произведение @code{m1} и @code{m2}.}
@end lisp

@noindent
При помощи этих процедур и элементарного предиката @code{number?},
который распознает числа, мы можем выразить правила дифференцирования в
виде следующей процедуры:

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
@end lisp

@noindent
Процедура @code{deriv} заключает в себе весь алгоритм дифференцирования.
Поскольку она выражена в терминах абстрактных данных, она будет
работать, как бы мы ни представили алгебраические выражения, если только
у нас будут соответствующие селекторы и конструкторы. Именно этим
вопросом нам и нужно теперь заняться.

@comment @subsubheading Representing algebraic expressions
@subsubheading Представление алгебраических выражений

Можно представить себе множество способов представления алгебраических
выражений с помощью списковых структур. Например, можно использовать
списки символов, которые отражали бы обычную алгебраическую нотацию, так
что @math{ax + b} представлялось бы как список @code{(a * x + b)}.
Однако естественней всего использовать ту же скобочную префиксную
запись, с помощью которой в Лиспе представляются комбинации; то есть
представлять @math{ax + b} в виде @code{(+ (* a x) b)}.
Тогда наше представление данных для задачи дифференцирования будет следующим:

@itemize @bullet

@item
Переменные --- это символы. Они распознаются элементарным предикатом
@code{symbol?}:

@lisp
(define (variable? x) (symbol? x))
@end lisp

@item
Две переменные одинаковы, если для представляющих их символов
выполняется @code{eq?}:

@lisp
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
@end lisp

@item
Суммы и произведения конструируются как списки:

@lisp
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
@end lisp

@item
Сумма --- это список, первый элемент которого символ @code{+}:

@lisp
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
@end lisp

@item
Первое слагаемое --- это второй элемент списка, представляющего сумму:

@lisp
(define (addend s) (cadr s))
@end lisp

@item
Второе слагаемое --- это третий элемент списка, представляющего сумму:

@lisp
(define (augend s) (caddr s))
@end lisp

@item
Произведение --- это список, первый элемент которого символ @code{*}:

@lisp
(define (product? x) (and (pair? x) (eq? (car x) '*)))
@end lisp

@item
Первый множитель --- это второй элемент списка, представляющего
произведение:

@lisp
(define (multiplier p) (cadr p))
@end lisp

@item
Второй множитель --- это третий элемент списка, представляющего
произведение:

@lisp
(define (multiplicand p) (caddr p))
@end lisp

@end itemize

@noindent
Таким образом, нам осталось только соединить это представление с
алгоритмом, заключенным в процедуре @code{deriv}, и мы получаем
работающую программу символьного дифференцирования. Посмотрим на
некоторые примеры ее поведения:

@lisp
(deriv '(+ x 3) 'x)
@i{(+ 1 0)}
(deriv '(* x y) 'x)
@i{(+ (* x 0) (* 1 y))}
(deriv '(* (* x y) (+ x 3)) 'x)
@i{(+ (* (* x y) (+ 1 0))}
   @i{(* (+ (* x 0) (* 1 y))}
      @i{(+  x 3)))}
@end lisp

@noindent
Ответы, которые выдает программа, правильны; однако их нужно упрощать.
Верно, что
@ifinfo

@example
d(xy)
----- = x * 0 + 1 * y
 dx
@end example

@end ifinfo
@tex
$$ {{\it d\,(xy\,)} \over {\it dx}} = x \cdot 0 + 1 \cdot y, $$
@end tex
@noindent
но нам хотелось бы, чтобы программа знала, что @math{x \cdot 0 = 0},
@math{1 \cdot y = y}, а @math{0 + y = y}. Ответом на второй
пример должно быть просто @math{y}. Как видно из
третьего примера, при усложнении выражений упрощение превращается в
серьезную проблему.

Наши теперешние затруднения очень похожи на те, с которыми мы
столкнулись при реализации рациональных чисел: мы не привели ответы к
простейшей форме. Чтобы произвести приведение рациональных чисел, нам
потребовалось изменить только конструкторы и селекторы в нашей
реализации. Здесь мы можем применить подобную же стратегию. Процедуру
@code{deriv} мы не будем изменять вовсе. Вместо этого мы изменим
@code{make-sum} так, что если оба слагаемых являются числами, она их
сложит и вернет их сумму. Кроме того, если одно из слагаемых равно 0, то
@code{make-sum} вернет другое.

@lisp
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
@end lisp

@noindent
Здесь используется процедура @code{=number?}, которая проверяет, не
равно ли выражение определенному числу:

@lisp
(define (=number? exp num) (and (number? exp) (= exp num)))
@end lisp

@noindent
Подобным же образом мы изменим и @code{make-product}, так. чтобы
встроить в него правила, что нечто, умноженное на 0, есть 0, а
умноженное на 1 равно самому себе:

@lisp
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
@end lisp

@noindent
Вот как эта версия работает на наших трех примерах:

@lisp
(deriv '(+ x 3) 'x)
@i{1}
(deriv '(* x y) 'x)
@i{y}
(deriv '(* (* x y) (+ x 3)) 'x)
@i{(+ (* x y) (* y (+ x 3)))}
@end lisp

@noindent
Хотя это заметное улучшение, третий пример показывает, что нужно многое
еще сделать, прежде чем мы получим программу, приводящую выражения к
форме, которую мы согласимся считать <<простейшей>>. Задача
алгебраического упрощения сложна, среди прочего, еще и потому, что
форма, которая является простейшей для одних целей, может таковой не
являться для других.

@quotation
@strong{@anchor{Упражнение 2.56}Упражнение 2.56:}
Покажите, как расширить простейшую программу
дифференцирования так, чтобы она воспринимала больше разных типов
выражений. Например, реализуйте правило взятия производной
@ifinfo

@example
d(u^n)            du
------ = nu^(n-1) --
  dx              dx
@end example

@end ifinfo
@tex
$$ {{\it d\,(u^n\,)} \over {\it dx}} = nu^{n-1} {{\it du} \over {\it dx}} $$
@end tex
@noindent
добавив еще одну
проверку к программе @code{deriv} и определив соответствующие процедуры
@code{exponentiation?}, @code{base}, @code{exponent} и
@code{make-exponentiation} (обозначать возведение в степень можно
символом @code{*}). Встройте правила, что любое выражение, возведенное в
степень 0, дает 1, а возведенное в степень 1 равно самому себе.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.57}Упражнение 2.57:}
Расширьте программу дифференцирования так, чтобы она
работала с суммами и произведениями любого (больше двух) количества
термов. Тогда последний из приведенных выше примеров мог бы быть записан
как

@lisp
(deriv '(* x y (+ x 3)) 'x)
@end lisp

Попытайтесь сделать это, изменяя только представление сумм и
произведений, не трогая процедуру @code{deriv}. Тогда, например,
процедура @code{addend} будет возвращать первое слагаемое суммы, а
@code{augend} сумму остальных.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.58}Упражнение 2.58:}
Предположим, что нам захотелось изменить программу
дифференцирования так, чтобы она работала с обычной математической
нотацией, где @code{+} и @code{*} не префиксные, а инфиксные операции.
Поскольку программа взятия производных определена в терминах абстрактных
данных, мы можем изменять представление выражений, с которыми она
работает, меняя только предикаты, селекторы и конструкторы, определяющие
представление алгебраических выражений, с которыми должен работать
дифференциатор.

@enumerate a.

@item
Покажите, как это сделать так, чтобы брать производные от выражений,
представленных в инфиксной форме, например
@code{(x + (3 * (x + (y + 2))))}. Для упрощения задачи предположите, что
@code{+} и @code{*} всегда принимают по два аргумента, и что в выражении
расставлены все скобки.

@item
Задача становится существенно сложней, если мы разрешаем стандартную
алгебраическую нотацию, например @code{(x + 3 * (x + y + 2))}, которая
опускает ненужные скобки и предполагает, что умножение выполняется
раньше, чем сложение. Можете ли Вы разработать соответствующие
предикаты, селекторы и конструкторы для этой нотации так, чтобы наша
программа взятия производных продолжала работать?

@end enumerate
@end quotation

@comment @subsection Example: Representing Sets
@subsection Пример: представление множеств
@node	2.3.3, 2.3.4, 2.3.2, 2.3

В предыдущих примерах мы построили представления для двух типов
составных объектов: для рациональных чисел и для алгебраических
выражений. В одном из этих примеров перед нами стоял выбор, упрощать ли
выражение при его конструировании или при обращении; в остальном же
выбор представления наших структур через списки был простым делом. Когда
мы обращаемся к представлению множеств, выбор представления не так
очевиден. Здесь существует несколько возможных представлений, и они
значительно отличаются друг от друга в нескольких аспектах.

Говоря неформально, множество есть просто набор различных объектов.
Чтобы дать ему более точное определение, можно использовать метод
абстракции данных. А именно, мы определяем <<множество>>, указывая
операции, которые можно производить над множествами. Это операции
@code{union-set} (объединение), @code{intersection-set} (пересечение),
@code{element-of-set?} (проверка на принадлежность) и @code{adjoin-set}
(добавление элемента). @code{Element-of-set?} --- это предикат, который
определяет, является ли данный объект элементом множества.
@code{Adjoin-set} принимает как аргументы объект и множество, и
возвращает множество, которое содержит все элементы исходного множества
плюс добавленный элемент. вычисляет объединение двух множеств, то есть
множество, содержащее те элементы, которые присутствуют хотя бы в одном
из аргументов. @code{Intersection-set} вычисляет пересечение двух
множеств, то есть множество, которое содержит только те элементы,
которые присутствуют в обоих аргументах. С точки зрения абстракции
данных, мы имеем право взять любое представление, позволяющее нам
использовать эти операции способом, который согласуется с вышеуказанной
интерпретацией.@footnote{Если нам хочется быть более формальными, мы
можем определить <<соответствие вышеуказанной интерпретации>> как
условие, что операции удовлетворяют некоторому набору правил вроде
следующих:

@noindent
@math{\bullet} Для любого множества @code{S} и любого объекта @code{x},
@code{(element-of-set? x (adjoin-set x S))} истинно (неформально:
<<добавление объекта к множеству дает множество, содержащее этот
объект>>).

@noindent
@math{\bullet} Для любых двух множеств @code{S} и @code{T} и любого объекта @code{x},
@code{(element-of-set? x (union-set S T))} равно
@code{(or (element-of-set? x S) (element-of-set? x T))} (неформально:
<<элементы @code{(union-set S T)} --- это те элементы, которые
принадлежат либо @code{S}, либо @code{T}>>).

@noindent
@math{\bullet} Для любого объекта @code{x}, @code{(element-of-set? x '())} ложно
(неформально: <<ни один объект не принадлежит пустому множеству>>).}

@comment @subsubheading Sets as unordered lists
@subsubheading Множества как неупорядоченные списки

Можно представить множество как список, в котором ни один элемент не
содержится более одного раза. Пустое множество представляется пустым
списком. При таком представлении @code{element-of-set?} подобен
процедуре @code{memq} из раздела @ref{2.3.1}. Она использует
не @code{eq?}, а @code{equal?}, так что элементы множества не обязаны
быть символами:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
@end lisp

@noindent
Используя эту процедуру, мы можем написать @code{adjoin-set}. Если
объект, который требуется добавить, уже принадлежит множеству, мы просто
возвращаем исходное множество. В противном случае мы используем
@code{cons}, чтобы добавить объект к списку. представляющему множество:

@lisp
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
@end lisp

@noindent
Для @code{intersection-set} можно использовать рекурсивную стратегию.
Если мы знаем, как получить пересечение @code{set2} и @code{cdr} от
@code{set1}, нам нужно только понять, надо ли добавить к нему @code{car}
от @code{set1}. Это зависит от того, принадлежит ли @code{(car set1)}
еще и @code{set2}. Получается такая процедура:

\enlargethispage{\baselineskip}

@lisp
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
@end lisp

@noindent
Один из вопросов, которые должны нас заботить при разработке
реализации --- эффективность. Рассмотрим число шагов, которые требуют
наши операции над множествами. Поскольку все они используют
@code{element-of-set?}, скорость этой операции оказывает большое влияние
на скорость реализации в целом. Теперь заметим, что для того, чтобы
проверить, является ли объект элементом множества, процедуре
@code{element-of-set?} может потребоваться просмотреть весь список. (В
худшем случае оказывается, что объекта в списке нет.) Следовательно,
если в множестве @math{n} элементов, @code{element-of-set?} может
затратить до @math{n} шагов. Таким образом, число требуемых шагов растет
как @math{\Theta (n)}. Число шагов, требуемых @code{adjoin-set}, которая
эту операцию использует, также растет как @math{\Theta (n)}. Для
@code{intersection-set}, которая проделывает @code{element-of-set?} для
каждого элемента @code{set1}, число требуемых шагов растет как
произведение размеров исходных множеств, или @math{\Theta (n^2)} для
двух множеств размера @math{n}. То же будет верно и для
@code{union-set}.

@quotation
@strong{@anchor{Упражнение 2.59}Упражнение 2.59:}
Реализуйте операцию @code{union-set} для представления
множеств в виде неупорядоченных списков.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.60}Упражнение 2.60:}
Мы указали, что множество представляется как список без
повторяющихся элементов. Допустим теперь, что мы разрешаем повторяющиеся
элементы. Например, множество @math{\{1, 2, 3\}} могло бы быть
представлено как список @code{(2 3 2 1 3 2 2)}. Разработайте процедуры
@code{element-of-set?}, @code{adjoin-set}, @code{union-@/set} и
@code{intersection-set}, которые бы работали с таким представлением. Как
соотносится эффективность этих операций с эффективностью соответствующих
процедур для представления без повторений? Существуют ли приложения, в
которых Вы бы использовали скорее это представление, чем представление
без повторений?
@end quotation

@comment @subsubheading Sets as ordered lists
@subsubheading Множества как упорядоченные списки

Один из способов ускорить операции над множествами состоит в том, чтобы
изменить представление таким образом, чтобы элементы множества
перечислялись в порядке возрастания. Для этого нам потребуется способ
сравнения объектов, так, чтобы можно было сказать, какой из них больше.
Например, символы мы могли бы сравнивать лексикографически, или же мы
могли бы найти какой-нибудь способ ставить каждому объекту в
соответствие некоторое уникальное число и затем сравнивать объекты путем
сравнения соответствующих чисел. Чтобы упростить обсуждение, мы
рассмотрим только случай, когда элементами множества являются числа, так
что мы сможем сравнивать элементы при помощи @code{>} и @code{<}. Мы
будем представлять множество чисел как список его элементов в
возрастающем порядке. В то время как первая наша реализация позволяла
нам представлять множество @math{\{1, 3, 6, 10\}} путем перечисления его
элементов в произвольном порядке, в новом представлении разрешен только
список @code{(1 3 6 10)}.

Одно из преимуществ упорядочения проявляется в @code{element-of-set?}:
проверяя наличие элемента, нам больше незачем просматривать все
множество. Если мы достигли элемента, который больше того объекта,
который мы ищем, мы можем уже сказать, что искомого в списке нет:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))
@end lisp

@noindent
Сколько шагов мы на этом выигрываем? В худшем случае, объект, который мы
ищем, может быть наибольшим в множестве, так что число шагов то же, что
и для неупорядоченного представления. С другой стороны, если мы ищем
элементы разных размеров, можно ожидать, что иногда мы сможем
останавливаться близко к началу списка, а иногда нам все же потребуется
просмотреть большую его часть. В среднем мы можем ожидать, что
потребуется просмотреть около половины элементов множества. Таким
образом, среднее число требуемых шагов будет примерно @math{n / 2}. Это
все еще рост порядка @math{\Theta (n)}, но это экономит
нам в среднем половину числа шагов по сравнению с предыдущей реализацией.

Более впечатляющее ускорение мы получаем в @code{intersection-set}. При
неупорядоченном представлении эта операция требовала @math{\Theta (n^2)}
шагов, поскольку мы производили полный поиск в @code{set2} для каждого
элемента @code{set1}. Однако при упорядоченном представлении мы можем
воспользоваться более разумным методом. Начнем со сравнения первых
элементов двух множеств, @code{x1} и @code{x2}. Если @code{x1} равно
@code{x2}, мы получаем один элемент пересечения, а остальные элементы
пересечения мы можем получить, пересекая оставшиеся элементы
списков-множеств. Допустим, однако, что @code{x1} меньше, чем @code{x2}.
Поскольку @code{x2} --- наименьший элемент @code{set2}, мы можем
немедленно заключить, что @code{x1} больше нигде в @code{set2} не может
встретиться и, следовательно, не принадлежит пересечению. Следовательно
пересечение двух множеств равно пересечению @code{set2} с @code{cdr} от
@code{set1}. Подобным образом, если @code{x2} меньше, чем @code{x1}, то
пересечение множеств получается путем пересечения @code{set1} с
@code{cdr} от @code{set2}. Вот процедура:

@lisp
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1)
                                          (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
@end lisp

@noindent
Чтобы оценить число шагов, необходимое для этого процесса, заметим, что
на каждом шагу мы сводим задачу нахождения пересечения к вычислению
пересечения меньших множеств --- убирая первый элемент либо из
@code{set1}, либо из @code{set2}, либо из обоих. Таким образом, число
требуемых шагов не больше суммы размеров @code{set1} и @code{set2}, а не
их произведения, как при неупорядоченном представлении. Это рост
@math{\Theta (n)}, а не @math{\Theta (n^2)} --- заметное ускорение,
даже для множеств небольшого размера.

@quotation
@strong{@anchor{Упражнение 2.61}Упражнение 2.61:}
Напишите реализацию @code{adjoin-set} для упорядоченного
представления. По аналогии с @code{element-of-set?} покажите, как
использовать упорядочение, чтобы получить процедуру, которая в среднем
требует только половину числа шагов, которое требуется при
неупорядоченном представлении.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.62}Упражнение 2.62:}
Дайте представление порядка @math{\Theta (n)} для операции
@code{union-set} с представлением в виде упорядоченных списков.
@end quotation

@comment @subsubheading Sets as binary trees
@subsubheading Множества как бинарные деревья

Можно добиться еще лучших результатов, чем при представлении в виде
упорядоченных списков, если расположить элементы множества в виде
дерева. Каждая вершина дерева содержит один элемент множества,
называемый <<входом>> этой вершины, и указатели (возможно, пустые) на
две другие вершины. <<Левый>> указатель указывает на элементы, меньшие,
чем тот, который содержится в вершине, а <<правый>> на элементы,
большие, чем тот, который содержится в вершине. На
рисунке @ref{Рисунок 2.16} показано несколько вариантов представления
множества @math{\{1, 3, 5, 7, 9, 11\}} в виде дерева. Одно и то же
множество может быть представлено в виде дерева несколькими различными
способами. Единственное, чего мы требуем от правильного
представления --- это чтобы все элементы левого поддерева были меньше,
чем вход вершины, а элементы правого поддерева больше.

@float
@quotation
@anchor{Рисунок 2.16}
@ifinfo
@strong{Рисунок 2.16:} Various binary trees that represent the set @math{\{1, 3, 5, 7, 9, 11\}}.

@example
   7          3             5
   /\         /\            /\
  3  9       1  7          3  9
 /\   \         /\        /   /\
1  5  11       5  9      1   7  11
                   \
                   11
@end example
@end ifinfo
@iftex
@sp -0.5
@center @image{fig/chap2/Fig2.16b,70mm,,,.pdf}
@sp 0.2
@quotation
@caption{@strong{Рисунок 2.16:} Various binary trees that represent the set @math{\{1, 3, 5, 7, 9, 11\}}.}
@end quotation
@sp 0.5
@end iftex
@end quotation
@end float

Преимущество древовидного представления следующее. Предположим, мы хотим
проверить, содержится ли в множестве число @math{x}. Начнем с того, что
сравним @math{x} со входом начальной вершины. Если @math{x} меньше его,
то мы уже знаем, что достаточно просмотреть только левое поддерево; если
@math{x} больше, достаточно просмотреть правое поддерево. Если дерево
<<сбалансировано>>, то каждое из поддеревьев будет по размеру примерно
вполовину меньше. Таким образом, за один шаг мы свели задачу поиска в
дереве размера @math{n} к задаче поиска в дереве размера @math{n / 2}.
Поскольку размер дерева уменьшается вдвое на каждом шаге, следует
ожидать, что число шагов, требуемых для поиска в дереве размера
@math{n}, растет как @math{\Theta (\log n)}.@footnote{Уменьшение размера
задачи вдвое на каждом шагу является определяющей характеристикой
логарифмического роста, как мы видели на примере алгоритма быстрого
возведения в степень в разделе @ref{1.2.4} и метода половинного деления в
разделе @ref{1.3.3}.}  Для больших множеств это будет заметным ускорением
по сравнению с предыдущими реализациями.

Деревья мы можем представлять при помощи списков. Каждая вершина будет
списком из трех элементов: вход вершины, левое поддерево и правое
поддерево. Пустой список на месте левого или правого поддерева будет
означать, что в этом месте никакое поддерево не присоединяется. Мы можем
описать это представление при помощи следующих процедур:@footnote{Мы
представляем множества при помощи деревьев, а деревья при помощи
списков --- получается абстракция данных на основе другой абстракции
данных. Процедуры @code{entry}, @code{left-branch}, @code{right-branch}
и @code{make-tree} мы можем рассматривать как способ изолировать
абстракцию <<бинарное дерево>> от конкретного способа, которым мы желаем
представить такое дерево в виде списковой структуры.}

@lisp
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
@end lisp

@noindent
Теперь можно написать процедуру @code{element-of-set?} с использованием
вышеописанной стратегии:

@lisp
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
@end lisp

@noindent
Добавление элемента к множеству реализуется похожим образом и также
требует @math{\Theta (\log n)} шагов. Чтобы добавить объект @code{x}, мы
сравниваем его с входом вершины и определяем, должны ли мы добавить
@code{x} к левой или правой ветви, а добавив @math{x} к соответствующей
ветви, мы соединяем результат с изначальным входом и второй ветвью. Если
@math{x} равен входу, мы просто возвращаем вершину. Если нам требуется
добавить @math{x} к пустому дереву, мы порождаем дерево, которое
содержит @math{x} на входе и пустые левое и правое поддеревья. Вот
процедура:

@lisp
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))
@end lisp

@noindent
Утверждение, что поиск в дереве можно осуществить за логарифмическое
число шагов, основывается на предположении, что дерево
<<сбалансировано>>, то есть что левое и правое его поддеревья содержат
приблизительно одинаковое число элементов, так что каждое поддерево
содержит приблизительно половину элементов своего родителя. Но как нам
добиться того, чтобы те деревья, которые мы строим, были сбалансированы?
Даже если мы начинаем со сбалансированного дерева, добавление элементов
при помощи @code{adjoin-set} может дать несбалансированный результат.
Поскольку позиция нового добавляемого элемента зависит от того, как этот
элемент соотносится с объектами, уже содержащимися в множестве, мы имеем
право ожидать, что если мы будем добавлять элементы <<случайным
образом>>, в среднем дерево будет получаться сбалансированным. Однако
такой гарантии у нас нет. Например, если мы начнем с пустого множества и
будем добавлять по очереди числа от 1 до 7, то получится весьма
несбалансированное дерево, показанное на рисунке @ref{Рисунок 2.17}.
В этом дереве все левые поддеревья пусты, так что нет никакого
преимущества по сравнению с простым упорядоченным списком. Одним из
способов решения этой проблемы было бы определение операции, которая
переводит произвольное дерево в сбалансированное с теми же элементами.
Тогда мы сможем проводить преобразование через каждые несколько операций
@code{adjoin-set}, чтобы поддерживать множество в сбалансированном виде.
Есть и другие способы решения этой задачи. Большая часть из них связана
с разработкой новых структур данных, для которых и поиск, и вставка
могут производиться за @math{\Theta (\log n)} шагов.@footnote{Примерами
таких структур могут служить (@newterm{B-trees}) и (@newterm{red-black trees}).
Существует обширная литература по структурам данных, посвященная этой задаче.
См. @ref{Cormen et al. 1990}.}

@float
@quotation
@anchor{Рисунок 2.17}
@ifinfo
@strong{Рисунок 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.

@example
1
 \
  2
   \
    4
     \
      5
       \
        6
         \
          7
@end example
@end ifinfo
@iftex
@sp -1.0
@center @image{fig/chap2/Fig2.17a,40mm,,,.pdf}
@sp 0.2
@caption{@strong{Рисунок 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.}
@sp 0.0
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 2.63}Упражнение 2.63:}
Каждая из следующих двух процедур преобразует дерево в список.

@lisp
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
@end lisp

@enumerate a.

@item
Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет,
то как их результаты различаются? Какой результат дают эти две процедуры
для деревьев с рисунка @ref{Рисунок 2.16}?

@item
Одинаков ли порядок роста этих процедур по отношению к числу шагов,
требуемых для преобразования сбалансированного дерева с @math{n}
элементами в список? Если нет, которая из них растет медленнее?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.64}Упражнение 2.64:}
Следующая процедура @code{list->tree} преобразует
упорядоченный список в сбалансированное бинарное дерево. Вспомогательная
процедура @code{partial-tree} принимает в качестве аргументов целое
число @math{n} и список по крайней мере из @math{n} элементов, и строит
сбалансированное дерево из первых @math{n} элементов дерева. Результат,
который возвращает @code{partial-tree}, --- это пара (построенная через
@code{cons}), @code{car} которой есть построенное дерево, а
@code{cdr} --- список элементов, не включенных в дерево.

@lisp
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result
                   (partial-tree
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
@end lisp

@enumerate a.

@item
Дайте краткое описание, как можно более ясно объясняющее работу
@code{partial-tree}. Нарисуйте дерево, которое @code{partial-tree}
строит из списка @code{(1 3 5 7 9 11)}

@item
Каков порядок роста по отношению к числу шагов, которые требуются
процедуре @code{list->tree} для преобразования дерева из @math{n}
элементов?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.65}Упражнение 2.65:}
Используя результаты упражнений @ref{Упражнение 2.63} и
@ref{Упражнение 2.64}, постройте реализации @code{union-set} и
@code{intersection-set} порядка @math{\Theta (n)} для множеств,
реализованных как (сбалансированные) бинарные
деревья.@footnote{Упражнениями @ref{Упражнение 2.63}--@ref{Упражнение 2.65}
мы обязаны Полу Хилфингеру.}
@end quotation

@comment @subsubheading Sets and information retrieval
@subsubheading Множества и поиск информации

Мы рассмотрели способы представления множеств при помощи списков и
увидели, как выбор представления для объектов данных может сильно влиять
на производительность программ, использующих эти данные. Еще одной
причиной нашего внимания к множествам было то, что описанные здесь
методы снова и снова возникают в приложениях, связанных с поиском
данных.

Рассмотрим базу данных, содержащую большое количество записей, например,
сведения о кадрах какой-нибудь компании или о транзакциях в торговой
системе. Как правило, системы управления данными много времени проводят,
занимаясь поиском и модификацией данных в записях; следовательно, им
нужны эффективные методы доступа к записям. Для этого часть каждой
записи выделяется как идентифицирующий (@newterm{key}). Ключом может служить что
угодно, что однозначно определяет запись. В случае записей о кадрах это
может быть номер карточки сотрудника. Для торговой системы это может
быть номер транзакции. Каков бы ни был ключ, когда мы определяем запись
в виде структуры данных, нам нужно указать процедуру выборки ключа,
которая возвращает ключ, связанный с данной записью.

Пусть мы представляем базу данных как множество записей. Чтобы получить
запись с данным ключом, мы используем процедуру @code{lookup}, которая
принимает как аргументы ключ и базу данных и возвращает запись,
содержащую указанный ключ, либо ложь, если такой записи нет.
@code{Lookup} реализуется почти так же, как @code{element-of-set?}.
Например, если множество записей реализуется как неупорядоченный список,
мы могли бы написать

@lisp
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
@end lisp

@noindent
Конечно, существуют лучшие способы представить большие множества, чем в
виде неупорядоченных списков. Системы доступа к информации, в которых
необходим <<произвольный доступ>> к записям, как правило, реализуются с
помощью методов, основанных на деревьях, вроде вышеописанной системы с
бинарными деревьями. При разработке таких систем методология абстракции
данных оказывается весьма полезной. Проектировщик может создать исходную
реализацию с помощью простого, прямолинейного представления вроде
неупорядоченных списков. Для окончательной версии это не подходит, но
такой вариант можно использовать как <<поспешную и небрежную>>
реализацию базы данных, на которой тестируется остальная часть системы.
Позже представление данных можно изменить и сделать более изощренным.
Если доступ к базе данных происходит в терминах абстрактных селекторов и
конструкторов, такое изменение представления данных не потребует никаких
модификаций в остальной системе.

@quotation
@strong{@anchor{Упражнение 2.66}Упражнение 2.66:}
Реализуйте процедуру @code{lookup} для случая, когда
множество записей организовано в виде бинарного дерева, отсортированного
по числовым значениям ключей.
@end quotation

@comment @subsection Example: Huffman Encoding Trees
@subsection Пример: деревья кодирования по Хаффману
@node	2.3.4,  , 2.3.3, 2.3

Этот раздел дает возможность попрактиковаться в использовании списковых
структур и абстракции данных для работы с множествами и деревьями. Они
применяются к методам представления данных как последовательностей из
единиц и нулей (битов). Например, стандартный код ASCII, который
используется для представления текста в компьютерах, кодирует каждый
символ как последовательность из семи бит. Семь бит позволяют нам
обозначить @math{2^7}, то есть 128 различных символов. В общем случае,
если нам требуется различать @math{n} символов, нам потребуется
@math{\log_2 n} бит для каждого символа. Если все наши сообщения
составлены из восьми символов A, B, C, D, E, F, G, и H, мы можем
использовать код с тремя битами для каждого символа, например

@example
A 000    C 010    E 100    G 110
B 001    D 011    F 101    H 111
@end example

@noindent
С таким кодом, сообщение

@example
BACADAEAFABBAAAGAH
@end example

@noindent
кодируется как строка из 54 бит

@example
001000010000011000100000101000001001000000000110000111
@end example

@noindent
Такие коды, как ASCII и наш код от A до H, известны под названием кодов
@emph{с фиксированной длиной} @newterm{fixed-length}, поскольку каждый символ сообщения они
представляют с помощью одного и того же числа битов. Иногда полезно
использовать и коды (@newterm{variable-length}), в которых различные символы могут
представляться различным числом битов. Например, азбука Морзе не для
всех букв алфавита использует одинаковое число точек и тире. В
частности, E, наиболее частая (в английском) буква, представляется с
помощью одной точки. В общем случае, если наши сообщения таковы, что
некоторые символы встречаются очень часто, а некоторые очень редко, то
мы можем кодировать свои данные более эффективно (т. е. с помощью
меньшего числа битов на сообщение), если более частым символам мы
назначим более короткие коды. Рассмотрим следующий код для букв с A по
H:

@example
A 0      C 1010    E 1100    G 1110
B 100    D 1011    F 1101    H 1111
@end example

@noindent
С таким кодом то же самое сообщение преобразуется в строку

@example
100010100101101100011010100100000111001111
@end example

@noindent
В этой строке 42 бита, так что она экономит более 20% места по сравнению
с приведенным выше кодом с фиксированной длиной.

Одна из сложностей при работе с кодом с переменной длиной состоит в том,
чтобы узнать, когда при чтении последовательности единиц и нулей
достигнут конец символа. В азбуке Морзе эта проблема решается при помощи
специального (@newterm{separator code}) (в данном случае паузы) после
последовательности точек и тире для каждой буквы. Другое решение состоит
в том, чтобы построить систему кодирования так, чтобы никакой полный код
символа не совпадал с началом (или ) кода никакого другого символа.
Такой код называется (@newterm{prefix}). В вышеприведенном примере A кодируется 0,
а B 100, так что никакой другой символ не может иметь код, который
начинается на 0 или 100.

В общем случае можно добиться существенной экономии, если использовать
коды с переменной длиной, использующие относительные частоты символов в
подлежащих кодированию сообщениях. Одна из схем такого кодирования
называется кодированием по Хаффману, в честь своего изобретателя, Дэвида
Хаффмана. Код Хаффмана может быть представлен как бинарное дерево, на
листьях которого лежат кодируемые символы. В каждом нетерминальном узле
находится множество символов с тех листьев, которые лежат под данным
узлом. Кроме того, каждому символу на листе дерева присваивается вес
(представляющий собой относительную частоту), а каждый нетерминальный
узел имеет вес, который равняется сумме весов листьев, лежащих под
данным узлом. Веса не используются в процессе кодирования и
декодирования. Ниже мы увидим, как они оказываются полезными при
построении дерева.

Рисунок @ref{Рисунок 2.18} изображает дерево Хаффмана для кода от A
до H, показанного выше. Веса в вершинах дерева указывают, что дерево
строилось для сообщений, где A встречается с относительной частотой 8, B
с относительной частотой 3, а все остальные буквы с относительной
частотой 1.

@float
@quotation
@anchor{Рисунок 2.18}
@ifinfo
@strong{Рисунок 2.18:} A Huffman encoding tree.

@example
           @{A B C D E F G H@} 17
                    *
                   / \
                  /   \
                A 8    * @{B C D E F G H@} 9
            __________/ \_____________
           /                          \
@{B C D@} 5 *                            * @{E F G H@} 4
         / \                       ___/ \___
        /   \                     /         \
      B 3    * @{C D@} 2   @{E F@} 2 *           * @{G H@} 2
            / \                 / \         / \
           /   \               /   \       /   \
         C 1   D 1           E 1   F 1   G 1   H 1
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap2/Fig2.18a,81mm,,,.pdf}
@sp 1.0
@center @caption{@strong{Рисунок 2.18:} A Huffman encoding tree.}
@sp 1.0
@end iftex
@end quotation
@end float

Имея дерево Хаффмана, можно найти код любого символа, если начать с
корня и двигаться вниз до тех пор, пока не будет достигнута концевая
вершина, содержащая этот символ. Каждый раз, как мы спускаемся по левой
ветви, мы добавляем 0 к коду, а спускаясь по правой ветви, добавляем 1.
(Мы решаем, по какой ветке двигаться, проверяя, не является ли одна из
веток концевой вершиной, а также содержит ли множество при вершине
символ, который мы ищем.) Например, начиная с корня на картине
@ref{Рисунок 2.18}, мы попадаем в концевую вершину D, сворачивая на
правую дорогу, затем на левую, затем на правую, затем, наконец, снова на
правую ветвь; следовательно, код для D --- 1011.

Чтобы раскодировать последовательность битов при помощи дерева Хаффмана,
мы начинаем с корня и просматриваем один за другим биты в
последовательности, чтобы решить, нужно ли нам спускаться по левой или
по правой ветви. Каждый раз, как мы добираемся до листовой вершины, мы
порождаем новый символ сообщения и возвращаемся к вершине дерева, чтобы
найти следующий символ. Например, пусть нам дано дерево, изображенное на
рисунке, и последовательность 10001010. Начиная от корня, мы идем по
правой ветви (поскольку первый бит в строке 1), затем по левой
(поскольку второй бит 0), затем опять по левой (поскольку и третий бит
0). Здесь мы попадаем в лист, соответствующий B, так что первый символ
декодируемого сообщения --- B. Мы снова начинаем от корня и идем налево,
поскольку следующий бит строки 0. Тут мы попадаем в лист, изображающий
символ A. Мы опять начинаем от корня с остатком строки 1010, двигаемся
направо, налево, направо, налево и приходим в C. Таким образом, все
сообщение было BAC.

@comment @subsubheading Generating Huffman trees
@subsubheading Порождение деревьев Хаффмана

Если нам дан <<алфавит>> символов и их относительные частоты, как мы
можем породить <<наилучший>> код? (Другими словами, какое дерево будет
кодировать сообщения при помощи наименьшего количества битов?) Хаффман
дал алгоритм для решения этой задачи и показал, что получаемый этим
алгоритмом код --- действительно наилучший код с переменной длиной для
сообщений, где относительная частота символов соответствует частотам,
для которых код строился. Здесь мы не будем доказывать оптимальность
кодов Хаффмана, но покажем, как эти коды строятся.@footnote{Обсуждение
математических свойств кодов Хаффмана можно найти в Hamming 1980.}

Алгоритм порождения дерева Хаффмана весьма прост. Идея состоит в том,
чтобы упорядочить дерево так, чтобы символы с наименьшей частотой
оказались дальше всего от корня. Начнем с множества терминальных вершин,
содержащих символы и их частоты, как указано в исходных данных, из
которых нам надо построить дерево. Теперь найдем два листа с наименьшими
весами и сольем их, получая вершину, у которой предыдущие две являются
левым и правым потомками. Вес новой вершины равен сумме весов ее ветвей.
Исключим два листа из исходного множества и заменим их новой вершиной.
Продолжим этот процесс. На каждом шаге будем сливать две вершины с
самыми низкими весами, исключая их из множества и заменяя вершиной, для
которой они являются левой и правой ветвями. Этот процесс заканчивается,
когда остается только одна вершина, которая и является корнем всего
дерева. Вот как было порождено дерево Хаффмана на
рисунке @ref{Рисунок 2.18}:

@example
Исходный набор листьев  @{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (E 1) (F 1) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F@} 2) (G 1) (H 1)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F@} 2) (@{G H@} 2)@}
               Слияние  @{(A 8) (B 3) (@{C D@} 2) (@{E F G H@} 4)@}
               Слияние  @{(A 8) (@{B C D@} 5) (@{E F G H@} 4)@}
               Слияние  @{(A 8) (@{B C D E F G H@} 9)@}
 Окончательное слияние  @{(@{A B C D E F G H@} 17)@}
@end example

@noindent
Алгоритм не всегда приводит к построению единственно возможного дерева,
поскольку на каждом шаге выбор вершин с наименьшим весом может быть не
единственным. Выбор порядка, в котором будут сливаться две вершины (то
есть, какая из них будет левым, а какая правым поддеревом) также
произволен.

@comment @subsubheading Representing Huffman trees
@subsubheading Представление деревьев Хаффмана

В следующих упражнениях мы будем работать с системой, которая использует
деревья Хаффмана для кодирования и декодирования сообщений и порождает
деревья Хаффмана в соответствии с вышеописанным алгоритмом. Начнем мы с
обсуждения того, как представляются деревья.

Листья дерева представляются в виде списка, состоящего из символа
@code{leaf} (лист), символа, содержащегося в листе, и веса:

@lisp
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
@end lisp

@noindent
Дерево в общем случае будет списком из левой ветви, правой ветви,
множества символов и веса. Множество символов будет просто их списком, а
не каким-то более сложным представлением. Когда мы порождаем дерево
слиянием двух вершин, мы получаем вес дерева как сумму весов этих
вершин, а множество символов как объединение множеств их символов.
Поскольку наши множества представлены в виде списка, мы можем породить
объединение при помощи процедуры @code{append}, определенной нами в
разделе @ref{2.2.1}:

@lisp
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
@end lisp

@noindent
Если мы порождаем дерево таким образом, то у нас будут следующие
селекторы:

@lisp
(define (left-branch  tree) (car  tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
@end lisp

@noindent
Процедуры @code{symbols} и @code{weight} должны вести себя несколько
по-разному в зависимости от того, вызваны они для листа или для дерева
общего вида. Это простые примеры (@newterm{generic procedures}) (процедур,
которые способны работать более, чем с одним типом данных), о которых мы будем
говорить намного более подробно в разделах @ref{2.4} и @ref{2.5}.

\enlargethispage{\baselineskip}

@comment @subsubheading The decoding procedure
@subsubheading Процедура декодирования

Следующая процедура реализует алгоритм декодирования. В качестве
аргументов она принимает список из единиц и нулей, а также дерево Хаффмана.

@lisp
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
@end lisp

@noindent
Процедура @code{decode-1} принимает два аргумента: список остающихся
битов и текущую позицию в дереве. Она двигается <<вниз>> по дереву,
выбирая левую или правую ветвь в зависимости от того, ноль или единица
следующий бит в списке (этот выбор делается в процедуре
@code{choose-branch}). Когда она достигает листа, она возвращает символ
из него как очередной символ сообщения, присоединяя его посредством
@code{cons} к результату декодирования остатка сообщения, начиная от
корня дерева. Обратите внимание на проверку ошибок в конце
@code{choose-branch}, которая заставляет программу протестовать, если во
входных данных обнаруживается что-либо помимо единиц и нулей.

@comment @subsubheading Sets of weighted elements
@subsubheading Множества взвешенных элементов

В нашем представлении деревьев каждая нетерминальная вершина содержит
множество символов, которое мы представили как простой список. Однако
алгоритм порождения дерева, который мы обсуждали выше, требует, чтобы мы
работали еще и с множествами листьев и деревьев, последовательно сливая
два наименьших элемента. Поскольку нам нужно будет раз за разом находить
наименьший элемент множества, удобно для такого множества использовать
упорядоченное представление.

Мы представим множество листьев и деревьев как список элементов,
упорядоченный по весу в возрастающем порядке. Следующая процедура
@code{adjoinset} для построения множеств подобна той, которая описана в
упражнении @ref{Упражнение 2.61}; однако элементы сравниваются по
своим весам, и никогда не бывает так, что добавляемый элемент уже
содержится в множестве.

@lisp
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
@end lisp

@noindent
Следующая процедура принимает список пар вида символ--частота, например
@code{((A 4) (B 2) (C 1) (D 1))}, и порождает исходное упорядоченное
множество листьев, готовое к слиянию по алгоритму Хаффмана:

@lisp
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    @r{; symbol}
                               (cadr pair))  @r{; frequency}
                    (make-leaf-set (cdr pairs))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.67}Упражнение 2.67:}
Пусть нам даны дерево кодирования и пример сообщения:

@lisp
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
@end lisp

Раскодируйте сообщение при помощи процедуры @code{decode}.

@end quotation

@quotation
@strong{@anchor{Упражнение 2.68}Упражнение 2.68:}
Процедура @code{encode} получает в качестве аргументов
сообщение и дерево, и порождает список битов, который представляет
закодированное сообщение.

@lisp
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
@end lisp

@code{encode-symbol} --- процедура, которую Вы должны написать,
возвращает список битов, который кодирует данный символ в соответствии с
заданным деревом. Вы должны спроектировать @code{encode-symbol} так,
чтобы она сообщала об ошибке, если символ вообще не содержится в дереве.
Проверьте свою процедуру, закодировав тот результат, который Вы получили
в упражнении @ref{Упражнение 2.67}, с деревом-примером и проверив,
совпадает ли то, что получаете Вы, с исходным сообщением.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.69}Упражнение 2.69:}
Следующая процедура берет в качестве аргумента список пар
вида символ-частота (где ни один символ не встречается более, чем в
одной паре) и порождает дерево кодирования по Хаффману в соответствии с
алгоритмом Хаффмана.

@lisp
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
@end lisp

Приведенная выше процедура @code{make-leaf-set} преобразует список пар в
упорядоченное множество пар. Вам нужно написать процедуру
@code{successive-merge}, которая при помощи @code{make-code-tree}
сливает наиболее легкие элементы множества, пока не останется только
один элемент, который и представляет собой требуемое дерево Хаффмана.
(Эта процедура устроена немного хитро, но она не такая уж сложная. Если
Вы видите, что строите сложную процедуру, значит, почти наверняка Вы
делаете что-то не то. Можно извлечь немалое преимущество из того, что мы
используем упорядоченное представление для множеств.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.70}Упражнение 2.70:}
Нижеприведенный алфавит из восьми символов с
соответствующими им относительными частотами был разработан, чтобы
эффективно кодировать слова рок-песен 1950-х годов. (Обратите внимание,
что <<символы>> <<алфавита>> не обязаны быть отдельными буквами.)

@example
A    2   GET 2   SHA 3   WAH 1
BOOM 1   JOB 2   NA 16   YIP 9
@end example

При помощи @code{generate-huffman-tree} (упр. @ref{Упражнение 2.69})
породите соответствующее дерево Хаффмана, и с помощью @code{encode}
(упр. @ref{Упражнение 2.68}) закодируйте следующее сообщение:

@example
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
@end example

Сколько битов потребовалось для кодирования? Каково наименьшее число
битов, которое потребовалось бы для кодирования этой песни, если
использовать код с фиксированной длиной для алфавита из восьми символов?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.71}Упражнение 2.71:}
Допустим, у нас есть дерево Хаффмана для алфавита из
@math{n} символов, и относительные частоты символов равны
@math{1, 2, 4, \ldots, 2^{n-1}}. Изобразите дерево для @math{n
= 5}; для @math{n = 10}. Сколько битов в таком дереве (для произвольного
@math{n}) требуется, чтобы закодировать самый частый символ? Самый
редкий символ?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.72}Упражнение 2.72:}
Рассмотрим процедуру кодирования, которую Вы разработали в
упражнении @ref{Упражнение 2.68}. Каков порядок роста в терминах
количества шагов, необходимых для кодирования символа? Не забудьте
включить число шагов, требуемых для поиска символа в каждой следующей
вершине. Ответить на этот вопрос в общем случае сложно. Рассмотрите
особый случай, когда относительные частоты символов таковы, как описано
в упражнении @ref{Упражнение 2.71}, и найдите порядок роста (как
функцию от @math{n}) числа шагов, необходимых, чтобы закодировать самый
частый и самый редкий символ алфавита.
@end quotation

@comment @section Multiple Representations for Abstract Data
@section Множественные представления для абстрактных данных
@node	2.4, 2.5, 2.3, Глава 2

В предыдущих разделах мы описали абстракцию данных, методологию,
позволяющую структурировать системы таким образом, что бо́льшую часть
программы можно специфицировать независимо от решений, которые
принимаются при реализации объектов, обрабатываемых программой.
Например, в разделе @ref{2.1.1} мы
узнали, как отделить задачу проектирования программы, которая пользуется
рациональными числами, от задачи реализации рациональных чисел через
элементарные механизмы построения составных данных в компьютерном языке.
Главная идея состояла в возведении барьера абстракции, --- в данном
случае, селекторов и конструкторов для рациональных чисел
(@code{make-rat}, @code{numer}, @code{denom}), --- который отделяет то,
как рациональные числа используются, от их внутреннего представления
через списковые структуры. Подобный же барьер абстракции отделяет детали
процедур, реализующих рациональную арифметику (@code{add-rat},
@code{sub-rat}, @code{mul-rat} и @code{div-rat}), от <<высокоуровневых>>
процедур, которые используют рациональные числа. Получившаяся программа
имеет структуру, показанную на рис. @ref{Рисунок 2.1}.

Такие барьеры абстракции --- мощное средство управления сложностью
проекта. Изолируя внутренние представления объектов данных, нам удается
разделить задачу построения большой программы на меньшие задачи, которые
можно решать независимо друг от друга. Однако такой тип абстракции
данных еще недостаточно мощен, поскольку не всегда имеет смысл говорить
о <<внутреннем представлении>> объекта данных.

Например, может оказаться более одного удобного представления для
объекта данных, и мы можем захотеть проектировать системы, которые
способны работать с множественными представлениями. В качестве простого
примера, комплексные числа можно представить двумя почти эквивалентными
способами: в декартовой форме (действительная и мнимая часть) и в
полярной форме (модуль и аргумент). Иногда лучше подходит декартова
форма, а иногда полярная. В сущности, вполне возможно представить себе
систему, в которой комплексные числа представляются обоими способами, а
процедуры-операции над комплексным числами способны работать с любым
представлением.

Еще важнее то, что часто программные системы разрабатываются большим
количеством людей в течение долгого времени, в соответствии с
требованиями, которые также со временем меняются. В такой ситуации
просто невозможно заранее всем договориться о выборе представления
данных. Так что в дополнение к барьерам абстракции данных, которые
отделяют представление данных от их использования, нам нужны барьеры
абстракции, которые отделяют друг от друга различные проектные решения и
позволяют различным решениям сосуществовать в рамках одной программы.
Более того, поскольку часто большие программы создаются путем
комбинирования существующих модулей, созданных независимо друг от друга,
нам требуются соглашения, которые позволяли бы программистам добавлять
модули к большим системам (@newterm{additively}), то есть без перепроектирования и
переписывания этих модулей.

В этом разделе мы научимся работать с данными, которые могут быть
представлены в разных частях программы различными способами. Это требует
построения (@newterm{generic procedures}) --- процедур, работающих с данными,
которые могут быть представлены более чем одним способом. Наш основной
метод построения обобщенных процедур будет состоять в том, чтобы
работать в терминах объектов, обладающих (@newterm{type tags}), то есть объектов,
явно включающих информацию о том, как их надо обрабатывать. Кроме того,
мы обсудим (@newterm{data-directed programming}) --- мощную и удобную стратегию
реализации, предназначенную для аддитивной сборки систем с обобщенными
операциями.

Мы начнем с простого примера комплексных чисел. Мы увидим, как метки
типа и стиль, управляемый данными, позволяют нам создать отдельные
декартово и полярное представления комплексных чисел, и при этом
поддерживать понятие абстрактного объекта <<комплексное число>> . Мы
добьемся этого, определив арифметические процедуры для комплексных чисел
(@code{add-complex}, @code{sub-complex}, @code{mul-complex} и
@code{div-complex}) в терминах обобщенных селекторов, которые получают
части комплексного числа независимо от того, как оно представлено.
Получающаяся система работы с комплексными числами, как показано на
рис. @ref{Рисунок 2.19}, содержит два типа барьеров абстракции.
<<Горизонтальные>> барьеры играют ту же роль, что и на
рис. @ref{Рисунок 2.1}. Они отделяют <<высокоуровневые>> операции от
<<низкоуровневых>> представлений. В дополнение к этому, существует еще
<<вертикальный>> барьер, который дает нам возможность отдельно
разрабатывать и добавлять альтернативные представления.

@endpage
@float
@anchor{Рисунок 2.19}
@ifinfo
@quotation
@strong{Рисунок 2.19:} Data-abstraction barriers in the complex-number system.

@example
           Programs that use complex numbers
  +-------------------------------------------------+
--| add-complex sub-complex mul-complex div-complex |--
  +-------------------------------------------------+
              Complex arithmetic package
---------------------------+---------------------------
          Rectangular      |         Polar
        representation     |     representation
---------------------------+---------------------------
    List structure and primitive machine arithmetic
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap2/Fig2.19a,108mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.19:} Data-abstraction barriers in the complex-number system.}
@sp 0.8
@end iftex
@end float

В разделе @ref{2.5} мы покажем, как с
помощью меток типа и стиля программирования, управляемого данными,
создать арифметический пакет общего назначения. Такой пакет дает
пользователю процедуры (@code{add}, @code{mul} и т.д.), с помощью
которых можно манипулировать всеми типами <<чисел>>, и если нужно, его
можно легко расширить, когда потребуется новый тип чисел. В
разделе @ref{2.5.3} мы покажем, как
использовать обобщенную арифметику в системе, работающей с символьной
алгеброй.

@menu
* 2-4-1::             Представления комплексных чисел
* 2-4-1::             Помеченные данные
* 2-4-1::             Программирование управляемое данными и аддитивность
@end menu

@comment @subsection Representations for Complex Numbers
@subsection Представления комплексных чисел
@node	2.4.1, 2.4.2, 2.4, 2.4

В качестве простого, хотя и нереалистичного, примера программы,
использующей обобщенные операции, мы разработаем систему, которая
производит арифметические операции над комплексными числами. Начнем мы с
обсуждения двух возможных представлений комплексного числа в виде
упорядоченной пары: декартова форма (действительная и мнимая части) и
полярная форма (модуль и аргумент).@footnote{В реальных вычислительных
системах, как правило, декартова форма предпочтительнее полярной из-за
ошибок округления при преобразованиях между этими двумя формами. Именно
поэтому пример с комплексными числами нереалистичен. Тем не менее, он
служит ясной иллюстрацией строения системы, использующей обобщенные
операции, и хорошим введением в более содержательные системы, которые мы
строим далее по ходу этой главы.} В разделе @ref{2.4.2}
будет показано, как оба представления можно заставить сосуществовать в
рамках одной программы при помощи меток типа и обобщенных операций.

Подобно рациональным числам, комплексные числа естественно представлять
в виде упорядоченных пар. Множество комплексных чисел можно представлять
себе как двумерное пространство с двумя перпендикулярными осями:
<<действительной>> и <<мнимой>> (см. рис. @ref{Рисунок 2.20}). С этой
точки зрения комплексное число @math{z 
= x + iy} (где @math{i^2 = -1}) можно представить как точку на
плоскости, действительная координата которой равна @math{x}, а мнимая
@math{y}. В этом представлении сложение комплексных чисел сводится к
сложению координат:
@ifinfo

@example
Real-part(z_1 + z_2) = Real-part(z_1) + Real-part(z_2)

Imaginary-part(z_1 + z_2) = Imaginary-part(z_1) + Imaginary-part(z_2)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
  \hbox{Real-part} (z_1 + z_2)\; 	&
    \hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \\
  \hbox{Imaginary-part} (z_1 + z_2)\; 	&
    \hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2).
\end{array}
$$
@end tex

@float
@quotation
@anchor{Рисунок 2.20}
@ifinfo
@strong{Рисунок 2.20:} Complex numbers as points in the plane.

@example
 Imaginary
    ^
    |
  y |.........................* z = x + ?y = r e^(?A)
    |                    __-- .
    |                __--     .
    |          r __--         .
    |        __--             .
    |    __-- \               .
    |__--    A |              .
----+----------+-------------------> Real
                              x
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.20,79mm,,,.pdf}
@sp 0.4
@center @caption{@strong{Рисунок 2.20:} Complex numbers as points in the plane.}
@sp 0.9
@end iftex
@end quotation
@end float

При умножении комплексных чисел естественней думать об их представлении
в полярной форме, в виде модуля и аргумента (@math{r} и @math{A} на рис.
@ref{Рисунок 2.20}). Произведение двух комплексных чисел есть вектор,
получаемый путем растягивания одного комплексного числа на модуль
другого и поворота на его же аргумент:
@ifinfo

@example
Magnitude(z_1 * z_2) = Magnitude(z_1) * Magnitude(z_2)

Angle(z_1 * z_2) = Angle(z_1) + Angle(z_2)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
    \hbox{Magnitude} (z_1 \cdot z_2)\; 	&
        \hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \\
    \hbox{Angle} (z_1 \cdot z_2)\; 		&
        \hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2).
\end{array}
$$
@end tex

@noindent
Таким образом, есть два различных представления для комплексных чисел, и
каждое из них удобнее для какого-то набора операций. Однако с точки
зрения человека, который пишет программу с использованием комплексных
чисел, принцип абстракции данных утверждает, что все операции,
работающие с комплексными числами, должны работать независимо от того,
какую интерпретацию использует компьютер. Например, часто бывает нужно
получить модуль комплексного числа, представленного в декартовых
координатах. Подобным образом, часто полезно уметь определять
действительную часть комплексного числа, представленного в полярных
координатах.

При разработке такой системы мы можем следовать той самой стратегии
абстракции данных, которую мы использовали в пакете работы с
рациональными числами в разделе @ref{2.1.1}. Предположим, что
операции над комплексными числами реализованы в терминах четырех
селекторов: @code{real-part}, @code{imag-part}, @code{magnitude} и
@code{angle}. Предположим еще, что у нас есть две процедуры для
построения комплексных чисел: @code{make-from-real-imag} возвращает
комплексное число с указанными действительной и мнимой частями, а
@code{make-from-mag-ang} возвращает комплексное число с указанными
модулем и аргументом. Эти процедуры обладают такими свойствами, что для
любого комплексного числа @code{z}

@lisp
(make-from-real-imag (real-part z) (imag-part z))
@end lisp

@noindent
и

@lisp
(make-from-mag-ang (magnitude z) (angle z))
@end lisp

@noindent
порождают комплексные числа, равные @code{z}.

Используя такие конструкторы и селекторы, мы можем реализовать
арифметику комплексных чисел через <<абстрактные данные>>, определяемые
этими конструкторами и селекторами, в точности как мы это делали для
рациональных чисел в
разделе @ref{2.1.1}. Как показывают
вышеуказанные формулы, можно складывать и вычитать комплексные числа в
терминах действительной и мнимой части, а умножать и делить в терминах
модуля и аргумента:

@lisp

(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
@end lisp

@noindent
Для того, чтобы придать пакету работы с комплексными числами
окончательный вид, нам осталось выбрать представление и реализовать
конструкторы и селекторы в терминах элементарных чисел и элементарной
списковой структуры. Есть два очевидных способа это сделать: можно
представлять комплексное число как пару в <<декартовой форме>>
(действительная часть, мнимая часть) либо в <<полярной форме>> (модуль,
аргумент). Какой вариант мы выберем?

Чтобы говорить о конкретных вариантах, предположим, что двое
программистов, Бен Битобор и Лиза П. Хакер, независимо друг от друга
разрабатывают представления для системы, работающей с комплексными
числами. Бен решает представлять комплексные числа в декартовой форме.
При таком решении доступ к действительной и мнимой частям комплексного
числа, а также построение его из действительной и мнимой частей
реализуются прямолинейно. Чтобы найти модуль и аргумент, а также чтобы
построить комплексное число с заданными модулем и аргументом, он
использует тригонометрические соотношения
@ifinfo

@example
                      __________
x = r cos A     r = ./ x^2 + y^2

y = r sin A     A = arctan(y,x)
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}lr@{{}={}}l}
    x & r \cos A, \qquad 	& r & \sqrt{x^2 + y^2}, \\
    y & r \sin A, \qquad 	& A & \arctan(y, x),
\end{array}
$$
@end tex
@noindent
которые связывают действительную и мнимую части
@math{(x, y)} с модулем и аргументом @math{(r, A)}.@footnote{Функция
взятия арктангенса, которая здесь используется, вычисляется процедурой
Scheme . Она берет два аргумента @math{y} и @math{x} и возвращает угол,
тангенс которого равен @math{y/x}. Знаки аргументов определяют, в каком
квадранте находится угол.} Таким образом, реализация Бена определяется
следующими селекторами и конструкторами:

@lisp
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z))
           (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
@end lisp

@noindent
Напротив, Лиза решает представить комплексные числа в полярной форме.
Для нее доступ к модулю и аргументу тривиален, но для получения
действительной и мнимой части ей приходится использовать
тригонометрические тождества. Вот представление Лизы:

@lisp
(define (real-part z) (* (magnitude z) (cos (angle z))))
(define (imag-part z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))
@end lisp

@noindent
Дисциплина абстракции данных обеспечивает то, что одни и те же
реализации процедур @code{add-complex}, @code{sub-complex},
@code{mul-complex} и @code{div-complex} будут работать как с Беновым
представлением, так и с Лизиным.

@comment @subsection Tagged data
@subsection Помеченные данные
@node	2.4.2, 2.4.3, 2.4.1, 2.4

Можно рассматривать абстракцию данных как применение принципа
<<наименьших обязательств>>. Реализуя систему обработки комплексных
чисел в разделе @ref{2.4.1}, мы
можем использовать либо декартово представление от Бена, либо полярное
от Лизы. Барьер абстракции, который образуют селекторы и конструкторы,
позволяет нам до последнего момента отложить выбор конкретного
представления для наших объектов данных, и таким образом сохранить
максимальную гибкость в проекте нашей системы.

Принцип наименьших обязательств можно довести до еще бо́льших крайностей.
Если нам понадобится, мы можем сохранить неопределенность представления
даже @emph{после} того, как мы спроектировали селекторы и конструкторы,
и использовать @emph{и} представление Бена, @emph{и} представление Лизы.
Однако если оба представления участвуют в одной и той же системе, нам
потребуется какой-нибудь способ отличить данные в полярной форме от
данных в декартовой форме. Иначе, если нас попросят, например, вычислить
@code{magnitude} от пары @math{(3,4)}, мы не будем знать, надо ли
ответить 5 (интерпретируя число в декартовой форме) или 3 (интерпретируя
его в полярной форме). Естественный способ добиться необходимого
различия состоит в том, чтобы использовать (@newterm{type tag}) --- символ
@code{rectangular} или @code{polar} --- как часть каждого комплексного
числа. Тогда, когда нам понадобится что-то делать с комплексным числом,
мы можем при помощи этой метки решить, который селектор требуется
применить.

Чтобы работать с помеченными данными, мы предположим, что у нас есть
процедуры @code{type-tag} и @code{contents}, которые извлекают из
элемента данных метку и собственно содержимое (полярные либо декартовы
координаты, если речь идет о комплексном числе). Кроме того, мы
постулируем процедуру @code{attach-tag}, которая берет метку и
содержимое, и выдает помеченный объект данных. Простейший способ
реализовать эти процедуры --- использовать обыкновенную списковую
структуру:

@lisp
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
@end lisp

@noindent
При помощи этих процедур мы можем определить предикаты
@code{rectangular?} и @code{polar?}, которые распознают, соответственно,
декартово и полярное представление:

@lisp
(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
(define (polar? z) (eq? (type-tag z) 'polar))
@end lisp

@noindent
Теперь, когда у нас имеются метки типов, Бен и Лиза могут переделать
свой код так, чтобы позволить своим разнородным представлениям
сосуществовать в одной и той же системе. Каждый раз, когда Бен создает
комплексное число, он помечает его как декартово. Каждый раз, когда Лиза
создает комплексное число, она помечает его как полярное. В дополнение к
этому, Бен и Лиза должны сделать так, чтобы не было конфликта имен между
названиями их процедур. Один из способов добиться этого --- Бену
добавить слово @code{rectangular} к названиям всех своих процедур
представления данных, а Лизе добавить @code{polar} к своим. Вот
переработанное декартово представление Бена из
раздела @ref{2.4.1}:

@lisp
(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
@end lisp

@noindent
а вот переработанное полярное представление Лизы:

@lisp
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))
(define (make-from-real-imag-polar x y)
  (attach-tag 'polar
              (cons (sqrt (+ (square x) (square y)))
                    (atan y x))))
(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
@end lisp

@noindent
Каждый обобщенный селектор реализуется как процедура, которая проверяет
метку своего аргумента и вызывает подходящую процедуру для обработки
данных нужного типа. Например, для того, чтобы получить действительную
часть комплексного числа, @code{real-part} смотрит на метку и решает,
звать ли Бенову @code{real-part-rectangular} или Лизину
@code{real-part-polar}. В каждом из этих случаев мы пользуемся
процедурой @code{contents}, чтобы извлечь голый, непомеченный элемент
данных и передать его либо в декартову, либо в полярную процедуру:

@lisp
(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type: REAL-PART" z))))
(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type: IMAG-PART" z))))
(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknown type: MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknown type: ANGLE" z))))
@end lisp

@noindent
Для реализации арифметических операций с комплексными числами мы
по-прежнему можем использовать старые процедуры @code{add-complex},
@code{sub-complex}, @code{mul-complex} и @code{div-complex} из
раздела @ref{2.4.1}, поскольку
вызываемые ими селекторы обобщенные и, таким образом, могут работать с
любым из двух представлений. Например, процедура @code{add-complex}
по-прежнему выглядит как

@lisp
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
@end lisp

@noindent
Наконец, нам надо решить, порождать ли комплексные числа в Беновом или
Лизином представлении. Одно из разумных решений состоит в том, чтобы
порождать декартовы числа, когда нам дают действительную и мнимую часть,
и порождать полярные числа, когда нам дают модуль и аргумент:

@lisp
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
@end lisp

@noindent
Структура получившейся системы комплексной арифметики показана на
рисунке @ref{Рисунок 2.21}. Система разбита на три относительно
независимых части: операции арифметики комплексных чисел, полярная
реализация Лизы и декартова реализация Бена. Полярная и декартова
реализации могли быть написаны Беном и Лизой по отдельности, и любую из
них может использовать в качестве внутреннего представления третий
программист, чтобы реализовать процедуры арифметики комплексных чисел в
терминах абстрактного интерфейса конструкторов и селекторов.

@float
@anchor{Рисунок 2.21}
@ifinfo
@quotation
@strong{Рисунок 2.21:} Structure of the generic complex-arithmetic system.

@example
    +-------------------------------------------------+
----| add-complex sub-complex mul-complex div-complex |----
    +-------------------------------------------------+
                Complex arithmetic package
                 +-----------------------+
                 | real-part   imag-part |
-----------------|                       |------------------
                 | magnitude   angle     |
                 +-----------+-----------+
           Rectangular       |          Polar
          representation     |     representation
-----------------------------+------------------------------
       List structure and primitive machine arithmetic
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.21a,108mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 2.21:} Structure of the generic complex-arithmetic system. }@short
@sp 0.8
@end iftex
@end float

Поскольку каждый объект данных помечен своим типом, селекторы работают с
данными обобщенным образом. Это означает, что каждый селектор по
определению обладает поведением, которое зависит от того, к какому типу
данных он применяется. Следует обратить внимание на общий механизм
доступа к отдельным представлениям: внутри любой данной реализации
представления (скажем, внутри полярного пакета Лизы) комплексное число
представляется нетипизированной парой (модуль, аргумент). Когда
обобщенный селектор обращается к данным полярного типа, он отрывает
метку и передает содержимое Лизиному коду. И наоборот, когда Лиза строит
число для общего пользования, она помечает его тип, чтобы процедуры
более высокого уровня могли его должным образом распознать. Такая
дисциплина снятия и добавления меток при передаче объектов данных с
уровня на уровень может быть ценной стратегией организации данных и
программ, как мы увидим в
разделе @ref{2.5}.

@comment @subsection Data-Directed Programming and Additivity
@subsection Программирование, управляемое данными, и аддитивность
@node	2.4.3,  , 2.4.2, 2.4

Общая стратегия проверки типа данных и вызова соответствующей процедуры
называется @emph{диспетчеризацией по типу} (@newterm{dispatching on type}). Это
хороший способ добиться модульности при проектировании системы. С другой
стороны, такая реализация диспетчеризации, как в
разделе @ref{2.4.2}, имеет два существенных недостатка.
Один заключается в том, что обобщенные процедуры интерфейса
(@code{real-part}, @code{imag-part}, @code{magnitude} и @code{angle})
обязаны знать про все имеющиеся способы представления. Предположим, к
примеру, что нам хочется ввести в нашу систему комплексных чисел еще
одно представление. Нам нужно будет сопоставить этому представлению тип,
а затем добавить в каждую из обобщенных процедур интерфейса по варианту
для проверки на этот новый тип и вызова селектора, соответствующего его
представлению.

Второй недостаток этого метода диспетчеризации состоит в том, что, хотя
отдельные представления могут проектироваться раздельно, нам нужно
гарантировать, что никакие две процедуры во всей системе не называются
одинаково. Вот почему Бену и Лизе пришлось изменить имена своих
первоначальных процедур из
раздела @ref{2.4.1}.

Оба эти недостатка являются следствием того, что наш метод реализации
обобщенных интерфейсов . Программист, реализующий обобщенные
процедуры-селекторы, должен их переделывать каждый раз, как добавляется
новое представление, а авторы, создающие отдельные представления, должны
изменять свой код, чтобы избежать конфликтов имен. В каждом из этих
случаев изменения, которые требуется внести в код, тривиальны, но их все
равно нужно делать, и отсюда проистекают неудобства и ошибки. Для
системы работы с комплексными числами в ее нынешнем виде это проблема
небольшая, но попробуйте представить, что есть не два, а сотни различных
представлений комплексных чисел. И что есть много обобщенных селекторов,
которые надо поддерживать в интерфейсе абстрактных данных. Представьте
даже, что ни один программист не знает всех интерфейсных процедур всех
реализаций. Проблема эта реальна, и с ней приходится разбираться в
программах вроде систем управления базами данных большого калибра.

Нам нужен способ еще более модуляризовать устройство системы. Это
позволяет метод программирования, который называется (@newterm{data-directed programming}).
Чтобы понять, как работает этот метод, начнем с
наблюдения: каждый раз, когда нам приходится работать с набором
обобщенных операций, общих для множества различных типов, мы, в
сущности, работаем с двумерной таблицей, где по одной оси расположены
возможные операции, а по другой всевозможные типы. Клеткам таблицы
соответствуют процедуры, которые реализуют каждую операцию для каждого
типа ее аргумента. В системе комплексной арифметики из предыдущего
раздела соответствие между именем операции, типом данных и собственно
процедурой было размазано по условным предложениям в обобщенных
процедурах интерфейса. Но ту же самую информацию можно было бы
организовать в виде таблицы, как показано на рис. @ref{Рисунок 2.22}.

Программирование, управляемое данными, --- метод проектирования
программ, позволяющий им напрямую работать с такого рода таблицей.
Механизм, который связывает код комплексных арифметических операций с
двумя пакетами представлений, мы ранее реализовали в виде набора
процедур, которые явно осуществляют диспетчеризацию по типу. Здесь мы
реализуем этот интерфейс через одну процедуру, которая ищет сочетание
имени операции и типа аргумента в таблице, чтобы определить, какую
процедуру требуется применить, а затем применяет ее к содержимому
аргумента. Если мы так сделаем, то, чтобы добавить к системе пакет с
новым представлением, нам не потребуется изменять существующие
процедуры; понадобится только добавить новые клетки в таблицу.

@float
@anchor{Рисунок 2.22}
@ifinfo
@quotation
@strong{Рисунок 2.22:} Table of operations for the complex-number system.

@example
           |               Types
Operations | Polar           | Rectangular
===========+=================+======================
real-part  | real-part-polar | real-part-rectangular
imag-part  | imag-part-polar | imag-part-rectangular
magnitude  | magnitude-polar | magnitude-rectangular
angle      | angle-polar     | angle-rectangular
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap2/Fig2.22,102mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.22:} Table of operations for the complex-number system. }@short
@sp 0.8
@end iftex
@end float

Чтобы реализовать этот план, предположим, что у нас есть две процедуры
@code{put} и @code{get}, для манипуляции с таблицей операций и типов:

@itemize @bullet

@item
@math{\hbox{\tt(put}\;\langle}@var{оп}@math{\kern0.1em\rangle\;\langle}@var{тип}@math{\kern0.08em\rangle\;\langle}@var{элемент}@math{\kern0.08em\rangle\hbox{\tt)}} вносит @math{\langle}@var{элемент}@math{\kern0.08em\rangle} в таблицу, в клетку, индексом которой служат операция
@math{\langle}@var{оп}@math{\kern0.1em\rangle} и тип @math{\langle}@var{тип}@math{\kern0.08em\rangle}.

@item
@math{\hbox{\tt(get}\;\langle}@var{оп}@math{\kern0.1em\rangle\;\langle}@var{элемент}@math{\kern0.08em\rangle\hbox{\tt)}} ищет в таблице ячейку с индексом
@math{\langle}@var{оп}@math{\kern0.08em\rangle}, @math{\langle}@var{тип}@math{\kern0.08em\rangle} 
и возвращает ее содержимое. Если ячейки нет, @code{get} возвращает ложь.

@end itemize

Пока что мы предположим, что @code{get} и @code{put} входят в наш язык.
В главе @ref{Глава 3} (раздел @ref{3.3.3}) мы увидим,
как реализовать эти и другие операции для работы с таблицами.

Программирование, управляемое данными, в системе с комплексными числами
можно использовать так: Бен, который разрабатывает декартово
представление, пишет код в точности как он это делал сначала. Он
определяет набор процедур, или (@newterm{package}), и привязывает эти процедуры к
остальной системе, добавляя в таблицу ячейки, которые сообщают системе,
как работать с декартовыми числами. Это происходит при вызове следующей
процедуры:

@lisp
(define (install-rectangular-package)
  @r{;; internal procedures}
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  @r{;; interface to the rest of the system}
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Обратите внимание, что внутренние процедуры --- те самые, которые Бен
писал, когда он в
разделе @ref{2.4.1} работал сам по
себе. Никаких изменений, чтобы связать их с остальной системой, не
требуется. Более того, поскольку определения процедур содержатся внутри
процедуры установки, Бену незачем беспокоиться о конфликтах имен с
другими процедурами вне декартова пакета. Чтобы связать их с остальной
системой, Бен устанавливает свою процедуру @code{real-part} под именем
операции @code{real-part} и типом @code{(rectangular)}, и то же самое он
проделывает с другими селекторами.@footnote{Мы используем список
@code{(rectangular)}, а не символ @code{rectangular}, чтобы
предусмотреть возможность операций с несколькими аргументами, не все из
которых одинакового типа.} Его интерфейс также определяет конструкторы,
которые может использовать внешняя система.@footnote{Тип, под которым
устанавливаются конструкторы, необязательно делать списком, поскольку
конструктор всегда вызывается для того, чтобы породить один объект
определенного типа.} Они совпадают с конструкторами, которые Бен
определяет для себя, но вдобавок прикрепляют метку.

Лизин полярный пакет устроен аналогично:

@lisp
(define (install-polar-package)
  @r{;; internal procedures}
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (* (magnitude z) (cos (angle z))))
  (define (imag-part z) (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  @r{;; interface to the rest of the system}
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Несмотря на то, что Бен и Лиза используют свои исходные процедуры с
совпадающими именами (например, @code{real-part}), эти определения
теперь внутренние для различных процедур (см.
раздел @ref{1.1.8}),
так что никакого конфликта имен не происходит.

Селекторы комплексной арифметики обращаются к таблице посредством общей
процедуры-<<операции>> @code{apply-generic}, которая применяет
обобщенную операцию к набору аргументов. @code{apply-generic} ищет в
таблице ячейку по имени операции и типам аргументов и применяет
найденную процедуру, если она существует:@footnote{@code{apply-generic}
пользуется точечной записью, описанной в
упражнении @ref{Упражнение 2.20}, поскольку различные обобщенные
операции могут принимать различное число аргументов. В
@code{apply-generic} значением @code{op} является первый аргумент вызова
@code{apply-generic}, а значением @code{args} список остальных
аргументов.

Кроме того, @code{apply-generic} пользуется элементарной процедурой
@code{apply}, которая принимает два аргумента: процедуру и список.
@code{Apply} вызывает процедуру, используя элементы списка как
аргументы. Например,

@lisp
(apply + (list 1 2 3 4))
@end lisp

@noindent
возвращает 10.}

@lisp
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types: APPLY-GENERIC"
            (list op type-tags))))))
@end lisp

@noindent
При помощи @code{apply-generic} можно определить обобщенные селекторы
так:

@lisp
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
@end lisp

@noindent
Заметим, что они не изменяются, если в систему добавляется новое
представление.

Кроме того, мы можем из той же таблицы получать конструкторы, которые
будут использоваться программами, внешними по отношению к пакетам, для
изготовления комплексных чисел из действительной и мнимой части либо из
модуля и аргумента. Как и в разделе @ref{2.4.2}, мы
порождаем декартово представление, если нам дают действительную и мнимую
часть, и полярное, если дают модуль и аргумент:

@lisp
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.73}Упражнение 2.73:}
В разделе @ref{2.3.2}
описывается программа, которая осуществляет символьное дифференцирование:

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product
                    (multiplier exp)
                    (deriv (multiplicand exp) var))
                   (make-product
                    (deriv (multiplier exp) var)
                    (multiplicand exp))))
        @math{\langle}@var{more rules can be added here}@math{\rangle}
        (else (error "unknown expression type:
                      DERIV" exp))))
@end lisp

Можно считать, что эта программа осуществляет диспетчеризацию по типу
выражения, которое требуется продифференцировать. В этом случае <<меткой
типа>> элемента данных является символ алгебраической операции
(например, @code{+}), а операция, которую нужно применить --
@code{deriv}. Эту программу можно преобразовать в управляемый данными
стиль, если переписать основную процедуру взятия производной в виде

@lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp))
               (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
@end lisp

@enumerate a.

@item
Объясните, что происходит в приведенном фрагменте кода. Почему нельзя
включить в операцию выбора, управляемого данными, предикаты
@code{number?} и @code{variable?}?

@item
Напишите процедуры для вычисления производных от суммы и произведения, а
также дополнительный код, чтобы добавить их к таблице, которой
пользуется приведенный фрагмент.

@item
Выберите еще какое-нибудь правило дифференцирования, например для
возведения в степень (упражнение @ref{Упражнение 2.56}), и установите
его в систему.

@item
В этой простой алгебраической системе тип выражения --- это
алгебраическая операция верхнего уровня. Допустим, однако, что мы
индексируем процедуры противоположным образом, так что строка
диспетчеризации в @code{deriv} выглядит как

@lisp
((get (operator exp) 'deriv) (operands exp) var)
@end lisp

@noindent
Какие изменения потребуются в системе дифференцирования?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.74}Упражнение 2.74:}
Insatiable Enterprises, Inc. --- децентрализованная
компания-конгломерат, которая состоит из большого количества независимых
подразделений, раскиданных по всему миру. Недавно вычислительные
мощности компании были связаны умной вычислительной сетью, создающей для
пользователя иллюзию, что он работает с единым компьютером. Президент
компании, когда она в первый раз пытается воспользоваться способностью
системы осуществлять доступ к файлам подразделений, с изумлением и
ужасом обнаруживает, что, несмотря на то, что все эти файлы реализованы
в виде структур данных на Scheme, конкретная структура данных отличается
от подразделения к подразделению. Спешно созывается совещание менеджеров
подразделений, чтобы найти стратегию, которая позволила бы собрать файлы
в единую систему для удовлетворения нужд главного офиса, и одновременно
сохранить существующую автономию подразделений.

Покажите, как такую стратегию можно реализовать при помощи
программирования, управляемого данными. К примеру, предположим, что
сведения о персонале каждого подразделения устроены в виде единого
файла, который содержит набор записей, проиндексированных по имени
служащего. Структура набора данных от подразделения к подразделению
различается. Более того, каждая запись сама по себе --- набор сведений
(в разных подразделениях устроенный по-разному), в котором информация
индексируется метками вроде @code{address} (адрес) или @code{salary}
(зарплата). В частности:

@enumerate a.

@item
Для главного офиса реализуйте процедуру @code{get-record}, которая
получает запись, относящуюся к указанному служащему, из указанного файла
персонала. Процедура должна быть применима к файлу любого подразделения.
Объясните, как должны быть структурированы файлы отдельных
подразделений. В частности, какую информацию о типах нужно хранить?

@item
Для главного офиса реализуйте процедуру @code{get-salary}, которая
возвращает зарплату указанного служащего из файла любого подразделения.
Как должна быть устроена запись, чтобы могла работать эта процедура?

@item
Для главного офиса напишите процедуру @code{find-employee-record}. Она
должна искать в файлах всех подразделений запись указанного служащего и
возвращать эту запись. Предположим, что в качестве аргументов эта
процедура принимает имя служащего и список файлов всех подразделений.

@item
Какие изменения требуется внести в систему, чтобы внести в центральную
систему информацию о новых служащих, когда Insatiable поглощает новую
компанию?

@end enumerate
@end quotation

@comment @subsubheading Message passing
@subsubheading Передача сообщений

Основная идея программирования, управляемого данными, состоит в том,
чтобы работать с обобщенными операциями в программах при помощи явных
манипуляций с таблицами операций и типов, вроде таблицы на
рисунке @ref{Рисунок 2.22}. В стиле программирования, который мы
применяли в разделе @ref{2.4.2}, диспетчеризация по типу
организуется внутри каждой операции, и каждая операция должна сама
заботиться о своей диспетчеризации. Это, в сущности, разбивает таблицу
операций и типов на строки, и каждая обобщенная операция представляет
собой строку таблицы.

Альтернативой такой стратегии реализации будет разбить таблицу по
столбцам и вместо <<умных операций>>, которые диспетчируют по типам
данных, работать с <<умными объектами данных>>, которые диспетчируют по
именам операций. Мы можем этого добиться, если устроим все так, что
объект данных, например комплексное число в декартовом представлении,
будет представляться в виде процедуры, которая в качестве входа
воспринимает имя операции и осуществляет соответствующее ей действие.
При такой организации можно написать @code{make-from-real-imag} в виде

@lisp
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude) (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else (error "Unknown op: MAKE-FROM-REAL-IMAG" op))))
  dispatch)
@end lisp

@noindent
Соответствующая процедура @code{apply-generic}, которая применяет
обобщенную операцию к аргументу, просто скармливает имя операции объекту
данных и заставляет его делать всю работу:@footnote{У такой организации
есть ограничение: она допускает обобщенные процедуры только от одного
аргумента.}

@lisp
(define (apply-generic op arg) (arg op))
@end lisp

@noindent
Обратите внимание, что значение, возвращаемое из
@code{make-from-real-imag}, является процедурой --- это внутренняя
процедура @code{dispatch}. Она вызывается, когда @code{apply-generic}
требует выполнить обобщенную операцию.

Такой стиль программирования называется (@newterm{message passing}). Имя
происходит из представления, что объект данных --- это сущность,
которая получает имя затребованной операции как <<сообщение>>. Мы уже
встречались с примером передачи сообщений в
разделе @ref{2.1.3}, где мы видели, как
@code{cons}, @code{car} и @code{cdr} можно определить безо всяких
объектов данных, с одними только процедурами. Теперь мы видим, что
передача сообщений не математический трюк, а полезный метод организации
систем с обобщенными операциями. В оставшейся части этой главы мы будем
продолжать пользоваться программированием, управляемым данными, а не
передачей сообщений, и рассмотрим обобщенные арифметические операции. Мы
вернемся к передаче сообщений в
главе @ref{Глава 3},
и увидим, что она может служить мощным инструментом для структурирования
моделирующих программ.

@quotation
@strong{@anchor{Упражнение 2.75}Упражнение 2.75:}
Реализуйте в стиле передачи сообщений конструктор
@code{make-from-mag-ang}. Он должен быть аналогичен приведенной выше
процедуре @code{make-from-real-imag}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.76}Упражнение 2.76:}
Когда большая система с обобщенными операциями развивается,
могут потребоваться новые типы объектов данных или новые операции. Для
каждой из трех стратегий --- обобщенные операции с явной
диспетчеризацией, стиль, управляемый данными, и передача сообщений, --
опишите, какие изменения нужно произвести в системе, чтобы добавить
новый тип или новую операцию. Какая организация лучше подходит для
системы, в которую часто добавляются новые типы? Какая для системы, где
часто появляются новые операции?
@end quotation

@comment @section Systems with Generic Operations
@section Системы с обобщенными операциями
@node	2.5,  , 2.4, Глава 2

В предыдущем разделе мы увидели, как проектировать системы, где объекты
данных могут быть представлены более чем одним способом. Основная идея
состоит в том, чтобы связать код, который определяет операции над
данными, и многочисленные реализации данных, при помощи обобщенных
процедур интерфейса. Теперь мы увидим, что ту же самую идею можно
использовать не только для того, чтобы определять обобщенные операции
для нескольких реализаций одного типа, но и для того, чтобы определять
операции, обобщенные относительно нескольких различных типов аргументов.
Мы уже встречались с несколькими различными пакетами арифметических
операций: элементарная арифметика (@code{+}, @code{-}, @code{*},
@code{/}), встроенная в наш язык, арифметика рациональных чисел
(@code{add-rat}, @code{sub-rat}, @code{mul-rat}, @code{div-rat}) из
раздела @ref{2.1.1} и арифметика комплексных чисел, которую мы
реализовали в разделе @ref{2.4.3}. Теперь
мы, используя методы программирования, управляемого данными, создадим
пакет арифметических операций, который включает все уже построенные нами
арифметические пакеты.

@float
@quotation
@ifinfo
@anchor{Рисунок 2.23}
@strong{Рисунок 2.23:} Generic arithmetic system.

@example
                        Programs that use numbers
                           +-----------------+
---------------------------| add sub mul div |-------------------
                           +-----------------+
                        Generic arithmetic package
 +-----------------+   +-------------------------+
 | add-rat sub-rat |   | add-complex sub-complex |   +---------+
-|                 |-+-|                         |-+-| + - * / |-
 | mul-rat div-rat | | | mul-complex div-complex | | +---------+
 +-----------------+ | +-------------------------+ |
      Rational       |     Complex artithmetic     |   Ordinary
     arithmetic      +--------------+--------------+  arithmetic
                     | Rectangular  |     Polar    |
---------------------+--------------+--------------+-------------
             List structure and primitive machine arithmetic
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.23a,111mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 2.23:} Generic arithmetic system.}
@sp 0.8
@end iftex
@end quotation
@end float

На рисунке @ref{Рисунок 2.23} показана структура системы, которую мы
собираемся построить. Обратите внимание на барьеры абстракции. С точки
зрения человека, работающего с <<числами>>, есть только одна процедура
@code{add}, которая работает, какие бы числа ей ни дали. @code{Add}
является частью обобщенного интерфейса, который позволяет программам,
пользующимся числами, одинаковым образом обращаться к раздельным пакетам
обыкновенной, рациональной и комплексной арифметики. Всякий конкретный
арифметический пакет (например, комплексная арифметика) сам по себе
доступен через обобщенные процедуры (например, @code{add-complex}),
которые связывают пакеты, предназначенные для различных реализаций
(таких, как декартовы и полярные числа). Более того, структура системы
аддитивна, так что можно проектировать отдельные арифметические пакеты
независимо и сочетать их, получая обобщенную арифметическую систему.

@menu
* 2-5-1::             Обобщенные арифметические операции
* 2-5-1::             Сочетание данных различных типов
* 2-5-1::             Пример символьная алгебра
@end menu

@comment @subsection Generic Arithmetic Operations
@subsection Обобщенные арифметические операции
@node	2.5.1, 2.5.2, 2.5, 2.5

Задача проектирования обобщенных арифметических операций аналогична
задаче проектирования обобщенных операций с комплексными числами. К
примеру, нам бы хотелось иметь обобщенную процедуру сложения @code{add},
которая действовала бы как обычное элементарное сложение @code{+} по
отношению к обычным числам, как @code{add-rat} по отношению к
рациональным числам и как @code{add-complex} по отношению к комплексным.
Реализовать @code{add} и прочие обобщенные арифметические операции мы
можем, следуя той же стратегии, которую мы использовали в разделе @ref{2.4.3}
для обобщенных селекторов комплексных чисел. К каждому числу мы прикрепим
метку типа и заставим обобщенную процедуру передавать управление в
нужный пакет в соответствии с типами своих аргументов.

Обобщенные арифметические процедуры определяются следующим образом:

@lisp
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
@end lisp

@noindent
Начнем с установки пакета для работы с числами, то есть элементарными
@newterm{ordinary} числами нашего языка. Мы пометим их символом
@code{scheme-number}. Арифметические операции этого пакета --- это элементарные
арифметические процедуры (так что нет никакой нужды определять
дополнительные процедуры для обработки непомеченных чисел). Поскольку
каждая из них принимает по два аргумента, в таблицу они заносятся с
ключом-списком @code{(scheme-number scheme-number)}:

@lisp
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
@end lisp

@noindent
Пользователи пакета Схемных чисел будут создавать (помеченные)
элементарные числа с помощью процедуры

@lisp
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
@end lisp

@noindent
Теперь, когда каркас обобщенной арифметической системы построен, мы
можем без труда добавлять новые типы чисел. Вот пакет, который реализует
арифметику рациональных чисел. Обратите внимание, что благодаря
аддитивности мы можем без изменений использовать код рациональной
арифметики из раздела @ref{2.1.1} в виде внутренних процедур пакета:

@lisp
(define (install-rational-package)
  @r{;; внутренние процедуры}
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  @r{;; интерфейс к остальной системе}
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
@end lisp

@noindent
Мы можем установить подобный пакет и для комплексных чисел, используя
метку @code{complex}. При создании пакета мы извлекаем из таблицы
операции @code{make-from-real-imag} и @code{make-from-mag-ang},
определенные в декартовом и полярном пакетах. Аддитивность позволяет нам
использовать без изменений в качестве внутренних операций процедуры
@code{add-complex}, @code{sub-complex}, @code{mul-complex} и
@code{div-complex} из
раздела @ref{2.4.1}.

@lisp
(define (install-complex-package)
  @r{;; процедуры, импортируемые из декартова и полярного пакетов}
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  @r{;; внутренние процедуры}
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  @r{;; интерфейс к остальной системе}
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
@end lisp

@noindent
Вне комплексного пакета программы могут создавать комплексные числа либо
из действительной и мнимой части, либо из модуля и аргумента. Обратите
внимание, как нижележащие процедуры, которые были изначально определены
в декартовом и полярном пакете, экспортируются в комплексный пакет, а
оттуда во внешний мир.

@lisp
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
@end lisp

@noindent
Здесь мы имеем двухуровневую систему меток. Типичное комплексное число,
например @math{3+4i} в декартовой форме, будет представлено так, как
показано на рисунке @ref{Рисунок 2.24}. Внешняя метка
(@code{complex}) используется, чтобы отнести число к пакету комплексных
чисел. Внутри комплексного пакета вторая метка (@code{rectangular})
относит число к декартову пакету. В большой и сложной системе может быть
несколько уровней, каждый из которых связан со следующим при помощи
обобщенных операций. Когда объект данных передается <<вниз>>, внешняя
метка, которая используется для отнесения к нужному пакету, отрывается
(при помощи вызова @code{contents}), и следующий уровень меток (если
таковой имеется) становится доступным для дальнейшей диспетчеризации.

@float
@quotation
@anchor{Рисунок 2.24}
@ifinfo
@strong{Рисунок 2.24:} Representation of @math{3 + 4i} in rectangular form.

@example
     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | * |
     +-|-+---+     +-|-+---+     +-|-+-|-+
       |             |             |   |
       V             V             V   V
 +---------+   +-------------+  +---+ +---+
 | complex |   | rectangular |  | 3 | | 4 |
 +---------+   +-------------+  +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap2/Fig2.24c,64mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 2.24:} Representation of @math{3 + 4i} in rectangular form.}
@sp 0.6
@end iftex
@end quotation
@end float

В приведенных пакетах мы использовали @code{add-rat}, @code{add-complex}
и другие арифметические процедуры ровно в таком виде, как они были
написаны с самого начала. Но когда эти определения оказываются внутри
различных процедур установки, отпадает необходимость давать им различные
имена: мы могли бы просто назвать их в обоих пакетах @code{add},
@code{sub}, @code{mul} и @code{div}.

@quotation
@strong{@anchor{Упражнение 2.77}Упражнение 2.77:}
Хьюго Дум пытается вычислить выражение
@code{(magnitude z)}, где @code{z} --- объект, показанный на
рис. @ref{Рисунок 2.24}. К своему удивлению, вместо ответа 5 он
получает сообщение об ошибке от @code{apply-generic}, гласящее, что у
операции @code{magnitude} нет методов для типа @code{(complex)}. Он
показывает результат Лизе П. Хакер. Та заявляет: <<Дело в том, что
селекторы комплексных чисел для чисел с меткой @code{complex} определены
не были, а были только для чисел с меткой @code{polar} и
@code{rectangular}. Все, что требуется, чтобы заставить это
работать --- это добавить к пакету @code{complex} следующее:>>

@lisp
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
@end lisp

Подробно опишите, почему это работает. В качестве примера, проследите
все процедуры, которые вызываются при вычислении @code{(magnitude z)},
где @code{z} --- объект, показанный на рис. @ref{Рисунок 2.24}. В
частности, сколько раз вызывается @code{apply-generic}? На какую
процедуру она диспетчирует в каждом случае?
@end quotation

@quotation
@strong{@anchor{Упражнение 2.78}Упражнение 2.78:}
В пакете @code{scheme-number} внутренние процедуры, в
сущности, ничего не делают, только вызывают элементарные процедуры
@code{+}, @code{-}, и т.д. Прямо использовать примитивы языка не было
возможности, поскольку наша система меток типов требует, чтобы каждый
объект данных был снабжен меткой. Однако на самом деле все реализации
Лиспа имеют систему типов, которую они используют внутри себя.
Элементарные процедуры вроде @code{symbol?} или @code{number?}
определяют, относится ли объект к определенному типу. Измените
определения @code{type-tag}, @code{contents} и @code{attach-tag} из
раздела @ref{2.4.2} так, чтобы наша обобщенная система
использовала внутреннюю систему типов Scheme. То есть, система должна
работать так же, как раньше, но только обычные числа должны быть
представлены просто в виде чисел языка Scheme, а не в виде пары, у
которой первый элемент символ @code{scheme-number}.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.79}Упражнение 2.79:}
Определите обобщенный предикат равенства @code{equ?},
который проверяет два числа на равенство, и вставьте его в пакет
обобщенной арифметики. Операция должна работать для обычных чисел,
рациональных и комплексных.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.80}Упражнение 2.80:}
Определите обобщенный предикат @code{=zero?}, который
проверяет, равен ли его аргумент нулю, и вставьте его в пакет обобщенной
арифметики. Предикат должен работать для обычных, рациональных и
комплексных чисел.
@end quotation

@comment @subsection Combining Data of Different Types
@subsection Сочетание данных различных типов
@node	2.5.2, 2.5.3, 2.5.1, 2.5

Мы видели, как можно построить объединенную арифметическую систему,
которая охватывает обыкновенные числа, комплексные числа, рациональные
числа и любые другие типы чисел, которые нам может потребоваться
изобрести, но мы упустили важный момент. Операции, которые мы до сих пор
определили, рассматривают различные типы данных как совершенно
независимые. Таким образом, есть отдельные пакеты для сложения,
например, двух обыкновенных чисел и двух комплексных чисел. Мы до сих
пор не учитывали того, что имеет смысл определять операции, которые
пересекают границы типов, например, сложение комплексного числа с
обычным. Мы затратили немалые усилия, чтобы воздвигнуть барьеры между
частями наших программ, так, чтобы их можно было разрабатывать и
понимать по отдельности. Нам бы хотелось добавить операции со смешанными
типами по возможности аккуратно, так, чтобы мы их могли поддерживать, не
нарушая всерьез границ модулей.

Один из способов управления операциями со смешанными типами состоит в
том, чтобы определить отдельную процедуру для каждого сочетания типов,
для которых операция имеет смысл. Например, мы могли бы расширить пакет
работы с комплексными числами и включить туда процедуру сложения
комплексных чисел с обычными, занося ее в таблицу с меткой
@code{(complex scheme-number)}:@footnote{Придется к тому же написать
почти такую же процедуру для типа @code{(scheme-number complex)}.}

@lisp
@r{;; включается в пакет комплексных чисел}
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
@end lisp

@noindent
Этот метод работает, но он очень громоздок. При такой системе стоимость
введения нового типа не сводится к тому, чтобы построить пакет процедур
для этого типа, но включает еще построение и установку процедур,
осуществляющих операции со смешанными типами. Это запросто может
потребовать больше кода, чем нужно, чтобы определить операции над самим
типом. Кроме того, этот метод подрывает нашу способность сочетать
отдельные пакеты аддитивно, или, по крайней мере, ограничивать степень,
в которой реализация отдельного пакета должна принимать другие пакеты в
расчет. Скажем, в вышеприведенном примере, кажется естественным, чтобы
ответственность за обработку смешанных операций с обычными и
комплексными числами лежала на комплексном пакете. Однако сочетание
рациональных и комплексных чисел может осуществляться комплексным
пакетом, рациональным пакетом, или каким-нибудь третьим, который
пользуется операциями, извлеченными из этих двух. Формулировка ясных
правил разделения ответственности между пакетами может стать непосильной
задачей при разработке систем с многими пакетами и многими смешанными
операциями.

@comment @subsubheading Coercion
@subsubheading Приведение типов

В ситуации общего вида, когда совершенно несвязанные друг с другом
операции применяются к совершенно друг с другом не связанным типам,
явное написание операций со смешанными типами, как бы это ни было
громоздко, --- все, на что мы можем рассчитывать. К счастью, обычно мы
можем воспользоваться дополнительной структурой, которая часто в скрытом
виде присутствует в нашей системе типов. Часто различные типы данных не
совсем независимы, и каким-то образом объекты одного типа можно
рассматривать как объекты другого. Такой процесс называется (@newterm{coercion}).
Например, если нас просят найти некоторую арифметическую комбинацию
обычного числа и комплексного, то мы можем рассматривать обычное число
как такое комплексное, у которого мнимая часть равна нулю. Это сводит
нашу задачу к сочетанию двух комплексных чисел, а с этим может
стандартным способом справиться пакет комплексной арифметики.

В общем случае мы можем реализовать эту идею, проектируя процедуры
приведения типа, которые переводят объект одного типа в эквивалентный
ему объект другого типа. Вот типичная процедура приведения типов,
которая преобразует данное обыкновенное число в комплексное, у которого
есть действительная часть, а мнимая равна нулю:

@lisp
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
@end lisp

@noindent
Мы записываем процедуры приведения типа в специальную таблицу приведения
типов, проиндексированную именами двух типов:

@lisp
(put-coercion 'scheme-number
              'complex
              scheme-number->complex)
@end lisp

@noindent
(Предполагается, что для работы с этой таблицей существуют процедуры
@code{put-coercion} и @code{get-coercion}.) Как правило, часть ячеек
этой таблицы будет пуста, потому что в общем случае невозможно привести
произвольный объект произвольного типа ко всем остальным типам. К
примеру, нет способа привести произвольное комплексное число к
обыкновенному, так что в таблице не появится общая процедура
@code{complex->scheme-number}.

Когда таблица приведения типов построена, мы можем работать с
приведением стандартным образом, приспособив для этого процедуру
@code{apply-generic} из раздела @ref{2.4.3}. Когда
нас просят применить операцию, мы первым делом, как и раньше, проверяем,
не определена ли уже операция для типов аргументов. Если да, мы вызываем
процедуру, найденную в таблице операций и типов. Если нет, мы пробуем
применить приведение типов. Для простоты мы рассматриваем только тот
случай, когда аргументов два.@footnote{Обобщение см. @ref{Упражнение 2.82}.}
Мы проверяем таблицу
преобразования типов и смотрим, можно ли объект первого типа привести ко
второму типу. Если да, осуществляем приведение и снова пробуем операцию.
Если объекты первого типа в общем случае ко второму не приводятся, мы
пробуем приведение в обратном направлении и смотрим, нет ли способа
привести второй аргумент к типу первого. Наконец, если нет никакого
известного способа привести один тип к другому, мы сдаемся. Вот эта
процедура:

@lisp
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else (error "No method for these types"
                                     (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
@end lisp

@noindent
Такая схема приведения типов имеет много преимуществ перед методом
явного определения смешанных операций, как это описано выше. Хотя нам
по-прежнему требуется писать процедуры приведения для связи типов
(возможно, @math{n^2} процедур для системы с @math{n} типами), для
каждой пары типов нам нужно написать только одну процедуру, а не по
процедуре на каждый набор типов и каждую обобщенную
операцию.@footnote{Если мы умные, мы обычно можем обойтись меньше, чем
@math{n^2} процедурами приведения типа. Например, если мы знаем, как из
типа 1 получить тип 2, а из типа 2 тип 3, то можно использовать это
знание для преобразования из 1 в 3. Это может сильно уменьшить
количество процедур, которые надо явно задавать при введении нового типа
в систему. Если нам не страшно ввести в свою систему требуемый уровень
изощренности, мы можем заставить ее искать по <<графу>> отношений между
типами и автоматически порождать все процедуры приведения типов, которые
можно вывести из тех, которые явно заданы.} Здесь мы рассчитываем на
то, что требуемая трансформация типов зависит только от самих типов, и
не зависит от операции, которую требуется применить.

С другой стороны, могут существовать приложения, для которых наша схема
приведения недостаточно обща. Даже когда ни один из объектов, которые
требуется сочетать, не может быть приведен к типу другого, операция
может оказаться применимой, если преобразовать оба объекта к третьему
типу. Чтобы справиться с такой степенью сложности и по-прежнему
сохранить модульность в наших программах, обычно необходимо строить
такие системы, которые еще в большей степени используют структуру в
отношениях между типами, как мы сейчас расскажем.

@comment @subsubheading Hierarchies of types
@subsubheading Иерархии типов

Описанная выше схема приведения типов опиралась на существование
естественных отношений между парами типов. Часто в отношениях типов
между собой существует более <<глобальная>> структура. Предположим,
например, что мы строим обобщенную арифметическую систему, которая
должна работать с целыми, рациональными, действительными и комплексными
числами. В такой системе вполне естественно будет рассматривать целое
число как частный случай рационального, которое в свою очередь является
частным случаем действительного числа, которое опять-таки частный случай
комплексного числа. Здесь мы имеем так называемую (@newterm{hierarchy of types}) в
которой, например, целые числа являются (@newterm{subtype}) рациональных чисел (то
есть всякая операция, которую можно применить к рациональному числу,
применима и к целым). Соответственно, мы говорим, что рациональные числа
являются (@newterm{supertype}) целых. Та конкретная иерархия, с которой мы имеем
дело здесь, имеет очень простой вид, а именно, у каждого типа не более
одного надтипа и не более одного подтипа. Такая структура, называемая
(@newterm{tower}), показана на рис. @ref{Рисунок 2.25}.

@float
@quotation
@anchor{Рисунок 2.25}
@ifinfo
@strong{Рисунок 2.25:} A tower of types.

@example
 complex
   ^
   |
  real
   ^
   |
rational
   ^
   |
integer
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap2/Fig2.25,11mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 2.25:} A tower of types.}
@sp 0.0
@end iftex
@end quotation
@end float

Если у нас имеется башня типов, то задача добавления нового типа в
систему сильно упрощается, поскольку требуется указать только то, каким
образом новый тип включается в ближайший надтип сверху и то, каким
образом он является надтипом типа, который находится прямо под ним.
Например, если мы хотим к комплексному числу добавить целое, нам не
нужно специально определять процедуру приведения типа
@code{integer->complex}. Вместо этого мы определяем, как можно перевести
целое число в рациональное, рациональное в действительное, и как
действительное число переводится в комплексное. Потом мы позволяем
системе преобразовать целое число в комплексное через все эти
промежуточные шаги и складываем два комплексных числа.

Можно переопределить процедуру @code{apply-generic} следующим образом:
для каждого типа требуется указать процедуру @code{raise}, которая
<<поднимает>> объекты этого типа на один уровень в башне. В таком
случае, когда системе требуется обработать объекты различных типов, она
может последовательно поднимать объекты более низких типов, пока все
объекты не окажутся на одном и том же уровне башни.
(Упражнения @ref{Упражнение 2.83} и @ref{Упражнение 2.84} касаются
деталей реализации такой стратегии.)

Еще одно преимущество башни состоит в том, что легко реализуется
представление о том, что всякий тип <<наследует>> операции своего
надтипа. Например, если мы не даем особой процедуры для нахождения
действительной части целого числа, мы все равно можем ожидать, что
@code{real-part} будет для них определена в силу того, что целые числа
являются подтипом комплексных. В случае башни мы можем устроить так,
чтобы это происходило само собой, модифицировав @code{apply-generic}.
Если требуемая операция не определена непосредственно для типа данного
объекта, мы поднимаем его до надтипа и пробуем еще раз. Так мы ползем
вверх по башне, преобразуя по пути свой аргумент, пока мы либо не найдем
уровень, на котором требуемую операцию можно произвести, либо не
доберемся до вершины (и в таком случае мы сдаемся).

Еще одно преимущество башни над иерархией более общего типа состоит в
том, что она дает нам простой способ <<опустить>> объект данных до его
простейшего представления. Например, если мы складываем @math{2+3i} с
@math{4-3i}, было бы приятно в качестве ответа получить целое 6, а не
комплексное @math{6+0i}. В упражнении @ref{Упражнение 2.85}
обсуждается способ, которым такую понижающую операцию можно реализовать.
(Сложность в том, что нам нужен общий способ отличить объекты, которые
можно понизить, вроде @math{6+0i}, от тех, которые понизить нельзя,
например @math{6+2i}.)

@float
@quotation
@anchor{Рисунок 2.26}
@ifinfo
@strong{Рисунок 2.26:} Relations among types of geometric figures.

@example
                     polygon
                    /       \
                   /         \
            triangle         quadrilateral
            /     \              /     \
           /       \            /       \
     isosceles   right      trapezoid   kite
     triangle    triangle       |         |
      |     \      |            |         |
      |      \     |            |         |
equilateral   isosceles   parallelogram   |
triangle      right          |       \    |
              triangle       |        \   |
                          rectangle  rhombus
                                \    /
                                 \  /
                                square
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap2/Fig2.26e,96mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 2.26:} Relations among types of geometric figures.}
@sp 0.8
@end iftex
@end quotation
@end float

@comment @subsubheading Inadequacies of hierarchies
@subsubheading Неадекватность иерархий

\enlargethispage{\baselineskip}

Если типы данных в нашей системе естественным образом выстраиваются в
башню, это сильно упрощает задачу работы с обобщенными операциями над
различными типами, как мы только что видели. К сожалению, обычно это не
так. На рисунке @ref{Рисунок 2.26} показано более сложное устройство
набора типов, а именно отношения между различными типами геометрических
фигур. Мы видим, что в общем случае у типа может быть более одного
подтипа. Например, и треугольники, и четырехугольники являются
разновидностями многоугольников. В дополнение к этому, у типа может быть
более одного надтипа. Например, равнобедренный прямоугольный треугольник
можно рассматривать и как равнобедренный, и как прямоугольный. Вопрос с
множественными надтипами особенно болезнен, поскольку из-за него
теряется единый способ <<поднять>> тип по иерархии. Нахождение
<<правильного>> надтипа, в котором требуется применить операцию к
объекту, может потребовать долгого поиска по всей сети типов внутри
процедуры вроде @code{apply-generic}. Поскольку в общем случае у типа
несколько подтипов, существует подобная проблема и в сдвиге значения
<<вниз>> по иерархии. Работа с большим количеством связанных типов без
потери модульности при разработке больших систем -- задача очень
трудная, и в этой области сейчас ведется много
исследований.@footnote{Данное утверждение, которое присутствует и в
первом издании этой книги, сейчас столь же верно, как и двенадцать лет
назад. Разработка удобного, достаточно общего способа выражать отношения
между различными типами сущностей (то, что философы называют
<<онтологией>>), оказывается невероятно сложным делом. Основная разница
между той путаницей, которая была десять лет назад, и той, которая есть
сейчас, состоит в том, что теперь множество неадекватных онтологических
теорий оказалось воплощено в массе соответственно неадекватных языков
программирования. Например, львиная доля сложности
объектно-ориентированных языков программирования --- и мелких
невразумительных различий между современными объектно-ориентированными
языками, --- сосредоточена в том, как рассматриваются обобщенные
операции над взаимосвязанными типами. Наше собственное описание
вычислительных объектов в главе @ref{Глава 3}
полностью избегает этих вопросов. Читатели, знакомые с
объектно-ориентированным программированием, заметят, что нам есть, что
сказать в главе 3
о локальном состоянии, но мы ни разу не упоминаем <<классы>> или
<<наследование>>. Мы подозреваем, что на самом деле эти проблемы нельзя
рассматривать только в терминах проектирования языков программирования,
без обращения к работам по представлению знаний и автоматическому
логическому выводу.}

@quotation
@strong{@anchor{Упражнение 2.81}Упражнение 2.81:}
Хьюго Дум заметил, что @code{apply-generic} может пытаться
привести аргументы к типу друг друга даже тогда, когда их типы и так
совпадают. Следовательно, решает он, нам нужно вставить в таблицу
приведения процедуры, которые приводят (@newterm{coerce}) аргументы
каждого типа к нему самому. Например, в дополнение к приведению
@code{scheme-number->complex}, описанному выше, он бы написал еще:

@lisp
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number
              'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
@end lisp

@enumerate a.

@item
Если установлены процедуры приведения типов, написанные Хьюго, что
произойдет, когда @code{apply-generic} будет вызвана с двумя аргументами
типа @code{scheme-number} или двумя аргументами типа @code{complex} для
операции, которая не находится в таблице для этих типов? Допустим,
например, что мы определили обобщенную процедуру возведения в степень:

@lisp
(define (exp x y) (apply-generic 'exp x y))
@end lisp

@noindent
и добавили процедуру возведения в степень в пакет чисел Scheme и ни в
какой другой:

@lisp
@r{;; Следующие строки добавляются в пакет scheme-number}
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y))))
     @r{; using primitive @code{expt}}
@end lisp

@noindent
Что произойдет, если мы позовем @code{exp} с двумя комплексными числами
в качестве аргументов?

@item
Прав ли Хьюго, что нужно что-то сделать с приведением однотипных
аргументов, или @code{apply-generic} и так работает правильно?

@item
Измените @code{apply-generic} так, чтобы она не пыталась применить
приведение, если у обоих аргументов один и тот же тип.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 2.82}Упражнение 2.82:}
Покажите, как обобщить @code{apply-generic} так, чтобы она
обрабатывала приведение в общем случае с несколькими аргументами. Один
из способов состоит в том, чтобы попытаться сначала привести все
аргументы к типу первого, потом к типу второго, и так далее. Приведите
пример, когда эта стратегия (а также двухаргументная версия, описанная
выше) недостаточно обща. (Подсказка: рассмотрите случай, когда в таблице
есть какие-то подходящие операции со смешанными типами, но обращения к
ним не произойдет.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.83}Упражнение 2.83:}
Предположим, что Вы разрабатываете обобщенную
арифметическую систему для работы с башней типов, показанной на
@ref{Рисунок 2.25}: целые, рациональные, действительные,
комплексные. Для каждого из типов (кроме комплексного), разработайте
процедуру, поднимающую объект на один уровень в башне. Покажите, как
ввести обобщенную операцию @code{raise}, которая будет работать для всех
типов (кроме комплексных чисел).
@end quotation

@quotation
@strong{@anchor{Упражнение 2.84}Упражнение 2.84:}
Используя операцию @code{raise} из
упражнения @ref{Упражнение 2.83}, измените процедуру
@code{apply-generic} так, чтобы она приводила аргументы к одному типу
путем последовательного подъема, как описано в этом разделе. Потребуется
придумать способ проверки, какой из двух типов выше по башне. Сделайте
это способом, <<совместимым>> с остальной системой, так, чтобы не
возникало проблем при добавлении к башне новых типов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.85}Упражнение 2.85:}
В этом разделе упоминался метод <<упрощения>> объекта
данных путем спуска его по башне насколько возможно вниз. Разработайте
процедуру @code{drop}, которая делает это для башни, описанной в
упражнении @ref{Упражнение 2.83}. Ключ к задаче состоит в том, что
надо решить некоторым общим способом, можно ли понизить объект в типе.
Например, комплексное число @math{1.5+0i} можно опустить до @code{real},
комплексное число @math{1+0i} до @code{integer}, а комплексное число
@math{2+3i} никуда понизить нельзя. Вот план того, как определить, можно
ли понизить объект: для начала определите обобщенную операцию
@code{project}, которая <<сталкивает>> объект вниз по башне. Например,
проекция комплексного числа будет состоять в отбрасывании его мнимой
части. Тогда число можно сдвинуть вниз в том случае, если, спроецировав
его, а затем подняв обратно до исходного типа, мы получаем нечто, равное
исходному числу. Покажите как реализовать эту идею в деталях, написав
процедуру @code{drop}, которая опускает объект как можно ниже.
Потребуется разработать различные операции
проекции@footnote{Действительное число можно спроецировать на целое при
помощи примитива , который возвращает целое число, ближайшее к своему
аргументу.} и установить @code{project} в системе в качестве обобщенной
операции. Вам также потребуется обобщенный предикат равенства, подобный
описанному в упражнении @ref{Упражнение 2.79}. Наконец, используя
@code{drop}, перепишите @code{apply-generic} из упражнения
@ref{Упражнение 2.84}, чтобы она <<упрощала>> свои результаты.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.86}Упражнение 2.86:}
Допустим, нам хочется работать с комплексными числами, чьи
действительные и мнимые части, модули и аргументы могут быть
обыкновенными числами, рациональными числами либо любыми другими, какие
нам захочется добавить к системе. Опишите и реализуйте изменения в
системе, которые потребуются, чтобы добавить такую возможность. Вам
придется определить операции вроде @code{sine} (синус) и @code{cosine}
(косинус), обобщенные на обыкновенные и рациональные числа.
@end quotation

@comment @subsection Example: Symbolic Algebra
@subsection Пример: символьная алгебра
@node	2.5.3,  , 2.5.2, 2.5

Обработка символьных алгебраических выражений представляет собой сложный
процесс, который иллюстрирует многие тяжелейшие проблемы, возникающие
при проектировании больших систем. В общем случае, алгебраическое
выражение можно рассматривать как иерархическую структуру, дерево
операций, применяемых к операндам. Мы можем строить алгебраические
выражения, начиная с элементарных объектов, таких, как константы и
переменные, и комбинируя их с помощью алгебраических операций, таких,
как сложение и умножение. Как и в других языках, мы формируем
абстракции, которые позволяют нам именовать составные объекты при помощи
простых терминов. В символьной алгебре типичными абстракциями являются
такие понятия, как линейная комбинация, многочлен, рациональная или
тригонометрическая функция. Мы можем рассматривать их как составные
<<типы>>, которые часто бывают полезны при управлении обработкой
выражений. Например, выражение
@ifinfo

@example
x^2 sin (y^2 + 1) + x cos 2y + cos(y^3 - 2y^2)
@end example

@end ifinfo
@tex
$$ x^2 \sin (y^2 + 1) + x \cos 2y + \cos(y^3 - 2y^2) $$
@end tex
@noindent
можно рассматривать
как многочлен по @math{x} с коэффициентами, которые являются
тригонометрическими функциями многочленов по @math{y}, чьи коэффициенты,
в свою очередь, целые числа.

Здесь мы не будем пытаться разработать полную систему для работы с
алгебраическими выражениями. Такие системы --- очень сложные программы,
использующие глубокие математические знания и элегантные алгоритмы. Мы
собираемся описать только одну простую, но важную часть алгебраических
операций --- арифметику многочленов. Мы проиллюстрируем типы решений,
которые приходится принимать разработчику подобной системы, и то, как
применить идеи абстракции данных и обобщенных операций, чтобы с их
помощью организовать работу.

@comment @subsubheading Arithmetic on polynomials
@subsubheading Арифметика многочленов

Первая задача при разработке системы для проведения арифметических
операций над многочленами --- решить, что именно представляет собой
многочлен. Обычно многочлены определяют по отношению к тем или иным
переменным. Ради простоты, мы ограничимся многочленами только с одной
переменной.@footnote{С другой стороны, мы разрешаем многочлены,
коэффициенты которых сами по себе являются многочленами от других
переменных. По существу, это дает нам такую же выразительную силу, что и
у полной системы со многими переменными, хотя и ведет к проблемам
приведения, как это обсуждается ниже.}. Мы определяем многочлен как
сумму термов, каждый из которых представляет собой либо коэффициент,
либо переменную, возведенную в степень, либо произведение того и
другого. Коэффициент определяется как алгебраическое выражение, не
зависящее от переменной многочлена. Например,
@ifinfo

@example
5x^2 + 3x + 7
@end example

@end ifinfo
@tex
$$ 5x^2 + 3x + 7 $$
@end tex
@noindent
есть простой многочлен с переменной @math{x}, а
@ifinfo

@example
(y^2 + 1)x^3 + (2y)x + 1
@end example

@end ifinfo
@tex
$$ (y^2 + 1)x^3 + (2y)x + 1 $$
@end tex
@noindent
есть многочлен по @math{x}, коэффициенты которого --- многочлены по @math{y}.

Уже здесь мы сталкиваемся с несколькими неудобными деталями. Является ли
первый из приведенных многочленов тем же объектом, что
@math{5y^2 + 3y + 7}? Разумный ответ на этот вопрос таков: <<если мы
рассматриваем многочлен как чисто математическую функцию, то да, но если
как синтаксическую форму, то нет>>. Второй пример алгебраически
эквивалентен многочлену по @math{y}, коэффициенты которого ---
многочлены по @math{x}. Должна ли наша система распознавать это?
Наконец, существуют другие способы представления многочленов ---
например, как произведение линейных множителей, как множество корней
(для многочлена с одной переменной), или как список значений многочлена
в заданном множестве точек.@footnote{В случае многочленов с одной
переменной задание значений многочлена в определенном множестве точек
может быть особенно удачным представлением. Арифметика многочленов
получается чрезвычайно простой. Чтобы получить, скажем, сумму двух
представленных таким образом многочленов, достаточно сложить значения в
соответствующих точках. Чтобы перейти обратно к более привычному
представлению, можно использовать формулу интерполяции Лагранжа, которая
показывает, как восстановить коэффициенты многочлена степени @math{n},
имея его значения в @math{n+1} точке.} Мы можем обойти эти вопросы,
решив, что в нашей системе алгебраических вычислений <<многочлен>> будет
определенной синтаксической формой, а не ее математическим значением.

Теперь пора подумать, как мы будем осуществлять арифметические операции
над многочленами. В нашей упрощенной системе мы рассмотрим только
сложение и умножение. Более того, мы будем настаивать, чтобы два
многочлена, над которыми проводится операция, имели одну и ту же
переменную.

К проектированию системы мы приступим, следуя уже знакомой нам
дисциплине абстракции данных. Мы будем представлять многочлены в виде
структуры данных под названием @newterm{poly}, которая состоит из переменной и набора
термов. Мы предполагаем, что имеются селекторы @code{variable} и
@code{term-list}, которые получают из poly эти данные, и конструктор
@code{make-poly}, который собирает poly из переменной и списка термов.
Переменная будет просто символом, так что для сравнения переменных мы
сможем использовать процедуру из раздела @ref{2.3.2}. Следующие
процедуры определяют сложение и умножение многочленов:

@lisp
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: ADD-POLY" (list p1 p2))))
(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: MUL-POLY" (list p1 p2))))
@end lisp

@noindent
Чтобы включить многочлены в нашу обобщенную арифметическую систему, нам
потребуется снабдить их метками типа. Мы будем пользоваться меткой
@code{polynomial} и вносить соответствующие операции над помеченными
многочленами в таблицу операций. Весь свой код мы включим в процедуру
установки пакета многочленов, подобно пакетам из
раздела @ref{2.5.1}:

@lisp
(define (install-polynomial-package)
  @r{;; внутренние процедуры}
  @r{;; представление poly}
  (define (make-poly variable term-list) (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  @math{\langle}@emph{процедуры @emph{same-variable?} и @emph{variable?} из раздела 2.3.2}@math{\rangle}
  @r{;; представление термов и списков термов}
  @math{\langle}@emph{процедуры @emph{adjoin-term} @dots{} @emph{coeff} из текста ниже}@math{\rangle}
  (define (add-poly p1 p2) @dots{})
  @math{\langle}@emph{процедуры, которыми пользуется @emph{add-poly}}@math{\rangle}
  (define (mul-poly p1 p2) @dots{})
  @math{\langle}@emph{процедуры, которыми пользуется @emph{mul-poly}}@math{\rangle}
  @r{;; интерфейс к остальной системе}
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)
@end lisp

@noindent
Сложение многочленов происходит по термам. Термы одинакового порядка (то
есть имеющие одинаковую степень переменной многочлена) нужно
скомбинировать. Это делается при помощи порождения нового терма того же
порядка, в котором коэффициент является суммой коэффициентов слагаемых.
Термы одного слагаемого, для которых нет соответствия в другом, просто
добавляются к порождаемому многочлену-сумме.

Для того, чтобы работать со списками термов, мы предположим, что имеется
конструктор @code{the-empty-termlist}, который возвращает пустой список
термов, и конструктор @code{adjoin-term}, который добавляет к списку
термов еще один. Кроме того, мы предположим, что имеется предикат
@code{empty-termlist?}, который говорит, пуст ли данный список, селектор
@code{first-term}, который получает из списка термов тот, у которого
наибольший порядок, и селектор @code{rest-terms}, который возвращает все
термы, кроме того, у которого наибольший порядок. Мы предполагаем, что
для работы с термами у нас есть конструктор @code{make-term}, строящий
терм с указанными порядком и коэффициентом, и селекторы @code{order} и
@code{coeff}, которые, соответственно, возвращают порядок и коэффициент
терма. Эти операции позволяют нам рассматривать и термы, и их списки как
абстракции данных, о конкретной реализации которых мы можем позаботиться
отдельно.

Вот процедура, которая строит список термов для суммы двух
многочленов:@footnote{Эта операция очень похожа на процедуру объединения
множеств @code{union-set}, которую мы разработали в
упражнении @ref{Упражнение 2.62}. На самом деле, если мы будем
рассматривать многочлены как множества, упорядоченные по степени
переменной, то программа, которая порождает список термов для суммы,
окажется почти идентична @code{union-set}.}

@lisp
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1))
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
@end lisp

@noindent
Самая важная деталь, которую здесь надо заметить, --- это что для
сложения коэффициентов комбинируемых термов мы использовали обобщенную
процедуру @code{add}. Это влечет глубокие последствия, как мы увидим
ниже.

Чтобы перемножить два списка термов, мы умножаем каждый терм из первого
списка на все термы второго, используя в цикле
@code{mul-term-by-allterms}, которая умножает указанный терм на все
термы указанного списка. Получившиеся списки термов (по одному на каждый
терм в первом списке) накапливаются и образуют сумму. Перемножение двух
термов дает терм, порядок которого равен сумме порядков множителей, а
коэффициент равен произведению коэффициентов множителей:

@lisp
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
@end lisp

@noindent
Вот и все, что нам требуется для сложения и умножения многочленов.
Обратите внимание, что, поскольку мы работаем с термами при помощи
обобщенных процедур @code{add} и @code{mul}, наш пакет работы с
многочленами автоматически оказывается в состоянии обрабатывать любой
тип коэффициента, о котором знает обобщенный арифметический пакет. Если
мы подключим механизм приведения типов, подобный тому, который
обсуждался в разделе @ref{2.5.2}, то
мы автоматически окажемся способны производить операции над многочленами
с коэффициентами различных типов, например
@ifinfo

@example
                         /        2                 \
[3x^2 + (2 + 3i)x + 7] * | x^4 + --- x^2 + (5 + 3i) |
                         \        3                 /
@end example

@end ifinfo
@tex
$$ [3x^2 + (2 + 3i)x + 7] \cdot \! \left[ x^4 + {2\over3} x^2 + (5 + 3i) \right]\!. $$
@end tex
Поскольку мы установили процедуры сложения и умножения многочленов
@code{add-poly} и @code{mul-poly} в обобщенной арифметической системе в
качестве операций @code{add} и @code{mul} для типа @code{polynomial},
наша система оказывается автоматически способна производить операции над
многочленами вроде
@ifinfo

@example
[(y + 1)x^2 + (y^2 + 1)x + (y - 1)] * [(y - 2)x + (y^3 + 7)]
@end example

@end ifinfo
@tex
$$ \Big[(y + 1)x^2 + (y^2 + 1)x + (y - 1)\Big] \cdot \Big[(y - 2)x + (y^3 + 7)\Big]\!. $$
@end tex
Причина этого в том, что, когда система пытается скомбинировать коэффициенты,
она диспетчирует через @code{add} и @code{mul}. Поскольку коэффициенты
сами по себе являются многочленами (по @math{y}), они будут
скомбинированы при помощи @code{add-poly} и @code{mul-poly}. В
результате получается своего рода <<рекурсия, управляемая данными>>,
где, например, вызов @code{mul-poly} приводит к рекурсивным вызовам
@code{mul-poly} для того, чтобы скомбинировать коэффициенты. Если бы
коэффициенты коэффициентов сами по себе были бы многочленами (это может
потребоваться, если надо представить многочлены от трех переменных),
программирование, управляемое данными, позаботится о том, чтобы система
прошла еще через один уровень рекурсивных вызовов, и так далее, на
столько уровней структуры, сколько требуют данные.@footnote{Чтобы все это
работало совершенно гладко, потребуется добавить в нашу систему
обобщенной арифметики возможность привести <<число>> к типу многочлена,
рассматривая его как многочлен степени ноль, коэффициентом которого
является данное число. Это нужно, если мы хотим осуществлять операции
вроде
@ifinfo

@example
[x^2 + (y + 1)x + 5] + [x^2 + 2x + 1]
@end example

@end ifinfo
@tex
$$ [x^2 + (y + 1)x + 5] + [x^2 + 2x + 1], $$
@end tex
@noindent
где требуется сложить коэффициент @math{y+1} с коэффициентом 2.}

@comment @subsubheading Representing term lists
@subsubheading Представление списков термов

Наконец, мы сталкиваемся с задачей реализовать хорошее представление для
списков термов. Список термов, в сущности, есть множество коэффициентов,
проиндексированное порядком терма. Следовательно, любой из методов
представления множеств, описанных в @ref{2.3.3}, годится для этой задачи. С
другой стороны, наши процедуры @code{add-terms} и @code{mul-terms}
всегда обрабатывают списки термов последовательно от наибольшего порядка
к наименьшему, так что мы будем использовать некоторую разновидность
упорядоченного представления.

Как нам устроить структуру данных, которая представляет список термов?
Одно из соображений --- <<плотность>> многочленов, с которыми мы будем
работать. Многочлен называется (@newterm{dense}), если в термах с большинством
порядков у него ненулевые коэффициенты. Если же в нем много нулевых
коэффициентов, он называется (@newterm{sparse}). Например,
@ifinfo

@example
A : x^5 + 2x^4 + 3x^2 - 2x - 5
@end example

@end ifinfo
@tex
$$ A: \quad x^5 + 2x^4 + 3x^2 - 2x - 5 $$
@end tex
@noindent
плотный многочлен, а
@ifinfo

@example
B : x^100 + 2x^2 + 1
@end example

@end ifinfo
@tex
$$ B: \quad x^{100} + 2x^2 + 1 $$
@end tex
@noindent
разреженный.

Списки термов плотных многочленов эффективнее всего представлять в виде
списков коэффициентов. Например, A в приведенном примере удобно
представляется в виде @code{(1 2 0 3 -2 -5)}. Порядок терма в таком
представлении есть длина списка, начинающегося с этого коэффициента,
уменьшенная на 1.@footnote{В этих примерах многочленов мы предполагаем,
что реализовали обобщенную арифметическую систему при помощи механизма
типов, предложенного в упражнении @ref{Упражнение 2.78}. Таким
образом, коэффициенты, которые являются обыкновенными числами, будут
представлены самими числами, а не парами с первым элементом ---
символом @code{scheme-number}.} Для разреженного многочлена вроде B
такое представление будет ужасным: получится громадный список нулей, в
котором изредка попадаются одинокие ненулевые термы. Более разумно
представление разреженного многочлена в виде списка ненулевых термов,
где каждый терм есть список, содержащий порядок терма и коэффициент при
этом порядке. При такой схеме многочлен B эффективно представляется в
виде @code{((100 1) (2 2) (0 1))}. Поскольку большинство операций над
многочленами применяется к разреженным многочленам, мы используем это
представление. Мы предполагаем, что список термов представляется в виде
списка, элементами которого являются термы, упорядоченные от бо́льшего
порядка к меньшему. После того, как решение принято, реализация
селекторов и конструкторов для термов и списков термов не представляет
трудностей:@footnote{Хотя мы предполагаем, что списки термов упорядочены,
мы реализовали @code{adjoin-term} путем простого @code{cons} к
существующему списку термов. Нам это может сойти с рук, пока мы
гарантируем, что процедуры (вроде @code{add-terms}), которые используют
@code{adjoin-term}, всегда вызывают ее с термом бо́льшего порядка, чем
уже есть в списке. Если бы нам не хотелось давать такую гарантию, мы
могли бы реализовать @code{adjoin-term} подобно конструктору
@code{adjoin-set} для представления множеств в виде упорядоченных
списков (упражнение @ref{Упражнение 2.61}).}:

@lisp
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))
(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
@end lisp

@noindent
где @code{=zero?} работает так, как определяется в @ref{Упражнение 2.80}
(см. также ниже @ref{Упражнение 2.87}).

Пользователи многочленного пакета будут создавать (помеченные)
многочлены при помощи процедуры:

@lisp
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
@end lisp

@quotation
@strong{@anchor{Упражнение 2.87}Упражнение 2.87:}
Установите @code{=zero? } для многочленов в обобщенный
арифметический пакет. Это позволит @code{adjoin-term} работать с
многочленами, чьи коэффициенты сами по себе многочлены.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.88}Упражнение 2.88:}
Расширьте систему многочленов так, чтобы она включала
вычитание многочленов. (Подсказка: может оказаться полезным определить
обобщенную операцию смены знака.)
@end quotation

@quotation
@strong{@anchor{Упражнение 2.89}Упражнение 2.89:}
Определите процедуры, которые реализуют представление в
виде списка термов, описанное выше как подходящее для плотных
многочленов.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.90}Упражнение 2.90:}
Допустим, что мы хотим реализовать систему многочленов,
которая эффективна как для плотных, так и для разреженных многочленов.
Один из способов это сделать заключается в том, чтобы разрешить в
системе оба типа представления. Ситуация аналогична примеру с
комплексными числами из раздела @ref{1.4}, где мы
позволили сосуществовать декартову и полярному представлению. Чтобы
добиться этого, нам придется различать виды списков термов и сделать
операции над списками термов обобщенными. Перепроектируйте систему с
многочленами так, чтобы это обобщение было реализовано. Это потребует
большого труда, а не только локальных изменений.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.91}Упражнение 2.91:}
Многочлены с одной переменной можно делить друг на друга,
получая частное и остаток. Например,
@ifinfo

@example
x^5 - 1
------- = x^3 + x, remainder x - 1
x^2 - 1
@end example

@end ifinfo
@tex
$$ {x^5 - 1 \over x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1. $$
@end tex
Деление можно производить в столбик. А именно, разделим старший член
делимого на старший член делителя. В результате получится первый терм
частного. Затем умножим результат на делитель, вычтем получившийся
многочлен из делимого и, рекурсивно деля разность на делитель, получим
оставшуюся часть частного. Останавливаемся, когда порядок делителя
превысит порядок делимого, и объявляем остатком то, что тогда будет
называться делимым. Кроме того, если когда-нибудь делимое окажется
нулем, возвращаем ноль в качестве и частного, и остатка.

Процедуру @code{div-poly} можно разработать, следуя образцу
@code{add-poly} и @code{mul-poly}. Процедура проверяет, одна ли и та же
у многочленов переменная. Если это так, @code{div-poly} откусывает
переменную и передает задачу в @code{div-terms}, которая производит
операцию деления над списками термов. Наконец, @code{div-poly}
прикрепляет переменную к результату, который выдает @code{div-terms}.
Удобно сделать так, чтобы @code{div-terms} выдавала и частное, и остаток
при делении. Она может брать в качестве аргументов два терма и выдавать
список, состоящий из списка термов частного и списка термов остатка.

Закончите следующее определение @code{div-terms}, вставив недостающие
выражения. Используйте ее, чтобы реализовать @code{div-poly}, которая
получает в виде аргументов два экземпляра poly, а выдает список из
poly--частного и poly--остатка.

@smalllisp
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     @math{\langle}@var{рекурсивно вычислить оставшуюся}@math{\rangle} ))
                @math{\langle}@var{сформировать окончательный резальтат}@math{\rangle} ))))))
@end smalllisp
@end quotation

@comment @subsubheading Hierarchies of types in symbolic algebra
@subsubheading Иерархии типов в символьной алгебре

Наша система обработки многочленов показывает, как объекты одного типа
(многочлены) могут на самом деле быть составными сущностями, содержащими
в качестве частей объекты многих различных типов. При определении
обобщенных операций это не составляет никакой реальной сложности. Нужно
только установить соответствующие обобщенные операции для выполнения
необходимых действий над частями составных типов. В сущности, мы видели,
что многочлены образуют своего рода <<рекурсивную абстракцию данных>>, в
том смысле, что части многочленов сами по себе могут быть многочленами.
Наши обобщенные операции и наш стиль программирования, управляемого
данными, могут справиться с такими трудностями без особого труда.

С другой стороны, алгебра многочленов представляет собой систему, в
которой типы данных нельзя естественным образом выстроить в виде башни.
Например, могут существовать многочлены по @math{x}, коэффициенты
которых являются многочленами по @math{y}. Но могут существовать и
многочлены по @math{y}, коэффициенты которых являются многочленами по
@math{x}. Никакой из этих типов не находится <<выше>> другого ни в каком
естественным смысле, и тем не менее элементы этих двух множеств часто
требуется складывать. Для этого существует несколько способов. Одна из
возможностей состоит в том, чтобы преобразовывать один из многочленов к
типу другого путем раскрытия и переупорядочения термов, так, чтобы у
обоих многочленов оказалась одна и та же главная переменная. Можно
навязать данным башнеподобную структуру путем упорядочения переменных,
и, таким образом, всегда преобразовывать любой многочлен к
<<канонической форме>>, где переменная с наибольшим приоритетом всегда
доминирует, а переменные с меньшим оказываются зарыты в коэффициенты.
Такая стратегия работает довольно хорошо, только преобразование может
без особой необходимости <<раздуть>> многочлен, так что его станет
неудобно читать и, возможно, менее эффективно обрабатывать. Для этой
области структура башни определенно не является естественной, как и для
любой другой области, где пользователь может изобретать новые типы
динамически, используя старые в различных комбинирующих формах, таких
как тригонометрические функции, последовательности степеней или
интегралы.

Не должно вызывать удивления то, что управление приведением типов
представляет серьезную проблему при разработке крупных систем
алгебраических манипуляций. Существенная часть сложности таких систем
связана с отношениями между различными типами. В сущности, можно честно
признать, что мы до сих пор не до конца понимаем приведение типов. Мы
даже не до конца осознаем понятие типа данных. Однако то, что мы знаем,
дает нам солидные принципы структурирования и модуляризации, которые
помогают в разработке больших систем.

@quotation
@strong{@anchor{Упражнение 2.92}Упражнение 2.92:}
Использовав упорядочение переменных, расширьте пакет работы
с многочленами так, чтобы сложение и умножение многочленов работало для
многочленов с несколькими переменными. (Это не простая задача!)
@end quotation

@comment @subsubheading Extended exercise: Rational functions
@subsubheading Расширенное упражнение: рациональные функции

Можно расширить обобщенную арифметическую систему и включить в нее
(@newterm{rational functions}). Это <<дроби>>, в которых числитель и знаменатель
являются многочленами, например
@ifinfo

@example
 x + 1
-------
x^3 - 1
@end example

@end ifinfo
@tex
$$ {x + 1 \over x^3 - 1}\,. $$
@end tex
Система должна уметь складывать, вычитать. умножать и делить рациональные
функции, а также осуществлять вычисления вроде
@ifinfo

@example
 x + 1       x      x^3 + 2x^2 + 3x + 1
------- + ------- = -------------------
x^3 - 1   x^2 - 1    x^4 + x^3 - x - 1
@end example

@end ifinfo
@tex
$$ {x + 1 \over x^3 - 1} + {x \over x^2 - 1} =
    {x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}\,. $$
@end tex
@noindent

(здесь сумма упрощена при помощи сокращения общих множителей. Обычное
<<перекрестное умножение>> дало бы многочлен четвертой степени в числителе
и пятой в знаменателе.)

Если мы изменим пакет арифметики рациональных чисел так, чтобы он
использовал обобщенные операции, то он будет делать то, что нам
требуется, за исключением задачи приведения к наименьшему знаменателю.

@quotation
@strong{@anchor{Упражнение 2.93}Упражнение 2.93:}
Модифицируйте пакет арифметики рациональных чисел, заставив
его пользоваться обобщенными операциями, но при этом измените
@code{make-rat}, чтобы она не пыталась сокращать дроби. Проверьте
систему, применив @code{make-rational} к двум многочленам, и получив
рациональную функцию

@lisp
(define p1 (make-polynomial 'x '((2 1) (0 1))))
(define p2 (make-polynomial 'x '((3 1) (0 1))))
(define rf (make-rational p2 p1))
@end lisp

Сложите теперь @code{rf} саму с собой, используя @code{add}. Вы увидите,
что процедура сложения не приводит дроби к наименьшему знаменателю.
@end quotation

@noindent
Приводить дроби многочленов к наименьшему знаменателю мы можем,
используя ту же самую идею, которой мы воспользовались для целых чисел:
изменить @code{make-rat}, чтобы она делила и числитель, и знаменатель на
их наибольший общий делитель. Понятие <<наибольшего общего делителя>>
имеет смысл для многочленов. Более того, вычислять НОД для многочленов
можно с помощью, в сущности, того же алгоритма Евклида, который работает
на целых числах.@footnote{То, что алгоритм Евклида работает для
многочленов, в алгебре формализуется утверждением, что многочлены
образуют структуру, называемую (Euclidean ring). Евклидово кольцо ---
это структура, на которой определены сложение, вычитание и коммутативное
умножение, а также некоторый способ сопоставить каждому элементу кольца
@math{x} <<меру>> --- неотрицательное целое число @math{m(x)},
обладающую следующими свойствами: @math{m(xy) \ge m(x)} для любых
ненулевых @math{x} и @math{y}, а также для любых @math{x} и @math{y}
существует @math{q}, такое, что @math{y = qx + r} и либо @math{r=0},
либо @math{m(r) < m(x)}. С абстрактной точки зрения, это все, что нужно,
чтобы доказать, что алгоритм Евклида работает. В случае целых чисел,
мера @math{m} каждого числа есть его модуль. Для структуры многочленов
мерой служит степень многочлена.} Вот целочисленная версия:

@lisp
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
@end lisp

@noindent
Взяв ее за основу, мы можем проделать очевидные изменения и определить
операцию извлечения НОД, которая работает на списках термов:

@lisp
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
@end lisp

@noindent
где @code{remainder-terms} извлекает компоненту списка, соответствующую
остатку, из списка, который возвращает операция деления списков термов
@code{divterms}, реализованная в упражнении @ref{Упражнение 2.91}.

@quotation
@strong{@anchor{Упражнение 2.94}Упражнение 2.94:}
Используя @code{div-terms}, напишите процедуру
@code{remainder-terms}, и с ее помощью определите @code{gcd-terms}, как
показано выше. Напишите теперь процедуру @code{gcd-polys}, которая
вычисляет НОД двух многочленов. (Процедура должна сообщать об ошибке,
если входные объекты являются многочленами от разных переменных.)
Установите в систему обобщенную операцию @code{greatest-common-divisor},
которая для многочленов сводится к @code{gcd-poly}, а для обыкновенных
чисел к обыкновенному @code{gcd}. В качестве проверки, попробуйте ввести

@lisp
(define p1 (make-polynomial
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
@end lisp

@noindent
и проверьте результат вручную.
@end quotation

@quotation
@strong{@anchor{Упражнение 2.95}Упражнение 2.95:}
Пусть @math{P_1}, @math{P_2} и @math{P_3} -- многочлены

@ifinfo

@example
P_1 : x^2 - 2x + 1

P_2 : 11x^2 + 7

P_3 : 13x + 5
@end example

@end ifinfo
@tex
$$
\begin{array}{l@{{}:}l}
    P_1 	& \quad x^2 - 2x + 1, \\
    P_2 	& \quad 11x^2 + 7, \\
    P_3 	& \quad 13x + 5.
\end{array}
$$
@end tex
Теперь пусть @math{Q_1} будет произведение @math{P_1} и
@math{P_2}, а @math{Q_2} произведение @math{P_1} и @math{P_3}. При
помощи @code{greatest-common-divisor}
(упражнение @ref{Упражнение 2.94}) вычислите НОД @math{Q_1} и
@math{Q_2}. Обратите внимание, что ответ не совпадает с @math{P_1}. Этот
пример вводит в вычисление операции с нецелыми числами, и это создает
сложности для алгоритма вычисления НОД.@footnote{В системах вроде MIT
Scheme получится многочлен, который на самом деле является делителем
@math{Q_1} и @math{Q_2}, но с рациональными коэффициентами. Во многих
других реализациях Scheme, где при делении целых чисел могут получаться
десятичные числа ограниченной точности, может оказаться, что мы не
получим правильного делителя.}. Чтобы понять, что здесь происходит,
попробуйте включить трассировку в @code{gcd-terms} при вычислении НОД
либо проведите деление вручную.
@end quotation

@noindent
Проблему, которую демонстрирует упражнение @ref{Упражнение 2.95},
можно решить, если мы используем следующий вариант алгоритма вычисления
НОД (который работает только для многочленов с целыми коэффициентами).
Прежде, чем проводить деление многочленов при вычислении НОД, мы
умножаем делимое на целую константу, которая выбирается так, чтобы в
процессе деления не возникло никаких дробей. Результат вычисления будет
отличаться от настоящего НОД на целую константу, но при приведении
рациональных функций к наименьшему знаменателю это несущественно; будет
проведено деление и числителя, и знаменателя на НОД, так что константный
множитель сократится.

\enlargethispage{\baselineskip}

Выражаясь более точно, если @math{P} и @math{Q} --- многочлены,
определим @math{O_1} как порядок @math{P} (то есть порядок его старшего
терма), а @math{O_2} как порядок @math{Q}. Пусть @math{c} будет
коэффициент старшего терма @math{Q}. В таком случае, можно показать, что
если мы домножим @math{P} на (@newterm{integerizing factor}) @math{c^{1+O_1-O_2}},
то получившийся многочлен можно будет поделить на @math{Q} алгоритмом
@code{div-terms}, получив результат, в котором не будет никаких дробей.
Операция домножения делимого на такую константу, а затем деления, иногда
называется (@newterm{pseudodivision}) @math{P} на @math{Q}. Остаток такого
деления называется (@newterm{pseudoremainder}).

@quotation
@strong{@anchor{Упражнение 2.96}Упражнение 2.96:}
@enumerate a.

@item
Напишите процедуру @code{pseudoremainder-terms}, которая работает в
точности как @code{remainder-terms}, но только прежде, чем позвать
@code{div-terms}, домножает делимое на множитель целости, описанный
выше. Модифицируйте @code{gcd-terms} так, чтобы она использовала
@code{pseudoremainder-terms}, и убедитесь, что теперь в примере из
упражнения @ref{Упражнение 2.95} @code{greatest-common-divisor} выдает
ответ с целыми коэффициентами.

@item
Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты
@math{P_1}. Измените @code{gcd-terms}, чтобы она убирала общий множитель
из коэффициентов ответа путем деления всех коэффициентов на их
(целочисленный) НОД.

@end enumerate
@end quotation

@noindent
Итак, вот как привести рациональную функцию к наименьшему знаменателю:

@itemize @bullet

@item
Вычислите НОД числителя и знаменателя, используя версию @code{gcd-terms}
из упражнения @ref{Упражнение 2.96}.

@item
Когда Вы получаете НОД, домножьте числитель и знаменатель на множитель
целости, прежде чем делить на НОД, чтобы при делении не получить дробных
коэффициентов. В качестве множителя можно использовать старший
коэффициент НОД, возведенный в степень @math{1 + O_1 - O_2}, где
@math{O_2} -- порядок НОД, а @math{O_1} --- максимум из порядков
числителя и знаменателя. Так Вы добьетесь того, чтобы деление числителя
и знаменателя на НОД не привносило дробей.

@item
В результате этой операции Вы получите числитель и знаменатель с целыми
коэффициентами. Обычно из-за всех множителей целости коэффициенты
окажутся очень большими, стало быть, на последнем шаге следует
избавиться от лишних множителей, вычислив (целый) наибольший общий
делитель числителя и знаменателя и поделив на него все термы.
@end itemize

@endpage
@quotation
@strong{@anchor{Упражнение 2.97}Упражнение 2.97:}
@enumerate a.

@item
Реализуйте этот алгоритм как процедуру @code{reduce-terms}, которая
принимает в качестве аргументов два списка термов @code{n} и @code{d} и
возвращает список из @code{nn} и @code{dd}, которые представляют собой
@code{n} и @code{d}, приведенные к наименьшему знаменателю по
вышеописанному алгоритму. Напишите, кроме того, процедуру
@code{reduce-poly}, подобную @code{add-poly}, которая проверяет, чтобы
два poly имели одну и ту же переменную. Если это так, @code{reduce-poly}
откусывает эту переменную и передает оставшуюся часть задачи в
@code{reduce-terms}, а затем прикрепляет переменную обратно к двум
спискам термов, которые получены из @code{reduce-terms}.

@item
Определите процедуру, аналогичную @code{reduce-terms}, которая делает
то, что делала для целых чисел исходная @code{make-rat}:

@lisp
(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
@end lisp

@noindent
и определите @code{reduce} как обобщенную операцию, которая вызывает
@code{apply-generic} и диспетчирует либо к @code{reduce-poly} (если
аргументы --- многочлены), либо к @code{reduce-integers} (для
аргументов типа @code{scheme-number}). Теперь Вы легко можете заставить
пакет рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от @code{make-rat} звать @code{reduce} прежде, чем сочетать
данные числитель и знаменатель в процессе порождения рационального
числа. Теперь система обрабатывает рациональные выражения и для целых
чисел, и для многочленов. Чтобы проверить программу, попробуйте пример,
который приведен в начале этого расширенного упражнения:

@lisp
(define  p1 (make-polynomial 'x '((1 1) (0  1))))
(define  p2 (make-polynomial 'x '((3 1) (0 -1))))
(define  p3 (make-polynomial 'x '((1 1))))
(define  p4 (make-polynomial 'x '((2 1) (0 -1))))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))
(add rf1 rf2)
@end lisp

Посмотрите, удалось ли Вам получить правильный ответ, правильно
приведенный к наименьшему знаменателю.
@end enumerate
@end quotation

@endpage
@noindent
Вычисление НОД находится в центре всякой системы, работающей с
рациональными числами. Алгоритм, который мы использовали в тексте, хотя
математически он естествен, работает очень медленно. Медлительность эта
проистекает отчасти из большого количества операций деления, а отчасти
из огромного размера промежуточных коэффициентов, которые порождаются в
ходе псевдоделения. Одна из активно разрабатываемых областей в теории
систем алгебраических манипуляций -- построение более быстрых алгоритмов
для вычисления НОД многочленов.@footnote{Изящный и чрезвычайно
эффективный метод вычисления НОД многочленов был открыт Ричардом
Зиппелем (Zippel 1979). Этот метод --- вероятностный алгоритм, подобно
быстрому тесту на простоту числа, описанному в главе @ref{Глава 1}.
Книга Зиппеля (@ref{Zippel 1993}) описывает этот метод, а также другие
способы нахождения НОД многочленов.}
