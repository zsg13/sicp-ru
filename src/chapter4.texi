@comment @chapter Metalinguistic Abstraction
@chapter Метаязыковая абстракция
@node    Chapter 4, Chapter 5, Chapter 3, Top

@quotation
@dots{} Именно в словах кроется магия --- в таких, как <<абракадабра>>,
<<Сезам, откройся>> и проч., --- но магические слова из одной истории
перестают быть таковыми в следующей. Настоящая магия состоит в том,
чтобы понять, когда и для чего слово сработает; трюк в том, чтобы
выучить трюк.

@dots{} А слова эти состоят из букв нашего алфавита: пара дюжин
закорючек, которые мы способны черкнуть пером. Вот где ключ @dots{}! И
сокровище тоже, если только мы сумеем его заполучить! Как
будто @dots{} как будто ключ к сокровищу и @emph{есть} само сокровище!

---John Barth, @cite{Chimera} (Перевод Виктора Лапицкого)
@end quotation

@c @sp 0.8

@noindent
\lettrine{И}{сследуя науку проектирования программ}, мы видели, что
программисты-эксперты управляют сложностью своих программ при помощи тех
же общих методик, какими пользуются проектировщики всех сложных систем.
Они сочетают элементарные единицы, получая при этом составные объекты, с
помощью абстракции составных объектов формируют строительные блоки
высших порядков, и при этом с целью сохранения модульности выбирают
наиболее удобный общий взгляд на структуру системы. Демонстрируя эти
методы, мы использовали Лисп как язык для описания процессов и для
построения вычислительных объектов данных, и процессы --- для
моделирования сложных явлений реального мира. Однако по мере того, как
мы сталкиваемся со все более сложными задачами, мы обнаруживаем, что
Лиспа, да и любого заранее заданного языка программирования,
недостаточно для наших нужд. Чтобы эффективнее выражать свои мысли,
постоянно приходится обращаться к новым языкам. Построение новых языков
является мощной стратегией управления сложностью в инженерном
проектировании; часто оказывается, что можно расширить свои возможности
работы над сложной задачей, приняв новый язык, позволяющий нам описывать
(а следовательно, и обдумывать) задачу новым способом, используя
элементы, методы их сочетания и механизмы абстракции, специально
подогнанные под стоящие перед нами проблемы.@footnote{Та же самая идея
встречается во всех областях техники. Например, у
инженеров-электронщиков существует множество языков для описания схем.
Два из них --- это язык электрических @emph{сетей} и язык электрических
@emph{систем}. Язык сетей делает акцент на физическом моделировании
устройств в терминах дискретных электрических элементов. Элементарными
объектами этого языка являются элементарные электрические
компоненты --- резисторы, конденсаторы, катушки индуктивности и
транзисторы, задаваемые через физические переменные: напряжение и ток.
Описывая схемы на языке сетей, инженер озабочен физическими
характеристиками своего проекта. Элементами системного языка, напротив,
являются модули обработки сигнала, например, фильтры и усилители.
Существенно только функциональное поведение модулей, и сигналами
манипулируют безотносительно к тому, в виде какого напряжения или тока
они реализуются физически. Язык систем построен на языке сетей, в том
смысле, что элементы систем обработки сигнала состоят из электрических
схем. Однако здесь инженера интересует крупномасштабная организация
электрических устройств, решающая определенную задачу; их физическая
совместимость подразумевается. Такая послойная организация языков служит
еще одним примером уровневого метода проектирования,
проиллюстрированного в @ref{2.2.4} на примере языка описания изображений.}

Программирование изобилует языками. Есть физические языки, например,
языки машинных кодов для конкретных компьютеров. Основным вопросом для
них является представление данных и управления через отдельные биты
памяти и машинные команды. Пишущий программы на машинном языке озабочен
тем, чтобы при помощи данной аппаратуры создать системы и инструменты
для эффективной реализации вычисления при ограниченных ресурсах. Языки
высокого уровня, возводимые поверх машинных, скрывают вопросы конкретной
реализации данных в виде набора битов и представления программ как
последовательности машинных команд. В этих языках присутствуют средства
комбинации и абстракции, например определения функций, которые подходят
для более крупномасштабной организации систем.

(@newterm{metalinguistic abstraction}), то есть построение новых языков, играет
важную роль во всех отраслях инженерного проектирования. Для
компьютерного программирования она особенно важна, поскольку в
программировании мы можем не только формулировать новые языки, но и
реализовывать их через построение вычислителей. (@newterm{evaluator}) (или
(@newterm{interpreter)}) для языка программирования --- это процедура, которая,
будучи примененной к выражению языка, производит действия, необходимые
для вычисления этого выражения.

Без преувеличения можно сказать, что самая основополагающая идея в
программировании такова:

@quotation
Вычислитель, который определяет значение выражений в языке
программирования --- всего лишь обычная программа.
@end quotation

@noindent
С этой мыслью приходит и новое представление о себе самих: мы начинаем
видеть в себе разработчиков языков, а не просто пользователей языков,
придуманных другими.

На самом деле, почти любую программу можно рассматривать как вычислитель
для какого-то языка. Например, система работы с многочленами из @ref{2.5.3}
заключает в себе правила арифметики многочленов и реализует их в
терминах операций над данными в списочной форме. Если мы дополним эту
систему процедурами для чтения и печати многочленов, то перед нами
окажется ядро специализированного языка для решения задач символьной
математики. И программа моделирования цифровой логики из @ref{3.3.4},
и программа распространения ограничений из @ref{3.3.5}
содержат свои собственные языки, со своими примитивами, средствами их
комбинирования и абстракции. С этой точки зрения, техника работы с
крупномасштабными компьютерными системами сливается с техникой создания
новых компьютерных языков, и вся информатика --- не более (но и не
менее), чем наука о построении подходящих языков описания.

Сейчас мы начинаем обзор методов, которые позволяют создавать одни языки
на основе других. В этой главе в качестве основы мы будем использовать
Лисп, и вычислители будем реализовывать как процедуры на Лиспе. Лисп
особенно хорошо подходит для этой задачи благодаря своей способности
представлять символические выражения и обрабатывать их. Первый шаг к
пониманию того, как реализуются языки, мы сделаем, построив вычислитель
для самого Лиспа. Язык, реализуемый нашим интерпретатором, будет
подмножеством диалекта Лиспа Scheme, которым мы пользуемся в этой книге.
Несмотря на то, что интерпретатор, описанный в этой главе, написан для
конкретного диалекта Лиспа, он содержит основную структуру вычислителя
для любого языка, ориентированного на выражения и предназначенного для
написания программ для последовательной машины. (На самом деле, глубоко
внутри большинства языковых процессоров содержится маленький
интерпретатор <<Лиспа>>.) Этот интерпретатор несколько упрощен для
удобства и наглядности обсуждения, и некоторые детали, которые важно
было бы включить в Лисп-систему промышленного качества, здесь были
оставлены за рамками изложения. Тем не менее, этот простой интерпретатор
способен выполнить большинство программ из данной книги.@footnote{Самое
важное, чего не хватает в нашем интерпретаторе, --- это механизмов,
обрабатывающих ошибки и поддерживающих отладку. Более подробное
обсуждение вычислителей можно найти в книге Friedman, Wand, and Haynes
1992, которая содержит обзор языков программирования на примере
последовательности интерпретаторов, написанных на Scheme.}

Важное преимущество, которое нам дает вычислитель, доступный в виде
программы на Лиспе, состоит в том, что мы можем реализовывать
альтернативные правила вычисления, описывая их как модификации программы
вычислителя. В частности, мы можем извлечь из этой способности немалую
выгоду, добиваясь более полного контроля над тем, как в вычислительных
моделях реализуется понятие времени. Этому вопросу была специально
посвящена @ref{Глава 3}.
Там мы смягчили некоторые сложности работы с состоянием и
присваиваниями, при помощи потоков отделив представление времени во
внешнем мире от времени внутри компьютера. Однако программы, работающие
с потоками, иногда бывали излишне громоздки, поскольку их ограничивал
аппликативный порядок вычисления, принятый в Scheme. В @ref{4.2} мы изменим
язык и получим более изящный подход в виде интерпретатора с
(@newterm{normal-order evaluation}).

В @ref{4.3}
язык меняется более радикально, и выражения получают не одно
единственное значение, а множество. В этом языке (@newterm{nondeterministic
computing}) становится естественным порождать все возможные значения
выражения, а затем искать среди них те, которые удовлетворяют
определенным ограничениям. Если описывать это в терминах вычисления и
времени, то время как будто разветвляется на множество <<возможных
будущих>>, и мы ищем среди них подходящие временные линии. При работе с
недетерминистским интерпретатором отслеживание множества значений и
поиск осуществляются автоматически встроенными механизмами языка.

В @ref{4.4} мы реализуем язык (@newterm{logic programming}), в котором знание
выражается в терминах отношений, а не в
терминах вычислений со входами и выходами. Несмотря на то, что язык при
этом оказывается сильно отличным от Лиспа, как, впрочем, и от любого
привычного языка, мы увидим, что интерпретатор для языка логического
программирования имеет, в сущности, ту же структуру, что и интерпретатор
Lisp.

@menu
* 4-1::              Метациклический интерπретатор
* 4-2::              Scheme с вариациями ленивый интерπретатор
* 4-3::              Scheme с вариациями --- недетерминистское вычисление
* 4-4::              Логическое πрограммирование
@end menu

@comment @section The Metacircular Evaluator
@section Метациклический интерпретатор
@node	4.1, 4.2, Chapter 4, Chapter 4

Наш интерпретатор Лиспа будет реализован как программа на Лиспе. Может
показаться, что размышления о выполнении Лисп-программ при помощи
интерпретатора, который сам написан на Лиспе, составляют порочный круг.
Однако вычисление есть процесс, так что вполне логично описывать процесс
вычисления с помощью Лиспа --- в конце концов, это наш инструмент для
описания процессов.@footnote{Даже с учетом этого, остаются важные стороны
процесса вычисления, которые в нашем интерпретаторе не проясняются.
Самая важная из них --- точные механизмы того, как одни процедуры
вызывают другие и возвращают значения процедурам, которые их вызвали.
Эти вопросы мы рассмотрим в @ref{Глава 5},
где мы исследуем процесс вычисления более внимательно, реализуя
вычислитель как простую регистровую машину.} Интерпретатор, написанный
на языке, который он сам реализует, называется (@newterm{metacircular}).

В сущности, метациклический интерпретатор является формулировкой на
языке Scheme модели вычислений с окружениями, описанной в @ref{3.2}.
Напомним, что в этой модели было две основные части:

@enumerate 1

@item
Чтобы выполнить комбинацию (составное выражение, не являющееся особой
формой), нужно вычислить его подвыражения и затем применить значение
подвыражения-оператора к значениям подвыражений-операндов.

@item
Чтобы применить составную процедуру к набору аргументов, нужно выполнить
тело процедуры в новом окружении. Для того, чтобы построить это
окружение, нужно расширить окружение объекта-процедуры кадром, в котором
формальные параметры процедуры связаны с аргументами, к которым
процедура применяется.

@end enumerate

@noindent
Эти два правила описывают сущность процесса вычисления, основной цикл, в
котором выражения, которые требуется выполнить в окружении, сводятся к
процедурам, которые нужно применить к аргументам, а те, в свою очередь,
сводятся к новым выражениям, которые нужно выполнить в новых окружениях,
и так далее, пока мы не доберемся до символов, чьи значения достаточно
найти в окружении, и элементарных процедур, которые применяются напрямую
(см. @ref{Рисунок 4.1}).@footnote{Если нам дается возможность
применять примитивы, то что остается сделать для реализации
интерпретатора? Задача интерпретатора состоит не в том, чтобы определить
примитивы языка, а в том, чтобы обеспечить связующие элементы ---
средства комбинирования и абстракции, --- которые превращают набор
примитивов в язык. А именно:

@math{\bullet} Интерпретатор позволяет работать с вложенными выражениями. Например,
чтобы вычислить значение выражения @code{(+ 1 6)}, достаточно применения
примитивов, но этого недостаточно для работы с выражением
@code{(+ 1 (* 2 3))}. Сама по себе элементарная процедура @code{+}
способна работать только с числами, и если передать ей аргумент ---
выражение @code{(* 2 3)}, она сломается. Одна из важных задач
интерпретатора --- устроить вычисление так, чтобы @code{(* 2 3)} свелось
к значению 6, прежде чем оно будет передано @code{+} как аргумент.

@math{\bullet} Интерпретатор позволяет использовать переменные. Например, элементарная
процедура сложения не знает, как работать с выражениями вроде
@code{(+ x 1)}. Нам нужен интерпретатор, чтобы следить за переменными и
получать их значения, прежде чем запускать элементарные процедуры.

@math{\bullet} Интерпретатор позволяет определять составные процедуры. При этом нужно
хранить определения процедур, знать, как эти определения используются
при вычислении выражений, и обеспечивать механизм, который позволяет
процедурам принимать аргументы.

@math{\bullet} Интерпретатор дает особые формы, вычисляющиеся иначе, чем вызовы
процедур.} Этот цикл вычисления будет построен в виде взаимодействия
двух основных процедур интерпретатора, @code{eval} и @code{apply},
описанных в @ref{4.1.1} (см. рис. @ref{Рисунок 4.1}).

Реализация интерпретатора будет зависеть от процедур, определяющих
(@newterm{syntax}) выполняемых выражений. При помощи абстракции данных мы сделаем
интерпретатор независимым от представления языка. К примеру, вместо
того, чтобы окончательно решать, что присваивание выражается в виде
списка, в котором первым элементом стоит символ @code{set!}, мы
пользуемся абстрактным предикатом @code{assignment?}, чтобы распознавать
присваивание, и абстрактными селекторами @code{assignment-variable} и
@code{assignment-value}, чтобы обращаться к его частям. Реализация
выражений будет подробно рассмотрена в @ref{4.1.2}. Имеются также операции,
описанные в @ref{4.1.3}, которые определяют представление процедур и окружений. Например,
@code{make-procedure} порождает составные процедуры,
@code{lookup-variable-value} извлекает значения переменных, а
@code{apply-primitive-procedure} применяет элементарную процедуру к
указанному списку аргументов.

@float
@c @quotation
@anchor{Рисунок 4.1}
@ifinfo
@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.

@example
                           .,ad88888888baa,
                  _    ,d8P"""        ""9888ba.      _
                 /  .a8"          ,ad88888888888a   |\
               /   aP'          ,88888888888888888a   \
              /  ,8"           ,88888888888888888888,  \
             |  ,8'            (888888888888888888888, |
            /  ,8'             `8888888888888888888888  \
            |  8)               `888888888888888888888, |
Procedure,  |  8                  "88888 Apply 8888888) | Expression
Arguments   |  8     Eval          `888888888888888888) | Environment
            |  8)                    "8888888888888888  |
            \  (b                     "88888888888888'  /
             | `8,                     8888888888888)  |
             \  "8a                   ,888888888888)  /
              \   V8,                 d88888888888"  /
              _\| `8b,             ,d8888888888P' _/
                     `V8a,       ,ad8888888888P'
                        ""88888888888888888P"
                             """"""""""""

                               [graphic by Normand Veillux, modified]
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.1,100mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.}
@sp 0.7
@end iftex
@c @end quotation
@end float

@menu
* 4-1-1::            Ядро интерπретатора
* 4-1-2::            Представление выражений
* 4-1-3::            Структуры данных интерπретатора
* 4-1-4::            Выπолнение интерπретатора как πрограммы
* 4-1-5::            Данные как πрограммы
* 4-1-6::            Внутренние оπределения
* 4-1-7::            Отделение синтаксического анализа от выπолнения
@end menu

@comment @subsection The Core of the Evaluator
@subsection Ядро интерпретатора
@node	4.1.1, 4.1.2, 4.1, 4.1

Процесс вычисления можно описать как взаимодействие двух процедур:
@code{eval} и @code{apply}.

@comment @subsubheading Eval
@subsubheading Eval

Процедура @code{eval} в качестве аргументов принимает выражение и
окружение. Она относит выражение к одному из возможных классов и
управляет его выполнением. @code{Eval} построена как разбор случаев в
зависимости от синтаксического типа выполняемого выражения. Для того,
чтобы процедура была достаточно общей, определение типа выражения мы
формулируем абстрактно, не связывая себя никакой конкретной реализацией
различных типов выражений. Для каждого типа выражений имеется предикат,
который распознает этот тип, и абстрактные средства для выбора его
частей. Такой (@newterm{abstract syntax}) позволяет легко видеть, как можно
изменить синтаксис языка и использовать тот же самый интерпретатор, но
только с другим набором синтаксических процедур.

\bigskip
@noindent
@b{Элементарные выражения}

@itemize @bullet

@item
Для самовычисляющихся выражений, например, чисел, @code{eval} возвращает
само выражение.

@item
@code{eval} должен находить значения переменных, просматривая окружение.

@end itemize

@noindent
@b{Особые формы}

@itemize @bullet

@item
Для выражений с кавычкой @code{eval} возвращает само закавыченное выражение.
    
@item
Присваивание переменной (или ее определение) должно вызвать @code{eval}
рекурсивно, чтобы вычислить новое значение, которое требуется связать с
переменной. Окружение нужно модифицировать, изменяя (или создавая)
связывание для переменной.

@item
Выражение @code{if} требует специальной обработки своих частей: если
предикат истинен, нужно выполнить следствие; если нет, альтернативу.

@item
Выражение @code{lambda} требуется преобразовать в процедуру, пригодную к
применению. Для этого нужно упаковать параметры и тело
@code{lambda}-выражения вместе с окружением, в котором оно вычисляется.

@item
Выражение @code{begin} требует выполнения своих подвыражений в том
порядке, как они появляются.

@item
Разбор случаев @code{cond} преобразуется во вложенные выражения
@code{if} и затем вычисляется.

@end itemize

@noindent
@b{Комбинации}

@itemize @bullet

@item
Для применения процедуры @code{eval} должна рекурсивно вычислить
операцию и операнды комбинации. Получившиеся процедура и аргументы
передаются @code{apply}, которая распоряжается собственно применением
процедуры.

@end itemize

@noindent
Вот определение @code{eval}:

@lisp
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))
@end lisp

@noindent
Ясности ради, @code{eval} реализована как перебор альтернатив через
@code{cond}. Недостаток этой реализации --- наша процедура обрабатывает
только несколько указанных типов выражений, и, не меняя определение
@code{eval}, новые типы добавить нельзя. В большинстве реализаций Лиспа
распределение выражений по типам сделано в стиле, управляемом данными.
Это дает пользователю возможность добавлять новые типы выражений,
которые @code{eval} будет способен распознать, не меняя само определение
@code{eval}. (См. упражнение @ref{Упражнение 4.3}.)

@comment @subsubheading Apply
@subsubheading Apply

Процедура @code{apply} принимает два аргумента: процедуру и список
аргументов, к которым ее надо применить. @code{Apply} делит процедуры на
два класса: для применения примитивов она зовет
@code{ apply-primitive-procedure}; составные процедуры она применяет, по
очереди вычисляя выражения, составляющие тело процедуры. Окружение, в
котором вычисляется тело составной процедуры, получается из базового
окружения, хранящегося в процедуре, добалением кадра, где параметры
процедуры связываются с аргументами, к которым процедура применяется.
Вот определение @code{apply}:

@lisp
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))
@end lisp

@comment @subsubheading Procedure arguments
@subsubheading Аргументы процедур

Обрабатывая применение процедуры, @code{eval} получает список
аргументов, к которым процедуру надо применить, при помощи
@code{list-of-values}. Процедура @code{list-of-values} в качестве
аргумента берет список операндов комбинации. Она вычисляет каждый
аргумент и возвращает список соответствующих значений.@footnote{Ветку
@code{application?} в @code{eval} можно было бы упростить, используя
@code{map} (и постановив, что @code{operands} возвращает список) вместо
того, чтобы писать явным образом процедуру @code{list-of-values}. Мы
решили не использовать здесь @code{map}, чтобы подчеркнуть, что
интерпретатор можно написать без обращения к процедурам высших порядков
(а следовательно, его можно написать на языке, в котором нет таких
процедур), притом, что язык, поддерживаемый интерпретатором, содержит
процедуры высших порядков.}

@lisp
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
@end lisp

@comment @subsubheading Conditionals
@subsubheading Условные выражения

Процедура @code{eval-if} вычисляет предикатную часть выражения @code{if}
в данном окружении. Если результат истинен, @code{eval-if} выполняет
следствие, если нет, --- альтернативу:

@lisp
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Использование @code{true?} в @code{eval-if} подчеркивает вопрос о связи
между реализуемым языком и языком реализации. Выражение
@code{if-predicate} выполняется в реализуемом языке, и, следовательно,
результат его является значением этого языка. Предикат интерпретатора
@code{true?} переводит это значение в значение, которое может быть
проверено выражением @code{if} в языке реализации: метациклическое
представление истины может не совпадать с ее представлением в
нижележащей Scheme.@footnote{В нашем случае, язык реализации и
реализуемый язык совпадают. Размышления о значении @code{true?}
расширяют наше сознание безотносительно к материальной сущности
истины.}

@comment @subsubheading Sequences
@subsubheading Последовательности

Процедура @code{eval-sequence} вызывается из @code{apply} для выполнения
последовательности выражений в теле процедуры, а также из @code{eval}
для обработки последовательности выражений в выражении @code{begin}. Она
принимает в виде аргументов последовательность выражений и окружение, и
выполняет выражения в том порядке, в котором они ей даны. Возвращаемое
значение совпадает со значением последнего выражения.

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))
@end lisp

@comment @subsubheading Assignments and definitions
@subsubheading Присваивания и определения

Следующая процедура обрабатывает присваивание переменным. При помощи
@code{eval} она находит значение, которое требуется присвоить, и
передает переменную и получившееся значение в процедуру
@code{set-variable-value!} для включения в текущее окружение.

@lisp
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
@end lisp

@noindent
Определения переменных обрабатываются сходным образом:@footnote{Эта
реализация @code{define} не учитывает один тонкий вопрос в обработке
внутренних определений, хотя в большинстве случаев работает правильно. В
чем состоит проблема и как ее решить, мы увидим в @ref{4.1.6}.}

@lisp
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
@end lisp

@noindent
В качестве возвращаемого значения для присваивания или определения мы
выбрали символ @code{ok}.@footnote{Как мы упоминали при введении
@code{define} и @code{set!}, их значения в Scheme зависят от
реализации --- то есть автор реализации имеет право выбрать такое
значение, какое он хочет.}

@quotation
@strong{@anchor{Упражнение 4.1}Упражнение 4.1:}
Заметим, что мы не можем сказать, вычисляет ли
метациклический интерпретатор операнды слева направо или справа налево.
Порядок вычисления наследуется от нижележащего Лиспа: если аргументы
@code{cons} в процедуре @code{list-of-values} вычисляются слева направо,
то и операнды в @code{list-of-values} будут вычисляться слева направо.
Если же вычисление аргументов @code{cons} происходит справа налево, то и
@code{list-of-values} будет вычислять операнды справа налево.

Напишите версию @code{list-of-values}, которая вычисляет операнды слева
направо, вне зависимости от порядка вычислений в нижележащем Лиспе.
Напишите также версию, которая вычисляет операнды справа налево.
@end quotation

@comment @subsection Representing Expressions
@subsection Представление выражений
@node	4.1.2, 4.1.3, 4.1.1, 4.1

Интерпретатор напоминает программу символьного дифференцирования,
описанную в @ref{2.3.2}.
Обе программы работают с символьными выражениями. В обеих результат
работы с составным выражением определяется рекурсивной обработкой частей
выражения и сочетанием частичных результатов, причем способ сочетания
зависит от типа выражения. И там, и там мы использовали абстракцию
данных, чтобы отделить общие правила работы от деталей того, как
представлены выражения. Для программы дифференцирования это означало,
что одна и та же процедура взятия производной могла работать с
алгебраическими выражениями в префиксной, инфиксной или какой-либо
другой записи. Для интерпретатора это означает, что синтаксис языка
определяется исключительно процедурами, которые классифицируют выражения
и выделяют их части.

Вот описание синтаксиса нашего языка:

@itemize

@item
К самовычисляющимся объектам относятся только числа и строки:

@lisp
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
@end lisp

@item
Переменные представляются в виде символов:

@lisp
(define (variable? exp) (symbol? exp))
@end lisp

@item
Выражения с кавычкой имеют форму
@code{(quote @math{\langle}@var{закавыченное-выражение}@math{\rangle})}

@lisp
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
@end lisp

@code{quoted?} определена посредством процедуры @code{tagged-list?},
которая распознает списки, начинающиеся с указанного символа:@footnote{В
@ref{2.3.1} упоминается, что интерпретатор
рассматривает закавыченное выражение как список, начинающийся с
@code{quote}, даже если выражение напечатано через знак кавычки.
Например, выражение @code{'a} будет выглядеть для интерпретатора как
@code{(quote a)}. См. упражнение @ref{Упражнение 2.55}.}

@lisp
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
@end lisp

@item
Присваивания имеют форму
@code{(set! @math{\langle}@var{πеременная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle})}:

@lisp
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
@end lisp

@item
Определения имеют вид

@lisp
(define @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle})
@end lisp

@noindent
или
or the form

@lisp
(define (@math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{πараметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πараметр}@math{_{\monoit{n}}\rangle})
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

Вторая форма (стандартное определение процедуры) является синтаксическим сахаром для

@lisp
(define @math{\langle}@var{πеременная}@math{\rangle}
  (lambda (@math{\langle}@var{πараметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πараметр}@math{_{\monoit{n}}\rangle})
    @math{\langle}@var{тело}@math{\rangle}))
@end lisp

Соответствующие синтаксические процедуры выглядят так:

@lisp
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)     @r{; formal parameters}
                   (cddr exp))))   @r{; body}
@end lisp

@item
@code{lambda}-выражения являются сπисками, которые начинаются с символа @code{lambda}:

@lisp
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
@end lisp

Мы приводим также конструктор для @code{lambda}-выражений. Он
используется в вышеприведенной процедуре @code{definition-value}:

@lisp
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
@end lisp

@item
Условные выражения начинаются с @code{if} и имеют предикат, следствие и
(необязательную) альтернативу. Если в выражении нет части-альтернативы,
мы указываем в ее качестве @code{false}.@footnote{Значение выражения
@code{if} в случае, когда предикат ложен, а альтернатива отсутствует, в
Scheme не определено; здесь мы решили сделать его ложным. Мы будем
поддерживать переменные @code{true} и @code{false} в выполняемых
выражениях путем связывания их в глобальном окружении.
См. @ref{4.1.4}.}

@lisp
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
@end lisp

Мы предоставляем также конструктор для @code{if}-выражений. Его будет
использовать процедура @code{cond->if} для преобразования выражений
@code{cond} в выражения @code{if}:

@lisp
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
@end lisp

@item
@code{Begin} упаковывает последовательность выражений в одно выражение.
В синтаксические операции над выражениями @code{begin} мы включаем
извлечение самой последовательности из выражения @code{begin}, а также
селекторы, которые возвращают первое выражение и остаток выражений в
последовательности.@footnote{Эти селекторы для списка выражений, а также
соответствующие им селекторы для списка операндов, не предназначаются
для абстракции данных. Они введены в качестве мнемонических имен для
основных списковых операций, чтобы легче было понимать вычислитель с
явным управлением из @ref{5.4}.}

@lisp
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
@end lisp

Кроме того, мы даем конструктор @code{sequence->exp} (для использования
в процедуре @code{cond->if}), который преобразует последовательность в
единое выражение, используя, если надо, @code{begin}:

@lisp
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
@end lisp

@item
Вызов процедуры --- это любое составное выражение, не попадающее ни в
один из перечисленных типов. Его @code{car} --- это оператор, а
@code{cdr} --- список операндов:

@lisp
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
@end lisp

@end itemize

@comment @subsubheading Derived expressions
@subsubheading Производные выражения

Некоторые особые формы языка можно определить через выражения,
включающие другие особые формы, вместо того, чтобы задавать их напрямую.
Как пример рассмотрим @code{cond}, который можно реализовать как гнездо
выражений @code{if}. Например, задачу вычисления выражения

@lisp
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
@end lisp

@noindent
можно свести к задаче вычисления следующего выражения, состоящего из
форм @code{if} и @code{begin}:

@lisp
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
@end lisp

@noindent
Такая реализация обработки @code{cond} упрощает интерпретатор, поскольку
она уменьшает количество особых форм, для которых требуется явно
описывать процесс вычисления.

Мы включаем в интерпретатор синтаксические процедуры, которые определяют
доступ к частям выражения @code{cond}, а также процедуру
@code{cond->if}, которая преобразует выражения @code{cond} в выражения
@code{if}. Анализ случаев начинается с @code{cond} и состоит из списка
ветвей-вариантов вида предикат-действие. Вариант считается
умолчательным, если его предикатом является символ
@code{else}.@footnote{Значение выражения @code{cond}, когда все предикаты
ложны, а вариант по умолчанию @code{else} отсутствует, в языке Scheme не
определено; здесь мы решили сделать его ложным.}

@lisp
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                        @r{; no @code{else} clause}
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
@end lisp

@noindent
Выражения (вроде @code{cond}), которые мы желаем реализовать через
синтаксические преобразования, называются (@newterm{derived expressions}).
Выражения @code{let} также являются производными
(см. @ref{Упражнение 4.6}).@footnote{Практические
Lisp-системы предоставляют механизм, который дает пользователю
возможность добавлять новые производные выражения и определять их
значения через синтаксические преобразования, не внося изменений в
вычислитель. Такое преобразование, определяемое пользователем,
называется (@newterm{macro}). Добавить простой механизм для определения макросов
легко, однако в получающемся языке возникают сложные проблемы конфликта
имен. Множество исследований посвящено поиску механизмов определения
макросов, в которых такие проблемы не возникают. См., например,
Kohlbecker 1986, Clinger and Rees 1991 и Hanson 1991.}

@quotation
@strong{@anchor{Упражнение 4.2}Упражнение 4.2:}
Хьюго Дум хочет переупорядочить ветви @code{eval} так, чтобы
ветвь для вызова процедур располагалась перед веткой для присваивания.
Он утверждает, что при этом интерпретатор станет эффективнее: поскольку
в программах обычно больше вызовов процедур, чем присваиваний,
определений и т. д., его усовершенствованный @code{eval} обычно будет
рассматривать меньше вариантов, чем исходный, при распознавании типа
выражения.

@enumerate a.

@item
Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением @code{(define x 3)}?)

@item
Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до
того, как он проверяет все остальные типы выражений. Помогите ему,
изменив синтаксис интерпретируемого языка так, чтобы вызовы процедур
начинались с символа @code{call}. Например, вместо @code{(factorial 3)}
нам теперь придется писать @code{(call factorial 3)}, а вместо
@code{(+ 1 2)} --- @code{(call + 1 2)}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.3}Упражнение 4.3:}
Перепишите @code{eval} так, чтобы диспетчеризация
происходила в стиле, управляемом данными. Сравните результат с
дифференцированием, управляемым данными, из @ref{Упражнение 2.73}.
(Можно использовать @code{car} составного выражения в качестве типа
этого выражения, так как это хорошо сочетается с синтаксисом, реализованным
в этом разделе.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.4}Упражнение 4.4:} Вспомним определения особых
форм @code{and} и @code{or} из @ref{Глава 1}:

@itemize @bullet

@item
@code{and:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается ложным, возвращается ложь; оставшиеся выражения не
вычисляются. Если все выражения оказываются истинными, возвращается
значение последнего из них. Если нет ни одного выражения, возвращается
истина.

@item
@code{or:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается истинным, возвращается это значение; оставшиеся
выражения не вычисляются. Если все выражения оказываются ложными, или
нет ни одного выражения, возвращается ложь.

@end itemize

Введите @code{and} и @code{or} в качестве новых особых форм
интерпретатора, определив соответствующие синтаксические процедуры и
процедуры выполнения @code{eval-and} и @code{eval-or}. В качестве
альтернативы покажите, как можно реализовать @code{and} и @code{or} в
виде производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.5}Упражнение 4.5:}
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
@code{cond}, @code{(@math{\langle}@var{πроверка}@math{\rangle} =>
@math{\langle}@var{πотребитель}@math{\rangle})}.  Если результат
вычисления @math{\langle}@var{πроверки}@math{\kern0.08em\rangle}
оказывается истинным значением, то вычисляется
@math{\langle}@var{πотребитель}@math{\kern0.08em\rangle}. Его значение
должно быть одноместной процедурой; эта процедура вызывается со значением
@math{\langle}@var{πроверки}@math{\kern0.08em\rangle} в качестве аргумента,
и результат этого вызова возвращается как значение выражения @code{cond}.
Например:

@lisp
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
@end lisp

@noindent
имеет значение 2. Измените обработку @code{cond} так, чтобы она
поддерживала этот расширенный синтаксис.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.6}Упражнение 4.6:}
Выражения @code{let} производны, поскольку

@lisp
(let ((@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{πер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
эквивалентно

@lisp
((lambda (@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πер}@math{_{\monoit{n}}\rangle})
   @math{\langle}@var{тело}@math{\rangle})
 @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}
 @dots{}
 @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle})
@end lisp

Напишите синтаксическое преобразование @code{let->combination}, которое
сводит вычисление @code{let}-выражений к вычислению комбинаций
указанного вида, и добавьте соответствующую ветку для обработки
@code{let} к @code{eval}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.7}Упражнение 4.7:}
Особая форма @code{let*} подобна @code{let}, но только
связывания переменных в @code{let*} происходят последовательно, и каждое
следующее связывание происходит в окружении, где видны все предыдущие.
Например,

@lisp
(let* ((x 3)  (y (+ x 2))  (z (+ x y 5)))
  (* x z))
@end lisp

@noindent
возвращает значение 39. Объясните, каким образом можно переписать
выражение @code{let*} в виде набора вложенных выражений @code{let}, и
напишите процедуру @code{let*->nested-lets}, которая проделывает это
преобразование. Если мы уже реализовали @code{let}
(@ref{Упражнение 4.6}) и хотим теперь расширить
интерпретатор так, чтобы он обрабатывал @code{let*}, достаточно ли будет
добавить в @code{eval} ветвь, в которой действием записано

@lisp
(eval (let*->nested-lets exp) env)
@end lisp

@noindent
или нужно явным образом преобразовывать @code{let*} в набор
непроизводных выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.8}Упражнение 4.8:}
<<Именованный @code{let}>> --- это вариант , который имеет
вид

@lisp
(let @math{\langle}@var{var}@math{\rangle} @math{\langle}@var{bindings}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@math{\langle}@var{связывание}@math{\rangle} и
@math{\langle}@var{тело}@math{\rangle} такие же, как и в обычном
@code{let}, но только @math{\langle}@var{переменная}@math{\rangle}
связана в @math{\langle}@var{теле}@math{\rangle} с процедурой, у
которой тело @math{\langle}@var{тело}@math{\rangle}, а имена
параметров --- переменные в
@math{\langle}@var{связываниях}@math{\rangle}. Таким образом, можно
неоднократно выполнять @math{\langle}@var{тело}@math{\rangle}, вызывая
процедуру по имени @math{\langle}@var{переменная}@math{\rangle}.
Например, итеративную процедуру для порождения чисел Фибоначчи
(@ref{1.2.2}) можно переписать при помощи именованного @code{let} как

@lisp

(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
@end lisp

Измените преобразование @code{let->combination} из
упражнения @ref{Упражнение 4.6} так, чтобы оно поддерживало именованный
@code{let}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.9}Упражнение 4.9:}
Во многих языках имеются различные конструкции для
построения циклов, например, @code{do}, @code{for}, @code{while} и
@code{until}. В Scheme итеративные процессы можно выразить через обычные
вызовы процедур, так что особые конструкции не дают никакого
существенного выигрыша в вычислительной мощности. С другой стороны,
часто они удобны. Придумайте какие-нибудь конструкции для итерации,
дайте примеры их использования и покажите, как их реализовать в виде
производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.10}Упражнение 4.10:}
При помощи абстракции данных мы смогли написать процедуру
@code{eval} так, что она не зависит от конкретного синтаксиса
интерпретируемого языка. Чтобы проиллюстрировать это свойство,
разработайте новый синтаксис для Scheme, изменив процедуры из этого
раздела и ничего не трогая в @code{eval} и @code{apply}.
@end quotation

@comment @subsection Evaluator Data Structures
@subsection Структуры данных интерпретатора
@node	4.1.3, 4.1.4, 4.1.2, 4.1

Помимо внешнего синтаксиса выражений, реализация интерпретатора должна
определить также внутренние структуры данных, с которыми она работает во
время выполнения программы, в частности, представление процедур и
окружений, а также истинных и ложных значений.

@comment @subsubheading Testing of predicates
@subsubheading Проверка предикатов

В условных выражениях мы воспринимаем в качестве истины все, кроме
специального ложного объекта @code{false}.

@lisp
(define (true? x)  (not (eq? x false)))
(define (false? x) (eq? x false))
@end lisp

@comment @subsubheading Representing procedures
@subsubheading Представление процедур

Работая с примитивами, мы предполагаем, что у нас есть следующие
процедуры:

@itemize @bullet

@item
@code{(apply-primitive-procedure @math{\langle}@var{процедура}@math{\rangle}
@math{\langle}@var{аргументы}@math{\rangle})}

@noindent
применяет данную элементарную процедуру к значениям аргументов из списка
@math{\langle}@var{аргументы}@math{\rangle} и возвращает результат
вызова.

@item
@code{(primitive-procedure? @math{\langle}@var{процедура}@math{\rangle})}

@noindent
проверяет, является ли @math{\langle}@var{процедура}@math{\rangle}
элементарной.

@end itemize

@noindent
Эти механизмы работы с элементарными процедурами подробнее описаны в
@ref{Часть 4.1.4}.

Составная процедура строится из параметров, те́ла процедуры и окружения
при помощи конструктора @code{make-procedure}:

@lisp
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
@end lisp

@comment @subsubheading Operations on Environments
@subsubheading Действия над окружениями

Интерпретатору нужно иметь несколько операций, действующих над
окружениями. Как объясняется в @ref{3.2},
окружение представляет собой последовательность кадров, а каждый кадр
является таблицей связываний, соотносящих переменные с их значениями.
Для работы с окружениями мы используем следующие операции:

@itemize @bullet

@item
@code{(lookup-variable-value @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
возвращает значение, связанное с символом
@math{\langle}@var{πеременная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle}, либо сообщает об ошибке,
если переменная не связана.

@item
@code{(extend-environment @math{\langle}@var{πеременные}@math{\rangle} @math{\langle}@var{значения}@math{\rangle} @math{\langle}@var{исх-окр}@math{\rangle})}
возвращает новое окружение, состоящее из нового кадра, в котором символы
из списка  @math{\langle}@var{πеременные}@math{\rangle} связаны с
соответствующими элементами списка
@math{\langle}@var{значения}@math{\rangle}, а объемлющим окружением
является окружение @math{\langle}@var{исх-окр}@math{\rangle}.

@item
@code{(define-variable! @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
добавляет к первому кадру @math{\langle}@var{окружение}@math{\rangle}
новое связывание, которое сопоставляет
@math{\langle}@var{πеременная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle}.

@item
@code{(set-variable-value! @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
изменяет связывание @math{\langle}@var{πеременная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle} так, что в дальнейшем ей
будет соответствовать @math{\langle}@var{значение}@math{\rangle}, либо
сообщает об ошибке, если переменная не связана.

@end itemize

@noindent
Чтобы реализовать все эти операции, мы представляем окружение в виде
списка кадров. Объемлющее окружение живет в @code{cdr} этого списка.
Пустое окружение --- это просто пустой список.

@lisp
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
@end lisp

@noindent
Каждый кадр в окружении представляется в виде пары списков: список
переменных, связанных в кадре, и список значений.@footnote{В
нижеследующем коде кадры не являются настоящей абстракцией данных:
@code{set-variable-value!} и @code{define-variable!} явным образом
изменяют значения в кадре при помощи @code{set-car!}. Назначение
процедур работы с кадрами --- сделать код операций над окружениями
простым для чтения.}

@lisp
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
@end lisp

@noindent
Чтобы расширить окружение новым кадром, который связывает переменные со
значениями, мы порождаем кадр, который состоит из списка переменных и
списка значений, и присоединяем его к окружению. Если количество
переменных и количество значений не совпадают, сообщаем об ошибке.

@lisp
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
@end lisp

@noindent
Чтобы найти переменную в окружении, мы просматриваем список переменных в
первом кадре. Если находим нужную переменную, то возвращаем
соответствующий элемент списка значений. Если мы не находим переменную в
текущем кадре, то ищем в объемлющем окружении, и так далее. Если мы
добираемся до пустого окружения, нужно сообщить об ошибке
<<неопределенная переменная>>.

@lisp
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы присвоить переменной новое значение в указанном окружении, мы ищем
переменную, точно так же, как в @code{lookup-variable-value}, и изменяем
соответствующее значение, когда его находим.

@lisp
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы определить переменную, мы просматриваем первый кадр в поисках
связывания для нее, и изменяем связывание, если его удается найти (так
же, как в @code{set-variable-value!}). Если связывания не существует, мы
присоединяем его к первому кадру.

@lisp
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))
@end lisp

@noindent
Описанный здесь метод --- только один из многих способов представления
окружений. Поскольку мы при помощи абстракции данных отделили конкретную
реализацию от остальных частей интерпретатора, при желании мы можем
сменить представление окружений.
(См. @ref{Упражнение 4.11}.) В Lisp-системе промышленного
качества быстрота операций над окружениями --- особенно обращения к
переменной --- очень сильно влияет на общую производительность.
Представление, описанное здесь, при всей своей концептуальной простоте
неэффективно и, скорее всего, его не стали бы использовать в рабочей
системе.@footnote{Недостаток этого представления (как и варианта из
@ref{Упражнение 4.11}) состоит в том, что вычислителю может
понадобиться просматривать слишком много кадров, чтобы найти связывание
конкретной переменной. Такой подход называется (@newterm{deep binding}).
Один из способов избежать такой потери производительности --- использовать
стратегию под названием (@newterm{lexical addressing}), которая обсуждается в
@ref{5.5.6}.}

@quotation
@strong{@anchor{Упражнение 4.11}Упражнение 4.11:}
Вместо того, чтобы представлять кадр в виде списка
списков, его можно представить как список связываний, где каждое
связывание является парой из имени и значения. Перепишите операции с
окружениями в соответствии с этим альтернативным представлением.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.12}Упражнение 4.12:}
Процедуры @code{set-variable-value!},
@code{define-variable!} и @code{lookup-variable-value} можно выразить
посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.13}Упражнение 4.13:}
Scheme позволяет создавать новые связывания через
@code{define}, но не дает никакого способа избавиться от связывания.
Реализуйте в интерпретаторе особую форму @code{make-unbound!}, которая
изымает связывание данного символа из окружения, в котором
@code{make-unbound!} выполняется. Задача определена не до конца.
Например, нужно ли удалять связывания в других кадрах, кроме первого?
Дополните спецификацию и объясните свой выбор вариантов.
@end quotation

@comment @subsection Running the Evaluator as a Program
@subsection Выполнение интерпретатора как программы
@node	4.1.4, 4.1.5, 4.1.3, 4.1

Написав интерпретатор, мы получаем в руки описание (выраженное на Lisp)
процесса вычисления лисповских выражений. Одно из преимуществ наличия
описания в виде программы в том, что эту программу можно запустить. У
нас внутри Лиспа есть работающая модель того, как сам Лисп вычисляет
выражения. Она может служить средой для экспериментов с правилами
вычисления, и дальше в этой главе мы такими экспериментами и займемся.

Программа-вычислитель в конце концов сводит выражения к применению
элементарных процедур. Следовательно, единственное, что нам требуется
для запуска интерпретатора, --- создать механизм, который обращается к
нижележащей Лисп-системе и моделирует вызовы элементарных процедур.

Нам нужно иметь связывание для каждого имени элементарной процедуры,
чтобы, когда @code{eval} выполняет вызов примитива, у него был объект,
который можно передать в @code{apply}. Поэтому мы выстраиваем глобальное
окружение, связывающее особые объекты с именами элементарных процедур,
которые могут появляться в вычисляемых нами выражениях. Кроме того,
глобальное окружение включает связывания для символов и @code{false},
так что их можно использовать как переменные в вычисляемых выражениях.

@lisp
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))
@end lisp

@noindent
Как именно мы представляем объекты-элементарные процедуры, не имеет
значения. Требуется только, чтобы их можно было распознавать и
применять, вызывая процедуры @code{primitive-procedure?} и
@code{apply-primitive-procedure}. Мы решили представлять примитивы в
виде списка, начинающегося с символа @code{primitive} и содержащего
процедуру нижележащего Лиспа, которая реализует данный примитив.

@lisp
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
@end lisp

@noindent
@code{setup-environment} получит имена и реализации элементарных
процедур из списка:@footnote{Любую процедуру, определенную в нижележащем
Лиспе, можно использовать как примитив для метациклического
интерпретатора. Имя примитива, установленного в интерпретаторе, не
обязательно должно совпадать с именем его реализации в нижележащем
Лиспе; здесь имена одни и те же потому, что метациклический
интерпретатор реализует саму Scheme. Так, например, мы могли бы написать
в списке @code{primitive-procedures} что-нибудь вроде
@code{(list 'first car)} или
@code{(list 'square (lambda (x) (* x x)))}.}

@lisp
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        @math{\langle}@var{другие πримитивы}@math{\rangle} ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
@end lisp

@noindent
Чтобы вызвать элементарную процедуру, мы просто применяем
процедуру-реализацию к аргументам, используя нижележащую
Lisp-систему.@footnote{@code{apply-in-underlying-scheme} --- это процедура
@code{apply}, которой мы пользовались в предыдущих главах. Процедура
@code{apply} метациклического интерпретатора (@ref{4.1.1}) имитирует работу
этого примитива. Наличие двух процедур с одинаковым именем ведет к технической
проблеме при запуске интерпретатора, поскольку определение @code{apply}
метациклического интерпретатора загородит определение примитива. Можно
избежать этого, переименовав метациклический @code{apply}, и избавиться
таким образом от конфликта с именем элементарной процедуры. Мы же вместо
этого приняли решение сохранить ссылку на исходный @code{apply}, выполнив

@lisp
(define apply-in-underlying-scheme apply)
@end lisp

@noindent
прежде, чем определили @code{apply} в интерпретаторе. Теперь мы можем
обращаться к исходной версии @code{apply} под другим именем.}

@lisp
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Для удобства работы с метациклическим интерпретатором мы организуем
(@newterm{driver loop}), который моделирует цикл чтения-выполнения-печати
нижележащей Лисп-системы. Этот цикл печатает (@newterm{prompt}), считывает входное
выражение, вычисляет это выражение в глобальном окружении и
распечатывает результат. Перед каждым результатом мы помещаем (output
prompt), чтобы отличить значение выражения от всего прочего, что может
быть напечатано.@footnote{Элементарная процедура ожидает ввода от
пользователя и возвращает ближайшее полное выражение, которое он
напечатает. Например, если пользователь напечатает @code{(+ 23 x)},
результатом @code{read} будет трехэлементный список из символа @code{+},
числа 23 и символа @code{x}. Если пользователь введет @code{'x},
результатом @code{read} будет двухэлементный список из символа
@code{quote} и символа @code{x}.}

@lisp
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
@end lisp

@noindent
Мы пользуемся специальной процедурой вывода @code{user-print}, чтобы не
печатать окружение составных процедур, которое может быть очень длинным
списком, и даже может содержать циклы.

@lisp
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
@end lisp

@noindent
Теперь для запуска интерпретатора нам остается только
проинициализировать глобальное окружение и войти в управляющий цикл. Вот
пример работы интерпретатора:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)

@i{;;; M-Eval input:}
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
@i{;;; M-Eval value:}
@i{ok}
@i{;;; M-Eval input:}
(append '(a b c) '(d e f))
@i{;;; M-Eval value:}
@i{(a b c d e f)}
@end lisp

@c @sp 1
@quotation
@strong{@anchor{Упражнение 4.14}Упражнение 4.14:}
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение @code{map}
и запускает несколько тестовых программ с его использованием. Они
замечательно работают. Хьюго, со своей стороны, ввел системную версию
@code{map} как примитив метациклического интерпретатора. Когда он
пытается его выполнить, все ломается самым ужасным образом. Объясните,
почему у Хьюго @code{map} не работает, а у Евы работает.
@end quotation

@comment @subsection Data as Programs
@subsection Данные как программы
@node	4.1.5, 4.1.6, 4.1.4, 4.1

При рассмотрении программы на Лиспе, вычисляющей лисповские выражения,
может быть полезна аналогия. Одна из возможных точек зрения на значение
программы состоит в том, что программа описывает абстрактную (возможно,
бесконечно большую) машину. Рассмотрим, например, знакомую нам программу
для вычисления факториалов:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Можно считать эту программу описанием машины, которая содержит узлы для
вычитания, умножения и проверки на равенство, двухпозиционный
переключатель и еще одну факториал-машину. (Факториал-машина получается
бесконечной, поскольку она содержит другую факториал-машину внутри
себя.) На рисунке @ref{Рисунок 4.2} изображена потоковая диаграмма
факториал-машины, которая показывает, как спаяны ее части.

Подобным образом, мы можем рассматривать вычислитель как особого рода
машину, которой подается в виде сырья описание другой машины. Обработав
свои входные данные, вычислитель перестраивает себя так, чтобы
моделировать описываемую машину. Например, если мы скормим вычислителю
определение @code{factorial}, как показано на
рисунке @ref{Рисунок 4.3}, он сможет считать факториалы.

@float
@quotation
@anchor{Рисунок 4.2}
@ifinfo
@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.

@example
    +-----------------------------------+
    | factorial                   |1    |
    |              |1             V     |
    |              |           +-----+  |
    |              V           | #   |  |
    |           +-----+        |     |  |
6 --------*-----|  =  |------->|   #-+-----> 720
    |     |     +-----+        |  /  |  |
    |     |                    | #   |  |
    |     |                    +-----+  |
    |     |                       ^     |
    |     |                       |     |
    |     |                    +--+--+  |
    |     *------------------->|  *  |  |
    |     |                    +-----+  |
    |     V                       ^     |
    |  +-----+    +-----------+   |     |
    |  |  -  +--->| factorial +---+     |
    |  +-----+    +-----------+         |
    |     ^                             |
    |     |1                            |
    +-----------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.2,84mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.}
@sp 0.9
@end iftex
@end quotation
@end float

С этой точки зрения, наш вычислитель-интерпретатор выглядит как
(@newterm{universal machine}). Она имитирует другие машины, представленные
в виде Lisp-программ.@footnote{То, что машины описаны на языке Лисп,
несущественно. Если дать нашему интерпретатору программу на Лиспе,
которая ведет себя как вычислитель для какого-нибудь другого языка,
скажем, Си, то вычислитель для Лиспа будет имитировать вычислитель для
Си, который, в свою очередь, способен сымитировать любую машину,
описанную в виде программы на Си. Подобным образом, написание
интерпретатора Лиспа на Си порождает программу на Си, способную
выполнить любую программу на Лиспе. Главная идея здесь состоит в том,
что любой вычислитель способен имитировать любой другой. Таким образом,
понятие <<того, что в принципе можно вычислить>> (если не принимать во
внимание практические вопросы времени и памяти, потребной для
вычисления), независимо от языка компьютера и выражает глубинное понятие
(computability). Это впервые было ясно показано Аланом М. Тьюрингом
(1912-1954), чья статья 1936 года заложила основы теоретической
информатики. В этой статье Тьюринг представил простую модель
вычислений, --- теперь известную как (@newterm{Turing machine}), --- и
утверждал, что любой <<эффективный процесс>> выразим в виде программы
для такой машины. (Этот аргумент известен как (@newterm{Church-Turing thesis}).)
Затем Тьюринг реализовал универсальную машину, т. е. машину Тьюринга,
которая работает как вычислитель для программ машин Тьюринга. При помощи
этой схемы рассуждений он показал, что существуют коррекно поставленные
задачи, которые не могут быть решены машиной Тьюринга
(см. @ref{Упражнение 4.15}), а следовательно не могут быть
сформулированы в виде <<эффективного процесса>>. Позднее Тьюринг внес
фундаментальный вклад и в развитие практической информатики. Например,
ему принадлежит идея структурирования программ с помощью подпрограмм
общего назначения. Биографию Тьюринга можно найти в Hodges 1983.} Это
замечательное устройство. Попробуйте представить себе аналогичный
вычислитель для электрических схем. Это была бы схема, которой на вход
поступает сигнал, кодирующий устройство какой-то другой схемы, например,
фильтра. Восприняв этот вход, наша схема-вычислитель стала бы работать
как фильтр, соответствующий описанию. Такая универсальная электрическая
схема имеет почти невообразимую сложность. Удивительно, что
интерпретатор программ --- сам по себе программа довольно
простая.@footnote{Некоторые считают странным, что вычислитель,
реализованный с помощью относительно простой процедуры, способен
имитировать программы, более сложные, чем он сам. Существование
универсальной машины-вычислителя --- глубокое и важное свойство
вычисления. (recursion theory), отрасль математической логики,
занимается логическими пределами вычислимости. В прекрасной книге
Дугласа Хофштадтера <<Гёдель, Эшер, Бах>> (Hofstadter 1979) исследуются
некоторые из этих идей.}

@float
@quotation
@anchor{Рисунок 4.3}
@ifinfo
@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.

@example
                   +--------+
            6 ---->|  eval  |----> 720
                   +--------+
                       /
             . . .    /  . . .
       . . .       ../. .      .
     .                           ..
    .   (define (factorial n)      . . .
   .      (if (= n 1)                   . .
    .         1                            .
    .         (* (factorial (- n 1)) n)))   .
      . .                       . .        .
          . .  . .      . . . .     . . . .
                   . ..
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.3,69mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.}
@sp 0.9
@end iftex
@end quotation
@end float

Еще одна замечательная черта интерпретатора заключается в том, что он
служит мостом между объектами данных, которыми манипулирует язык
программирования, и самим языком. Представим себе, что работает
программа интерпретатора (реализованная на Лиспе), и что пользователь
вводит выражения в интерпретатор и рассматривает результаты. С точки
зрения пользователя, входное выражение вроде @code{(* x x)} является
выражением языка программирования, которое интерпретатор должен
выполнить. Однако с точки зрения интерпретатора это всего лишь список (в
данном случае, список из трех символов: @code{*}, @code{x} и @code{x}), с
которым нужно работать по ясно очерченным правилам.

Нас не должно смущать, что программы пользователя являются данными для
интерпретатора. На самом деле, иногда бывает удобно игнорировать это
различие и, предоставляя пользовательским программам доступ к
@code{eval}, давать пользователю возможность явным образом вычислить
объект данных как выражение Лиспа. Во многих диалектах Лиспа имеется
элементарная процедура @code{eval}, которая в виде аргументов берет
выражение и окружение, и вычисляет выражение в указанном
окружении.@footnote{Предупреждение: эта процедура @code{eval} --- не то
же самое, что процедура @code{eval}, реализованная нами в @ref{4.1.1},
потому что она работает с @emph{настоящими} окружениями, а не с
искусственными структурами окружений, которые мы построили в @ref{4.1.3}.
С этими настоящими
окружениями пользователь не может работать, как с обычными списками; к
ним нужно обращаться через @code{eval} или другие специальные операции.
Подобным образом, элементарная процедура @code{apply}, упомянутая
раньше, не то же самое, что метациклическая @code{apply}, поскольку она
использует настоящие процедуры Scheme, а не объекты-процедуры, которые
мы конструировали в разделах @ref{4.1.3} и @ref{4.1.4}.} Таким образом, как

@lisp
(eval '(* 5 5) user-initial-environment)
@end lisp

@noindent
так и

@lisp
(eval (cons '* (list 5 5)) user-initial-environment)
@end lisp

@noindent
возвращают результат 25.@footnote{Реализация MIT Scheme имеет процедуру
@code{eval}, а также символ , связанный с исходным окружением, в котором
вычисляются выражения.}

@quotation
@strong{@anchor{Упражнение 4.15}Упражнение 4.15:}
Если даны одноаргументная процедура @code{p} и объект
@code{a}, то говорят, что @code{p} <<останавливается>> на @code{a}, если
выражение @code{(p a)} возвращает значение (а не печатает сообщение об
ошибке или выполняется вечно). Покажите, что невозможно написать
процедуру @code{halts?}, которая бы точно определяла для любой процедуры
@code{p} и любого объекта @code{a}, останавливается ли @code{p} на
@code{a}. Используйте следующее рассуждение: если бы имелась такая
процедура @code{halts?}, можно было бы написать следующую программу:

@lisp
(define (run-forever) (run-forever))
(define (try p)
  (if (halts? p p) (run-forever) 'halted))
@end lisp

Теперь рассмотрите выражение @code{(try try)} и покажите, что любое
возможное завершение (остановка или вечное выполнение) нарушает
требуемое поведение @code{halts?}.@footnote{Хотя здесь мы предположили,
что @code{halts?} получает процедурный объект, заметим, что рассуждение
остается в силе даже в том случае, когда на вход подается текст
процедуры и ее окружение. В этом и состоит знаменитая (Halting Theorem)
Тьюринга, в которой был дан первый пример (non-computable) задачи,
т. е. корректно поставленного задания, которое невозможно выполнить с
помощью вычислительной процедуры.}
@end quotation

@comment @subsection Internal Definitions
@subsection Внутренние определения
@node	4.1.6, 4.1.7, 4.1.5, 4.1

Наша модель вычислений с окружениями и метациклический интерпретатор
выполняют определения по очереди, расширяя кадр окружения на одно
определение за раз. Это особенно удобно для диалоговой разработки
программы, когда программисту нужно свободно смешивать вызовы процедур с
определениями новых процедур. Однако если мы внимательно поразмыслим над
внутренними определениями, с помощью которых реализуется блочная
структура (введенная в @ref{1.1.8}), то мы увидим, что пошаговое расширение
окружения --- одно имя за другим --- может оказаться не лучшим способом
определения локальных переменных.

Рассмотрим процедуру с внутренними определениями, например

@lisp
(define (f x)
  (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)  (if (= n 0) false (even? (- n 1))))
  @math{\langle}@var{остаток тела @code{f}}@math{\rangle})
@end lisp

@noindent
Здесь нам хочется, чтобы имя @code{odd?} в теле процедуры @code{even?}
ссылалось на процедуру @code{odd?}, которая определена позже, чем
@code{even?}. Область действия имени @code{odd?} --- это все тело
@code{f}, а не только та его часть, которая лежит за точкой внутри
@code{f}, где определяется @code{odd?}. В самом деле, ели заметить, что
сама @code{odd?} определена с помощью @code{even?} --- так что
@code{even?} и @code{odd?} являются взаимно рекурсивными
процедурами, --- то становится ясно, что единственная
удовлетворительная интерпретация двух @code{define} --- рассматривать
их так, как будто @code{even?} и @code{odd?} были добавлены в окружение
одновременно. В общем случае, сферой действия локального имени является
целиком тело процедуры, в котором вычисляется @code{define}.

В нынешнем виде интерпретатор будет вычислять вызовы @code{f} правильно,
но причина этого <<чисто случайная>>: поскольку определения внутренних
процедур расположены в начале, никакие их вызовы не вычисляются, пока
они все не определены. Следовательно, к тому времени, когда выполняется
@code{even?}, @code{odd?} уже определена. Фактически, последовательный
механизм вычисления дает те же результаты, что и механизм,
непосредственно реализующий одновременное определение, для всякой
процедуры, где внутренние определения стоят в начале тела, а вычисление
выражений для определяемых переменных не использует ни одну из этих
переменных. (Пример процедуры, которая не удовлетворяет этим
требованиям, так что последовательное определение не равносильно
одновременному, можно найти в @ref{Упражнение 4.19}.)@footnote{Нежелание
зависеть в программах от этого механизма вычисления побудило нас написать
<<администрация ответственности не несет>> в примечании @ref{Сноска 28} в
@ref{Глава 1}.
Настаивая на том, чтобы внутренние определения стояли в начале тела и не
использовали друг друга во время вычисления самих определений, стандарт
IEEE Scheme дает авторам реализаций некоторую свободу при выборе
механизма вычисления этих определений. Выбор того или иного правила
вычисления может показаться мелочью, которая влияет только на
интерпретацию <<плохих>> программ. Однако в @ref{5.5.6} мы увидим, что
через переход к модели с одновременным определением внутренних
переменных можно избежать некоторых досадных трудностей, которые бы в
противном случае возникли при написании компилятора.}

Однако имеется простой способ обрабатывать определения так, чтобы у
локально определенных имен оказалась действительно общая сфера
действия, --- достаточно лишь создать все будущие внутренние переменные
текущего окружения, прежде чем начнется вычисление какого-либо из
выражений, возвращающих значение. Можно это сделать, например, путем
синтаксического преобразования @code{lambda}-выражений. Прежде чем
выполнять тело выражения @code{lambda}, мы <<прочесываем>> его и
уничтожаем все внутренние определения. Локально определенные переменные
будут созданы через @code{let}, а затем получат значения посредством
присваивания. Например, процедура

@lisp
(lambda @math{\langle}@var{πеременные}@math{\rangle}
  (define u @math{\langle}@var{e1}@math{\rangle})
  (define v @math{\langle}@var{e2}@math{\rangle})
  @math{\langle}@var{e3}@math{\rangle})
@end lisp

@noindent
преобразуется в

@lisp
(lambda @math{\langle}@var{πеременные}@math{\rangle}
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u @math{\langle}@var{e1}@math{\rangle})
    (set! v @math{\langle}@var{e2}@math{\rangle})
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

@noindent
где @code{unassigned*} --- специальный символ, который при поиске
переменной вызывает сообщение об ошибке, если программа пытается
использовать значение переменной, которой ничего еще не присвоено.

Альтернативная стратегия поиска внутренних определений показана в
упражнении @ref{Упражнение 4.18}. В отличие от преобразования,
продемонстрированного только что, она навязывает программисту следующее
ограничение: значение каждой определяемой переменной должно вычисляться
без обращения к значениям других определяемых
переменных.@footnote{Стандарт IEEE Scheme допускает различные стратегии
реализации. В нем говорится, что программист обязан подчиняться этому
ограничению, но реализация может его не проверять. Некоторые реализации
Scheme, включая MIT Scheme, используют преобразование, показанное выше.
В таких реализациях будут работать некоторые из программ, которые это
ограничение нарушают.}

@quotation
@strong{@anchor{Упражнение 4.16}Упражнение 4.16:}
В этом упражнении мы реализуем только что описанный метод
обработки внутренних определений. Мы предполагаем, что интерпретатор
поддерживает @code{let} (см. упражнение @ref{Упражнение 4.6}).

@enumerate a.

@item
Измените процедуру @code{lookup-variable-value} (@ref{4.1.3}) так, чтобы она,
обнаруживая в качестве значения символ @code{*unassigned*}, сообщала об ошибке.

@item
Напишите процедуру , которая берет тело процедуры и возвращает его
эквивалент без внутренних определений, выполняя описанное нами
преобразование.

@item
Вставьте @code{scan-out-defines} в интерпретатор, либо в
@code{make-procedure}, либо в @code{procedure-body} (см. @ref{4.1.3}).
Какое из этих мест лучше? Почему?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.17}Упражнение 4.17:}
Нарисуйте диаграммы окружения, которое находится в силе в
момент выполнения выражения @emph{@math{\langle}e3@math{\rangle}} из
процедуры выше по тексту, и сравните его устройство при последовательной
обработке определений и при описанном выше преобразовании. Откуда в
преобразованной программе берется дополнительный кадр? Объясните, почему
это различие никогда не отражается на поведении корректных программ.
Придумайте, как заставить интерпретатор реализовать правило
<<одновременной>> сферы действия для внутренних определений без создания
дополнительного кадра.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.18}Упражнение 4.18:} Рассмотрим альтернативную
стратегию обработки определений, которая переводит пример из текста в

@lisp
(lambda @math{\langle}@var{переменные}@math{\rangle}
  (let ((u '*unassigned*) (v '*unassigned*))
    (let ((a @math{\langle}@var{e1}@math{\rangle}) (b @math{\langle}@var{e2}@math{\rangle}))
      (set! u a)
      (set! v b))
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

Здесь @code{a} и @code{b} представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру @code{solve} из @ref{3.5.4}:

@lisp
(define (solve f y0 dt)
  (define  y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

Будет ли эта процедура работать, если внутренние определения
преобразуются так, как предлагается в этом упражнении? А если так, как в
тексте раздела? Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.19}Упражнение 4.19:}
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том,
каким должен быть результат выражения

\enlargethispage{\baselineskip}

@lisp
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
@end lisp

Бен говорит, что следует действовать согласно последовательному правилу
для @code{define}: @code{b} равно 11, затем @code{a} определяется как 5,
так что общий результат равен 16. Лиза возражает, что взаимная рекурсия
требует правила одновременной сферы действия для внутренних определений
и нет причин рассматривать имена процедур отдельно от прочих имен. То
есть она выступает за механизм, реализованный в @ref{Упражнение 4.16}.
При этом @code{a} оказывается не
определено в момент, когда вычисляется @code{b}. Следовательно, по
мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с обоими.
Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение @code{a} должно использоваться при
вычислении @code{b}. Следовательно, по мнению Евы, @code{a} должно
равняться 5, @code{b} должно быть 15, а общий результат 20. Какую из
этих точек зрения Вы поддерживаете (если у Вас нет своей четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?@footnote{Авторы MIT Scheme согласны с
Лизой, и вот почему: в принципе права Ева --- определения следует
рассматривать как одновременные. Однако придумать универсальный
эффективный механизм, который вел бы себя так, как она требует, кажется
трудным. Если же такого механизма нет, то лучше порождать ошибку в
сложных случаях параллельных определений (мнение Лизы), чем выдавать
неверный ответ (как хочет Бен).}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.20}Упражнение 4.20:}
Поскольку внутренние определения выглядят
последовательными, а на самом деле параллельны, некоторые предпочитают
их вовсе избегать и вместо этого пользуются особой формой @code{letrec}.
@code{Letrec} выглядит так же, как @code{let}, поэтому неудивительно,
что переменные в нем связываются одновременно и имеют одинаковую для
всех сферу действия. Можно переписать процедуру-пример @code{f} из
текста без внутренних определений, но при этом в точности с тем же
значением, так:

@lisp
(define (f x)
  (letrec
    ((even? (lambda (n)
              (if (= n 0) true  (odd?  (- n 1)))))
     (odd?  (lambda (n)
              (if (= n 0) false (even? (- n 1))))))
    @math{\langle}@var{остаток тела @code{f}}@math{\rangle}))
@end lisp

Выражение @code{letrec} имеет вид

@lisp
(letrec ((@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{πер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
и является вариантом @code{let}, в котором выражения
@math{\langle}@var{выр}@math{_k\rangle},
устанавливающие начальные значения для переменных
@math{\langle}@var{πер}@math{_k\rangle}, вычисляются
в окружении, которое включает все связывания @code{letrec}. Это делает
возможным рекурсию между связываниями, к примеру, взаимную рекурсию
@code{even?} и @code{odd?} в последнем примере, или вычисление
факториала 10 через

@lisp
(letrec
  ((fact (lambda (n)
           (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
@end lisp

@enumerate a.

@item
Реализуйте @code{letrec} как производное выражение, переводя выражение
@code{letrec} в выражение @code{let}, как показано в тексте раздела или
в упражнении @ref{Упражнение 4.18}. То есть переменные @code{letrec}
должны создаваться в @code{let}, а затем получать значение через
@code{set!}.

@item
Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся @code{define} внутри процедуры, то
пусть пользуются обычным @code{let}. Покажите, что́ в его рассуждениях
неверно. Нарисуйте диаграмму, показывающую окружение, в котором
выполняется @math{\langle}@var{остаток тела @code{f}}@math{\rangle} во
время вычисления выражения @code{(f 5)}, если @code{f} определена как в
этом упражнении. Нарисуйте диаграмму окружений для того же вычисления,
но только с @code{let} на месте @code{letrec} в определении @code{f}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.21}Упражнение 4.21:}
Как ни удивительно, интуитивная догадка Хьюго (в @ref{Упражнение 4.20})
оказывается верной. Действительно,
можно строить рекурсивные процедуры без использования @code{letrec} (и
даже без @code{define}), только способ это сделать намного тоньше, чем
казалось Хьюго. Следующее выражение вычисляет факториал 10 с помощью
рекурсивной процедуры:@footnote{В этом примере показан программистский
трюк, позволяющий формулировать рекурсивные процедуры без помощи
@code{define}. Самый общий прием такого рода называется (Y operator), и
с его помощью можно реализовать рекурсию в <<чистом
@math{\lambda}-исчислении>>. (Подробности о лямбда-исчислении можно
найти в Stoy 1977, а демонстрацию @math{Y}-оператора на Scheme в Gabriel
1988.)}

@lisp
((lambda (n)
   ((lambda (fact) (fact fact n))
    (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
 10)
@end lisp

@enumerate a.

@item
Проверьте, что это выражение на самом деле считает факториалы (вычисляя
его). Постройте аналогичное выражение для вычисления чисел Фибоначчи.

@item
Рассмотрим следующую процедуру, включающую взаимно рекурсивные
внутренние определения:

@lisp
(define (f x)
  (define (even? n)
    (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)
    (if (= n 0) false (even? (- n 1))))
  (even? x))
@end lisp

Восстановите пропущенные фрагменты так, чтобы получилось альтернативное
определение @code{f}, где нет ни внутренних определений, ни @code{letrec}:

@lisp
(define (f x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))))
@end lisp
@end enumerate
@end quotation

@comment @subsection Separating Syntactic Analysis from Execution
@subsection Отделение синтаксического анализа от выполнения
@node	4.1.7,  , 4.1.6, 4.1

Написанный нами интерпретатор прост, но очень неэффективен, потому что
синтаксический анализ выражений перемешан в нем с их выполнением. Таким
образом, сколько раз выполняется программа, столько же раз анализируется
ее синтаксис. Рассмотрим, например, вычисление @code{(factorial 4)},
если дано следующее определение факториала:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Каждый раз, когда вызывается @code{factorial}, интерпретатор должен
определить, что тело процедуры является условным выражением, и извлечь
его предикат. Только после этого он может вычислить предикат и поступить
в соответствии с его значением. Каждый раз, когда вычисляется выражение
@code{(* (factorial (- n 1)) n)} или подвыражения
@code{(factorial (- n 1))} и @code{(- n 1)}, интерпретатор должен
произвести анализ случаев внутри @code{eval}, выяснить, что выражение
является вызовом процедуры, а также извлечь его оператор и операнды.
Такой анализ недёшев. Проделывать его многократно --- неразумно.

Можно преобразовать интерпретатор так, чтобы синтаксический анализ
проводился только один раз, и повысить таким образом эффективность
работы.@footnote{Такое преобразование является неотъемлемой частью
процесса компиляции, который мы рассмотрим в @ref{Глава 5}.
Джонатан Рис написал для проекта T интерпретатор Scheme с похожей
структурой приблизительно в 1982 голу (Rees and Adams 1982). Марк Фили
(Feeley 1986, см. также Feeley and Lapalme 1987) независимо изобрел этот
метод в своей дипломной работе.} Мы разбиваем процедуру @code{eval},
которая принимает выражение и окружение, на две части. @code{analyze}
берет только выражение. Она выполняет синтаксический анализ и возвращает
новую @emph{исполнительную процедуру} (@newterm{execution procedure}). В этой
процедуре упакована работа, которую придется проделать при выполнении
выражения. Исполнительная процедура берет в качестве аргумента окружение
и завершает вычисление. При этом экономится работа, потому что
@code{analyze} будет для каждого выражения вызываться только один раз, а
исполнительная процедура, возможно, многократно.

После разделения анализа и выполнения @code{eval} превращается в

@lisp
(define (eval exp env) ((analyze exp) env))
@end lisp

@noindent
Результатом вызова @code{analyze} является исполнительная процедура,
которая применяется к окружению. @code{Analyze} содержит тот же самый
анализ, который делал исходный @code{eval} из @ref{4.1.1}, однако процедуры,
между которыми мы выбираем, только анализируют, а не окончательно выполняют
выражение.

@lisp
(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else (error "Unknown expression type: ANALYZE" exp))))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Вот самая простая из процедур анализа, которая обрабатывает
самовычисляющиеся выражения. Ее результатом является исполнительная
процедура, которая игнорирует свой аргумент-окружение и просто
возвращает само выражение:

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
@end lisp

@noindent
В случае кавычки мы можем добиться некоторого выигрыша, извлекая
закавыченное выражение только один раз на стадии анализа, а не на стадии
выполнения.

@lisp
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
@end lisp

@noindent
Поиск переменной нужно проводить на стадии выполнения, поскольку при
этом требуется знать окружение.@footnote{Есть, впрочем, важная часть
поиска переменной, которую все-таки @emph{можно} осуществить во время
синтаксического анализа. Как мы покажем в @ref{5.5.6}, можно
определить позицию в структуре окружения, где будет находиться нужное
значение, и таким образом избежать необходимости искать в окружении
элемент, который соответствует переменной.}

@lisp
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
@end lisp

@noindent
Анализ присваивания, @code{analyze-assignment}, также должен отложить
само присваивание до времени выполнения, когда будет в наличии
окружение. Однако возможность (рекурсивно) проанализировать выражение
@code{assignment-value} сразу, на стадии анализа, --- это большой
выигрыш в эффективности, поскольку теперь это выражение будет
анализироваться только однажды. То же верно и для определений:

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
@end lisp

@noindent
Для условных выражений мы извлекаем и анализируем предикат, следствие и
альтернативу на стадии анализа.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
@end lisp

@noindent
При анализе выражения @code{lambda} также достигается значительный
выигрыш в эффективности: тело @code{lambda} анализируется только один
раз, а процедура, получающаяся в результате выполнения @code{lambda},
может применяться многократно.

@lisp
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
@end lisp

@noindent
Анализ последовательности выражений (в @code{begin} или в теле
@code{lambda}-выражения) более сложен.@footnote{См. @ref{Упражнение 4.23},
в котором объясняются некоторые подробности обработки последовательностей.}
Каждое выражение в последовательности анализируется, и для каждого
получается исполнительная процедура. Эти исполнительные процедуры
комбинируются в одну общую исполнительную процедуру, которая принимает в
качестве аргумента окружение и последовательно вызывает каждую из
частичных исполнительных процедур, передавая ей окружение как аргумент.

@lisp
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@noindent
Для вызова процедуры мы анализируем оператор и операнды и строим
исполнительную процедуру, которая вызывает исполнительную процедуру
оператора (получая при этом объект-процедуру, которую следует применить)
и исполнительные процедуры операндов (получая аргументы). Затем мы все
это передаем в @code{execute-application}, аналог @code{apply} из @ref{4.1.1}.
@code{Execute-application} отличается от @code{apply} тем, что тело
составной процедуры уже проанализировано, так что нет нужды в дальнейшем
анализе. Вместо этого мы просто вызываем исполнительную процедуру для
тела, передавая ей расширенное окружение.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env)
       (map (lambda (aproc) (aproc env))
            aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@noindent
В нашем новом интерпретаторе используются те же структуры данных,
синтаксические процедуры и вспомогательные процедуры времени выполнения,
что и в разделах @ref{4.1.2}, @ref{4.1.3} и @ref{4.1.3}.

@endpage
@quotation
@strong{@anchor{Упражнение 4.22}Упражнение 4.22:}
Расширьте интерпретатор из этого раздела так, чтобы он
поддерживал @code{let}. (См. упражнение @ref{Упражнение 4.6}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.23}Упражнение 4.23:}
Лиза П. Хакер не понимает, зачем делать
@code{analyze-sequence} такой сложной. Все остальные процедуры
анализа --- простые трансформации соответствующих вычисляющих процедур
(или ветвей @code{eval}) из @ref{4.1.1}. Лиза ожидала, что
@code{analyze-sequence} будет выглядеть так:

@lisp
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (lambda (env)
      (execute-sequence procs env))))
@end lisp

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше
работы по вычислению последовательности во время анализа. В Лизиной
исполнительной процедуре вызовы частичных исполнительных процедур,
вместо того, чтобы быть встроенными, перебираются в цикле. В результате,
хотя отдельные выражения в последовательности оказываются
проанализированы, сама последовательность анализируется во время
выполнения.

Сравните две версии @code{analyze-sequence}. Рассмотрите, например,
обычный случай (типичный для тел процедур), когда в последовательности
только одно выражение. Какую работу будет делать исполнительная
процедура, предложенная Лизой? А процедура из текста раздела? Как
соотносятся эти две процедуры в случае последовательности из двух
выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.24}Упражнение 4.24:}
Спроектируйте и проведите несколько экспериментов, чтобы
сравнить скорость исходного метациклического вычислителя и его версии из
этого раздела. С помощью результатов этих опытов оцените долю времени,
которая тратится на анализ и на собственно выполнение в различных
процедурах.
@end quotation

@comment @section Variations on a Scheme --- Lazy Evaluation
@section Scheme с вариациями: ленивый интерпретатор
@node	4.2, 4.3, 4.1, Chapter 4

Теперь, имея в своем распоряжении интерпретатор, выраженный в виде
программы на Лиспе, мы можем экспериментировать с различными вариантами
строения языка, просто модифицируя этот интерпретатор. В самом деле,
часто изобретение нового языка начинается с того, что пишут
интерпретатор, который встраивает новый язык в существующий язык
высокого уровня. Например, если нам хочется обсудить какую-то деталь
предлагаемой модификации Лиспа с другим членом Лисп-сообщества, мы можем
предъявить ему интерпретатор, в котором эта модификация реализована.
Тогда наш адресат может поэкспериментировать с новым интерпретатором и
послать в ответ свои замечания в виде дальнейших модификаций. Реализация
на высокоуровневой основе не только упрощает проверку и отладку
вычислителя; такое встраивание к тому же позволяет разработчику
слизывать@footnote{Слизывать (@emph{snarf}): <<Брать, в особенности
большой документ или файл, с целью использовать с разрешения владельца
или без оного>>. Пролизывать (@emph{snarf down}): <<Слизывать, иногда с
дополнительным значением восприятия, переработки или понимания>>. (Эти
определения были слизаны из Steele et al. 1983. См. также Raymond
1993.)} черты языка-основы, как наш встроенный интерпретатор Лиспа
использовал примитивы и структуру управления нижележащего Лиспа. Только
позже (да и то не всегда) разработчику приходится брать на себя труд
построения полной реализации на низкоуровневом языке или в аппаратуре. В
этом разделе и следующем мы изучаем некоторые вариации на тему Scheme,
которые значительно увеличивают ее выразительную силу.

@menu
* 4-2-1::            Нормальный πорядок вычислений и аππликативный
* 4-2-2::            Интерπретатор с ленивым вычислением
* 4-2-3::            Потоки как ленивые сπиски
@end menu

@comment @subsection Normal Order and Applicative Order
@subsection Нормальный порядок вычислений и аппликативный порядок
@node	4.2.1, 4.2.2, 4.2, 4.2

В @ref{1.1}, где мы начали обсуждение моделей вычисления, мы указали, что
Scheme --- язык с (@newterm{applicative-order language}), а именно, что все
аргументы процедур в Scheme вычисляются в момент вызова. Напротив, в языках с
(@newterm{normal-order language}) вычисление аргументов процедур задерживается
до момента, когда действительно возникает нужда в их значениях. Если
вычисление аргументов процедур откладывается как можно дольше (например,
до того момента, когда они требуются какой-либо элементарной процедуре),
то говорят о @emph{ленивом вычислении} (@newterm{lazy evaluation}).
@footnote{Терминологическая разница между выражениями <<ленивый>> и
<<нормальный порядок вычислений>> несколько размыта.
Обычно <<ленивый>> относится к механизмам конкретных интерпретаторов, а
<<нормальный порядок>> к семантике языков независимо от способа
реализации. Однако разделение здесь не жесткое, и часто эти термины
употребляются как синонимы.} Рассмотрим процедуру

@lisp
(define (try a b) (if (= a 0) 1 b))
@end lisp

@noindent
Выполнение @code{(try 0 (/ 1 0))} в Scheme приводит к ошибке. При
ленивых вычислениях никакой ошибки не возникнет. Вычисление выражения
даст результат 1, поскольку к аргументу @code{(/ 1 0)} обращаться не
понадобится.

Примером использования ленивых вычислений может служить процедура
@code{unless}:

@lisp
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
@end lisp

@noindent
которую можно использовать в выражениях вроде

@lisp
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0") 0))
@end lisp

@noindent
В аппликативном языке это не будет работать, потому что и обычное
значение, и значение исключения будут выполнены еще до вызова
@code{unless} (См. упражнение @ref{Упражнение 1.6}). Преимущество
ленивых вычислений в том, что некоторые процедуры, например, та же
@code{unless}, могут выполнять полезные действия, даже если вычисление
некоторых их аргументов способно привести к ошибке или бесконечному
циклу.

Если тело процедуры начинает выполняться прежде, чем вычисляется ее
аргумент, то процедура называется (non-strict) по этому аргументу. Если
же аргумент вычисляется прежде, чем происходит вход в процедуру, то
процедура называется (strict) по этому аргументу.@footnote{Термины
<<строгий>> и <<нестрогий>> означают, в сущности, то же самое, что
<<аппликативный>> и <<нормальный>> порядок вычислений, но только они
относятся к отдельным процедурам и их аргументам, а не к языку в целом.
На конференциях по языкам программирования можно услышать, как
кто-нибудь говорит: <<В языке Hassle с нормальным порядком вычислений
есть несколько строгих примитивов. Остальные процедуры принимают
аргументы через ленивое вычисление>>.} В чисто аппликативном языке все
процедуры строги по всем своим аргументам. В языке с чисто нормальным
порядком вычислений все составные процедуры нестроги по всем своим
аргументам, а элементарные процедуры могут быть и такими, и такими.
Бывают также языки (см. упражнение @ref{Упражнение 4.31}), которые
дают программисту возможность явно обозначать строгость определяемых им
процедур.

Яркий пример процедуры, которой может быть полезно оказаться
нестрогой, --- это @code{cons} (и вообще почти любой конструктор
структур данных). Можно производить полезные вычисления, составлять из
элементов структуры данных и работать с ними, даже если значения
элементов неизвестны. Вполне имеет смысл задача, например, посчитать
длину списка, не зная значений его отдельных элементов. В
@ref{4.2.3} мы развиваем эту идею и реализуем потоки из @ref{Глава 3}
в виде списков, составленных из нестрогих @code{cons}-пар.

@quotation
@strong{@anchor{Упражнение 4.25}Упражнение 4.25:}
Предположим, что мы (в обычной Scheme с аппликативным
порядком вычислений) определяем @code{unless} как показано выше, а затем
определяем @code{factorial} через @code{unless}:

@lisp
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
@end lisp

Что произойдет, если мы попытаемся вычислить @code{(factorial 5)}? Будут
ли наши определения работать в языке с нормальным порядком вычислений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.26}Упражнение 4.26:}
Бен Битобор и Лиза П. Хакер расходятся во мнениях о
важности ленивых вычислений для реализации конструкций вроде
@code{unless}. Бен указывает, что при аппликативном порядке
@code{unless} можно реализовать как особую форму. Лиза отвечает, что в
таком случае @code{unless} будет просто синтаксисом, а не процедурой,
которую можно использовать в сочетании с процедурами высших порядков.
Проясните детали в обеих позициях. Покажите, как реализовать
@code{unless} в виде производного выражения (вроде @code{cond} или
@code{let}), и приведите пример ситуации, когда имеет смысл, чтобы
@code{unless} была процедурой, а не особой формой.
@end quotation

@comment @subsection An Interpreter with Lazy Evaluation
@subsection Интерпретатор с ленивым вычислением
@node	4.2.2, 4.2.3, 4.2.1, 4.2

В этом разделе мы реализуем язык с нормальным порядком вычислений,
который отличается от Scheme только тем, что все составные процедуры по
всем аргументам нестроги. Элементарные процедуры по-прежнему будут
строгими. Совсем несложно, модифицируя интерпретатор из раздела
@ref{4.1.1}, добиться, чтобы интерпретируемый
язык вел себя таким образом. Почти что все требуемые изменения
сосредоточены вокруг механизма процедурного вызова.

Основная идея состоит в том, что при вызове процедуры интерпретатор
должен определить, какие аргументы требуется вычислить, а какие
задержать. Задержанные аргументы не вычисляются, а преобразуются в
объекты, называемые (@newterm{thunks}).@footnote{Название <<санк>> было
придумано в неформальной группе, которая обсуждала реализацию вызова по имени в
Алголе 60. Было замечено, что большую часть анализа (<<обдумывания>>,
@emph{thinking about}) выражения можно производить во время компиляции;
таким образом, во время выполнения выражение будет уже большей частью
<<обдумано>> (@emph{thunk about} --- намеренно неверно образованная
английская форма) (Ingerman et al. 1960).} В санке должна содержаться
информация, необходимая, чтобы вычислить значение аргумента, когда оно
потребуется, и сделать это так, как будто оно вычислено во время вызова.
Таким образом, санк должен содержать выражение-аргумент и окружение, в
котором вычисляется вызов процедуры.

Процесс вычисления санка называется (@newterm{forcing}).@footnote{Это
аналогично использованию слова @code{force} (<<вынудить>>,
<<заставить>>) для задержанных объектов, при помощи которых в @ref{Глава 3}
представлялись потоки. Основная разница между тем, что мы делаем здесь,
и тем, чем мы занимались в @ref{Глава 3},
состоит в том, что теперь мы встраиваем задержку и вынуждение в
интерпретатор, и они применяются автоматически и единообразно во всем
языке.} Вообще говоря, санк вынуждается только тогда, когда требуется
его значение: когда он передается в элементарную процедуру, использующую
его значение; когда он служит предикатом в условном выражении; или когда
он является значением оператора, который нужно применить как процедуру.
Мы должны решить, будем ли мы (@newterm{memoize}) санки, как мы делали с
задержанными объектами в @ref{3.5.1}.
При использовании мемоизации, когда санк вынуждается в первый раз, он
запоминает вычисленное значение. Последующие вызовы только возвращают
запомненное значение, не вычисляя его заново. Мы делаем выбор в пользу
мемоизации, поскольку для многих приложений это эффективнее. Здесь,
однако, имеются тонкости.@footnote{Ленивые вычисления, совмещенные с
мемоизацией, иногда называют методом передачи аргументов с
(@newterm{call by need}), в отличие от (@newterm{call-by-name}). (Вызов
по имени, введенный в Алголе 60, аналогичен немемоизированному ленивому
вычислению.) Как проектировщики языка мы можем сделать интерпретатор
мемоизирующим или немемоизирующим, или же оставить это на усмотрение
программистов (упражнение @ref{Упражнение 4.31}). Как можно было ожидать
из @ref{Глава 3}, этот выбор вызывает к жизни вопросы, особенно тонкие и
запутанные в присутствии присваивания. (См. упражнения @ref{Упражнение 4.27}
и @ref{Упражнение 4.29}.) В замечательной статье Клингера (Clinger 1982)
делается попытка прояснить многомерную путаницу, которая здесь возникает.}

@comment @subsubheading Modifying the evaluator
@subsubheading Преобразование интерпретатора

Основная разница между ленивым интерпретатором и интерпретатором из @ref{4.1}
состоит в обработке вызовов процедур внутри @code{eval} и @code{apply}.

Ветка @code{application?} в @code{eval} принимает вид

@lisp
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
@end lisp

@noindent
Это почти тот же код, что был в ветке @code{application?} в @code{eval}
из @ref{}. Однако при ленивом
вычислении мы зовем @code{apply} с выражениями операндов, а не с
аргументами, которые получаются при их вычислении. Мы также передаем
@code{apply} окружение, поскольку оно понадобится для построения санков,
если нам хочется, чтобы аргуметы вычислялись с задержкой. Оператор мы
по-прежнему вычисляем, потому что сама применяемая процедура нужна
@code{apply}, чтобы выбрать действие на основании ее типа (элементарная
или составная) и применить ее.

Всякий раз, когда нам требуется собственно значение выражения, мы вместо
простого @code{eval} пользуемся процедурой

@lisp
(define (actual-value exp env)
  (force-it (eval exp env)))
@end lisp

@noindent
чтобы, если значение выражения является санком, оно было вынуждено.

Наша новая версия @code{apply} также почти совпадает с версией из @ref{4.1.1}.
Разница состоит в том, что @code{eval} передает ей невычисленные выражения:
для элементарных процедур (они строгие) мы вычисляем все аргументы и затем
вызываем примитив; для составных процедур (они нестрогие) мы прежде применения
процедуры замораживаем все аргументы.

@lisp
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))   @r{; изменение}
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)  @r{; изменение}
           (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY"
                     procedure))))
@end lisp

@noindent
Процедуры, обрабатывающие аргументы, почти такие же, как @code{list-of-values}
из @ref{4.1.1}, но только @code{list-of-delayed-args} замораживает аргументы,
вместо того, чтобы их вычислять, а в @code{list-of-arg-values} вместо
@code{eval} используется @code{actual-value}:

@lisp
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))
(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
@end lisp

@noindent
Кроме того, нам требуется изменить в интерпретаторе обработку @code{if},
где вместо @code{eval} мы должны вызывать @code{ actual-value}, чтобы
значение предикатного выражения вычислялось прежде, чем мы проверим,
истинно оно или ложно:

@lisp
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Наконец, нужно изменить процедуру @code{driver-loop} (@ref{4.1.4}), чтобы она
звала @code{actual-value} вместо @code{eval}. Таким образом, если
задержанное значение добирается до цикла чтение-вычисление-печать, то
оно, прежде чем печататься, будет разморожено. Кроме того, чтобы
показать, что работа идет с ленивым интерпретатором, мы изменим подсказки:

@lisp
(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value
            input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
@end lisp

@noindent
Внеся эти изменения, мы можем запустить интерпретатор и протестировать
его. Успешное вычисление выражения @code{try}, описанного в @ref{4.2.1},
показывает, что интерпретатор проводит ленивое вычисление:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)
@i{;;; L-Eval input:}
(define (try a b) (if (= a 0) 1 b))
@i{;;; L-Eval value:}
@i{ok}
@i{;;; L-Eval input:}
(try 0 (/ 1 0))
@i{;;; L-Eval value:}
@i{1}
@end lisp

@comment @subsubheading Representing thunks
@subsubheading Представление санков

Наш интерпретатор должен устроить работу так, чтобы при применении
процедур к аргументам порождались санки, и чтобы потом они вынуждались.
Выражение в санке должно запаковываться вместе с окружением, так, чтобы
потом можно было по ним вычислить аргумент. Чтобы вынудить санк, мы
просто извлекаем из него выражение и окружение, и вычисляем выражение в
окружении. Мы используем при этом не @code{eval}, а @code{actual-value},
так что если результат выражения сам окажется санком, мы и его вынудим,
и так пока не доберемся до не-санка.

@lisp
(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
@end lisp

@noindent
Простой способ упаковать выражение вместе с окружением --- создать
список из выражения и окружения. Таким образом, мы порождаем санк так:

@lisp
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr  thunk))
(define (thunk-env thunk) (caddr thunk))
@end lisp

@noindent
Однако на самом деле нам в интерпретаторе нужны не такие санки, а
мемоизированные. Мы сделаем так, чтобы санк при вынуждении превращался в
вычисленный санк. Для этого мы будем заменять хранимое в нем выражение
на значение и менять метку санка, чтобы можно было понять, что он уже
вычислен.@footnote{Заметим, что, вычислив выражение, мы еще и стираем из
санка окружение. Это не влияет на то, какие значения возвращает
интерпретатор. Однако при этом экономится память, поскольку стирание
ссылки из санка на @code{env}, когда она становится больше не нужна,
позволяет подвергнуть эту структуру (@newterm{garbage collection}) и заново
использовать ее память. Мы обсудим это в @ref{5.3}.

Подобным образом можно было бы разрешить собирать как мусор ненужные
окружения в мемоизированных задержанных объектах из @ref{3.5.1}:
@code{memo-proc}, сохранив значение процедуры @code{proc}, делала бы
что-нибудь вроде @code{(set! proc '())}, чтобы забыть саму процедуру
(включающую окружение, где было вычислено @code{delay}).}

@lisp
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk)
  (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj)
                                     (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj)
                     result)     @r{; replace @code{exp} with its value}
           (set-cdr! (cdr obj)
                     '())        @r{; forget unneeded @code{env}}
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
@end lisp

@noindent
Заметим, что одна и та же процедура @code{delay-it} работает и с
мемоизацией, и без нее.

@quotation
@strong{@anchor{Упражнение 4.27}Упражнение 4.27:}
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

@lisp
(define count 0)
(define (id x) (set! count (+ count 1)) x)
@end lisp

Вставьте пропущенные значения в данной ниже последовательности действий
и объясните свои ответы.@footnote{Это упражнение показывает, что
взаимодействие между ленивыми вычислениями и побочными эффектами может
быть весьма запутанным. Ровно этого можно было ожидать после обсуждения в
@ref{Глава 3}.}

@lisp
(define w (id (id 10)))
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
w
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.28}Упражнение 4.28:}
@code{Eval}, передавая оператор в @code{apply}, вычисляет
его не при помощи @code{eval}, а через @code{actual-value}, чтобы
вынудить. Приведите пример, который показывает, что такое вынуждение
необходимо.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.29}Упражнение 4.29:}
Придумайте пример программы, которая, по Вашему мнению,
будет работать намного медленнее без мемоизации, чем с мемоизацией.
Рассмотрим, помимо этого, следующую последовательность действий, в
которой процедура @code{id} определена как в
упражнении @ref{Упражнение 4.27}, а счетчик @code{count} начинает с 0:

@lisp
(define (square x) (* x x))
@i{;;; L-Eval input:}
(square (id 10))
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp

Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.30}Упражнение 4.30:}
Пабло Э. Фект, бывший программист на языке C,
беспокоится, что ленивый интерпретатор не вынуждает выражения в
последовательности, и оттого некоторые побочные эффекты могут никогда не
произойти. Поскольку ни у одного выражения в последовательности, помимо
конечного, значение не используется (выражение стоит там только ради
своего эффекта, например, чтобы присвоить значение переменной или
что-нибудь напечатать), у значения такого выражения не может
впоследствии быть применения, для которого его потребуется вынудить
(например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
@code{eval-sequence} из @ref{4.1.1}
так, чтобы она вместо @code{eval} использовала @code{actual-value}:

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
@end lisp

@enumerate a.

@item
Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
@code{for-each} из упражнения @ref{Упражнение 2.23} --- важный пример
последовательности с побочными эффектами:

@lisp
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
@end lisp

Он утверждает, что интерпретатор из текста (с исходным @code{eval-sequence})
правильно работает с этой процедурой:

@lisp
@i{;;; L-Eval input:}
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
@i{57}
@i{321}
@i{88}
@i{;;; L-Eval value:}
@i{done}
@end lisp

Объясните, почему Бен прав насчет поведения @code{for-each}.

@item
Пабло соглашается с Беном по поводу примера с @code{for-each}, но
говорит, что, предлагая изменить @code{eval-sequence}, он имел в виду
другой тип программ. Он определяет в ленивом интерпретаторе следующие
две процедуры:

@lisp
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
@end lisp

Какие значения вернут @code{(p1 1)} и @code{(p2 1)} с исходной
@code{eval-sequence}? Каковы будут значения с изменением, которое
предлагает Пабло?

@item
Пабло указывает также, что изменение @code{eval-sequence}, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

@item
Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.31}Упражнение 4.31:}
Подход, принятый в этом разделе, нехорош тем, что вносит
изменение в Scheme, не сохраняя ее семантику. Было бы приятнее
реализовать ленивые вычисления как (@newterm{upward-compatible extension}), то
есть так, чтобы обычные программы на Scheme работали как прежде. Этого
можно добиться, расширив синтаксис определений процедур, так, чтобы
пользователь мог решать, нужно ли задерживать аргументы. При этом можно
еще предоставить пользователю выбор между задержкой с мемоизацией и без
нее. Например, определение

@lisp
(define (f a (b lazy) c (d lazy-memo))
  @dots{})
@end lisp

@noindent
делало бы @code{f} процедурой от четырех аргументов, причем первый и
третий вычисляются при вызове процедуры, второй задерживается, а
четвертый задерживается и мемоизируется. Таким образом, обыкновенные
определения процедур будут задавать такое же поведение, как в обычной
Scheme, а добавление декларации @code{lazy-memo} к каждому параметру
каждой составной процедуры приведет к поведению, как у ленивого
интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового
синтаксиса @code{define}. Кроме того, надо будет добиться, чтобы
@code{eval} и @code{apply} определяли, когда надо задерживать аргументы,
и соответствующим образом задерживали и вынуждали их. Наконец, придется
обеспечить,чтобы вынуждение было с мемоизацией или без оной, смотря по
обстоятельствам.
@end quotation

@comment @subsection Streams as Lazy Lists
@subsection Потоки как ленивые списки
@node	4.2.3,  , 4.2.2, 4.2

В @ref{3.5.1} мы показали, как реализовать потоки в виде задержанных списков.
Мы ввели особые формы @code{delay} и @code{cons-stream}, которые позволили нам
строить <<обещания>> вычислить @code{cdr} потока, не выполняя эти
обещания до более позднего времени. Можно было бы использовать этот же
метод и вводить новые особые формы всякий раз, когда нам требуется
детальное управление процессом вычисления, но это было бы весьма
неуклюже. Прежде всего, особая форма, в отличие от процедуры, не
является полноправным объектом, и ее нельзя использовать в сочетании с
процедурами высших порядков.@footnote{Это как раз тот вопрос, который
возник по отношению к процедуре @code{unless} в @ref{Упражнение 4.26}.}
Кроме того, нам пришлось ввести
потоки как новый тип объектов данных, похожий на списки, но отличный от
них, и из-за этого потребовалось заново переписать для работы с потоками
множество обычных операций над списками (@code{map}, @code{append} и
тому подобное).

Когда у нас есть ленивое вычисление, списки и потоки можно считать одним
и тем же типом, так что не возникает нужды в особых формах и в отдельных
наборах операций для списков и потоков. Все, что нам требуется, --- это
так устроить дела, чтобы @code{cons} оказалась нестрогой. Можно сделать
это, расширив интерпретатор и разрешив нестрогие элементарные процедуры,
а затем реализовать @code{cons} как одну из таких процедур. Однако проще
вспомнить (из @ref{2.1.3}), что
вообще не существует особой нужды реализовывать @code{cons} как
примитив. Вместо этого можно представлять пары в виде
процедур:@footnote{Это процедурное представление, описанное в
упражнении @ref{Упражнение 2.4}. В сущности, подошла бы и любая другая
процедурная реализация (например, на основе передачи сообщений).
Обратите внимание, что внести эти определения в ленивый интерпретатор
можно, просто набрав их в управляющем цикле. Если мы изначально включили
@code{cons}, @code{car} и @code{cdr} как примитивы в глобальное
окружение, они будут переопределены. (См. также @ref{Упражнение 4.33} и @ref{Уπражнение 4.34}.)}

@lisp
(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))
@end lisp

@noindent
Выраженные через эти базовые операции, стандартные определения операций
над списками будут работать как с бесконечными списками (потоками), так
и с конечными, а потоковые операции можно определить как операции над
списками. Вот несколько примеров:

@lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items)) (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
(define ones (cons 1 ones))
(define integers (cons 1 (add-lists ones integers)))
@i{;;; L-Eval input:}
(list-ref integers 17)
@i{;;; L-Eval value:}
@i{18}
@end lisp

@noindent
Заметим, что ленивые списки еще ленивее, чем потоки в @ref{Глава 3}:
задерживается не только @code{cdr} списка, но и @code{car}.
@footnote{Благодаря этому можно реализовать задержанные версии
не только последовательностей, но и более общих видов списковых
структур. В Hughes 1990 обсуждаются некоторые применения <<ленивых
деревьев>>.} На самом деле, даже доступ к @code{car} или @code{cdr}
ленивой пары не обязательно вынуждает значение элемента списка. Значение
будет вынуждено только тогда, когда это действительно нужно ---
например, чтобы использовать его в качестве аргумента примитива или
напечатать в качестве ответа.

Ленивые пары также помогают с решением проблемы, которая возникла в @ref{3.5.4},
где мы обнаружили, что формулировка потоковых моделей систем с циклами
может потребовать оснащения программы явными операциями @code{delay},
помимо тех, что встроены в @code{cons-stream}. При ленивом вычислении
все аргументы процедур единообразно задерживаются. Например, можно
реализовать процедуры для интегрирования списка и решения
дифференциальных уравнений так, как мы изначально намеревались в @ref{3.5.4}:

@lisp
(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) int)))
  int)
(define (solve f y0 dt)
  (define  y (integral dy y0 dt))
  (define dy (map f y))
  y)
@i{;;; L-Eval input:}
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
@i{;;; L-Eval value:}
@i{2.716924}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.32}Упражнение 4.32:}
Приведите несколько примеров, которые показывают разницу между потоками из
@ref{Глава 3} и <<более ленивыми>> списками, описанными в этом разделе.
Как можно воспользоваться этой дополнительной ленивостью?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.33}Упражнение 4.33:}
Бен Битобор проверяет вышеописанную реализацию при помощи выражения

@lisp
(car '(a b c))
@end lisp

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что <<списки>>. которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями
@code{cons}, @code{car} и @code{cdr}. Измените работу интерпретатора с
закавыченными выражениями так, чтобы при вводе списковых выражений в
цикле управления получались настоящие ленивые списки.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.34}Упражнение 4.34:}
Измените управляющий цикл интерпретатора так, чтобы
ленивые пары и списки печатались каким-либо разумным образом. (Как Вы
собираетесь работать с бесконечными списками)? Вероятно, понадобится
также изменить представление ленивых пар, чтобы при печати интерпретатор
их распознавал и печатал особым образом.
@end quotation

@comment @section Variations on a Scheme --- Nondeterministic Computing
@section Scheme с вариациями --- недетерминистское вычисление
@node	4.3, 4.4, 4.2, Chapter 4

В этом разделе мы расширяем интерпретатор Scheme так, чтобы он поддерживал
парадигму программирования, называемую (@newterm{nondeterministic computing}),
встраивая в интерпретатор средства поддержки автоматического поиска. Это
значительно более глубокое изменение в языке, чем введение ленивых вычислений в
@ref{Часть 4.2}.

Подобно обработке потоков, недетерминистское вычисление полезно в
задачах типа <<порождение и проверка>>. Рассмотрим такую задачу: даются
два списка натуральных чисел, и требуется найти пару чисел --- одно из
первого списка, другое из второго, --- сумма которых есть простое число. В
@ref{2.2.3} мы уже рассмотрели, как это можно сделать при помощи операций над
конечными последовательностями, а в @ref{3.5.3} ---
при помощи бесконечных потоков. Наш подход состоял в том, чтобы породить
последовательность всех возможных пар и отфильтровать ее, выбирая пары,
в которых сумма есть простое число. Порождаем ли мы на самом деле
сначала всю последовательность, как в @ref{Глава 2},
или чередуем порождение и фильтрацию, как в @ref{Глава 3},
несущественно для общей картины того, как организовано вычисление.

\enlargethispage{\baselineskip}

При недетерминистском подходе используется другой образ. Просто
представим себе, что мы (каким-то образом) выбираем число из первого
списка и число из второго списка, а затем предъявляем (при помощи
какого-то механизма) требование, чтобы их сумма была простым числом. Это
выражается следующей процедурой:

@lisp
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
@end lisp

@noindent
Может показаться, что эта процедура просто переформулирует задачу, а не
указывает способ ее решить. Однако это законная недетерминистская
программа.@footnote{Мы предполагаем, что уже заранее определена процедура
@code{prime?}, которая проверяет числа на простоту. Даже если такая
процедура определена, @code{prime-sum-pair} может подозрительно
напоминать бестолковую попытку определения квадратного корня на
псевдо-Лиспе из начала @ref{1.1.7}.
На самом деле, подобного рода процедура вычисления квадратного корня
может быть сформулирована в виде недетерминистской программы. Вводя в
интерпретатор механизм поиска, мы размываем границу между чисто
декларативными описаниями и императивными спецификациями способов
вычислить ответ. В @ref{4.4} мы пойдем еще дальше в этом направлении.}

Основная идея здесь состоит в том, что выражениям в недетерминистском
языке разрешается иметь более одного возможного значения. Например,
@code{an-element-of} может вернуть любой элемент данного списка. Наш
интерпретатор недетерминистских программ будет автоматически выбирать
возможное значение и запоминать, что он выбрал. Если впоследствии
какое-либо требование не будет выполнено, интерпретатор попробует другой
вариант выбора и будет перебирать варианты, пока вычисление не
закончится успешно или пока варианты не иссякнут. Подобно тому, как
ленивый интерпретатор освобождал программиста от заботы о деталях
задержки и вынуждения значений, недетерминистский интерпретатор
позволяет ему не заботиться о том, как происходит выбор.

Поучительно будет сравнить различные понятия времени, складывающиеся при
недетерминистских вычислениях и обработке потоков. При обработке потоков
ленивые вычисления используются для того, чтобы устранить связь между
временем, когда строится поток возможных ответов, и временем, когда
порождаются собственно ответы. Интерпретатор создает иллюзию, что все
возможные ответы предоставлены нам во вневременной последовательности.
При недетерминистских вычислениях выражение представляет собой
исследование множества возможных миров, каждый из которых определяется
множеством выбранных вариантов. Некоторые возможные миры приводят в
тупик, другие дают полезные ответы. Вычислитель недетерминистских
программ создает иллюзию, что время разветвляется, и что у наших
программ есть различные возможные истории исполнения. Если мы
оказываемся в тупике, мы можем вернуться к последней точке выбора и
продолжить путь по другой ветке.

Описываемый в этом разделе интерпретатор недетерминистских программ
называется @code{amb}-интерпретатор, потому что он основан на новой
особой форме @code{amb}. Мы можем ввести вышеприведенное определение
@code{prime-sum-pair} в управляющем цикле @code{amb}-интерпретатора
(наряду с определениями @code{prime?}, @code{an-element-of} и @code{require})
и запустить процедуру:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}
@end lisp

@noindent
Возвращенное значение было получено после того, как интерпретатор сделал
несколько попыток выбора из каждого списка, последняя из которых
оказалась успешной.

В @ref{4.3.1} и показывается, как она поддерживает недетерминизм через механизм
поиска, встроенный в интерпретатор. В @ref{4.3.2} приводятся примеры
недетерминистских программ, а @ref{4.3.3} содержит подробности
того, как реализовать @code{amb}-интерпретатор путем модификации
обычного интерпретатора Scheme.

@menu
* 4-3-1::            Amb и Search
* 4-3-2::            Примеры недетерминистских πрограмм
* 4-3-3::            Реализация @code{amb}-интерπретатора
@end menu

@comment @subsection Amb and Search
@subsection @code{Amb} и @code{search}
@node	4.3.1, 4.3.2, 4.3, 4.3

Чтобы расширить Scheme и поддержать недетерминистское программирование,
мы вводим новую особую форму @code{amb}.@footnote{Идея недетерминистского
программирования с помощью @code{amb}-выражений впервые была описана
Джоном Маккарти в 1961 году (см. McCarthy 1967).} Выражение

@lisp
(amb @math{\langle}@var{e}@math{_{\mono{1}}\rangle} @math{\langle}@var{e}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{e}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
возвращает <<произвольным образом>> значение одного из @math{n}
выражений @math{\langle}@math{e_i}@math{\rangle}.  Например, выражение

@lisp
(list (amb 1 2 3) (amb 'a 'b))
@end lisp

@noindent
имеет шесть возможных значений:

@lisp
@code{(1 a)} @code{(1 b)} @code{(2 a)} @code{(2 b)} @code{(3 a)} @code{(3 b)}
@end lisp

@noindent
@code{amb} с одним вариантом возвращает обыкновенное (одно) значение.

@noindent
@code{amb} без вариантов --- выражение @code{(amb)} --- является
выражением без приемлемых значений. С операционной точки зрения,
выполнение выражения @code{(amb)} приводит к <<неудаче>> в вычислении:
выполнение обрывается, и никакого значения не возвращается. При помощи
этого выражения можно следующим образом выразить требование, чтобы
выполнялось предикатное выражение @code{p}:

@lisp
(define (require p) (if (not p) (amb)))
@end lisp

@noindent
Через @code{amb} и @code{require} можно реализовать процедуру
@code{an-element-of}, используемую выше:

@lisp
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
@end lisp

@noindent
Если список пуст, @code{an-element-of} терпит неудачу. В противном
случае он произвольным образом возвращает либо первый элемент списка,
либо элемент, выбранный из хвоста списка.

Можно также выразить выбор из бесконечного множества. Следующая
процедура произвольным образом возвращает целое число, большее или
равное некоторому данному @code{n}:

@lisp
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
@end lisp

@noindent
Это похоже на потоковую процедуру @code{integers-starting-from}, описанную в
@ref{3.5.2}, но есть важное различие: потоковая процедура возвращает поток,
который представляет последовательность всех целых чисел, начиная с
@code{n}, а процедура, написанная через @code{amb}, выдает одно целое
число.@footnote{На самом деле, различие между произвольным выбором с
возвратом единственного значения и возвратом всех возможных значений
выбора определяется в некоторой степени точкой зрения. С точки зрения
того кода, который использует значение, недетерминистский выбор
возвращает одно значение. С точки зрения программиста, проектирующего
код, недетерминистский выбор потенциально возвращает все возможные
значения, а вычисление разветвляется, вследствие чего каждое значение
исследуется отдельно.}

Мысля абстрактно, мы можем представить, что выполнение выражения
@code{amb} заставляет время разветвиться, и на каждой ветке оно
продолжается с одним из возможных значений выбора. Мы говорим, что @code{amb}
представляет собой (@newterm{nondeterministic choice point}). Если бы у
нас была машина с достаточным числом процессоров, которые можно было бы
динамически выделять, то поиск можно было бы реализовать напрямую.
Выполнение происходило бы, как в последовательной машине, пока не
встретится выражение @code{amb}. В этот момент выделялись и
инициализировались бы дополнительные процессоры, которые продолжали бы
все параллельные потоки выполнения, обусловленные выбором. Каждый
процессор продолжал бы последовательное выполнение одного из потоков,
как если бы он был единственным, пока поток не оборвется, потерпев
неудачу, не разделится сам или не завершится.@footnote{Можно возразить,
что этот механизм безнадежно неэффективен. Чтобы решить какую-нибудь
просто сформулированную задачу таким образом, могут потребоваться
миллионы процессоров, и бо́льшую часть времени бо́льшая часть этих
процессоров будет ничем не занята. Это возражение нужно воспринимать в
контексте истории. Память раньше точно так же считалась дорогим
ресурсом. В 1964 году мегабайт памяти стоил 400 000 долларов. Сейчас в
каждом персональном компьютере имеется много мегабайтов памяти, и
бо́льшую часть времени бо́льшая часть этой памяти не используется. Трудно
недооценить стоимость электроники при массовом производстве.}

С другой стороны, если у нас есть машина, которая способна выполнять
только один процесс (или небольшое число параллельных процессов),
альтернативы приходится рассматривать последовательно. Можно представить
себе интерпретатор, который в каждой точке выбора произвольным образом
выбирает, по какой ветке продолжить выполнение. Однако случайный выбор
может легко привести к неудачам. Можно было бы запускать такой
интерпретатор многократно, делая случайный выбор и надеясь, что в конце
концов мы получим требуемое значение, но лучше проводить (systematic
search) среди всех возможных путей выполнения. @code{Amb}-интерпретатор,
который мы разработаем в этом разделе, реализует систематический поиск
следующим образом: когда интерпретатор встречает выражение @code{amb},
он сначала выбирает первый вариант. Такой выбор может в дальнейшем
привести к другим точкам выбора. В каждой точке выбора интерпретатор
сначала будет выбирать первый вариант. Если выбор приводит к неудаче,
интерпретатор автомагически@footnote{Автомагически: <<Автоматически, но
при этом таким способом, который говорящий почему-либо (обычно либо
из-за его сложности, либо уродливости, или даже тривиальности) не
склонен объяснять>>. (Steele 1983; Raymond 1993)} (backtracks) к
последней точке выбора и пробует следующий вариант. Если в какой-то
точке выбора варианты исчерпаны, интерпретатор возвращается к предыдущей
точке выбора и продолжает оттуда. Такой процесс реализует стратегию
поиска, которую называют (depth-first search) или (chronological
backtracking).@footnote{У встраивания стратегий автоматического
поиска в языки программирования долгая и пестрая история. Первые
предположения, что недетерминистские алгоритмы можно изящно реализовать
в языке программирования с поиском и автоматическим возвратом,
высказывались Робертом Флойдом (Floyd 1967). Карл Хьюитт (Hewitt 1969)
изобрел язык программирования Плэнер (Planner), который явным образом
поддерживал автоматический хронологический поиск в возвратом,
обеспечивая встроенную стратегию поиска в глубину. Сассман, Виноград и
Чарняк (Sussman, Winograd, and Charniak 1971) реализовали подмножество
этого языка, названное ими МикроПлэнер (MicroPlanner), которое
использовалось в работе по автоматическому решению задач и планированию
действий роботов. Похожие идеи, основанные на логике и доказательстве
теорем, привели к созданию в Эдинбурге и Марселе изящного языка Пролог
(Prolog) (который мы обсудим в @ref{4.4}).
Разочаровавшись в автоматическом поиске, Макдермот и Сассман (McDermott
and Sussman 1972) разработали язык Коннивер (Conniver), в котором
имелись механизмы, позволявшие программисту управлять стратегией поиска.
Однако это оказалось слишком громоздким, и Сассман и Столлман (Sussman
and Stallman 1975) нашли более удобный в обращении подход, когда
исследовали методы символьного анализа электрических цепей. Они
разработали схему нехронологического поиска с возвратом, которая была
основана на отслеживании логических зависимостей, связывающих факты, и
стала известна как метод (@newterm{dependency-directed backtracking}). При всей
своей сложности, их метод позволял строить достаточно эффективные
программы, так как почти не проводилось излишнего поиска. Дойл (Doyle
1979) и Макаллестер (McAllester 1978; McAllester 1980) обобщили и
сделали более ясными идеи Столлмана и Сассмана, разработав новую
парадигму для формулирования поиска, называемую сейчас (truth
maintenance). Все современные системы решения задач основаны на
какой-либо форме поддержания истины. У Форбуса и де Клеера (Forbus and
deKleer 1993) можно найти обсуждение изящных способов строить системы с
поддержанием истины и приложения, в которых используется поддержание
истины. Заби, Макаллестер и Чепман (Zabih, McAllester, and Chapman 1987)
описывают недетерминистское расширение Scheme, основанное на @code{amb};
оно похоже на интерпретатор, обсуждаемый в этом разделе, но более
сложно, поскольку использует поиск с возвратом, управляемый
зависимостями, а не хронологический. Уинстон (Winston 1992) дает
введение в обе разновидности поиска с возвратом.}.

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора не совсем обычен. Он
считывает выражение и печатает значение первого успешного вычисления,
как в примере с @code{prime-sum-pair} в начале раздела. Если нам хочется
увидеть значение следующего успешного выполнения, мы можем попросить
интерпретатор вернуться и попробовать породить значение следующего
успешного выполнения. Для этого нужно ввести символ . Если вводится
какое-то другое выражение, а не @code{try-again}, интерпретатор начнет
решать новую задачу, отбрасывая неисследованные варианты предыдущей. Вот
пример работы с интерпретатором:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(3 110)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(8 35)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; There are no more values of}
@i{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}

@i{;;; Amb-Eval input:}
(prime-sum-pair '(19 27 30) '(11 36 58))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(30 11)}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.35}Упражнение 4.35:}
Напишите процедуру @code{an-integer-between}, которая
возвращает целое число, лежащее между двумя заданными границами. С ее
помощью можно следующим образом реализовать процедуру для поиска
Пифагоровых троек, то есть троек чисел @math{(i, j, k)} между заданными
границами, таких, что @math{i \leq j} и @math{i^2 + j^2 = k^2}:

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.36}Упражнение 4.36:}
В упражнении @ref{Упражнение 3.69} рассматривалась задача
порождения потока @emph{всех} Пифагоровых троек, без всякой верхней
границы диапазона целых чисел, в котором надо искать. Объясните, почему
простая замена @code{an-integer-between} на
@code{an-integer-startingfrom} в процедуре из
упражнения @ref{Упражнение 4.35} не является адекватным способом
порождения произвольных Пифагоровых троек. Напишите процедуру, которая
решает эту задачу. (Это значит, что Вам нужно написать процедуру, для
которой многократный запрос @code{try-again} в принципе способен
породить все Пифагоровы тройки.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.37}Упражнение 4.37:}
Бен Битобор утверждает, что следующий метод порождения
Пифагоровых троек эффективнее, чем приведенный в
упражнении @ref{Упражнение 4.35}. Прав ли он? (Подсказка: найдите,
сколько вариантов требуется рассмотреть.)

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
@end lisp
@end quotation

@comment @subsection Examples of Nondeterministic Programs
@subsection Примеры недетерминистских программ
@node	4.3.2, 4.3.3, 4.3.1, 4.3

В @ref{4.3.3} описывается реализация @code{amb}-интерпретатора. Однако
для начала мы приведем несколько примеров его использования. Преимущество
недетерминистского программирования состоит в том, что можно отвлечься от
деталей процесса поиска, а следовательно, выражать программы на более высоком
уровне абстракции.

@comment @subsubheading Logic Puzzles
@subsubheading Логические загадки

Следующая задача (взятая из Dinesman 1968) --- типичный представитель
большого класса простых логических загадок.

@quotation
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах
пятиэтажного дома. Бейкер живет не на верхнем этаже. Купер живет не на
первом этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер
живет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?
@end quotation

@noindent
Можно впрямую определить, кто на каком этаже живет, перечислив все
возможности и наложив данные нам ограничения.@footnote{В нашей программе
используется следующая процедура, определяющая, все ли элементы списка
отличны друг от друга:

@lisp
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
@end lisp

@noindent
Процедура @code{member} подобна @code{memq}, но на равенство проверяет с
помощью @code{equal?}, а не @code{eq?}.}

@lisp
(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
        (smith    (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)       (list 'cooper cooper)
          (list 'fletcher fletcher) (list 'miller miller)
          (list 'smith smith))))
@end lisp

@noindent
Выполнение выражения @code{(multiple-dwelling)} дает следующий результат:

@lisp
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
@end lisp

@noindent
Эта простая процедура работает, но работает очень медленно. В
@ref{Упражнение 4.39} и @ref{Уπражнение 4.40} обсуждаются возможные улучшения.

@quotation
@strong{@anchor{Упражнение 4.38}Упражнение 4.38:}
Измените процедуру @code{multiple-dwelling}, отказавшись
от требования, что Смит и Флетчер живут не на соседних этажах. Сколько
решений имеется у измененной загадки?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.39}Упражнение 4.39:}
Влияет ли порядок ограничений в процедуре
@code{multiple-dwelling} на ответ? Влияет ли он на время, необходимое
для поиска ответа? Если Вы считаете, что он имеет значение, то покажите,
как можно ускорить программу, переупорядочив ограничения. Если Вы
считаете, что порядок значения не имеет, объясните, почему.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.40}Упражнение 4.40:}
Сколько возможных соответствий между людьми и этажами
имеется в задаче о проживании, если учитывать требование, что все живут
на разных этажах, и если его не учитывать? Крайне неэффективно порождать
все возможные соответствия между людьми и этажами, а затем полагаться на
то, что поиск с возвратом отсечет лишнее. Например, большая часть
ограничений зависит только от одной или двух переменных, соответствующих
людям, и их можно было бы проверять раньше, чем этажи выбраны для всех
действующих лиц. Напишите и продемонстрируйте значительно более
эффективную недетерминистскую процедуру, которая бы решала задачу,
порождая только те варианты, которые еще не исключены благодаря
предыдущим ограничениям. (Подсказка: потребуется набор вложенных
выражений @code{let}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.41}Упражнение 4.41:}
Напишите процедуру для решения задачи о проживании на обычной Scheme.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.42}Упражнение 4.42:}
Решите задачу <<Лгуньи>> (из Phillips 1934):

Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что
каждая девочка должна написать домой о результатах экзамена и при этом
сделать одно верное и одно неверное утверждение. Вот соответствующие
выдержки из их писем:

@itemize @bullet

@item
Бетти: <<Китти была на экзамене второй, а я только третьей>>.

@item
Этель: <<Вам будет приятно узнать, что я написала лучше всех. Второй была Джоан>>.

@item
Джоан: <<Я была третьей, а бедная Этель последней>>.

@item
Китти: <<Я оказалась второй. Мэри была только четвертой>>.

@item
Мэри: <<Я была четвертой. Первое место заняла Бетти>>.

@end itemize

В каком порядке на самом деле расположились отметки девочек?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.43}Упражнение 4.43:}
Решите с помощью @code{amb}-интерпретатора следующую
задачу.@footnote{Задача взята из книжки <<Занимательные загадки>>,
опубликованной в 60-е годы издательством Литтон Индастриз. Книжка
приписывает задачу газете <<Кэнзас стейт энджинир>>.}

У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей тоже.
Эти четверо друзей --- полковник Даунинг, мистер Холл, сэр Барнакл Худ
и доктор Паркер. У каждого из них тоже есть по дочери, и каждый из них
назвал свою яхту в честь дочери одного из своих друзей. Яхта сэра
Барнакла называется Габриэлла, яхта мистера Мура --- Лорна, а у мистера
Холла яхта Розалинда. Мелисса, яхта полковника Даунинга, названа в честь
дочери сэра Барнакла. Отец Габриэллы владеет яхтой, названной в честь
дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно (см.
упражнение @ref{Упражнение 4.40}). Кроме того, определите, сколько
будет решений, если не указывается, что фамилия Мэри Энн --- Мур.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.44}Упражнение 4.44:} В упражнении
@ref{Упражнение 2.42} описывалась <<задача о восьми ферзях>>, в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.
@end quotation

@comment @subsubheading Parsing natural language
@subsubheading Синтаксический анализ естественного языка

Программы, которые должны принимать на входе естественный язык, обычно
прежде всего пытаются провести (@newterm{parsing}) ввода, то есть сопоставить
входному тексту какую-то грамматическую структуру. Например, мы могли бы
попытаться распознавать простые предложения, состоящие из артикля, за
которым идет существительное, а вслед за ними глагол, например @emph{The
cat eats} (<<Кошка ест>>). Чтобы выполнять такой анализ, нам нужно уметь
определять части речи, к которым относятся отдельные слова. Мы можем для
начала составить несколько списков, которые задают классы
слов:@footnote{Здесь мы используем соглашение, что первый элемент списка
обозначает часть речи, к которой относятся остальные слова списка.}

@lisp
(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
@end lisp

@noindent
Нам также нужна (@newterm{grammar}), то есть набор правил, которые описывают,
как элементы грамматической структуры составляются из меньших элементов.
Простейшая грамматика может постановить, что предложение всегда состоит
из двух частей --- именной группы, за которой следует глагол, --- и
что именная группа состоит из артикля и имени существительного. С такой
грамматикой предложение @emph{The cat eats} разбирается так:

@lisp
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
@end lisp

@noindent
Мы можем породить такой разбор при помощи простой программы, в которой
для каждого грамматического правила имеется своя процедура. Чтобы
разобрать предложение, мы определяем две его составные части и
возвращаем список из этих элементов, помеченный символом @code{sentence}:

@lisp
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
@end lisp

@noindent
Подобным образом, разбор именной группы состоит в поиске артикля и
существительного:

@lisp
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
@end lisp

@noindent
На самом нижнем уровне разбор сводится к многократной проверке, является
ли следующее неразобранное слово элементом списка слов для данной части
речи. Чтобы реализовать это, мы заводим глобальную переменную
@code{*unparsed*}, содержащую еще неразобранный ввод. Каждый раз,
проверяя слово, мы требуем, чтобы @code{*unparsed*} не была пустым
списком и чтобы ее значение начиналось со слова из указанного списка.
Если это так, мы убираем слово из @code{*unparsed*} и возвращаем его
вместе с частью речи (которую можно найти в голове
списка).@footnote{Обратите внимание, что @code{parse-word} изменяет
список необработанных слов при помощи @code{set!}. Для того, чтобы это
работало, @code{amb}-интерпретатор при возврате должен отменять действия
операций @code{set!}.}

@lisp
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
@end lisp

@noindent
Чтобы запустить разбор, нужно только присвоить переменной @code{*unparsed*}
весь имеющийся ввод, попытаться проанализировать предложение и убедиться,
что ничего не осталось в конце:

@lisp
(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*)) sent))
@end lisp

Теперь мы можем опробовать анализатор и убедиться, что он работает на
нашем простом примере:

@lisp
@i{;;; Amb-Eval input:}
(parse '(the cat eats))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@end lisp
@smalllisp
@i{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}
@end smalllisp

@noindent
@code{amb}-интерпретатор здесь удобно использовать потому, что
ограничения на разбор легко выражаются при помощи @code{require}. Однако
по-настоящему достоинства автоматического поиска с возвратом проявляются
тогда, когда мы обращаемся к более сложным грамматикам, где имеются
варианты декомпозиции единиц.

Добавим к грамматике список предлогов:

@lisp
(define prepositions '(prep for to in by with))
@end lisp

@noindent
и определим предложную группу (например, @emph{for the cat}, <<для
кошки>>) как последовательность из предлога и именной группы:

@lisp
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
@end lisp

@noindent
Теперь мы можем сказать, что предложение --- это именная группа, за
которой следует глагольная группа, а глагольная группа --- это либо
глагол, либо глагольная группа, дополненная предложной
группой@footnote{Заметим, что это определение рекурсивно --- за
глаголом может следовать любое число предложных групп.}:

@lisp
(define (parse-sentence)
  (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend
          (list 'verb-phrase
                verb-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
@end lisp

@noindent
Раз уж мы занялись этим делом, можно также уточнить определение именной
группы и разрешить выражения вроде @emph{a cat in the class} (<<кошка в
аудитории>>). То, что раньше называлось именной группой, теперь мы будем
называть простой именной группой, а именная группа теперь может быть
либо простой именной группой, либо именной группой, которая дополняется
предложной группой:

@lisp
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend
          (list 'noun-phrase
                noun-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
@end lisp

@noindent
Обновленная грамматика позволяет разбирать более сложные предложения.
Например,

@lisp
(parse '(the student with the cat sleeps in the class))
@end lisp

@noindent
дает

@lisp
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase
   (prep in)
   (simple-noun-phrase (article the) (noun class)))))
@end lisp

@noindent
Заметим, что входное предложение может иметь более одного законного
анализа. В предложении @emph{The professor lectures to the student with
the cat} (<<Профессор читает лекцию студенту с кошкой>>) может иметься в
виду, что профессор вместе с кошкой читают лекцию, или что кошка --- у
студента. Наша недетерминистская программа находит оба варианта:

@lisp
(parse '(the professor lectures to the student with the cat))
@end lisp

@noindent
дает

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase
    (prep to)
    (simple-noun-phrase (article the) (noun student))))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat)))))
@end lisp

@noindent
Если πоπросить интерπретатор πоискать еще, πолучится

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase
    (simple-noun-phrase (article the) (noun student))
    (prep-phrase
     (prep with)
     (simple-noun-phrase (article the) (noun cat)))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.45}Упражнение 4.45:}
Согласно заданной выше грамматике, следующее предложение
можно проанализировать пятью различными способами: @emph{The professor
lectures to the student in the class with the cat} (<<Профессор читает
лекцию студенту в аудитории с кошкой>>). Покажите эти пять разборов и
объясните разницу в оттенках значения между ними.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.46}Упражнение 4.46:} Интерпретаторы в разделах
@ref{4.1} и @ref{4.2} не определяют, в каком порядке вычисляются операнды
при вызове процедуры. Мы увидим, что @code{amb}-интерпретатор вычисляет их
слева направо. Объясните, почему программа разбора не стала бы работать, если
бы операнды вычислялись в каком-нибудь другом порядке.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.47}Упражнение 4.47:}
Хьюго Дум говорит, что поскольку глагольная группа --- это
либо глагол, либо глагольная группа плюс предложная группа, было бы
намного естественнее определить процедуру @code{parse-verb-phrase} так
(и то же сделать для именных групп):

@lisp
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
@end lisp

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в @code{amb}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.48}Упражнение 4.48:}
Дополните описанную выше грамматику так, чтобы она могла
работать с более сложными предложениями. Например, можно позволить
именным и глагольным группам включать прилагательные и наречия, или же
можно обрабатывать сложные предложения.@footnote{Грамматики такого рода
могут быть сколь угодно сложными, но по сравнению с настоящей обработкой
естественного языка они остаются игрушкой. Настоящее понимание
естественного языка компьютером требует сложного сочетания
синтаксического анализа с интерпретацией значения. С другой стороны,
даже простые анализаторы могут быть полезны для поддержки гибких
командных языков в программах вроде систем поиска информации. Уинстон
(Winston 1992) описывает вычислительные подходы к пониманию настоящего
естественного языка, а также применение простых грамматик в командных
языках.}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.49}Упражнение 4.49:}
Лизу П. Хакер больше интересует не анализ предложений, а
их порождение. Она замечает, что если изменить процедуру
@code{parse-word} так, чтобы она игнорировала <<входное предложение>>,
всегда заканчивалась успехом и порождала подходящее слово, мы сможем
использовать те же программы, которые мы написали для анализа, для
порождения предложений. Реализуйте идею Лизы и покажите первые
пять-шесть порожденных предложений.@footnote{Несмотря на то, что идея
Лизы (будучи удивительно простой) дает результат, порождаемые
предложения оказываются довольно скучными --- они не отображают
возможные предложения нашего языка никаким интересным образом. Дело в
том, что грамматика рекурсивна во многих местах, а метод Лизы
<<проваливается>> в одну из рекурсий и там застревает. Как с этим можно
бороться, Вы увидите в упражнении @ref{Упражнение 4.50}.}
@end quotation

@comment @subsection Implementing the @code{amb} Evaluator
@subsection Реализация @code{amb}-интерпретатора
@node	4.3.3,  , 4.3.2, 4.3

Выполнение выражения в обыкновенной Scheme может вернуть результат,
может вообще не завершиться, и, наконец, может закончиться сообщением об
ошибке. В недетерминистской Scheme при выполнении выражения, в
дополнение ко всему этому, может еще обнаружиться тупик, и в этом случае
вычисление должно откатиться к предыдущей точке выбора. Интерпретация
недетерминистской Scheme осложняется из-за этой дополнительной
возможности.

Мы построим @code{amb}-интерпретатор для недетерминистской Scheme,
модифицировав анализирующий интерпретатор из @ref{4.1.7}.@footnote{В
@ref{4.2} мы решили реализовать ленивый интерпретатор как модификацию
обыкновенного метациклического интерпретатора из @ref{4.1.1}. Напротив,
здесь в основу @code{amb}-интерпретатора мы кладем анализирующий
интерпретатор из @ref{4.1.7},
поскольку исполнительные процедуры этого интерпретатора служат удобной
базой для реализации поиска с возвратом.} Как и в анализирующем
интерпретаторе, вычисление выражения происходит путем вызова
исполнительной процедуры, которая получается при анализе этого
выражения. Разница между интерпретацией обыкновенной Scheme и
недетерминистской Scheme будет полностью сводиться к исполнительным
процедурам.

@comment @subsubheading Execution procedures and continuations
@subsubheading Исполнительные процедуры и продолжения

Напомним, что исполнительные процедуры обыкновенного интерпретатора
принимают один аргумент: окружение, в котором происходит вычисление
выражения. В противоположность этому, исполнительные процедуры
@code{amb}-интерпретатора принимают три аргумента: окружение и две
процедуры, называемые (@newterm{continuation procedures}). Вычисление выражения
будет заканчиваться вызовом одного из этих продолжений: если результатом
вычисления является значение, то зовется (@newterm{success continuation}) с этим
значением в качестве аргумента; если вычисление натыкается на тупик,
вызывается (@newterm{failure continuation}). Построение и вызов соответствующих
продолжений служит механизмом, с помощью которого в недетерминистском
интерпретаторе реализуется поиск с возвратом.

Задача продолжения успеха --- принять значение и продолжить вычисление.
Помимо этого значения, продолжение успеха получает дополнительное
продолжение неудачи, которое нужно будет вызвать, если использование
значения приведет в тупик.

Задача продолжения неудачи --- попробовать другую ветвь
недетерминистского процесса. Главная особенность недетерминистского
языка состоит в том, что выражения могут представлять собой точки выбора
между вариантами. Выполнение такого выражения должно продолжиться
согласно одному из указанных взаимоисключающих вариантов, несмотря на
то, что заранее неизвестно, какие варианты приведут к приемлемым
результатам. При обработке такой ситуации интерпретатор выбирает один из
вариантов и передает его значение продолжению успеха. Кроме того, он
строит и передает вместе со значением продолжение неудачи, которое потом
можно вызвать, чтобы рассмотреть другой вариант.

Неудача возникает во время вычисления (то есть, зовется продолжение
неудачи), когда пользовательская программа явным образом отказывается от
текущего рассматриваемого варианта (например, вызов @code{require} может
привести к выполнению @code{(amb)}, а это выражение всегда терпит
неудачу --- см. @ref{4.3.1}). В этом месте
продолжение неудачи вернет нас к последней по времени точке и оттуда
направит по другому варианту. Если же в этой точке выбора больше не
осталось вариантов, то запускается неудача в предыдущей точке выбора, и
так далее. Кроме того, продолжения неудачи запускаются управляющим
циклом в ответ на запрос @code{try-again}, чтобы найти еще одно значение
последнего выражения.

Помимо того, если на какой-то ветке процесса, возникшей в результате
выбора, происходит операция с побочным эффектом (например, присваивание
переменной), то может понадобиться отменить побочный эффект, если
процесс наткнется на неудачу, прежде чем будет сделан новый выбор. Этого
мы добиваемся, заставив операцию с побочным эффектом порождать
продолжение неудачи, которое отменяет эффект и отправляет неудачу
дальше.

\enlargethispage{\baselineskip}

Итак, продолжения неудачи порождаются
@itemize @bullet

@item
в выражениях @code{amb} --- чтобы обеспечить механизм выбора
альтернативных вариантов, если текущий выбор, сделанный внутри
@code{amb}, приведет к тупику;

@item
в управляющем цикле верхнего уровня --- чтобы иметь возможность
сообщить о неудаче, когда перебраны все альтернативы;

@item
в присваиваниях --- чтобы во время отката перехватывать неудачи и
отменять присваивания.
@end itemize

@noindent
Неудачи возбуждаются только тогда, когда программа заходит в тупик. Это
происходит

@itemize @bullet

@item
если пользовательская программа выполняет выражение @code{(amb)};

@item
если пользователь печатает @code{try-again} в управляющем цикле.

@end itemize

@noindent
Кроме того, продолжения неудачи вызываются при обработке неудачи:

@itemize @bullet

@item
Когда продолжение неудачи, порожденное присваиванием, заканчивает отмену
побочного эффекта, оно вызывает то предложение неудачи, которое оно само
перехватило, и посредством его отправляет неудачу назад до точки выбора,
которая привела к присваиванию, либо до верхнего уровня.

@item
Когда продолжение неудачи для @code{amb} исчерпывает все варианты
выбора, оно вызывает продолжение неудачи, которое изначально было дано
@code{amb}, и посредством его распространяет неудачу до предыдущей точки
выбора, либо до верхнего уровня.
@end itemize

@comment @subsubheading Structure of the evaluator
@subsubheading Структура интерпретатора

Процедуры представления синтаксиса и данных в @code{amb}-интерпретаторе,
а также базовая процедура @code{analyze}, совпадают с соответствующими
процедурами в интерпретаторе из @ref{4.1.7}, только здесь требуются
дополнительные синтаксические процедуры для анализа особой формы @code{amb}:
@footnote{Мы предполагаем, что интерпретатор поддерживает @code{let} (см.
@ref{Упражнение 4.22}), который мы использовали в недетерминистских программах.}

@lisp
(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
@end lisp

@noindent
Кроме того, требуется добавить в процедуру разбора @code{analyze} ветку,
которая будет распознавать эту особую форму и порождать соответствующую
исполнительную процедуру:

@lisp
((amb? exp) (analyze-amb exp))
@end lisp

@noindent
Процедура верхнего уровня @code{ambeval} (сходная с версией @code{eval},
приведенной в @ref{4.1.7}) анализирует данное выражение и применяет полученную
исполнительную процедуру к данному окружению и двум данным продолжениям:

@lisp
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
@end lisp

@noindent
Продолжение успеха представляет собой процедуру от двух аргументов:
только что полученного значения и продолжения неудачи, которое нужно
будет применить, если обработка значения впоследствии приведет к
неудаче. Продолжение неудачи представляет собой процедуру без
аргументов. Таким образом, общая форма исполнительной процедуры такова:

@lisp
(lambda (env succeed fail)
  @r{;; @code{succeed} выглядит как @code{(lambda (value fail) @dots{})}}
  @r{;; @code{fail} выглядит как @code{(lambda () @dots{})}}
  @dots{})
@end lisp

@noindent
Например

@lisp
(ambeval @math{\langle}@var{вурыжение}@math{\rangle}
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
@end lisp

@noindent
попытается вычислить данное выражение, и вернет либо его значение (если
вычисление будет успешным), либо символ @code{failed} (если вычисление
потерпит неудачу). Вызов @code{ambeval} в нижеприведенном управляющем
цикле использует намного более сложные процедуры продолжения, которые
возвращаются к выполнению цикла и поддерживают запрос @code{try-again}.

Сложность @code{amb}-интерпретатора по большей части заключается в
механизмах передачи продолжений, когда исполнительные процедуры вызывают
друг друга. Читая код в этом разделе, следует сравнивать каждую
исполнительную процедуру с соответствующей процедурой обыкновенного
интерпретатора из @ref{4.1.7}.

@comment @subsubheading Simple expressions
@subsubheading Простые выражения

Исполнительные процедуры для простейших видов выражений здесь, в
сущности, такие же, как и в обычном интерпретаторе, не считая того, что
здесь надо уметь управлять продолжениями. Исполнительные процедуры
просто зовут продолжение успеха, давая ему значение выражения, и
передают дальше продолжение неудачи, которое получили сами.

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env) fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env) fail))))
@end lisp

@noindent
Заметим, что поиск переменной всегда <<успешен>>. Если процедуре
@code{lookup-variable-value} не удается найти значение, она, как обычно,
сообщает об ошибке. Такая <<неудача>> означает ошибку в программе:
ссылку на несвязанную переменную; это не означает, что нам нужно
пробовать какой-либо другой вариант недетерминистского выбора вместо
того, который исполняется сейчас.

@comment @subsubheading Conditionals and sequences
@subsubheading Условные выражения и последовательности

Обработка условных выражений также похожа на соответствующий процесс в
обычном интерпретаторе. Исполнительная процедура, порождаемая в
@code{analyze-if}, зовет исполнительную процедуру предиката @code{pproc}
с продолжением успеха, которое, проверив, истинно ли значение предиката,
в соответствии с этим выполняет либо следствие, либо альтернативу. Если
выполнение @code{pproc} терпит неудачу, вызывается исходное продолжение
неудачи, переданное в выражение @code{if}.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             @r{;; πродолжение усπеха πри вычислении πредиката}
             @r{;; и получении @code{pred-value}}
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             @r{;; πродолжение неудачи πри вычислении πредиката}
             fail))))
@end lisp

@noindent
Последовательности тоже обрабатываются так же, как и в предыдущем
интерпретаторе, если не считать махинаций в подпроцедуре
@code{sequentially}, которые требуются для передачи продолжений. А
именно, чтобы выполнить последовательно @code{a} и @code{b}, мы вызываем
@code{a} с продолжением успеха, вызывающим @code{b}.

@lisp
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         @r{;; πродолжение усπеха πри вызове @code{a}}
         (lambda (a-value fail2)
           (b env succeed fail2))
         @r{;; πродолжение неудачи πри вызове @code{a}}
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@comment @subsubheading Definitions and assignments
@subsubheading Определения и присваивания

Определения --- еще один случай, когда обработка продолжений сопряжена
с известными трудностями, поскольку требуется сначала вычислить
выражение, которое будет значением определяемой переменной, а затем уже
ее собственно определить. Ради этого процедура вычисления значения
@code{vproc} вызывается со следующими аргументами: окружение,
продолжение успеха и продолжение неудачи. Если вычисление @code{vproc}
происходит успешно и дает значение @code{val} для определяемой
переменной, то переменная определяется и успех распространяется далее:

@lisp
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
@end lisp

@noindent
Присваивания устроены интереснее. Это первый случай, когда мы
действительно используем продолжения, а не просто передаем их из
процедуры в процедуру. Исполнительная процедура для присваивания
начинается так же, как и процедура для определения. Сначала она пытается
получить новое значение, которое надо присвоить переменной. Если
вычисление @code{vproc} терпит неудачу, неудачно и все присваивание.

Однако если @code{vproc} выполняется удачно, и мы действительно
выполняем присваивание, то нам нужно рассмотреть возможность, что
текущая ветка вычисления позже, может быть, приведет к неудаче. Тогда
нам понадобится откатиться к моменту до присваивания. Таким образом, нам
нужно уметь отменить присваивание в процессе возврата@footnote{Мы не
заботились об отмене определений, поскольку можно предположить, что
внутренние определения изымаются (@ref{4.1.6}).}

Этого мы добиваемся, передавая @code{vproc} продолжение успеха
(отмеченное ниже комментарием <<@emph{1*}>>), которое сохраняет старое
значение переменной, прежде чем присвоить ей новое значение и продолжить
вычисление. Продолжение неудачи, которое передается вместе со значением
присваивания (и отмечено ниже комментарием <<@emph{2*}>>),
восстанавливает старое значение переменной, прежде чем продолжить откат.
То есть, успешное присваивание дает продолжение неудачи, которое
перехватит последующую неудачу; неудача, которая в противном случае
вызвала бы @code{fail2}, вместо этого зовет эту процедуру, а она
отменяет присваивание и уже затем зовет @code{fail2}.

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        @r{; *1*}
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    @r{; *2*}
                            (set-variable-value!
                             var old-value env)
                            (fail2)))))
             fail))))
@end lisp

@comment @subsubheading Procedure applications
@subsubheading Вызов процедур

Исполнительная процедура для вызовов не содержит никаких новшеств, кроме
сложных технических деталей работы с продолжениями. Сложность возникает
внутри @code{analyze-application} и обусловлена необходимостью следить
за продолжениями успеха и неудачи при вычислении операндов. Мы вычисляем
операнды с помощью процедуры @code{get-args}, а не простого @code{map},
как в обыкновенном интерпретаторе.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
@end lisp

@noindent
Заметьте, как в @code{get-args} для движения через @code{cdr} по списку
исполнительных процедур @code{aproc} и сборки через @code{cons}
получающегося списка аргументов каждая @code{aproc} в списке вызывается
с продолжением успеха, которое рекурсивно зовет @code{get-args}. Каждый
из этих рекурсивных вызовов @code{get-args} имеет продолжение успеха,
значение которого --- @code{cons} свежеполученного аргумента со списком
уже собранных аргументов:

@lisp
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       @r{;; πродолжение усπеха для этой @code{aproc}}
       (lambda (arg fail2)
         (get-args
          (cdr aprocs)
          env
          @r{;; πродолжение усπеха для}
          @r{;; рекурсивного вызова @code{get-args}}
          (lambda (args fail3)
            (succeed (cons arg args) fail3))
          fail2))
       fail)))
@end lisp

@noindent
Собственно вызов процедуры, который выполняет
@code{execute-application}, осуществляется так же, как и в обыкновенном
интерпретаторе, не считая того, что необходимо управлять продолжениями.

@lisp
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@comment @subsubheading Evaluating @code{amb} expressions
@subsubheading Выполнение выражений @code{amb}

Особая форма @code{amb} --- ключевой элемент недетерминистского языка.
Здесь лежит сущность процесса интерпретации и обоснование необходимости
отслеживать продолжения. Исполнительная процедура для @code{amb}
определяет цикл @code{try-next}, который перебирает исполнительные
процедуры для всех возможных значений выражения @code{amb}. Каждая из
исполнительных процедур вызывается с продолжением неудачи, которое
попробует выполнить следующий вариант. Когда вариантов больше не
остается, все выражение @code{amb} терпит неудачу.

@lisp
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda () (try-next (cdr choices))))))
      (try-next cprocs))))
@end lisp

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора сложен из-за наличия
механизма, позволяющего пользователю заново попытаться выполнить
выражение. Цикл использует процедуру @code{internal-loop}, которая в
качестве аргумента принимает процедуру @code{try-again}. Наш замысел
состоит в том, чтобы вызов @code{try-again} переходил к следующему
нерассмотренному варианту в недетерминистском вычислении. Процедура
@code{internal-loop} либо зовет @code{try-again}, если пользователь
набирает @code{try-again} в управляющем цикле, либо запускает новое
вычисление, вызывая @code{ambeval}.

Продолжение неудачи в этом вызове @code{ambeval} сообщает пользователю,
что значений больше нет, и перезапускает управляющий цикл.

Продолжение успеха для вызова @code{ambeval} устроено тоньше. Мы
печатаем вычисленное значение, а потом заново запускаем внутренний цикл
с процедурой @code{try-again}, которая сможет попробовать следующий
вариант. Этот переход к следующему варианту выражается процедурой
@code{next-alternative}, которая передана вторым аргументом в
продолжение успеха. Обычно мы считаем этот второй аргумент продолжением
неудачи, которое придется использовать, если текущая ветвь исполнения
потерпит неудачу. Однако в данном случае мы завершили успешное
вычисление, так что <<неудачный>> вариант можно позвать для того, чтобы
найти дополнительные успешные варианты вычисления.

@lisp
(define input-prompt  ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline) (display ";;; Starting a new problem ")
            (ambeval
             input
             the-global-environment
             @r{;; @code{ambeval} усπех}
             (lambda (val next-alternative)
               (announce-output output-prompt)
               (user-print val)
               (internal-loop next-alternative))
             @r{;; @code{ambeval} неудача}
             (lambda ()
               (announce-output
                ";;; There are no more values of")
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline) (display ";;; There is no current problem")
     (driver-loop))))
@end lisp

@noindent
Самый первый вызов @code{internal-loop} использует процедуру
@code{try-again}, которая жалуется, что не было дано никакой задачи, и
возобновляет управляющий цикл. Такое поведение требуется, если
пользователь набирает @code{try-again}, еще не задав выражение для
вычисления.

@quotation
@strong{@anchor{Упражнение 4.50}Упражнение 4.50:}
Реализуйте новую особую форму @code{ramb}, которая подобна
@code{amb}, однако перебирает варианты не слева направо, а в случайном
порядке. Покажите, как такая форма может пригодиться в Лизиной задаче из
упражнения @ref{Упражнение 4.49}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.51}Упражнение 4.51:}
Реализуйте новую разновидность присваивания
@code{permanent-set!} --- присваивание, которое не отменяется при
неудачах. Например, можно выбрать два различных элемента в списке и
посчитать, сколько для этого потребовалось попыток, следующим образом:

@lisp
(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(a b 2)}
@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(a c 3)}
@end lisp

Какие значения были бы напечатаны, если бы мы вместо
@code{permanent-set!} использовали здесь обычный @code{set!}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.52}Упражнение 4.52:}
Реализуйте новую конструкцию @code{if-fail}, которая
позволяет пользователю перехватить неудачу при выполнении выражения.
@code{If-fail} принимает два выражения. Первое она выполняет как обычно
и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения, как в
следующем примере:

@lisp
@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{all-odd}

@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{8}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.53}Упражнение 4.53:} Если у нас есть
@code{permanent-set!}, описанное в упражнении @ref{Упражнение 4.51}, и
@code{if-fail} из упражнения @ref{Упражнение 4.52}, то каков будет
результат вычисления

@lisp
(let ((pairs '()))
  (if-fail
   (let ((p (prime-sum-pair '(1 3 5 8)
                            '(20 35 110))))
     (permanent-set! pairs (cons p pairs))
     (amb))
   pairs))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.54}Упражнение 4.54:}
Если бы мы не догадались, что конструкцию можно
реализовать как обычную процедуру с помощью @code{amb}, так что
пользователь сам может определить ее в своей недетерминистской
программе, то нам пришлось бы задать эту конструкцию в виде особой
формы. Потребовались бы синтаксические процедуры

@lisp
(define (require? exp)
  (tagged-list? exp 'require))
(define (require-predicate exp)
  (cadr exp))
@end lisp

@noindent
новая ветвь разбора в @code{analyze}:

@lisp
((require? exp) (analyze-require exp))
@end lisp

@noindent
а также процедура @code{analyze-require}, которая обрабатывает выражения
@code{require}. Допишите следующее определение @code{analyze-require}:

@lisp
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if @math{\langle}??@math{\rangle}
                   @math{\langle}??@math{\rangle}
                   (succeed 'ok fail2)))
             fail))))

@end lisp
@end quotation


@comment @section Logic Programming
@section Логическое программирование
@node	4.4,  , 4.3, Chapter 4

В @ref{Глава 1} мы подчеркивали, что информатика имеет дело с императивным
знанием (<<как сделать>>), в то время как математика имеет дело с декларативным
знанием (<<что такое>>). Действительно, языки программирования требуют,
чтобы программист, выражая свои знания, указывал методы пошагового
решения определенных задач. С другой стороны, языки высокого уровня
обеспечивают в рамках своих реализаций существенный объем
методологических знаний, которые освобождает пользователя от забот о
многих деталях того, как проходит описываемое вычисление.

Большинство языков программирования, включая Лисп, построены вокруг
вычисления значений математических функций. Языки, ориентированные на
выражения, (такие, как Лисп, Фортран и Алгол) пользуются тем, что
выражение, описывающее значение функции, можно интерпретировать и как
способ вычислить это значение. По этой причине большинство языков
программирования имеют уклон в однонаправленные вычисления (вычисления
со строго определенными входом и выходом). Имеются, однако, совсем
другие языки программирования, в которых этот уклон ослаблен. Пример
такого языка мы видели в @ref{3.3.5},
где объектами вычисления были арифметические ограничения. В системе
ограничений направление и порядок вычислений определены не столь четко;
стало быть, чтобы провести вычисление, система должна содержать в себе
более детальное знание <<как сделать>>, чем в случае с обычным
арифметическим вычислением. Однако это не значит, что пользователь вовсе
не отвечает за то, чтобы обеспечить систему императивным знанием.
Существует множество сетей, которые задают одно и то же множество
ограничений, и пользователю нужно выбрать из множества математически
эквивалентных сетей одну подходящую, чтобы описать нужное вычисление.

Недетерминистский интерпретатор программ из @ref{4.3}
тоже представляет собой отход от представления, что программирование
связано с построением алгоритмов для вычисления однонаправленных
функций. В недетерминистском языке у выражений может быть более одного
значения, и оттого вычисление работает с отношениями, а не с функциями,
у которых значение только одно. Логическое программирование расширяет
эту идею, сочетая реляционный взгляд на программирование с мощной
разновидностью символьного сопоставления с образцом, которую называют
(@newterm{unification}).@footnote{Логическое программирование выросло из долгой
традиции исследований по автоматическому доказательству теорем. Ранние
программы доказательства теорем достигали лишь скромных результатов, так
как они полностью перебирали пространство возможных доказательств.
Крупный прорыв, который сделал такой поиск осмысленным, случился в
начале 1960х годов, когда были открыты (unification algorithm) и
(resolution principle) (Robinson 1965). Резолюцию использовали,
например, Грин и Рафаэль (Green and Raphael 1968, см. также Green 1969)
как основу дедуктивной системы вопрос-ответ. Большую часть этого периода
исследователи сосредотачивались на алгоритмах, которые гарантированно
находят решение, если оно существует. Такими алгоритмами было трудно
управлять, и трудно было указать им направление доказательства. Хьюитт
(Hewitt 1969) нашел возможность сочетать управляющую структуру языка
программирования с операциями системы логического манипулирования, и это
привело к появлению работы по автоматическому поиску, упомянутой в
@ref{4.3.1} (@ref{Сноска 4.47}).
В то же самое время в Марселе Кольмероэ разрабатывал системы обработки
естественного языка, основанные на правилах (см. Colmerauer et al.
1973). Для представления этих правил он изобрел язык Пролог. Ковальски
(Kowalski 1973; Kowalski 1979) в Эдинбурге обнаружил, что выполнение
программы на Прологе можно интерпретировать как доказательство теорем (с
использованием метода доказательства, называемого линейной резолюцией
Хорновских форм). Слияние этих двух линий привело к возникновению
традиции логического программирования. Таким образом, в споре о
приоритетах в области логического программирования французы могут
указать на корни Пролога в Марсельском университете, а британцы на
работы, сделанные в университете Эдинбурга. А по мнению исследователей
из MIT, обе эти группы разработали логическое программирование, когда
пытались понять, что же хотел сказать Хьюитт в своей блистательной, но
трудночитаемой диссертации. Историю логического программирования можно
найти в Robinson 1983.}

Когда этот подход работает, он служит весьма мощным способом написания
программ. Отчасти эта мощь проистекает из того, что один факт вида <<что
такое>> можно использовать для решения нескольких различных задач с
разными компонентами <<как сделать>>. Для примера рассмотрим операцию
@code{append}, которая в качестве аргументов принимает два списка и
объединяет их элементы в один список. В процедурном языке вроде Лиспа
можно определить @code{append} через базовый конструктор списков
@code{cons}, как в @ref{2.2.1}:

@lisp

(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
@end lisp

@noindent
Эту процедуру можно рассматривать как перевод на Лисп следующих двух
правил; первое покрывает случай, когда первый список пуст, а второе ---
случай непустого списка, представляющего собой @code{cons} двух частей:

@itemize @bullet

@item
Для любого списка @code{y}, @code{append} пустого списка и @code{y} дает
@code{y}.

@item
Для любых @code{u}, @code{v}, @code{y} и @code{z}, @code{append} от
@code{(cons u v)} и @code{y} дает @code{(cons u z)}, если @code{append}
от @code{v} и @code{y} дает @code{z}.@footnote{Соответствие между
правилами и процедурой такое: пусть @code{x} из процедуры (когда
@code{x} непустой) соответствует @code{(cons u v)} из правила. Тогда
@code{z} из правила соответствует @code{append} от @code{(cdr x)} и @code{y}.}

@end itemize

@noindent
С помощью процедуры @code{append} мы можем решать задачи типа

@quotation
Найти @code{append} от @code{(a b)} и @code{(c d)}.
@end quotation

@noindent
Однако тех же двух правил достаточно для решения следующих типов
вопросов, на которые процедура ответить не может:

@quotation
Найти список @code{y}, такой, что @code{append} @code{(a b)} и @code{y}
дает @code{(a b c d)}.

Найти все такие @code{x} и @code{y}, что @code{append} от них дает
@code{(a b c d)}.
@end quotation

@noindent
В языке логического программирования, когда программист пишет
<<процедуру>> @code{append}, он формулирует два правила, приведенные
выше. Знание <<как сделать>> автоматически обеспечивается
интерпретатором, что позволяет использовать одну эту пару правил для
ответа на все три типа вопросов об @code{append}.@footnote{Это ни в коем
случае не освобождает программиста полностью от решения задачи, как
вычислить ответ. Существует множество математически эквивалентных
наборов правил для отношения @code{append}, и только некоторые из них
можно превратить в эффективное средство для вычисления в каком-либо
направлении. Вдобавок, иногда информация <<что такое>> ничего не говорит
о том, @emph{как} вычислить ответ, --- возьмем, например, задачу найти
такое @math{y}, что @math{y^2 = x}.}

У современных языков логического программирования (включая тот, который
мы сейчас реализуем) есть существенные недостатки, а именно: их общие
методы <<как сделать>> порой заводят в ненужные бесконечные циклы или
вызывают нежелательное поведение другого рода. Логическое
программирование сейчас активно исследуется в информатике.@footnote{Пик
интереса к логическому программированию пришелся на начало 80-х, когда
японское правительство инициировало амбициозный проект, целью которого
было построение сверхбыстрых компьютеров, оптимизированных для
логических языков программирования. Скорость таких компьютеров
предполагалось измерять в LIPS (Logical Inferences Per Second --- число
логических выводов в секунду), а не в обычных FLOPS (FLoating-point
Operations Per Second --- число операций с плавающей точкой в секунду).
Несмотря на то, что в рамках проекта удалось создать аппаратное и
программное обеспечение, которое изначально планировалось, интересы
международной компьютерной промышленности сместились в другом
направлении. Обзор и оценку японского проекта можно найти в Feigenbaum
and Shrobe 1993. К тому же и в сообществе логических программистов
возник интерес к реляционному программированию на основе других методов,
помимо простого сопоставления с образцом, например, к работе с
численными ограничениями --- вроде тех, которые присутствуют в системе
распространения ограничений из @ref{3.3.5}.}

Ранее в этой главе мы изучили технологию реализации интерпретаторов и
описали те ее элементы, которые необходимы в интерпретаторе
Лисп-подобного языка (в сущности, любого традиционного языка). Теперь мы
воспользуемся этими идеями при рассмотрении интерпретатора для языка
логического программирования. Мы называем этот язык (query language),
поскольку он весьма удобен для извлечения информации из баз данных при
помощи (queries), то есть выраженных на нашем языке вопросов. Несмотря
на то, что язык запросов сильно отличается от Лиспа, его удобно
обсуждать в терминах той же самой общей схемы, которую мы использовали
до сих пор: как набор элементарных составляющих, дополненных средствами
комбинирования, которые позволяют нам сочетать простые составляющие и
получать при этом сложные, и средствами абстракции, которые позволяют
нам рассматривать сложные составляющие как единые концептуальные
единицы. Интерпретатор языка логического программирования существенно
сложнее, чем интерпретатор языка типа Лиспа. Тем не менее, нам предстоит
убедиться, что наш интерпретатор языка запросов содержит многие из тех
же элементов, которые были в интерпретаторе из @ref{4.1}. В частности, у
нас будет часть <<eval>>, которая классифицирует выражения в соответствии
с типом, и часть <<apply>>, которая реализует механизм абстракции языка
(процедуры в случае Лиспа и (rules) в случае логического
программирования). Кроме того, в реализации центральную роль будет
играть структура данных, построенная из кадров и определяющая
соотношение между символами и связанными с ними значениями. Еще одна
интересная сторона нашей реализации языка запросов --- то, что мы
существенным образом используем потоки, введенные в
@ref{Глава 3}.

@menu
* 4-4-1::            Дедуктивный поиск информации
* 4-4-2::            Как действует система обработки запросов
* 4-4-3::            Является ли логическое программирование математической логикой?
* 4-4-4::            Реализация запросной системы
@end menu

@comment @subsection Deductive Information Retrieval
@subsection Дедуктивный поиск информации
@node	4.4.1, 4.4.2, 4.4, 4.4

Логическое программирование хорошо приспособлено для построения
интерфейсов к базам данных, служащих для поиска информации. Язык
запросов, который мы реализуем в этой главе, спроектирован именно для
такого использования.

Чтобы показать, чем занимается система запросов, мы покажем, как с ее
помощью управлять базой данных персонала для <<Микрошафт>>, процветающей
компании из окрестностей Бостона со специализацией в области высоких
технологий. Язык предоставляет возможность поиска информации о
сотрудниках, производимого с помощью образцов; он также может
осуществлять логический вывод на основании общих правил.

@comment @subsubheading A sample data base
@subsubheading База данных

База данных персонала <<Микрошафт>> содержит (@newterm{assertions}) о
сотрудниках компании. Вот информация о Бене Битоборе, местном компьютерном гуру:

@lisp
@code{(адрес (Битобор Бен) (Сламервилл (Ридж Роуд) 10))}
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(зарплата (Битобор Бен) 60000)}
@end lisp

Каждое утверждение представляет собой список (в данном случае тройку).
элементы которого сами могут быть списками.

В качестве местного гуру Бен отвечает за компьютерный отдел компании и
руководит двумя программистами и одним техником. Вот информация о них:

@lisp
@code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(зарплата (Хакер Лиза П) 40000)}
@code{(начальник (Хакер Лиза П) (Битобор Бен))}

@code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(зарплата (Фект Пабло Э) 35000)}
@code{(начальник (Фект Пабло Э) (Битобор Бен))}

@code{(адрес (Поправич Дайко) (Бостон (Бэй Стейт Роуд) 22))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@code{(зарплата (Поправич Дайко) 25000)}
@code{(начальник (Поправич Дайко) (Битобор Бен))}
@end lisp

Имеется также программист-стажер, над которым начальствует Лиза:

@lisp
@code{(адрес (Дум Хьюго) (Сламервилл (Пайн Три Роуд) 80))}
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@code{(зарплата (Дум Хьюго) 30000)}
@code{(начальник (Дум Хьюго) (Хакер Лиза П))}
@end lisp

Все эти служащие работают в компьютерном отделе, на что указывает слово
@code{компьютеры} в начале описания их должностей.

Бен --- служащий высокого ранга. Его начальник --- сам глава компании:

@lisp
@code{(начальник (Битобор Бен) (Уорбак Оливер))}

@code{(адрес (Уорбак Оливер) (Суэлсли (Топ Хип Роуд)))}
@code{(должность (Уорбак Оливер) (администрация большая шишка))}
@code{(зарплата (Уорбак Оливер) 150000)}
@end lisp

Помимо компьютерного отдела, руководимого Беном, в компании имеется
бухгалтерия, где работает главный бухгалтер со своим помощником:

@lisp
@code{(адрес (Скрудж Эбин) (Уэстон (Шейди Лейн) 10))}
@code{(должность (Скрудж Эбин) (бухгалтерия главный бухгалтер))}
@code{(зарплата (Скрудж Эбин) 75000)}
@code{(начальник (Скрудж Эбин) (Уорбак Оливер))}

@code{(адрес (Крэтчит Роберт) (Олстон (Норт Гарвард Стрит) 16))}
@code{(должность (Крэтчит Роберт) (бухгалтерия писец))}
@code{(зарплата (Крэтчит Роберт) 18000)}
@code{(начальник (Крэтчит Роберт) (Скрудж Эбин))}
@end lisp

Есть еще секретарь главы компании:

@lisp
@code{(адрес (Фиден Кон) (Сламервилл (Онион Сквер) 5))}
@code{(должность (Фиден Кон) (администрация секретарь))}
@code{(зарплата (Фиден Кон) 25000)}
@code{(начальник (Фиден Кон) (Уорбак Оливер))}
@end lisp

Данные содержат также утверждения о том, какой род работы могут
выполнять сотрудники, имеющие другую должность. Например, компьютерный
гуру способен выполнять работу как компьютерного программиста, так и
компьютерного техника:

@lisp
@code{(может-замещать (компьютеры гуру) (компьютеры программист))}
@code{(может-замещать (компьютеры гуру) (компьютеры техник))}
@end lisp

Программист может выполнять работу стажера:

@lisp
@code{(может-замещать (компьютеры программист)
                (компьютеры программист стажер))}
@end lisp

Кроме того, как всем известно,

@lisp
@code{(может-замещать (администрация секретарь)
                (администрация большая шишка))}
@end lisp

@comment @subsubheading Simple queries
@subsubheading Простые запросы

Язык запросов дает пользователям возможность извлекать информацию из
базы данных, формулируя запросы в ответ на приглашение системы.
Например, чтобы найти всех программистов, можно сказать

@lisp
@i{;;; Ввод заπроса:}
@end lisp
@example
(должность ?x (компьютеры программист))
@end example

Система выведет следующие результаты:

@lisp
@i{;;; Результаты заπроса:}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@end lisp

@noindent
Входной запрос указывает, что мы ищем в базе данных записи,
соответствующие некоторому (@newterm{pattern}). В этом примере образец указывает,
что запись должна состоять из трех элементов, из которых первый является
символом @code{должность}, второй может быть чем угодно, а третий
представляет собой список @code{(компьютеры программист)}. <<Что
угодно>>, которое может стоять на второй позиции в искомом списке,
изображается (@newterm{pattern variable}) @code{?x}. В общем случае переменная
образца --- это символ, который мы считаем именем переменной,
предваряемый знаком вопроса. Несколько позже мы увидим, почему имеет
смысл давать переменным образца имена, а не просто ставить в образцы
@code{?}, означающее <<что угодно>>. Система отвечает на простой запрос,
выводя все записи в базе данных, соответствующие введенному образцу.

В образце может содержаться более одной переменной. Например,
@lisp
(address ?x ?y)
@end lisp

@noindent
выводит адреса всех служащих.

В образце может совсем не быть переменных. В этом случае запрос просто
проверяет, содержится ли запись в базе. Если да, будет одна подходящая
под образец запись; если нет, ни одной.

Одна и та же переменная может встречаться в образце в нескольких местах,
и это означает, что одинаковое <<что угодно>> должно встретиться в
каждом из этих мест. Ради этого переменным и даются имена. Например,

@lisp
(supervisor ?x ?x)
@end lisp

@noindent
находит всех сотрудников, которые сами себе начальники (впрочем, в нашей
пробной базе таковых не имеется).

Запросу

@lisp
(job ?x (computer ?type))
@end lisp

@noindent
соответствуют все записи о должностях, в которых третий элемент является
двухэлементным списком, а первый элемент в нем @code{компьютеры}:

@lisp
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@end lisp

@noindent
Этому образцу @emph{не} соответствует запись

@lisp
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@end lisp

@noindent
поскольку третий элемент здесь является списком из трех элементов, а
третий элемент образца указывает, что элементов должно быть два. Если бы
нам захотелось изменить образец так, чтобы третий элемент мог быть любым
списком, который начинается с @code{компьютеры}, мы могли бы
написать@footnote{Здесь используется точечная запись, введенная в
упражнении @ref{Упражнение 2.20}.}

@lisp
@code{(должность ?x (компьютеры . ?type))}
@end lisp

@noindent
Например,

@lisp
@code{(компьютеры . ?type)}
@end lisp

@noindent
соответствуют данные

@lisp
@code{(компьютеры программист стажер)}
@end lisp

@noindent
причем @code{?type} равняется списку @code{(программист стажер)}. Тому
же образцу соответствуют данные

@lisp
@code{(компьютеры программист)}
@end lisp

@noindent
где @code{?type} равняется списку @code{(программист)}, и данные

@lisp
@code{(компьютеры)}
@end lisp

@noindent
где @code{?type} равняется пустому списку @code{()}.

Можно следующим образом описать обработку простых запросов в нашем языке:

@itemize @bullet

@item
Система находит все присваивания переменным в образце запроса, которые
(@newterm{satisfy}) запросу --- то есть, все наборы значений переменных, такие,
что если переменные образца (@newterm{instantiated with}), то есть замещаются,
своими значениями, то результат находится в базе данных.

@item
Система отвечает на запрос, перечисляя все конкретизации образца с
удовлетворяющими ему присваиваниями переменным.

@end itemize

@noindent
Заметим, что в случае, когда образец не содержит переменных, запрос
сводится к выяснению, находится ли образец в базе. Если да, то нулевое
присваивание, не сообщающее значений никаким переменным, удовлетворяет
запросу к текущей базе данных.

@quotation
@strong{@anchor{Упражнение 4.55}Упражнение 4.55:}
Постройте простые запросы, которые извлекают из базы
данных следующую информацию:

@enumerate

@item
Все сотрудники, начальником которых является Бен Битобор.

@item
Имена и должности всех работников бухгалтерии.

@item
Имена и адреса всех сотрудников, живущих в Сламервилле.

@end enumerate
@end quotation

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Простые запросы являются элементарными операциями языка запросов. Чтобы
порождать составные операции, язык предоставляет средства
комбинирования. Один из элементов, превращающих язык запросов в язык
логического программирования --- то, что средства комбинирования
запросов отражают средства комбинирования, используемые при построении
логических выражений: @code{and} (и), @code{or} (или) и @code{not} (не).
(Здесь @code{and}, @code{or} и @code{not} --- это не элементарные
выражения Лиспа, а операции, встроенные в язык запросов.)

Мы можем найти адреса всех программистов с помощью @code{and} так:

@lisp
(and (@code{должность} ?person (@code{компьютеры программист}))
     (@code{адрес} ?person ?where))
@end lisp

@noindent
Получаем на выводе

@lisp
(and @code{(должность (Хакер Лиза П) (компьютеры программист))}
     @code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78)))}

(and @code{(должность (Фект Пабло Э) (компьютеры программист))}
     @code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(and @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
удовлетворяют все наборы значений переменных образца, которые
одновременно удовлетворяют @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Как и в случае с простыми запросами, система при обработке составного
запроса находит все присваивания переменным образца, удовлетворяющие
запросу, и затем печатает все конкретизации запроса этими значениями.

Другой метод построения составных запросов --- через @code{or}.
Например,

@lisp
(or @code{(начальник ?x (Битобор Бен))}
    @code{(начальник ?x (Хакер Лиза П)))}
@end lisp

@noindent
найдет всех сотрудников, над которыми начальствует Бен Битобор или Лиза
П. Хакер:

@lisp
(or @code{(начальник (Хакер Лиза П) (Битобор Бен))}
    @code{(начальник (Хакер Лиза П) (Хакер Лиза П)))}

(or @code{(начальник (Фект Пабло Э) (Битобор Бен))}
    @code{(начальник (Фект Пабло Э) (Хакер Лиза П)))}

(or @code{(начальник (Поправич Дайко) (Битобор Бен))}
    @code{(начальник (Поправич Дайко) (Хакер Лиза П)))}

(or @code{(начальник (Дум Хьюго) (Битобор Бен))}
    @code{(начальник (Дум Хьюго) (Хакер Лиза П)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(or @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяют все наборы значений переменных образца, которые
удовлетворяют по крайней мере одному из @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Кроме того, составные запросы можно порождать при помощи @code{not}.
Например,

@lisp
(and @code{(начальник ?x (Битобор Бен))}
     (not @code{(должность ?x (компьютеры программист))}))
@end lisp

@noindent
ищет всех сотрудников, для которых начальник Бен Битобор, не являющихся
программистами. В общем случае, запросу

@lisp
(not @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle})
@end lisp

@noindent
удовлетворяют все присваивания переменным образца, которые не удовлетворяют
@math{\langle}@var{запросу}@math{_1\rangle}.@footnote{Это
описание @code{not} верно только для простых случаев. На самом деле
поведение этой конструкции более сложное. Мы исследуем тонкости
@code{not} в разделах @ref{Часть 4.4.2} и @ref{Часть 4.4.3}.}

Последняя комбинирующая форма называется @code{lisp-value}. Когда она
стоит в начале образца, она указывает, что следующий элемент является
предикатом Лиспа, который требуется применить к остальным
(конкретизированным) элементам как к аргументам. В общем случае, образец

@lisp
(lisp-value @math{\langle}@var{предикат}@math{\rangle} @math{\langle}@var{arg}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{arg}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяется теми присваиваниями переменным образца, для которых
применение @math{\langle}@var{предиката}@math{\rangle} к конкретизированным
@math{\langle}@var{arg}@math{_1\rangle} @dots{}
@math{\langle}@var{arg}@math{_n\rangle} дает истину.
Например, чтобы найти всех сотрудников с зарплатой выше 30000 долларов,
можно написать@footnote{@code{lisp-value} имеет смысл использовать
только для тех операций, которых нет в языке запросов. В частности, с
его помощью не следует проверять равенство (так как для этого
предназначено сопоставление в языке запросов) и неравенство (так как это
можно сделать посредством правила @code{same}, приведенного ниже).}

@lisp
(and (salary ?person ?amount) (lisp-value > ?amount 30000))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.56}Упражнение 4.56:}
Сформулируйте составные запросы для получения следующей
информации:

@enumerate a.

@item
имена всех сотрудников, у которых начальником Бен Битобор, и их адреса;

@item
все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой Бена;

@item
все сотрудники, у которых начальник не относится к компьютерному отделу,
вместе с именем и должностью их начальника.

@end enumerate

@end quotation

@comment @subsubheading Rules
@subsubheading Правила

In addition to primitive queries and compound queries, the query language
provides means for abstracting queries.  These are given by @newterm{rules}.
The rule

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
specifies that two people live near each other if they live in the same town.
The final @code{not} clause prevents the rule from saying that all people live
near themselves.  The @code{same} relation is defined by a very simple
rule:@footnote{Notice that we do not need @code{same} in order to make two
things be the same: We just use the same pattern variable for each---in effect,
we have one thing instead of two things in the first place.  For example, see
@code{?town} in the @code{lives-near} rule and @code{?middle-manager} in the
@code{wheel} rule below.  @code{same} is useful when we want to force two
things to be different, such as @code{?person-1} and @code{?person-2} in the
@code{lives-near} rule.  Although using the same pattern variable in two parts
of a query forces the same value to appear in both places, using different
pattern variables does not force different values to appear.  (The values
assigned to different pattern variables may be the same or different.)}

@lisp
(rule (same ?x ?x))
@end lisp

@noindent
The following rule declares that a person is a ``wheel'' in an organization if
he supervises someone who is in turn a supervisor:

@lisp
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
@end lisp

@noindent
The general form of a rule is

@lisp
(rule @math{\langle}@var{conclusion}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@noindent
where @math{\langle}@var{conclusion}@math{\rangle} is a pattern and @math{\langle}@var{body}@math{\rangle} is any
query.@footnote{We will also allow rules without bodies, as in @code{same}, and
we will interpret such a rule to mean that the rule conclusion is satisfied by
any values of the variables.} We can think of a rule as representing a large
(even infinite) set of assertions, namely all instantiations of the rule
conclusion with variable assignments that satisfy the rule body.  When we
described simple queries (patterns), we said that an assignment to variables
satisfies a pattern if the instantiated pattern is in the data base.  But the
pattern needn't be explicitly in the data base as an assertion.  It can be an
implicit assertion implied by a rule.  For example, the query

@lisp
(lives-near ?x (Bitdiddle Ben))
@end lisp

@noindent
results in

@lisp
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
@end lisp

@noindent
To find all computer programmers who live near Ben Bitdiddle, we can ask

@lisp
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
@end lisp

@noindent
As in the case of compound procedures, rules can be used as parts of other
rules (as we saw with the @code{lives-near} rule above) or even be defined
recursively.  For instance, the rule

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
@end lisp

@noindent
says that a staff person is outranked by a boss in the organization if the boss
is the person's supervisor or (recursively) if the person's supervisor is
outranked by the boss.

@quotation
@strong{@anchor{Уπражнение 4.57}Уπражнение 4.57:}
Define a rule that says that
person 1 can replace person 2 if either person 1 does the same job as person 2
or someone who does person 1's job can also do person 2's job, and if person 1
and person 2 are not the same person. Using your rule, give queries that find
the following:

@enumerate a.

@item
all people who can replace Cy D. Fect;

@item
all people who can replace someone who is being paid more than they are,
together with the two salaries.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.58}Уπражнение 4.58:}
Define a rule that says that a
person is a ``big shot'' in a division if the person works in the division but
does not have a supervisor who works in the division.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.59}Уπражнение 4.59:}
Ben Bitdiddle has missed one
meeting too many.  Fearing that his habit of forgetting meetings could cost him
his job, Ben decides to do something about it.  He adds all the weekly meetings
of the firm to the Microshaft data base by asserting the following:

@lisp
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
@end lisp

Each of the above assertions is for a meeting of an entire division.  Ben also
adds an entry for the company-wide meeting that spans all the divisions.  All
of the company's employees attend this meeting.

@lisp
(meeting whole-company (Wednesday 4pm))
@end lisp

@enumerate a.

@item
On Friday morning, Ben wants to query the data base for all the meetings that
occur that day.  What query should he use?

@item
Alyssa P. Hacker is unimpressed.  She thinks it would be much more useful to be
able to ask for her meetings by specifying her name.  So she designs a rule
that says that a person's meetings include all @code{whole-company} meetings
plus all meetings of that person's division.  Fill in the body of Alyssa's
rule.

@lisp
(rule (meeting-time ?person ?day-and-time)
      @math{\langle}@var{rule-body}@math{\rangle})
@end lisp

@item
Alyssa arrives at work on Wednesday morning and wonders what meetings she has
to attend that day.  Having defined the above rule, what query should she make
to find this out?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.60}Уπражнение 4.60:}
By giving the query

@lisp
(lives-near ?person (Hacker Alyssa P))
@end lisp

Alyssa P. Hacker is able to find people who live near her, with whom she can
ride to work.  On the other hand, when she tries to find all pairs of people
who live near each other by querying

@lisp
(lives-near ?person-1 ?person-2)
@end lisp

@noindent
she notices that each pair of people who live near each other is listed twice;
for example,

@lisp
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
@end lisp

Why does this happen?  Is there a way to find a list of people who live near
each other, in which each pair appears only once?  Explain.
@end quotation

@comment @subsubheading Logic as programs

We can regard a rule as a kind of logical implication: @emph{If} an assignment
of values to pattern variables satisfies the body, @emph{then} it satisfies the
conclusion.  Consequently, we can regard the query language as having the
ability to perform @newterm{logical deductions} based upon the rules.  As an
example, consider the @code{append} operation described at the beginning of
@ref{4.4}.  As we said, @code{append} can be characterized by the
following two rules:

@itemize @bullet

@item
For any list @code{y}, the empty list and @code{y} @code{append} to form
@code{y}.

@item
For any @code{u}, @code{v}, @code{y}, and @code{z}, @code{(cons u v)} and
@code{y} @code{append} to form @code{(cons u z)} if @code{v} and @code{y}
@code{append} to form @code{z}.

@end itemize

@noindent
To express this in our query language, we define two rules for a relation

@lisp
(append-to-form x y z)
@end lisp

@noindent
which we can interpret to mean ``@code{x} and @code{y} @code{append} to form
@code{z}'':

@lisp
(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
@end lisp

@noindent
The first rule has no body, which means that the conclusion holds for any value
of @code{?y}.  Note how the second rule makes use of dotted-tail notation to
name the @code{car} and @code{cdr} of a list.

Given these two rules, we can formulate queries that compute the @code{append}
of two lists:

@lisp
@i{;;; Query input:}
(append-to-form (a b) (c d) ?z)
@i{;;; Query results:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
What is more striking, we can use the same rules to ask the question ``Which
list, when @code{append}ed to @code{(a b)}, yields @code{(a b c d)}?''  This is
done as follows:

@lisp
@i{;;; Query input:}
(append-to-form (a b) ?y (a b c d))
@i{;;; Query results:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
We can also ask for all pairs of lists that @code{append} to form @code{(a b c
d)}:

@lisp
@i{;;; Query input:}
(append-to-form ?x ?y (a b c d))
@i{;;; Query results:}
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
@end lisp

@noindent
The query system may seem to exhibit quite a bit of intelligence in using the
rules to deduce the answers to the queries above.  Actually, as we will see in
the next section, the system is following a well-determined algorithm in
unraveling the rules.  Unfortunately, although the system works impressively in
the @code{append} case, the general methods may break down in more complex
cases, as we will see in @ref{4.4.3}.

@quotation
@strong{@anchor{Уπражнение 4.61}Уπражнение 4.61:}
The following rules implement a
@code{next-to} relation that finds adjacent elements of a list:

@lisp
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
@end lisp

What will the response be to the following queries?

@lisp
(?x next-to ?y in (1 (2 3) 4))
(?x next-to  1 in (2 1 3 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.62}Уπражнение 4.62:}
Define rules to implement the
@code{last-pair} operation of @ref{Уπражнение 2.17}, which returns a list
containing the last element of a nonempty list.  Check your rules on queries
such as @code{(last-pair (3) ?x)}, @code{(last-pair (1 2 3) ?x)} and
@code{(last-pair (2 ?x) (3))}.  Do your rules work correctly on queries such as
@code{(last-pair ?x (3))} ?
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.63}Уπражнение 4.63:}
The following data base (see
Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way
of Cain:

@lisp
(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
@end lisp

Formulate rules such as ``If @math{S} is the son of @math{f}, and @math{f} is the son of
@math{G}, then @math{S} is the grandson of @math{G}'' and ``If @math{W} is the wife of
@math{M}, and @math{S} is the son of @math{W}, then @math{S} is the son of @math{M}'' (which
was supposedly more true in biblical times than today) that will enable the
query system to find the grandson of Cain; the sons of Lamech; the grandsons of
Methushael.  (See @ref{Уπражнение 4.69} for some rules to deduce more complicated
relationships.)
@end quotation

@comment @subsection How the Query System Works
@node	4.4.2, 4.4.3, 4.4.1, 4.4

In @ref{4.4.4} we will present an implementation of the query
interpreter as a collection of procedures.  In this section we give an overview
that explains the general structure of the system independent of low-level
implementation details.  After describing the implementation of the
interpreter, we will be in a position to understand some of its limitations and
some of the subtle ways in which the query language's logical operations differ
from the operations of mathematical logic.

It should be apparent that the query evaluator must perform some kind of search
in order to match queries against facts and rules in the data base.  One way to
do this would be to implement the query system as a nondeterministic program,
using the @code{amb} evaluator of @ref{4.3} (see @ref{Уπражнение 4.78}).
Another possibility is to manage the search with the aid of streams.  Our
implementation follows this second approach.

The query system is organized around two central operations called
@newterm{pattern matching} and @newterm{unification}.  We first describe
pattern matching and explain how this operation, together with the organization
of information in terms of streams of frames, enables us to implement both
simple and compound queries.  We next discuss unification, a generalization of
pattern matching needed to implement rules.  Finally, we show how the entire
query interpreter fits together through a procedure that classifies expressions
in a manner analogous to the way @code{eval} classifies expressions for the
interpreter described in @ref{4.1}.

@endpage
@comment @subsubheading Pattern matching

A @newterm{pattern matcher} is a program that tests whether some datum fits a
specified pattern.  For example, the data list @code{((a b) c (a b))} matches
the pattern @code{(?x c ?x)} with the pattern variable @code{?x} bound to
@code{(a b)}.  The same data list matches the pattern @code{(?x ?y ?z)} with
@code{?x} and @code{?z} both bound to @code{(a b)} and @code{?y} bound to
@code{c}.  It also matches the pattern @code{((?x ?y) c (?x ?y))} with
@code{?x} bound to @code{a} and @code{?y} bound to @code{b}.  However, it does
not match the pattern @code{(?x a ?y)}, since that pattern specifies a list
whose second element is the symbol @code{a}.

The pattern matcher used by the query system takes as inputs a pattern, a
datum, and a @newterm{frame} that specifies bindings for various pattern
variables.  It checks whether the datum matches the pattern in a way that is
consistent with the bindings already in the frame.  If so, it returns the given
frame augmented by any bindings that may have been determined by the match.
Otherwise, it indicates that the match has failed.

For example, using the pattern @code{(?x ?y ?x)} to match @code{(a b a)} given
an empty frame will return a frame specifying that @code{?x} is bound to
@code{a} and @code{?y} is bound to @code{b}.  Trying the match with the same
pattern, the same datum, and a frame specifying that @code{?y} is bound to
@code{a} will fail.  Trying the match with the same pattern, the same datum,
and a frame in which @code{?y} is bound to @code{b} and @code{?x} is unbound
will return the given frame augmented by a binding of @code{?x} to @code{a}.

The pattern matcher is all the mechanism that is needed to process simple
queries that don't involve rules.  For instance, to process the query

@lisp
(job ?x (computer programmer))
@end lisp

@noindent
we scan through all assertions in the data base and select those that match the
pattern with respect to an initially empty frame.  For each match we find, we
use the frame returned by the match to instantiate the pattern with a value for
@code{?x}.

@endpage
@comment @subsubheading Streams of frames

The testing of patterns against frames is organized through the use of streams.
Given a single frame, the matching process runs through the data-base entries
one by one.  For each data-base entry, the matcher generates either a special
symbol indicating that the match has failed or an extension to the frame.  The
results for all the data-base entries are collected into a stream, which is
passed through a filter to weed out the failures.  The result is a stream of
all the frames that extend the given frame via a match to some assertion in the
data base.@footnote{Because matching is generally very expensive, we would like
to avoid applying the full matcher to every element of the data base.  This is
usually arranged by breaking up the process into a fast, coarse match and the
final match.  The coarse match filters the data base to produce a small set of
candidates for the final match.  With care, we can arrange our data base so
that some of the work of coarse matching can be done when the data base is
constructed rather then when we want to select the candidates.  This is called
@newterm{indexing} the data base.  There is a vast technology built around
data-base-indexing schemes.  Our implementation, described in
@ref{4.4.4}, contains a simple-minded form of such an optimization.}

In our system, a query takes an input stream of frames and performs the above
matching operation for every frame in the stream, as indicated in @ref{Рисунок 4.4}.
That is, for each frame in the input stream, the query generates a new
stream consisting of all extensions to that frame by matches to assertions in
the data base.  All these streams are then combined to form one huge stream,
which contains all possible extensions of every frame in the input stream.
This stream is the output of the query.

To answer a simple query, we use the query with an input stream consisting of a
single empty frame.  The resulting output stream contains all extensions to the
empty frame (that is, all answers to our query).  This stream of frames is then
used to generate a stream of copies of the original query pattern with the
variables instantiated by the values in each frame, and this is the stream that
is finally printed.

@float
@c @quotation
@anchor{Рисунок 4.4}
@ifinfo
@strong{Рисунок 4.4:} A query processes a stream of frames.

@example
                                  output stream
  input stream   +-------------+  of frames,
  of frames      |    query    |  filtered and extended
---------------->|             +------------------------->
                 | (job ?x ?y) |
                 +-------------+
                        ^
                        |
               stream of assertions
                  from data base
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.4,102mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.4:} A query processes a stream of frames.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@comment @subsubheading Compound queries

The real elegance of the stream-of-frames implementation is evident when we
deal with compound queries.  The processing of compound queries makes use of
the ability of our matcher to demand that a match be consistent with a
specified frame.  For example, to handle the @code{and} of two queries, such as

@lisp
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
@end lisp

@noindent
(informally, ``Find all people who can do the job of a computer programmer
trainee''), we first find all entries that match the pattern

@lisp
(can-do-job ?x (computer programmer trainee))
@end lisp

@float
@quotation
@anchor{Рисунок 4.5}
@ifinfo
@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced
by operating on the stream of frames in series.

@example
                +----------------------+
                |       (and A B)      |
  input stream  |                      |  output stream
  of frames     |   +---+       +---+  |  of frames
------------------->| A +------>| B +-------------------->
                |   +---+       +---+  |
                |     ^           ^    |
                |     |           |    |
                |     +-----*-----+    |
                +-----------|----------+
                            |
                        data base
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap4/Fig4.5,93mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced by operating on the stream of frames in series.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
This produces a stream of frames, each of which contains a binding for
@code{?x}.  Then for each frame in the stream we find all entries that match

@lisp
(job ?person ?x)
@end lisp

@noindent
in a way that is consistent with the given binding for @code{?x}.  Each such
match will produce a frame containing bindings for @code{?x} and
@code{?person}.  The @code{and} of two queries can be viewed as a series
combination of the two component queries, as shown in @ref{Рисунок 4.5}.  The
frames that pass through the first query filter are filtered and further
extended by the second query.

@float
@anchor{Рисунок 4.6}
@ifinfo
@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced
by operating on the stream of frames in parallel and merging the results.

@example
           +---------------------------+
           |          (or A B)         |
           |    +---+                  |
input      | +->| A |------------+     |  output
stream of  | |  +---+            V     |  stream of
frames     | |    ^          +-------+ |  frames
-------------*    |          | merge +--------------->
           | |    |          +-------+ |
           | |    |              ^     |
           | |    |   +---+      |     |
           | +------->| B +------+     |
           |      |   +---+            |
           |      |     ^              |
           |      |     |              |
           |      +--*--+              |
           +---------|-----------------+
                     |
                 data base
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap4/Fig4.6,107mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced by operating on the stream of frames in parallel and merging the results.}
@sp 0.4
@end iftex
@end float

@ref{Рисунок 4.6} shows the analogous method for computing the
@code{or} of two
queries as a parallel combination of the two component queries.  The input
stream of frames is extended separately by each query.  The two resulting
streams are then merged to produce the final output stream.

Even from this high-level description, it is apparent that the processing of
compound queries can be slow.  For example, since a query may produce more than
one output frame for each input frame, and each query in an @code{and} gets its
input frames from the previous query, an @code{and} query could, in the worst
case, have to perform a number of matches that is exponential in the number of
queries (see @ref{Уπражнение 4.76}).@footnote{But this kind of exponential
explosion is not common in @code{and} queries because the added conditions tend
to reduce rather than expand the number of frames produced.} Though systems for
handling only simple queries are quite practical, dealing with complex queries
is extremely difficult.@footnote{There is a large literature on
data-base-management systems that is concerned with how to handle complex
queries efficiently.}

From the stream-of-frames viewpoint, the @code{not} of some query acts as a
filter that removes all frames for which the query can be satisfied.  For
instance, given the pattern

@lisp
(not (job ?x (computer programmer)))
@end lisp

@noindent
we attempt, for each frame in the input stream, to produce extension frames
that satisfy @code{(job ?x (computer programmer))}.  We remove from the input
stream all frames for which such extensions exist.  The result is a stream
consisting of only those frames in which the binding for @code{?x} does not
satisfy @code{(job ?x (computer programmer))}.  For example, in processing the
query

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
@end lisp

@noindent
the first clause will generate frames with bindings for @code{?x} and
@code{?y}.  The @code{not} clause will then filter these by removing all frames
in which the binding for @code{?x} satisfies the restriction that @code{?x} is
a computer programmer.@footnote{There is a subtle difference between this
filter implementation of @code{not} and the usual meaning of @code{not} in
mathematical logic.  See @ref{4.4.3}.}

The @code{lisp-value} special form is implemented as a similar filter on frame
streams.  We use each frame in the stream to instantiate any variables in the
pattern, then apply the Lisp predicate.  We remove from the input stream all
frames for which the predicate fails.

@comment @subsubheading Unification

In order to handle rules in the query language, we must be able to find the
rules whose conclusions match a given query pattern.  Rule conclusions are like
assertions except that they can contain variables, so we will need a
generalization of pattern matching---called @newterm{unification}---in which
both the ``pattern'' and the ``datum'' may contain variables.

A unifier takes two patterns, each containing constants and variables, and
determines whether it is possible to assign values to the variables that will
make the two patterns equal.  If so, it returns a frame containing these
bindings.  For example, unifying @code{(?x a ?y)} and @code{(?y ?z a)} will
specify a frame in which @code{?x}, @code{?y}, and @code{?z} must all be bound
to @code{a}.  On the other hand, unifying @code{(?x ?y a)} and @code{(?x b ?y)}
will fail, because there is no value for @code{?y} that can make the two
patterns equal.  (For the second elements of the patterns to be equal,
@code{?y} would have to be @code{b}; however, for the third elements to be
equal, @code{?y} would have to be @code{a}.)  The unifier used in the query
system, like the pattern matcher, takes a frame as input and performs
unifications that are consistent with this frame.

The unification algorithm is the most technically difficult part of the query
system.  With complex patterns, performing unification may seem to require
deduction.  To unify @code{(?x ?x)} and @code{((a ?y c) (a b ?z))}, for
example, the algorithm must infer that @code{?x} should be @code{(a b c)},
@code{?y} should be @code{b}, and @code{?z} should be @code{c}.  We may think
of this process as solving a set of equations among the pattern components.  In
general, these are simultaneous equations, which may require substantial
manipulation to solve.@footnote{In one-sided pattern matching, all the
equations that contain pattern variables are explicit and already solved for
the unknown (the pattern variable).} For example, unifying @code{(?x ?x)} and
@code{((a ?y c) (a b ?z))} may be thought of as specifying the simultaneous
equations

@lisp
?x  =  (a ?y c)
?x  =  (a b ?z)
@end lisp

@noindent
These equations imply that

@lisp
(a ?y c)  =  (a b ?z)
@end lisp

@noindent
which in turn implies that

@lisp
 a  =  a,
?y  =  b,
 c  =  ?z,
@end lisp

@noindent
and hence that

@lisp
?x  =  (a b c)
@end lisp

@noindent
In a successful pattern match, all pattern variables become bound, and the
values to which they are bound contain only constants.  This is also true of
all the examples of unification we have seen so far.  In general, however, a
successful unification may not completely determine the variable values; some
variables may remain unbound and others may be bound to values that contain
variables.

Consider the unification of @code{(?x a)} and @code{((b ?y) ?z)}.  We can
deduce that @code{?x = (b ?y)} and @code{a = ?z}, but we cannot further solve
for @code{?x} or @code{?y}.  The unification doesn't fail, since it is
certainly possible to make the two patterns equal by assigning values to
@code{?x} and @code{?y}.  Since this match in no way restricts the values
@code{?y} can take on, no binding for @code{?y} is put into the result frame.
The match does, however, restrict the value of @code{?x}.  Whatever value
@code{?y} has, @code{?x} must be @code{(b ?y)}.  A binding of @code{?x} to the
pattern @code{(b ?y)} is thus put into the frame.  If a value for @code{?y} is
later determined and added to the frame (by a pattern match or unification that
is required to be consistent with this frame), the previously bound @code{?x}
will refer to this value.@footnote{Another way to think of unification is that
it generates the most general pattern that is a specialization of the two input
patterns.  That is, the unification of @code{(?x a)} and @code{((b ?y) ?z)} is
@code{((b ?y) a)}, and the unification of @code{(?x a ?y)} and @code{(?y ?z
a)}, discussed above, is @code{(a a a)}.  For our implementation, it is more
convenient to think of the result of unification as a frame rather than a
pattern.}

@comment @subsubheading Applying rules

Unification is the key to the component of the query system that makes
inferences from rules. To see how this is accomplished, consider processing a
query that involves applying a rule, such as

@lisp
(lives-near ?x (Hacker Alyssa P))
@end lisp

@noindent
To process this query, we first use the ordinary pattern-match procedure
described above to see if there are any assertions in the data base that match
this pattern.  (There will not be any in this case, since our data base
includes no direct assertions about who lives near whom.)  The next step is to
attempt to unify the query pattern with the conclusion of each rule.  We find
that the pattern unifies with the conclusion of the rule

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
resulting in a frame specifying that @code{?person-2} is bound to @code{(Hacker
Alyssa P)} and that @code{?x} should be bound to (have the same value as)
@code{?person-1}.  Now, relative to this frame, we evaluate the compound query
given by the body of the rule.  Successful matches will extend this frame by
providing a binding for @code{?person-1}, and consequently a value for
@code{?x}, which we can use to instantiate the original query pattern.

In general, the query evaluator uses the following method to apply a rule when
trying to establish a query pattern in a frame that specifies bindings for some
of the pattern variables:

@itemize @bullet

@item
Unify the query with the conclusion of the rule to form, if successful, an
extension of the original frame.

@item
Relative to the extended frame, evaluate the query formed by the body of the
rule.

@end itemize

@noindent
Notice how similar this is to the method for applying a procedure in the
@code{eval}/@code{apply} evaluator for Lisp:

@itemize @bullet

@item
Bind the procedure's parameters to its arguments to form a frame that extends
the original procedure environment.

@item
Relative to the extended environment, evaluate the expression formed by the
body of the procedure.

@end itemize

@noindent
The similarity between the two evaluators should come as no surprise.  Just as
procedure definitions are the means of abstraction in Lisp, rule definitions
are the means of abstraction in the query language.  In each case, we unwind
the abstraction by creating appropriate bindings and evaluating the rule or
procedure body relative to these.

@comment @subsubheading Simple queries

We saw earlier in this section how to evaluate simple queries in the absence of
rules.  Now that we have seen how to apply rules, we can describe how to
evaluate simple queries by using both rules and assertions.

Given the query pattern and a stream of frames, we produce, for each frame in
the input stream, two streams:

@itemize @bullet

@item
a stream of extended frames obtained by matching the pattern against all
assertions in the data base (using the pattern matcher), and

@item
a stream of extended frames obtained by applying all possible rules (using the
unifier).@footnote{Since unification is a generalization of matching, we could
simplify the system by using the unifier to produce both streams.  Treating the
easy case with the simple matcher, however, illustrates how matching (as
opposed to full-blown unification) can be useful in its own right.}

@end itemize

@noindent
Appending these two streams produces a stream that consists of all the ways
that the given pattern can be satisfied consistent with the original frame.
These streams (one for each frame in the input stream) are now all combined to
form one large stream, which therefore consists of all the ways that any of the
frames in the original input stream can be extended to produce a match with the
given pattern.

@comment @subsubheading The query evaluator and the driver loop

Despite the complexity of the underlying matching operations, the system is
organized much like an evaluator for any language.  The procedure that
coordinates the matching operations is called @code{qeval}, and it plays a role
analogous to that of the @code{eval} procedure for Lisp.  @code{qeval} takes as
inputs a query and a stream of frames.  Its output is a stream of frames,
corresponding to successful matches to the query pattern, that extend some
frame in the input stream, as indicated in @ref{Рисунок 4.4}.  Like @code{eval},
@code{qeval} classifies the different types of expressions (queries) and
dispatches to an appropriate procedure for each.  There is a procedure for each
special form (@code{and}, @code{or}, @code{not}, and @code{lisp-value}) and one
for simple queries.

The driver loop, which is analogous to the @code{driver-loop} procedure for the
other evaluators in this chapter, reads queries from the terminal.  For each
query, it calls @code{qeval} with the query and a stream that consists of a
single empty frame.  This will produce the stream of all possible matches (all
possible extensions to the empty frame).  For each frame in the resulting
stream, it instantiates the original query using the values of the variables
found in the frame.  This stream of instantiated queries is then
printed.@footnote{The reason we use streams (rather than lists) of frames is
that the recursive application of rules can generate infinite numbers of values
that satisfy a query.  The delayed evaluation embodied in streams is crucial
here: The system will print responses one by one as they are generated,
regardless of whether there are a finite or infinite number of responses.}

The driver also checks for the special command @code{assert!}, which signals
that the input is not a query but rather an assertion or rule to be added to
the data base.  For instance,

@lisp
(assert! (job (Bitdiddle Ben)
              (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
@end lisp


@comment @subsection Is Logic Programming Mathematical Logic?
@node	4.4.3, 4.4.4, 4.4.2, 4.4

The means of combination used in the query language may at first seem identical
to the operations @code{and}, @code{or}, and @code{not} of mathematical logic,
and the application of query-language rules is in fact accomplished through a
legitimate method of inference.@footnote{That a particular method of inference
is legitimate is not a trivial assertion.  One must prove that if one starts
with true premises, only true conclusions can be derived.  The method of
inference represented by rule applications is @newterm{modus ponens}, the
familiar method of inference that says that if @math{A} is true and @emph{A
implies B} is true, then we may conclude that @math{B} is true.} This
identification of the query language with mathematical logic is not really
valid, though, because the query language provides a @newterm{control
structure} that interprets the logical statements procedurally.  We can often
take advantage of this control structure.  For example, to find all of the
supervisors of programmers we could formulate a query in either of two
logically equivalent forms:

@lisp
(and (job ?x (computer programmer)) (supervisor ?x ?y))
@end lisp

@noindent
or

@lisp
(and (supervisor ?x ?y) (job ?x (computer programmer)))
@end lisp

@noindent
If a company has many more supervisors than programmers (the usual case), it is
better to use the first form rather than the second because the data base must
be scanned for each intermediate result (frame) produced by the first clause of
the @code{and}.

The aim of logic programming is to provide the programmer with techniques for
decomposing a computational problem into two separate problems: ``what'' is to
be computed, and ``how'' this should be computed.  This is accomplished by
selecting a subset of the statements of mathematical logic that is powerful
enough to be able to describe anything one might want to compute, yet weak
enough to have a controllable procedural interpretation.  The intention here is
that, on the one hand, a program specified in a logic programming language
should be an effective program that can be carried out by a computer.  Control
(``how'' to compute) is effected by using the order of evaluation of the
language.  We should be able to arrange the order of clauses and the order of
subgoals within each clause so that the computation is done in an order deemed
to be effective and efficient.  At the same time, we should be able to view the
result of the computation (``what'' to compute) as a simple consequence of the
laws of logic.

Our query language can be regarded as just such a procedurally interpretable
subset of mathematical logic.  An assertion represents a simple fact (an atomic
proposition).  A rule represents the implication that the rule conclusion holds
for those cases where the rule body holds.  A rule has a natural procedural
interpretation: To establish the conclusion of the rule, establish the body of
the rule.  Rules, therefore, specify computations.  However, because rules can
also be regarded as statements of mathematical logic, we can justify any
``inference'' accomplished by a logic program by asserting that the same result
could be obtained by working entirely within mathematical logic.@footnote{We
must qualify this statement by agreeing that, in speaking of the ``inference''
accomplished by a logic program, we assume that the computation terminates.
Unfortunately, even this qualified statement is false for our implementation of
the query language (and also false for programs in Prolog and most other
current logic programming languages) because of our use of @code{not} and
@code{lisp-value}.  As we will describe below, the @code{not} implemented in
the query language is not always consistent with the @code{not} of mathematical
logic, and @code{lisp-value} introduces additional complications.  We could
implement a language consistent with mathematical logic by simply removing
@code{not} and @code{lisp-value} from the language and agreeing to write
programs using only simple queries, @code{and}, and @code{or}.  However, this
would greatly restrict the expressive power of the language.  One of the major
concerns of research in logic programming is to find ways to achieve more
consistency with mathematical logic without unduly sacrificing expressive
power.}

@comment @subsubheading Infinite loops

A consequence of the procedural interpretation of logic programs is that it is
possible to construct hopelessly inefficient programs for solving certain
problems.  An extreme case of inefficiency occurs when the system falls into
infinite loops in making deductions.  As a simple example, suppose we are
setting up a data base of famous marriages, including

@lisp
(assert! (married Minnie Mickey))
@end lisp

@noindent
If we now ask

@lisp
(married Mickey ?who)
@end lisp

@noindent
we will get no response, because the system doesn't know that if @math{A} is
married to @math{B}, then @math{B} is married to @math{A}.  So we assert the rule

@lisp
(assert! (rule (married ?x ?y) (married ?y ?x)))
@end lisp

@noindent
and again query

@lisp
(married Mickey ?who)
@end lisp

@noindent
Unfortunately, this will drive the system into an infinite loop, as follows:

@itemize @bullet

@item
The system finds that the @code{married} rule is applicable; that is, the rule
conclusion @code{(married ?x ?y)} successfully unifies with the query pattern
@code{(married Mickey ?who)} to produce a frame in which @code{?x} is bound to
@code{Mickey} and @code{?y} is bound to @code{?who}.  So the interpreter
proceeds to evaluate the rule body @code{(married ?y ?x)} in this frame---in
effect, to process the query @code{(married ?who Mickey)}.

@item
One answer appears directly as an assertion in the data base: @code{(married
Minnie Mickey)}.

@item
The @code{married} rule is also applicable, so the interpreter again evaluates
the rule body, which this time is equivalent to @code{(married Mickey ?who)}.

@end itemize

@noindent
The system is now in an infinite loop.  Indeed, whether the system will find
the simple answer @code{(married Minnie Mickey)} before it goes into the loop
depends on implementation details concerning the order in which the system
checks the items in the data base.  This is a very simple example of the kinds
of loops that can occur.  Collections of interrelated rules can lead to loops
that are much harder to anticipate, and the appearance of a loop can depend on
the order of clauses in an @code{and} (see @ref{Уπражнение 4.64}) or on low-level
details concerning the order in which the system processes
queries.@footnote{This is not a problem of the logic but one of the procedural
interpretation of the logic provided by our interpreter.  We could write an
interpreter that would not fall into a loop here.  For example, we could
enumerate all the proofs derivable from our assertions and our rules in a
breadth-first rather than a depth-first order.  However, such a system makes it
more difficult to take advantage of the order of deductions in our programs.
One attempt to build sophisticated control into such a program is described in
@ref{deKleer et al. 1977}.  Another technique, which does not lead to such serious
control problems, is to put in special knowledge, such as detectors for
particular kinds of loops (@ref{Уπражнение 4.67}).  However, there can be no
general scheme for reliably preventing a system from going down infinite paths
in performing deductions.  Imagine a diabolical rule of the form ``To show
@math{P(x)} is true, show that @math{P(f(x))} is true,'' for some
suitably chosen function @math{f}.}

@comment @subsubheading Problems with @code{not}

Another quirk in the query system concerns @code{not}.  Given the data base of
@ref{4.4.1}, consider the following two queries:

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
@end lisp

@noindent
These two queries do not produce the same result.  The first query begins by
finding all entries in the data base that match @code{(supervisor ?x ?y)}, and
then filters the resulting frames by removing the ones in which the value of
@code{?x} satisfies @code{(job ?x (computer programmer))}.  The second query
begins by filtering the incoming frames to remove those that can satisfy
@code{(job ?x (computer programmer))}.  Since the only incoming frame is empty,
it checks the data base to see if there are any patterns that satisfy
@code{(job ?x (computer programmer))}.  Since there generally are entries of
this form, the @code{not} clause filters out the empty frame and returns an
empty stream of frames.  Consequently, the entire compound query returns an
empty stream.

The trouble is that our implementation of @code{not} really is meant to serve
as a filter on values for the variables.  If a @code{not} clause is processed
with a frame in which some of the variables remain unbound (as does @code{?x}
in the example above), the system will produce unexpected results. Similar
problems occur with the use of @code{lisp-value}---the Lisp predicate can't
work if some of its arguments are unbound.  See @ref{Уπражнение 4.77}.

There is also a much more serious way in which the @code{not} of the query
language differs from the @code{not} of mathematical logic.  In logic, we
interpret the statement ``not @math{P}'' to mean that @math{P} is not true.  In the
query system, however, ``not @math{P}'' means that @math{P} is not deducible from the
knowledge in the data base.  For example, given the personnel data base of
@ref{4.4.1}, the system would happily deduce all sorts of @code{not}
statements, such as that Ben Bitdiddle is not a baseball fan, that it is not
raining outside, and that 2 + 2 is not 4.@footnote{Consider the query
@code{(not (baseball-fan (Bitdiddle Ben)))}.  The system finds that
@code{(baseball-fan (Bitdiddle Ben))} is not in the data base, so the empty
frame does not satisfy the pattern and is not filtered out of the initial
stream of frames.  The result of the query is thus the empty frame, which is
used to instantiate the input query to produce @code{(not (baseball-fan
(Bitdiddle Ben)))}.} In other words, the @code{not} of logic programming
languages reflects the so-called @newterm{closed world assumption} that all
relevant information has been included in the data base.@footnote{A discussion
and justification of this treatment of @code{not} can be found in the article
by @ref{Clark (1978)}.}

@quotation
@strong{@anchor{Уπражнение 4.64}Уπражнение 4.64:}
Louis Reasoner mistakenly deletes
the @code{outranked-@/by} rule (@ref{4.4.1}) from the data base.  When he
realizes this, he quickly reinstalls it.  Unfortunately, he makes a slight
change in the rule, and types it in as

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person
                           ?middle-manager))))
@end lisp

Just after Louis types this information into the system, DeWitt Aull comes by
to find out who outranks Ben Bitdiddle. He issues the query

@lisp
(outranked-by (Bitdiddle Ben) ?who)
@end lisp

After answering, the system goes into an infinite loop.  Explain why.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.65}Уπражнение 4.65:}
Cy D. Fect, looking forward to
the day when he will rise in the organization, gives a query to find all the
wheels (using the @code{wheel} rule of @ref{4.4.1}):

@lisp
(wheel ?who)
@end lisp

To his surprise, the system responds

@lisp
@i{;;; Query results:}
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
@end lisp

Why is Oliver Warbucks listed four times?
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.66}Уπражнение 4.66:}
Ben has been generalizing the
query system to provide statistics about the company.  For example, to find the
total salaries of all the computer programmers one will be able to say

@lisp
(sum ?amount (and (job ?x (computer programmer))
                  (salary ?x ?amount)))
@end lisp

In general, Ben's new system allows expressions of the form

@lisp
(accumulation-function @math{\langle}@var{variable}@math{\rangle} @math{\langle}@var{query pattern}@math{\rangle})
@end lisp

@noindent
where @code{accumulation-function} can be things like @code{sum},
@code{average}, or @code{maximum}.  Ben reasons that it should be a cinch to
implement this.  He will simply feed the query pattern to @code{qeval}.  This
will produce a stream of frames.  He will then pass this stream through a
mapping function that extracts the value of the designated variable from each
frame in the stream and feed the resulting stream of values to the accumulation
function.  Just as Ben completes the implementation and is about to try it out,
Cy walks by, still puzzling over the @code{wheel} query result in
@ref{Уπражнение 4.65}.  When Cy shows Ben the system's response, Ben groans,
``Oh, no, my simple accumulation scheme won't work!''

What has Ben just realized?  Outline a method he can use to salvage the
situation.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.67}Уπражнение 4.67:}
Devise a way to install a loop
detector in the query system so as to avoid the kinds of simple loops
illustrated in the text and in @ref{Уπражнение 4.64}.
The general idea is that
the system should maintain some sort of history of its current chain of
deductions and should not begin processing a query that it is already working
on.  Describe what kind of information (patterns and frames) is included in
this history, and how the check should be made.  (After you study the details
of the query-system implementation in @ref{Часть 4.4.4}, you may want to
modify the system to include your loop detector.)
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.68}Уπражнение 4.68:}
Define rules to implement the
@code{reverse} operation of @ref{Уπражнение 2.18}, which returns a list
containing the same elements as a given list in reverse order.  (Hint: Use
@code{append-to-form}.)  Can your rules answer both @code{(reverse (1 2 3) ?x)}
and @code{(reverse ?x (1 2 3))} ?
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.69}Уπражнение 4.69:}
Beginning with the data base and
the rules you formulated in @ref{Уπражнение 4.63}, devise a rule for adding
``greats'' to a grandson relationship. This should enable the system to deduce
that Irad is the great-grandson of Adam, or that Jabal and Jubal are the
great-great-great-great-great-grandsons of Adam.  (Hint: Represent the fact
about Irad, for example, as @code{((great grandson) Adam Irad)}.  Write rules
that determine if a list ends in the word @code{grandson}.  Use this to express
a rule that allows one to derive the relationship @code{((great .  ?rel) ?x
?y)}, where @code{?rel} is a list ending in @code{grandson}.)  Check your rules
on queries such as @code{((great grandson) ?g ?ggs)} and @code{(?relationship
Adam Irad)}.
@end quotation

@comment @subsection Implementing the Query System
@node	4.4.4,  , 4.4.3, 4.4

@ref{4.4.2} described how the query system works. Now we fill in the
details by presenting a complete implementation of the system.

@menu
* 4-4-4-1::          The Driver Loop and Instantiation
* 4-4-4-2::          The Evaluator
* 4-4-4-3::          Finding Assertions by Pattern Matching
* 4-4-4-4::          Rules and Unification
* 4-4-4-5::          Maintaining the Data Base
* 4-4-4-6::          Stream Operations
* 4-4-4-7::          Query Syntax Procedures
* 4-4-4-8::          Frames and Bindings
@end menu

@subsubsection The Driver Loop and Instantiation
@node 4.4.4.1, 4.4.4.2, 4.4.4, 4.4.4

The driver loop for the query system repeatedly reads input expressions.  If
the expression is a rule or assertion to be added to the data base, then the
information is added.  Otherwise the expression is assumed to be a query.  The
driver passes this query to the evaluator @code{qeval} together with an initial
frame stream consisting of a single empty frame.  The result of the evaluation
is a stream of frames generated by satisfying the query with variable values
found in the data base.  These frames are used to form a new stream consisting
of copies of the original query in which the variables are instantiated with
values supplied by the stream of frames, and this final stream is printed at
the terminal:

@lisp
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
@end lisp

@noindent
Here, as in the other evaluators in this chapter, we use an abstract syntax for
the expressions of the query language.  The implementation of the expression
syntax, including the predicate @code{assertion-to-be-added?} and the selector
@code{add-assertion-body}, is given in @ref{4.4.4.7}.
@code{add-rule-or-assertion!} is defined in @ref{4.4.4.5}.

Before doing any processing on an input expression, the driver loop transforms
it syntactically into a form that makes the processing more efficient.  This
involves changing the representation of pattern variables.  When the query is
instantiated, any variables that remain unbound are transformed back to the
input representation before being printed.  These transformations are performed
by the two procedures @code{query-syntax-process} and
@code{contract-question-mark} (@ref{4.4.4.7}).

To instantiate an expression, we copy it, replacing any variables in the
expression by their values in a given frame.  The values are themselves
instantiated, since they could contain variables (for example, if @code{?x} in
@code{exp} is bound to @code{?y} as the result of unification and @code{?y} is
in turn bound to 5).  The action to take if a variable cannot be instantiated
is given by a procedural argument to @code{instantiate}.

@lisp
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
@end lisp

@noindent
The procedures that manipulate bindings are defined in @ref{4.4.4.8}.

@subsubsection The Evaluator
@node 4.4.4.2, 4.4.4.3, 4.4.4.1, 4.4.4

The @code{qeval} procedure, called by the @code{query-driver-loop}, is the
basic evaluator of the query system.  It takes as inputs a query and a stream
of frames, and it returns a stream of extended frames.  It identifies special
forms by a data-directed dispatch using @code{get} and @code{put}, just as we
did in implementing generic operations in @ref{Глава 2}.  Any query that is
not identified as a special form is assumed to be a simple query, to be
processed by @code{simple-query}.

@lisp
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
@end lisp

@noindent
@code{type} and @code{contents}, defined in @ref{4.4.4.7}, implement
the abstract syntax of the special forms.

@comment @subsubheading Simple queries

The @code{simple-query} procedure handles simple queries.  It takes as
arguments a simple query (a pattern) together with a stream of frames, and it
returns the stream formed by extending each frame by all data-base matches of
the query.

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
@end lisp

@noindent
For each frame in the input stream, we use @code{find-assertions}
(@ref{4.4.4.3}) to match the pattern against all assertions in the data base,
producing a stream of extended frames, and we use @code{apply-rules}
(@ref{4.4.4.4}) to apply all possible rules, producing another stream of
extended frames.  These two streams are combined (using
@code{stream-append-delayed}, @ref{4.4.4.6}) to make a stream of all
the ways that the given pattern can be satisfied consistent with the original
frame (see @ref{Уπражнение 4.71}).  The streams for the individual input frames
are combined using @code{stream-flatmap} (@ref{4.4.4.6}) to form one
large stream of all the ways that any of the frames in the original input
stream can be extended to produce a match with the given pattern.

@comment @subsubheading Compound queries

@code{and} queries are handled as illustrated in @ref{Рисунок 4.5} by the
@code{conjoin} procedure.  @code{conjoin} takes as inputs the conjuncts and the
frame stream and returns the stream of extended frames.  First, @code{conjoin}
processes the stream of frames to find the stream of all possible frame
extensions that satisfy the first query in the conjunction.  Then, using this
as the new frame stream, it recursively applies @code{conjoin} to the rest of
the queries.

@lisp
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts) frame-stream))))
@end lisp

@noindent
The expression

@lisp
(put 'and 'qeval conjoin)
@end lisp

@noindent
sets up @code{qeval} to dispatch to @code{conjoin} when an @code{and} form is
encountered.

@code{or} queries are handled similarly, as shown in @ref{Рисунок 4.6}.  The
output streams for the various disjuncts of the @code{or} are computed
separately and merged using the @code{interleave-delayed} procedure from
@ref{4.4.4.6}.  (See @ref{Уπражнение 4.71} and @ref{Уπражнение 4.72}.)

@lisp
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
(put 'or 'qeval disjoin)
@end lisp

@noindent
The predicates and selectors for the syntax of conjuncts and disjuncts are
given in @ref{4.4.4.7}.

@comment @subsubheading Filters

@code{not} is handled by the method outlined in @ref{4.4.2}.  We
attempt to extend each frame in the input stream to satisfy the query being
negated, and we include a given frame in the output stream only if it cannot be
extended.

@lisp
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null?
          (qeval (negated-query operands)
                 (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
@end lisp

@noindent
@code{lisp-value} is a filter similar to @code{not}.  Each frame in the stream
is used to instantiate the variables in the pattern, the indicated predicate is
applied, and the frames for which the predicate returns false are filtered out
of the input stream.  An error results if there are unbound pattern variables.

@lisp
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var: LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
@end lisp

@noindent
@code{execute}, which applies the predicate to the arguments, must @code{eval}
the predicate expression to get the procedure to apply.  However, it must not
evaluate the arguments, since they are already the actual arguments, not
expressions whose evaluation (in Lisp) will produce the arguments.  Note that
@code{execute} is implemented using @code{eval} and @code{apply} from the
underlying Lisp system.

@lisp
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
@end lisp

@noindent
The @code{always-true} special form provides for a query that is always
satisfied.  It ignores its contents (normally empty) and simply passes through
all the frames in the input stream.  @code{always-true} is used by the
@code{rule-body} selector (@ref{4.4.4.7}) to provide bodies for rules
that were defined without bodies (that is, rules whose conclusions are always
satisfied).

@lisp
(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
@end lisp

@noindent
The selectors that define the syntax of @code{not} and @code{lisp-value} are
given in @ref{4.4.4.7}.

@subsubsection Finding Assertions@* by Pattern Matching
@node 4.4.4.3, 4.4.4.4, 4.4.4.2, 4.4.4

@code{find-assertions}, called by @code{simple-query} (@ref{4.4.4.2}),
takes as input a pattern and a frame.  It returns a stream of frames, each
extending the given one by a data-base match of the given pattern.  It uses
@code{fetch-@/assertions} (@ref{4.4.4.5}) to get a stream of all the
assertions in the data base that should be checked for a match against the
pattern and the frame.  The reason for @code{fetch-assertions} here is that we
can often apply simple tests that will eliminate many of the entries in the
data base from the pool of candidates for a successful match.  The system would
still work if we eliminated @code{fetch-assertions} and simply checked a stream
of all assertions in the data base, but the computation would be less efficient
because we would need to make many more calls to the matcher.

@lisp
(define (find-assertions pattern frame)
  (stream-flatmap
   (lambda (datum) (check-an-assertion datum pattern frame))
   (fetch-assertions pattern frame)))
@end lisp

@noindent
@code{check-an-assertion} takes as arguments a pattern, a data object
(assertion), and a frame and returns either a one-element stream containing the
extended frame or @code{the-empty-stream} if the match fails.

@lisp
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
@end lisp

@noindent
The basic pattern matcher returns either the symbol @code{failed} or an
extension of the given frame.  The basic idea of the matcher is to check the
pattern against the data, element by element, accumulating bindings for the
pattern variables.  If the pattern and the data object are the same, the match
succeeds and we return the frame of bindings accumulated so far.  Otherwise, if
the pattern is a variable we extend the current frame by binding the variable
to the data, so long as this is consistent with the bindings already in the
frame.  If the pattern and the data are both pairs, we (recursively) match the
@code{car} of the pattern against the @code{car} of the data to produce a
frame; in this frame we then match the @code{cdr} of the pattern against the
@code{cdr} of the data.  If none of these cases are applicable, the match fails
and we return the symbol @code{failed}.

@lisp
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match
          (cdr pat)
          (cdr dat)
          (pattern-match (car pat) (car dat) frame)))
        (else 'failed)))
@end lisp

@noindent
Here is the procedure that extends a frame by adding a new binding, if this is
consistent with the bindings already in the frame:

@lisp
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
@end lisp

@noindent
If there is no binding for the variable in the frame, we simply add the binding
of the variable to the data.  Otherwise we match, in the frame, the data
against the value of the variable in the frame.  If the stored value contains
only constants, as it must if it was stored during pattern matching by
@code{extend-if-consistent}, then the match simply tests whether the stored and
new values are the same.  If so, it returns the unmodified frame; if not, it
returns a failure indication.  The stored value may, however, contain pattern
variables if it was stored during unification (see @ref{4.4.4.4}).  The
recursive match of the stored pattern against the new data will add or check
bindings for the variables in this pattern.  For example, suppose we have a
frame in which @code{?x} is bound to @code{(f ?y)} and @code{?y} is unbound,
and we wish to augment this frame by a binding of @code{?x} to @code{(f b)}.
We look up @code{?x} and find that it is bound to @code{(f ?y)}.  This leads us
to match @code{(f ?y)} against the proposed new value @code{(f b)} in the same
frame.  Eventually this match extends the frame by adding a binding of
@code{?y} to @code{b}.  @code{?X} remains bound to @code{(f ?y)}.  We never
modify a stored binding and we never store more than one binding for a given
variable.

The procedures used by @code{extend-if-consistent} to manipulate bindings are
defined in @ref{4.4.4.8}.

@comment @subsubheading Patterns with dotted tails

If a pattern contains a dot followed by a pattern variable, the pattern
variable matches the rest of the data list (rather than the next element of the
data list), just as one would expect with the dotted-tail notation described in
@ref{Уπражнение 2.20}.  Although the pattern matcher we have just implemented
doesn't look for dots, it does behave as we want.  This is because the Lisp
@code{read} primitive, which is used by @code{query-driver-loop} to read the
query and represent it as a list structure, treats dots in a special way.

When @code{read} sees a dot, instead of making the next item be the next
element of a list (the @code{car} of a @code{cons} whose @code{cdr} will be the
rest of the list) it makes the next item be the @code{cdr} of the list
structure.  For example, the list structure produced by @code{read} for the
pattern @code{(computer ?type)} could be constructed by evaluating the
expression @code{(cons 'computer (cons '?type '()))}, and that for
@code{(computer . ?type)} could be constructed by evaluating the expression
@code{(cons 'computer '?type)}.

Thus, as @code{pattern-match} recursively compares @code{car}s and @code{cdr}s
of a data list and a pattern that had a dot, it eventually matches the variable
after the dot (which is a @code{cdr} of the pattern) against a sublist of the
data list, binding the variable to that list.  For example, matching the
pattern @code{(computer . ?type)} against @code{(computer programmer trainee)}
will match @code{?type} against the list @code{(programmer trainee)}.

@subsubsection Rules and Unification
@node 4.4.4.4, 4.4.4.5, 4.4.4.3, 4.4.4

@code{apply-rules} is the rule analog of @code{find-assertions}
(@ref{Section 4.4.4.3}).  It takes as input a pattern and a frame, and it forms a stream
of extension frames by applying rules from the data base.
@code{stream-flatmap} maps @code{apply-a-rule} down the stream of possibly
applicable rules (selected by @code{fetch-rules}, @ref{Section 4.4.4.5}) and
combines the resulting streams of frames.

@lisp
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
@end lisp

@noindent
@code{apply-a-rule} applies rules using the method outlined in
@ref{4.4.2}.  It first augments its argument frame by unifying the rule
conclusion with the pattern in the given frame.  If this succeeds, it evaluates
the rule body in this new frame.

Before any of this happens, however, the program renames all the variables in
the rule with unique new names.  The reason for this is to prevent the
variables for different rule applications from becoming confused with each
other.  For instance, if two rules both use a variable named @code{?x}, then
each one may add a binding for @code{?x} to the frame when it is applied.
These two @code{?x}'s have nothing to do with each other, and we should not be
fooled into thinking that the two bindings must be consistent.  Rather than
rename variables, we could devise a more clever environment structure; however,
the renaming approach we have chosen here is the most straightforward, even if
not the most efficient.  (See @ref{Уπражнение 4.79}.)  Here is the
@code{apply-a-rule} procedure:

@lisp
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result (unify-match query-pattern
                                     (conclusion clean-rule)
                                     query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
@end lisp

@noindent
The selectors @code{rule-body} and @code{conclusion} that extract parts of a
rule are defined in @ref{4.4.4.7}.

We generate unique variable names by associating a unique identifier (such as a
number) with each rule application and combining this identifier with the
original variable names.  For example, if the rule-application identifier is 7,
we might change each @code{?x} in the rule to @code{?x-7} and each @code{?y} in
the rule to @code{?y-7}.  (@code{make-new-variable} and
@code{new-rule-application-id} are included with the syntax procedures in
@ref{4.4.4.7}.)

@lisp
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
@end lisp

@noindent
The unification algorithm is implemented as a procedure that takes as inputs
two patterns and a frame and returns either the extended frame or the symbol
@code{failed}.  The unifier is like the pattern matcher except that it is
symmetrical---variables are allowed on both sides of the match.
@code{unify-match} is basically the same as @code{pattern-match}, except that
there is extra code (marked ``@code{***}'' below) to handle the case where the
object on the right side of the match is a variable.

@lisp
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  @r{; ***}
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
@end lisp

@noindent
In unification, as in one-sided pattern matching, we want to accept a proposed
extension of the frame only if it is consistent with existing bindings.  The
procedure @code{extend-if-possible} used in unification is the same as the
@code{extend-if-consistent} used in pattern matching except for two special
checks, marked ``@code{***}'' in the program below.  In the first case, if the
variable we are trying to match is not bound, but the value we are trying to
match it with is itself a (different) variable, it is necessary to check to see
if the value is bound, and if so, to match its value.  If both parties to the
match are unbound, we may bind either to the other.

The second check deals with attempts to bind a variable to a pattern that
includes that variable.  Such a situation can occur whenever a variable is
repeated in both patterns.  Consider, for example, unifying the two patterns
@code{(?x ?x)} and @code{(?y @math{\langle}@var{expression involving @code{?y}}@math{\rangle})} in a
frame where both @code{?x} and @code{?y} are unbound.  First @code{?x} is
matched against @code{?y}, making a binding of @code{?x} to @code{?y}.  Next,
the same @code{?x} is matched against the given expression involving @code{?y}.
Since @code{?x} is already bound to @code{?y}, this results in matching
@code{?y} against the expression.  If we think of the unifier as finding a set
of values for the pattern variables that make the patterns the same, then these
patterns imply instructions to find a @code{?y} such that @code{?y} is equal to
the expression involving @code{?y}.  There is no general method for solving
such equations, so we reject such bindings; these cases are recognized by the
predicate @code{depends-on?}.@footnote{In general, unifying @code{?y} with an
expression involving @code{?y} would require our being able to find a fixed
point of the equation @code{?y} = @math{\langle}@var{expression involving @code{?y}}@math{\rangle}.  It
is sometimes possible to syntactically form an expression that appears to be
the solution.  For example, @code{?y} = @code{(f ?y)} seems to have the fixed
point @code{(f (f (f @dots{} )))}, which we can produce by beginning with the
expression @code{(f ?y)} and repeatedly substituting @code{(f ?y)} for
@code{?y}.  Unfortunately, not every such equation has a meaningful fixed
point.  The issues that arise here are similar to the issues of manipulating
infinite series in mathematics.  For example, we know that 2 is the solution to
the equation @math{y = 1 + y / 2}.  Beginning with the expression @math{1 + y / 2}
and repeatedly substituting @math{1 + y / 2} for @math{y} gives
@ifinfo

@example
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ...
@end example

@end ifinfo
@tex
$$ 2 = y = 1 + {y \over 2} = 1 + {1\over2}\left(1 + {y \over 2}\right) =
	1 + {1\over2} + {y \over 4} = \dots , $$
@end tex
@noindent
which leads to
@ifinfo

@example
2 = 1 + 1/2 + 1/4 + 1/8 + ...
@end example

@end ifinfo
@tex
$$ 2 = 1 + {1\over2} + {1\over4} + {1\over8} + \dots. $$
@end tex
@noindent
However, if we try the same manipulation beginning with the observation that -1
is the solution to the equation @math{y = 1 + 2y}, we obtain
@ifinfo

@example
-1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ...
@end example

@end ifinfo
@tex
$$ -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \dots, $$
@end tex
@noindent
which leads to
@ifinfo

@example
-1 = 1 + 2 + 4 + 8 + ...
@end example

@end ifinfo
@tex
$$ -1 = 1 + 2 + 4 + 8 + \dots. $$
@end tex
@noindent
Although the formal manipulations used in deriving these two equations are
identical, the first result is a valid assertion about infinite series but the
second is not.  Similarly, for our unification results, reasoning with an
arbitrary syntactically constructed expression may lead to errors.}  On the
other hand, we do not want to reject attempts to bind a variable to itself.
For example, consider unifying @code{(?x ?x)} and @code{(?y ?y)}.  The second
attempt to bind @code{?x} to @code{?y} matches @code{?y} (the stored value of
@code{?x}) against @code{?y} (the new value of @code{?x}).  This is taken care
of by the @code{equal?}  clause of @code{unify-match}.

@lisp
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match (binding-value binding) val frame))
          ((var? val)                      @r{; ***}
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     @r{; ***}
           'failed)
          (else (extend var val frame)))))
@end lisp

@noindent
@code{depends-on?} is a predicate that tests whether an expression proposed to
be the value of a pattern variable depends on the variable.  This must be done
relative to the current frame because the expression may contain occurrences of
a variable that already has a value that depends on our test variable.  The
structure of @code{depends-on?} is a simple recursive tree walk in which we
substitute for the values of variables whenever necessary.

@lisp
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
@end lisp

@subsubsection Maintaining the Data Base
@node 4.4.4.5, 4.4.4.6, 4.4.4.4, 4.4.4

One important problem in designing logic programming languages is that of
arranging things so that as few irrelevant data-base entries as possible will
be examined in checking a given pattern.  In our system, in addition to storing
all assertions in one big stream, we store all assertions whose @code{car}s are
constant symbols in separate streams, in a table indexed by the symbol.  To
fetch an assertion that may match a pattern, we first check to see if the
@code{car} of the pattern is a constant symbol.  If so, we return (to be tested
using the matcher) all the stored assertions that have the same @code{car}.  If
the pattern's @code{car} is not a constant symbol, we return all the stored
assertions.  Cleverer methods could also take advantage of information in the
frame, or try also to optimize the case where the @code{car} of the pattern is
not a constant symbol.  We avoid building our criteria for indexing (using the
@code{car}, handling only the case of constant symbols) into the program;
instead we call on predicates and selectors that embody our criteria.

@lisp
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
@end lisp

@noindent
@code{get-stream} looks up a stream in the table and returns an empty stream if
nothing is stored there.

@lisp
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
@end lisp

@noindent
Rules are stored similarly, using the @code{car} of the rule conclusion.  Rule
conclusions are arbitrary patterns, however, so they differ from assertions in
that they can contain variables.  A pattern whose @code{car} is a constant
symbol can match rules whose conclusions start with a variable as well as rules
whose conclusions have the same @code{car}.  Thus, when fetching rules that
might match a pattern whose @code{car} is a constant symbol we fetch all rules
whose conclusions start with a variable as well as those whose conclusions have
the same @code{car} as the pattern.  For this purpose we store all rules whose
conclusions start with a variable in a separate stream in our table, indexed by
the symbol @code{?}.

@lisp
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
@end lisp

@noindent
@code{add-rule-or-assertion!} is used by @code{query-driver-loop} to add
assertions and rules to the data base.  Each item is stored in the index, if
appropriate, and in a stream of all assertions or rules in the data base.

@lisp
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
@end lisp

@noindent
To actually store an assertion or a rule, we check to see if it can be indexed.
If so, we store it in the appropriate stream.

@lisp
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream
                assertion
                current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
@end lisp

@noindent
The following procedures define how the data-base index is used.  A pattern (an
assertion or a rule conclusion) will be stored in the table if it starts with a
variable or a constant symbol.

@lisp
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
@end lisp

@noindent
The key under which a pattern is stored in the table is either @code{?} (if it
starts with a variable) or the constant symbol with which it starts.

@lisp
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
@end lisp

@noindent
The index will be used to retrieve items that might match a pattern if the
pattern starts with a constant symbol.

@lisp
(define (use-index? pat) (constant-symbol? (car pat)))
@end lisp

@quotation
@strong{@anchor{Уπражнение 4.70}Уπражнение 4.70:}
What is the purpose of the
@code{let} bindings in the procedures @code{add-assertion!} and
@code{add-rule!} ?  What would be wrong with the following implementation of
@code{add-assertion!} ?  Hint: Recall the definition of the infinite stream of
ones in @ref{3.5.2}: @code{(define ones (cons-stream 1 ones))}.

@lisp
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
@end lisp
@end quotation

@subsubsection Stream Operations
@node 4.4.4.6, 4.4.4.7, 4.4.4.5, 4.4.4

The query system uses a few stream operations that were not presented in
@ref{Глава 3}.

@code{stream-append-delayed} and @code{interleave-delayed} are just like
@code{stream-@/append} and @code{interleave} (@ref{3.5.3}), except that
they take a delayed argument (like the @code{integral} procedure in
@ref{3.5.4}).  This postpones looping in some cases (see @ref{Уπражнение 4.71}).

@lisp
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed
        (stream-cdr s1)
        delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed
        (force delayed-s2)
        (delay (stream-cdr s1))))))
@end lisp

@noindent
@code{stream-flatmap}, which is used throughout the query evaluator to map a
procedure over a stream of frames and combine the resulting streams of frames,
is the stream analog of the @code{flatmap} procedure introduced for ordinary
lists in @ref{2.2.3}.  Unlike ordinary @code{flatmap}, however, we
accumulate the streams with an interleaving process, rather than simply
appending them (see @ref{Уπражнение 4.72} and @ref{Уπражнение 4.73}).

@lisp
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
@end lisp

@noindent
The evaluator also uses the following simple procedure to generate a stream
consisting of a single element:

@lisp
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
@end lisp

@subsubsection Query Syntax Procedures
@node 4.4.4.7, 4.4.4.8, 4.4.4.6, 4.4.4

@code{type} and @code{contents}, used by @code{qeval} (@ref{4.4.4.2}),
specify that a special form is identified by the symbol in its @code{car}.
They are the same as the @code{type-tag} and @code{contents} procedures in
@ref{2.4.2}, except for the error message.

@lisp
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
@end lisp

@noindent
The following procedures, used by @code{query-driver-loop} (in
@ref{4.4.4.1}), specify that rules and assertions are added to the data base by
expressions of the form @code{(assert! @math{\langle}@var{rule-or-assertion}@math{\rangle})}:

@lisp
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp) (car (contents exp)))
@end lisp

@noindent
Here are the syntax definitions for the @code{and}, @code{or}, @code{not}, and
@code{lisp-value} special forms (@ref{4.4.4.2}):

@lisp
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
@end lisp

@noindent
The following three procedures define the syntax of rules:

@lisp
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule)) '(always-true) (caddr rule)))
@end lisp

@noindent
@code{query-driver-loop} (@ref{4.4.4.1}) calls
@code{query-syntax-process} to transform pattern variables in the expression,
which have the form @code{?symbol}, into the internal format @code{(? symbol)}.
That is to say, a pattern such as @code{(job ?x ?y)} is actually represented
internally by the system as @code{(job (? x) (? y))}.  This increases the
efficiency of query processing, since it means that the system can check to see
if an expression is a pattern variable by checking whether the @code{car} of
the expression is the symbol @code{?}, rather than having to extract characters
from the symbol.  The syntax transformation is accomplished by the following
procedure:@footnote{Most Lisp systems give the user the ability to modify the
ordinary @code{read} procedure to perform such transformations by defining
@newterm{reader macro characters}.  Quoted expressions are already handled in
this way: The reader automatically translates @code{'expression} into
@code{(quote expression)} before the evaluator sees it.  We could arrange for
@code{?expression} to be transformed into @code{(? expression)} in the same
way; however, for the sake of clarity we have included the transformation
procedure here explicitly.

@code{expand-question-mark} and @code{contract-question-mark} use several
procedures with @code{string} in their names.  These are Scheme primitives.}

@lisp
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
@end lisp

@noindent
Once the variables are transformed in this way, the variables in a pattern are
lists starting with @code{?}, and the constant symbols (which need to be
recognized for data-base indexing, @ref{4.4.4.5}) are just the symbols.

@lisp
(define (var? exp) (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
@end lisp

@noindent
Unique variables are constructed during rule application (in
@ref{Section 4.4.4.4}) by means of the following procedures.
The unique identifier for
a rule application is a number, which is incremented each time a rule is
applied.

@lisp
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
@end lisp

@noindent
When @code{query-driver-loop} instantiates the query to print the answer, it
converts any unbound pattern variables back to the right form for printing,
using

@lisp
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?"
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
@end lisp

@subsubsection Frames and Bindings
@node 4.4.4.8,  , 4.4.4.7, 4.4.4

Frames are represented as lists of bindings, which are variable-value pairs:

@lisp
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding) (car binding))
(define (binding-value binding) (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
@end lisp

@quotation
@strong{@anchor{Уπражнение 4.71}Уπражнение 4.71:}
Louis Reasoner wonders why the
@code{simple-query} and @code{disjoin} procedures (@ref{4.4.4.2}) are
implemented using explicit @code{delay} operations, rather than being defined
as follows:

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append
      (find-assertions query-pattern frame)
      (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts)
              frame-stream)
       (disjoin (rest-disjuncts disjuncts)
                frame-stream))))
@end lisp

Can you give examples of queries where these simpler definitions would lead to
undesirable behavior?
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.72}Уπражнение 4.72:}
Why do @code{disjoin} and
@code{stream-flatmap} interleave the streams rather than simply append them?
Give examples that illustrate why interleaving works better.  (Hint: Why did we
use @code{interleave} in @ref{3.5.3}?)
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.73}Уπражнение 4.73:}
Why does @code{flatten-stream}
use @code{delay} explicitly?  What would be wrong with defining it as follows:

@lisp
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.74}Уπражнение 4.74:}
Alyssa P. Hacker proposes to use
a simpler version of @code{stream-flatmap} in @code{negate}, @code{lisp-value},
and @code{find-assertions}.  She observes that the procedure that is mapped
over the frame stream in these cases always produces either the empty stream or
a singleton stream, so no interleaving is needed when combining these streams.

@enumerate a.

@item
Fill in the missing expressions in Alyssa's program.

@lisp
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))
(define (simple-flatten stream)
  (stream-map @math{\langle}??@math{\rangle}
              (stream-filter @math{\langle}??@math{\rangle} stream)))
@end lisp

@item
Does the query system's behavior change if we change it in this way?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.75}Уπражнение 4.75:}
Implement for the query language
a new special form called @code{unique}.  @code{unique} should succeed if there
is precisely one item in the data base satisfying a specified query.  For
example,

@lisp
(unique (job ?x (computer wizard)))
@end lisp

@noindent
should print the one-item stream

@lisp
(unique (job (Bitdiddle Ben) (computer wizard)))
@end lisp

@noindent
since Ben is the only computer wizard, and

@lisp
(unique (job ?x (computer programmer)))
@end lisp

@noindent
should print the empty stream, since there is more than one computer
programmer.  Moreover,

@lisp
(and (job ?x ?j) (unique (job ?anyone ?j)))
@end lisp

@noindent
should list all the jobs that are filled by only one person, and the people who
fill them.

There are two parts to implementing @code{unique}.  The first is to write a
procedure that handles this special form, and the second is to make
@code{qeval} dispatch to that procedure.  The second part is trivial, since
@code{qeval} does its dispatching in a data-directed way.  If your procedure is
called @code{uniquely-asserted}, all you need to do is

@lisp
(put 'unique 'qeval uniquely-asserted)
@end lisp

@noindent
and @code{qeval} will dispatch to this procedure for every query whose
@code{type} (@code{car}) is the symbol @code{unique}.

The real problem is to write the procedure @code{uniquely-asserted}.  This
should take as input the @code{contents} (@code{cdr}) of the @code{unique}
query, together with a stream of frames.  For each frame in the stream, it
should use @code{qeval} to find the stream of all extensions to the frame that
satisfy the given query.  Any stream that does not have exactly one item in it
should be eliminated.  The remaining streams should be passed back to be
accumulated into one big stream that is the result of the @code{unique} query.
This is similar to the implementation of the @code{not} special form.

Test your implementation by forming a query that lists all people who supervise
precisely one person.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.76}Уπражнение 4.76:}
Our implementation of @code{and}
as a series combination of queries (@ref{Рисунок 4.5}) is elegant, but it is
inefficient because in processing the second query of the @code{and} we must
scan the data base for each frame produced by the first query.  If the data
base has @math{n} elements, and a typical query produces a number of output frames
proportional to @math{n} (say @math{n / k}), then scanning the data base for each
frame produced by the first query will require @math{n^2 / k} calls to the
pattern matcher.  Another approach would be to process the two clauses of the
@code{and} separately, then look for all pairs of output frames that are
compatible.  If each query produces @math{n / k} output frames, then this means
that we must perform @math{n^2 / k^2} compatibility checks---a factor of @math{k}
fewer than the number of matches required in our current method.

Devise an implementation of @code{and} that uses this strategy.  You must
implement a procedure that takes two frames as inputs, checks whether the
bindings in the frames are compatible, and, if so, produces a frame that merges
the two sets of bindings.  This operation is similar to unification.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.77}Уπражнение 4.77:}
In @ref{4.4.3} we saw
that @code{not} and @code{lisp-value} can cause the query language to give
``wrong'' answers if these filtering operations are applied to frames in which
variables are unbound.  Devise a way to fix this shortcoming.  One idea is to
perform the filtering in a ``delayed'' manner by appending to the frame a
``promise'' to filter that is fulfilled only when enough variables have been
bound to make the operation possible.  We could wait to perform filtering until
all other operations have been performed.  However, for efficiency's sake, we
would like to perform filtering as soon as possible so as to cut down on the
number of intermediate frames generated.
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.78}Уπражнение 4.78:}
Redesign the query language as a
nondeterministic program to be implemented using the evaluator of
@ref{4.3}, rather than as a stream process.  In this approach, each query will
produce a single answer (rather than the stream of all answers) and the user
can type @code{try-again} to see more answers.  You should find that much of
the mechanism we built in this section is subsumed by nondeterministic search
and backtracking.  You will probably also find, however, that your new query
language has subtle differences in behavior from the one implemented here.  Can
you find examples that illustrate this difference?
@end quotation

@quotation
@strong{@anchor{Уπражнение 4.79}Уπражнение 4.79:}
When we implemented the Lisp
evaluator in @ref{4.1}, we saw how to use local environments to avoid
name conflicts between the parameters of procedures.  For example, in
evaluating

@lisp
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
@end lisp

@noindent
there is no confusion between the @code{x} in @code{square} and the @code{x} in
@code{sum-@/of-@/squares}, because we evaluate the body of each procedure in an
environment that is specially constructed to contain bindings for the local
variables.  In the query system, we used a different strategy to avoid name
conflicts in applying rules.  Each time we apply a rule we rename the variables
with new names that are guaranteed to be unique.  The analogous strategy for
the Lisp evaluator would be to do away with local environments and simply
rename the variables in the body of a procedure each time we apply the
procedure.

Implement for the query language a rule-application method that uses
environments rather than renaming.  See if you can build on your environment
structure to create constructs in the query language for dealing with large
systems, such as the rule analog of block-structured procedures.  Can you
relate any of this to the problem of making deductions in a context (e.g., ``If
I supposed that @math{P} were true, then I would be able to deduce @math{A} and
@math{B}.'') as a method of problem solving?  (This problem is open-ended.  A good
answer is probably worth a Ph.D.)
@end quotation

