@comment @chapter Metalinguistic Abstraction
@chapter Метаязыковая абстракция
@node    Chapter 4, Chapter 5, Chapter 3, Top

@quotation
@dots{} Именно в словах кроется магия --- в таких, как <<абракадабра>>,
<<Сезам, откройся>> и проч., --- но магические слова из одной истории
перестают быть таковыми в следующей. Настоящая магия состоит в том,
чтобы понять, когда и для чего слово сработает; трюк в том, чтобы
выучить трюк.

@dots{} А слова эти состоят из букв нашего алфавита: пара дюжин
закорючек, которые мы способны черкнуть пером. Вот где ключ @dots{}! И
сокровище тоже, если только мы сумеем его заполучить! Как
будто @dots{} как будто ключ к сокровищу и @emph{есть} само сокровище!

---John Barth, @cite{Chimera} (Перевод Виктора Лапицкого)
@end quotation

@c @sp 0.8

@noindent
\lettrine{И}{сследуя науку проектирования программ}, мы видели, что
программисты-эксперты управляют сложностью своих программ при помощи тех
же общих методик, какими пользуются проектировщики всех сложных систем.
Они сочетают элементарные единицы, получая при этом составные объекты, с
помощью абстракции составных объектов формируют строительные блоки
высших порядков, и при этом с целью сохранения модульности выбирают
наиболее удобный общий взгляд на структуру системы. Демонстрируя эти
методы, мы использовали Лисп как язык для описания процессов и для
построения вычислительных объектов данных, и процессы --- для
моделирования сложных явлений реального мира. Однако по мере того, как
мы сталкиваемся со все более сложными задачами, мы обнаруживаем, что
Лиспа, да и любого заранее заданного языка программирования,
недостаточно для наших нужд. Чтобы эффективнее выражать свои мысли,
постоянно приходится обращаться к новым языкам. Построение новых языков
является мощной стратегией управления сложностью в инженерном
проектировании; часто оказывается, что можно расширить свои возможности
работы над сложной задачей, приняв новый язык, позволяющий нам описывать
(а следовательно, и обдумывать) задачу новым способом, используя
элементы, методы их сочетания и механизмы абстракции, специально
подогнанные под стоящие перед нами проблемы.@footnote{Та же самая идея
встречается во всех областях техники. Например, у
инженеров-электронщиков существует множество языков для описания схем.
Два из них --- это язык электрических @emph{сетей} и язык электрических
@emph{систем}. Язык сетей делает акцент на физическом моделировании
устройств в терминах дискретных электрических элементов. Элементарными
объектами этого языка являются элементарные электрические
компоненты --- резисторы, конденсаторы, катушки индуктивности и
транзисторы, задаваемые через физические переменные: напряжение и ток.
Описывая схемы на языке сетей, инженер озабочен физическими
характеристиками своего проекта. Элементами системного языка, напротив,
являются модули обработки сигнала, например, фильтры и усилители.
Существенно только функциональное поведение модулей, и сигналами
манипулируют безотносительно к тому, в виде какого напряжения или тока
они реализуются физически. Язык систем построен на языке сетей, в том
смысле, что элементы систем обработки сигнала состоят из электрических
схем. Однако здесь инженера интересует крупномасштабная организация
электрических устройств, решающая определенную задачу; их физическая
совместимость подразумевается. Такая послойная организация языков служит
еще одним примером уровневого метода проектирования,
проиллюстрированного в @ref{2.2.4} на примере языка описания изображений.}

Программирование изобилует языками. Есть физические языки, например,
языки машинных кодов для конкретных компьютеров. Основным вопросом для
них является представление данных и управления через отдельные биты
памяти и машинные команды. Пишущий программы на машинном языке озабочен
тем, чтобы при помощи данной аппаратуры создать системы и инструменты
для эффективной реализации вычисления при ограниченных ресурсах. Языки
высокого уровня, возводимые поверх машинных, скрывают вопросы конкретной
реализации данных в виде набора битов и представления программ как
последовательности машинных команд. В этих языках присутствуют средства
комбинации и абстракции, например определения функций, которые подходят
для более крупномасштабной организации систем.

(@newterm{metalinguistic abstraction}), то есть построение новых языков, играет
важную роль во всех отраслях инженерного проектирования. Для
компьютерного программирования она особенно важна, поскольку в
программировании мы можем не только формулировать новые языки, но и
реализовывать их через построение вычислителей. (@newterm{evaluator}) (или
(@newterm{interpreter)}) для языка программирования --- это процедура, которая,
будучи примененной к выражению языка, производит действия, необходимые
для вычисления этого выражения.

Без преувеличения можно сказать, что самая основополагающая идея в
программировании такова:

@quotation
Вычислитель, который определяет значение выражений в языке
программирования --- всего лишь обычная программа.
@end quotation

@noindent
С этой мыслью приходит и новое представление о себе самих: мы начинаем
видеть в себе разработчиков языков, а не просто пользователей языков,
придуманных другими.

На самом деле, почти любую программу можно рассматривать как вычислитель
для какого-то языка. Например, система работы с многочленами из @ref{2.5.3}
заключает в себе правила арифметики многочленов и реализует их в
терминах операций над данными в списочной форме. Если мы дополним эту
систему процедурами для чтения и печати многочленов, то перед нами
окажется ядро специализированного языка для решения задач символьной
математики. И программа моделирования цифровой логики из @ref{3.3.4},
и программа распространения ограничений из @ref{3.3.5}
содержат свои собственные языки, со своими примитивами, средствами их
комбинирования и абстракции. С этой точки зрения, техника работы с
крупномасштабными компьютерными системами сливается с техникой создания
новых компьютерных языков, и вся информатика --- не более (но и не
менее), чем наука о построении подходящих языков описания.

Сейчас мы начинаем обзор методов, которые позволяют создавать одни языки
на основе других. В этой главе в качестве основы мы будем использовать
Лисп, и вычислители будем реализовывать как процедуры на Лиспе. Лисп
особенно хорошо подходит для этой задачи благодаря своей способности
представлять символические выражения и обрабатывать их. Первый шаг к
пониманию того, как реализуются языки, мы сделаем, построив вычислитель
для самого Лиспа. Язык, реализуемый нашим интерпретатором, будет
подмножеством диалекта Лиспа Scheme, которым мы пользуемся в этой книге.
Несмотря на то, что интерпретатор, описанный в этой главе, написан для
конкретного диалекта Лиспа, он содержит основную структуру вычислителя
для любого языка, ориентированного на выражения и предназначенного для
написания программ для последовательной машины. (На самом деле, глубоко
внутри большинства языковых процессоров содержится маленький
интерпретатор <<Лиспа>>.) Этот интерпретатор несколько упрощен для
удобства и наглядности обсуждения, и некоторые детали, которые важно
было бы включить в Лисп-систему промышленного качества, здесь были
оставлены за рамками изложения. Тем не менее, этот простой интерпретатор
способен выполнить большинство программ из данной книги.@footnote{Самое
важное, чего не хватает в нашем интерпретаторе, --- это механизмов,
обрабатывающих ошибки и поддерживающих отладку. Более подробное
обсуждение вычислителей можно найти в книге Friedman, Wand, and Haynes
1992, которая содержит обзор языков программирования на примере
последовательности интерпретаторов, написанных на Scheme.}

Важное преимущество, которое нам дает вычислитель, доступный в виде
программы на Лиспе, состоит в том, что мы можем реализовывать
альтернативные правила вычисления, описывая их как модификации программы
вычислителя. В частности, мы можем извлечь из этой способности немалую
выгоду, добиваясь более полного контроля над тем, как в вычислительных
моделях реализуется понятие времени. Этому вопросу была специально
посвящена @ref{Глава 3}.
Там мы смягчили некоторые сложности работы с состоянием и
присваиваниями, при помощи потоков отделив представление времени во
внешнем мире от времени внутри компьютера. Однако программы, работающие
с потоками, иногда бывали излишне громоздки, поскольку их ограничивал
аппликативный порядок вычисления, принятый в Scheme. В @ref{4.2} мы изменим
язык и получим более изящный подход в виде интерпретатора с
(@newterm{normal-order evaluation}).

В @ref{4.3}
язык меняется более радикально, и выражения получают не одно
единственное значение, а множество. В этом языке (@newterm{nondeterministic
computing}) становится естественным порождать все возможные значения
выражения, а затем искать среди них те, которые удовлетворяют
определенным ограничениям. Если описывать это в терминах вычисления и
времени, то время как будто разветвляется на множество <<возможных
будущих>>, и мы ищем среди них подходящие временные линии. При работе с
недетерминистским интерпретатором отслеживание множества значений и
поиск осуществляются автоматически встроенными механизмами языка.

В @ref{4.4} мы реализуем язык (@newterm{logic programming}), в котором знание
выражается в терминах отношений, а не в
терминах вычислений со входами и выходами. Несмотря на то, что язык при
этом оказывается сильно отличным от Лиспа, как, впрочем, и от любого
привычного языка, мы увидим, что интерпретатор для языка логического
программирования имеет, в сущности, ту же структуру, что и интерпретатор
Lisp.

@menu
* 4-1::              Метациклический интерπретатор
* 4-2::              Scheme с вариациями ленивый интерπретатор
* 4-3::              Scheme с вариациями --- недетерминистское вычисление
* 4-4::              Логическое πрограммирование
@end menu

@comment @section The Metacircular Evaluator
@section Метациклический интерпретатор
@node	4.1, 4.2, Chapter 4, Chapter 4

Наш интерпретатор Лиспа будет реализован как программа на Лиспе. Может
показаться, что размышления о выполнении Лисп-программ при помощи
интерпретатора, который сам написан на Лиспе, составляют порочный круг.
Однако вычисление есть процесс, так что вполне логично описывать процесс
вычисления с помощью Лиспа --- в конце концов, это наш инструмент для
описания процессов.@footnote{Даже с учетом этого, остаются важные стороны
процесса вычисления, которые в нашем интерпретаторе не проясняются.
Самая важная из них --- точные механизмы того, как одни процедуры
вызывают другие и возвращают значения процедурам, которые их вызвали.
Эти вопросы мы рассмотрим в @ref{Глава 5},
где мы исследуем процесс вычисления более внимательно, реализуя
вычислитель как простую регистровую машину.} Интерпретатор, написанный
на языке, который он сам реализует, называется (@newterm{metacircular}).

В сущности, метациклический интерпретатор является формулировкой на
языке Scheme модели вычислений с окружениями, описанной в @ref{3.2}.
Напомним, что в этой модели было две основные части:

@enumerate 1

@item
Чтобы выполнить комбинацию (составное выражение, не являющееся особой
формой), нужно вычислить его подвыражения и затем применить значение
подвыражения-оператора к значениям подвыражений-операндов.

@item
Чтобы применить составную процедуру к набору аргументов, нужно выполнить
тело процедуры в новом окружении. Для того, чтобы построить это
окружение, нужно расширить окружение объекта-процедуры кадром, в котором
формальные параметры процедуры связаны с аргументами, к которым
процедура применяется.

@end enumerate

@noindent
Эти два правила описывают сущность процесса вычисления, основной цикл, в
котором выражения, которые требуется выполнить в окружении, сводятся к
процедурам, которые нужно применить к аргументам, а те, в свою очередь,
сводятся к новым выражениям, которые нужно выполнить в новых окружениях,
и так далее, пока мы не доберемся до символов, чьи значения достаточно
найти в окружении, и элементарных процедур, которые применяются напрямую
(см. @ref{Рисунок 4.1}).@footnote{Если нам дается возможность
применять примитивы, то что остается сделать для реализации
интерпретатора? Задача интерпретатора состоит не в том, чтобы определить
примитивы языка, а в том, чтобы обеспечить связующие элементы ---
средства комбинирования и абстракции, --- которые превращают набор
примитивов в язык. А именно:

@math{\bullet} Интерпретатор позволяет работать с вложенными выражениями. Например,
чтобы вычислить значение выражения @code{(+ 1 6)}, достаточно применения
примитивов, но этого недостаточно для работы с выражением
@code{(+ 1 (* 2 3))}. Сама по себе элементарная процедура @code{+}
способна работать только с числами, и если передать ей аргумент ---
выражение @code{(* 2 3)}, она сломается. Одна из важных задач
интерпретатора --- устроить вычисление так, чтобы @code{(* 2 3)} свелось
к значению 6, прежде чем оно будет передано @code{+} как аргумент.

@math{\bullet} Интерпретатор позволяет использовать переменные. Например, элементарная
процедура сложения не знает, как работать с выражениями вроде
@code{(+ x 1)}. Нам нужен интерпретатор, чтобы следить за переменными и
получать их значения, прежде чем запускать элементарные процедуры.

@math{\bullet} Интерпретатор позволяет определять составные процедуры. При этом нужно
хранить определения процедур, знать, как эти определения используются
при вычислении выражений, и обеспечивать механизм, который позволяет
процедурам принимать аргументы.

@math{\bullet} Интерпретатор дает особые формы, вычисляющиеся иначе, чем вызовы
процедур.} Этот цикл вычисления будет построен в виде взаимодействия
двух основных процедур интерпретатора, @code{eval} и @code{apply},
описанных в @ref{4.1.1} (см. рис. @ref{Рисунок 4.1}).

Реализация интерпретатора будет зависеть от процедур, определяющих
(@newterm{syntax}) выполняемых выражений. При помощи абстракции данных мы сделаем
интерпретатор независимым от представления языка. К примеру, вместо
того, чтобы окончательно решать, что присваивание выражается в виде
списка, в котором первым элементом стоит символ @code{set!}, мы
пользуемся абстрактным предикатом @code{assignment?}, чтобы распознавать
присваивание, и абстрактными селекторами @code{assignment-variable} и
@code{assignment-value}, чтобы обращаться к его частям. Реализация
выражений будет подробно рассмотрена в @ref{4.1.2}. Имеются также операции,
описанные в @ref{4.1.3}, которые определяют представление процедур и окружений. Например,
@code{make-procedure} порождает составные процедуры,
@code{lookup-variable-value} извлекает значения переменных, а
@code{apply-primitive-procedure} применяет элементарную процедуру к
указанному списку аргументов.

@float
@c @quotation
@anchor{Рисунок 4.1}
@ifinfo
@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.

@example
                           .,ad88888888baa,
                  _    ,d8P"""        ""9888ba.      _
                 /  .a8"          ,ad88888888888a   |\
               /   aP'          ,88888888888888888a   \
              /  ,8"           ,88888888888888888888,  \
             |  ,8'            (888888888888888888888, |
            /  ,8'             `8888888888888888888888  \
            |  8)               `888888888888888888888, |
Procedure,  |  8                  "88888 Apply 8888888) | Expression
Arguments   |  8     Eval          `888888888888888888) | Environment
            |  8)                    "8888888888888888  |
            \  (b                     "88888888888888'  /
             | `8,                     8888888888888)  |
             \  "8a                   ,888888888888)  /
              \   V8,                 d88888888888"  /
              _\| `8b,             ,d8888888888P' _/
                     `V8a,       ,ad8888888888P'
                        ""88888888888888888P"
                             """"""""""""

                               [graphic by Normand Veillux, modified]
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.1,100mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 4.1:} The @code{eval}-@code{apply} cycle exposes the essence of a computer language.}
@sp 0.7
@end iftex
@c @end quotation
@end float

@menu
* 4-1-1::            Ядро интерπретатора
* 4-1-2::            Представление выражений
* 4-1-3::            Структуры данных интерπретатора
* 4-1-4::            Выπолнение интерπретатора как πрограммы
* 4-1-5::            Данные как πрограммы
* 4-1-6::            Внутренние оπределения
* 4-1-7::            Отделение синтаксического анализа от выπолнения
@end menu

@comment @subsection The Core of the Evaluator
@subsection Ядро интерпретатора
@node	4.1.1, 4.1.2, 4.1, 4.1

Процесс вычисления можно описать как взаимодействие двух процедур:
@code{eval} и @code{apply}.

@comment @subsubheading Eval
@subsubheading Eval

Процедура @code{eval} в качестве аргументов принимает выражение и
окружение. Она относит выражение к одному из возможных классов и
управляет его выполнением. @code{Eval} построена как разбор случаев в
зависимости от синтаксического типа выполняемого выражения. Для того,
чтобы процедура была достаточно общей, определение типа выражения мы
формулируем абстрактно, не связывая себя никакой конкретной реализацией
различных типов выражений. Для каждого типа выражений имеется предикат,
который распознает этот тип, и абстрактные средства для выбора его
частей. Такой (@newterm{abstract syntax}) позволяет легко видеть, как можно
изменить синтаксис языка и использовать тот же самый интерпретатор, но
только с другим набором синтаксических процедур.

\bigskip
@noindent
@b{Элементарные выражения}

@itemize @bullet

@item
Для самовычисляющихся выражений, например, чисел, @code{eval} возвращает
само выражение.

@item
@code{eval} должен находить значения переменных, просматривая окружение.

@end itemize

@noindent
@b{Особые формы}

@itemize @bullet

@item
Для выражений с кавычкой @code{eval} возвращает само закавыченное выражение.
    
@item
Присваивание переменной (или ее определение) должно вызвать @code{eval}
рекурсивно, чтобы вычислить новое значение, которое требуется связать с
переменной. Окружение нужно модифицировать, изменяя (или создавая)
связывание для переменной.

@item
Выражение @code{if} требует специальной обработки своих частей: если
предикат истинен, нужно выполнить следствие; если нет, альтернативу.

@item
Выражение @code{lambda} требуется преобразовать в процедуру, пригодную к
применению. Для этого нужно упаковать параметры и тело
@code{lambda}-выражения вместе с окружением, в котором оно вычисляется.

@item
Выражение @code{begin} требует выполнения своих подвыражений в том
порядке, как они появляются.

@item
Разбор случаев @code{cond} преобразуется во вложенные выражения
@code{if} и затем вычисляется.

@end itemize

@noindent
@b{Комбинации}

@itemize @bullet

@item
Для применения процедуры @code{eval} должна рекурсивно вычислить
операцию и операнды комбинации. Получившиеся процедура и аргументы
передаются @code{apply}, которая распоряжается собственно применением
процедуры.

@end itemize

@noindent
Вот определение @code{eval}:

@lisp
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))
@end lisp

@noindent
Ясности ради, @code{eval} реализована как перебор альтернатив через
@code{cond}. Недостаток этой реализации --- наша процедура обрабатывает
только несколько указанных типов выражений, и, не меняя определение
@code{eval}, новые типы добавить нельзя. В большинстве реализаций Лиспа
распределение выражений по типам сделано в стиле, управляемом данными.
Это дает пользователю возможность добавлять новые типы выражений,
которые @code{eval} будет способен распознать, не меняя само определение
@code{eval}. (См. упражнение @ref{Упражнение 4.3}.)

@comment @subsubheading Apply
@subsubheading Apply

Процедура @code{apply} принимает два аргумента: процедуру и список
аргументов, к которым ее надо применить. @code{Apply} делит процедуры на
два класса: для применения примитивов она зовет
@code{ apply-primitive-procedure}; составные процедуры она применяет, по
очереди вычисляя выражения, составляющие тело процедуры. Окружение, в
котором вычисляется тело составной процедуры, получается из базового
окружения, хранящегося в процедуре, добалением кадра, где параметры
процедуры связываются с аргументами, к которым процедура применяется.
Вот определение @code{apply}:

@lisp
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))
@end lisp

@comment @subsubheading Procedure arguments
@subsubheading Аргументы процедур

Обрабатывая применение процедуры, @code{eval} получает список
аргументов, к которым процедуру надо применить, при помощи
@code{list-of-values}. Процедура @code{list-of-values} в качестве
аргумента берет список операндов комбинации. Она вычисляет каждый
аргумент и возвращает список соответствующих значений.@footnote{Ветку
@code{application?} в @code{eval} можно было бы упростить, используя
@code{map} (и постановив, что @code{operands} возвращает список) вместо
того, чтобы писать явным образом процедуру @code{list-of-values}. Мы
решили не использовать здесь @code{map}, чтобы подчеркнуть, что
интерпретатор можно написать без обращения к процедурам высших порядков
(а следовательно, его можно написать на языке, в котором нет таких
процедур), притом, что язык, поддерживаемый интерпретатором, содержит
процедуры высших порядков.}

@lisp
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
@end lisp

@comment @subsubheading Conditionals
@subsubheading Условные выражения

Процедура @code{eval-if} вычисляет предикатную часть выражения @code{if}
в данном окружении. Если результат истинен, @code{eval-if} выполняет
следствие, если нет, --- альтернативу:

@lisp
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Использование @code{true?} в @code{eval-if} подчеркивает вопрос о связи
между реализуемым языком и языком реализации. Выражение
@code{if-predicate} выполняется в реализуемом языке, и, следовательно,
результат его является значением этого языка. Предикат интерпретатора
@code{true?} переводит это значение в значение, которое может быть
проверено выражением @code{if} в языке реализации: метациклическое
представление истины может не совпадать с ее представлением в
нижележащей Scheme.@footnote{В нашем случае, язык реализации и
реализуемый язык совпадают. Размышления о значении @code{true?}
расширяют наше сознание безотносительно к материальной сущности
истины.}

@comment @subsubheading Sequences
@subsubheading Последовательности

Процедура @code{eval-sequence} вызывается из @code{apply} для выполнения
последовательности выражений в теле процедуры, а также из @code{eval}
для обработки последовательности выражений в выражении @code{begin}. Она
принимает в виде аргументов последовательность выражений и окружение, и
выполняет выражения в том порядке, в котором они ей даны. Возвращаемое
значение совпадает со значением последнего выражения.

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))
@end lisp

@comment @subsubheading Assignments and definitions
@subsubheading Присваивания и определения

Следующая процедура обрабатывает присваивание переменным. При помощи
@code{eval} она находит значение, которое требуется присвоить, и
передает переменную и получившееся значение в процедуру
@code{set-variable-value!} для включения в текущее окружение.

@lisp
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
@end lisp

@noindent
Определения переменных обрабатываются сходным образом:@footnote{Эта
реализация @code{define} не учитывает один тонкий вопрос в обработке
внутренних определений, хотя в большинстве случаев работает правильно. В
чем состоит проблема и как ее решить, мы увидим в @ref{4.1.6}.}

@lisp
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
@end lisp

@noindent
В качестве возвращаемого значения для присваивания или определения мы
выбрали символ @code{ok}.@footnote{Как мы упоминали при введении
@code{define} и @code{set!}, их значения в Scheme зависят от
реализации --- то есть автор реализации имеет право выбрать такое
значение, какое он хочет.}

@quotation
@strong{@anchor{Упражнение 4.1}Упражнение 4.1:}
Заметим, что мы не можем сказать, вычисляет ли
метациклический интерпретатор операнды слева направо или справа налево.
Порядок вычисления наследуется от нижележащего Лиспа: если аргументы
@code{cons} в процедуре @code{list-of-values} вычисляются слева направо,
то и операнды в @code{list-of-values} будут вычисляться слева направо.
Если же вычисление аргументов @code{cons} происходит справа налево, то и
@code{list-of-values} будет вычислять операнды справа налево.

Напишите версию @code{list-of-values}, которая вычисляет операнды слева
направо, вне зависимости от порядка вычислений в нижележащем Лиспе.
Напишите также версию, которая вычисляет операнды справа налево.
@end quotation

@comment @subsection Representing Expressions
@subsection Представление выражений
@node	4.1.2, 4.1.3, 4.1.1, 4.1

Интерпретатор напоминает программу символьного дифференцирования,
описанную в @ref{2.3.2}.
Обе программы работают с символьными выражениями. В обеих результат
работы с составным выражением определяется рекурсивной обработкой частей
выражения и сочетанием частичных результатов, причем способ сочетания
зависит от типа выражения. И там, и там мы использовали абстракцию
данных, чтобы отделить общие правила работы от деталей того, как
представлены выражения. Для программы дифференцирования это означало,
что одна и та же процедура взятия производной могла работать с
алгебраическими выражениями в префиксной, инфиксной или какой-либо
другой записи. Для интерпретатора это означает, что синтаксис языка
определяется исключительно процедурами, которые классифицируют выражения
и выделяют их части.

Вот описание синтаксиса нашего языка:

@itemize

@item
К самовычисляющимся объектам относятся только числа и строки:

@lisp
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
@end lisp

@item
Переменные представляются в виде символов:

@lisp
(define (variable? exp) (symbol? exp))
@end lisp

@item
Выражения с кавычкой имеют форму
@code{(quote @math{\langle}@var{закавыченное-выражение}@math{\rangle})}

@lisp
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
@end lisp

@code{quoted?} определена посредством процедуры @code{tagged-list?},
которая распознает списки, начинающиеся с указанного символа:@footnote{В
@ref{2.3.1} упоминается, что интерпретатор
рассматривает закавыченное выражение как список, начинающийся с
@code{quote}, даже если выражение напечатано через знак кавычки.
Например, выражение @code{'a} будет выглядеть для интерпретатора как
@code{(quote a)}. См. упражнение @ref{Упражнение 2.55}.}

@lisp
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
@end lisp

@item
Присваивания имеют форму
@code{(set! @math{\langle}@var{πеременная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle})}:

@lisp
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
@end lisp

@item
Определения имеют вид

@lisp
(define @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle})
@end lisp

@noindent
или
or the form

@lisp
(define (@math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{πараметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πараметр}@math{_{\monoit{n}}\rangle})
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

Вторая форма (стандартное определение процедуры) является синтаксическим сахаром для

@lisp
(define @math{\langle}@var{πеременная}@math{\rangle}
  (lambda (@math{\langle}@var{πараметр}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πараметр}@math{_{\monoit{n}}\rangle})
    @math{\langle}@var{тело}@math{\rangle}))
@end lisp

Соответствующие синтаксические процедуры выглядят так:

@lisp
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)     @r{; formal parameters}
                   (cddr exp))))   @r{; body}
@end lisp

@item
@code{lambda}-выражения являются сπисками, которые начинаются с символа @code{lambda}:

@lisp
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
@end lisp

Мы приводим также конструктор для @code{lambda}-выражений. Он
используется в вышеприведенной процедуре @code{definition-value}:

@lisp
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
@end lisp

@item
Условные выражения начинаются с @code{if} и имеют предикат, следствие и
(необязательную) альтернативу. Если в выражении нет части-альтернативы,
мы указываем в ее качестве @code{false}.@footnote{Значение выражения
@code{if} в случае, когда предикат ложен, а альтернатива отсутствует, в
Scheme не определено; здесь мы решили сделать его ложным. Мы будем
поддерживать переменные @code{true} и @code{false} в выполняемых
выражениях путем связывания их в глобальном окружении.
См. @ref{4.1.4}.}

@lisp
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
@end lisp

Мы предоставляем также конструктор для @code{if}-выражений. Его будет
использовать процедура @code{cond->if} для преобразования выражений
@code{cond} в выражения @code{if}:

@lisp
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
@end lisp

@item
@code{Begin} упаковывает последовательность выражений в одно выражение.
В синтаксические операции над выражениями @code{begin} мы включаем
извлечение самой последовательности из выражения @code{begin}, а также
селекторы, которые возвращают первое выражение и остаток выражений в
последовательности.@footnote{Эти селекторы для списка выражений, а также
соответствующие им селекторы для списка операндов, не предназначаются
для абстракции данных. Они введены в качестве мнемонических имен для
основных списковых операций, чтобы легче было понимать вычислитель с
явным управлением из @ref{5.4}.}

@lisp
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
@end lisp

Кроме того, мы даем конструктор @code{sequence->exp} (для использования
в процедуре @code{cond->if}), который преобразует последовательность в
единое выражение, используя, если надо, @code{begin}:

@lisp
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
@end lisp

@item
Вызов процедуры --- это любое составное выражение, не попадающее ни в
один из перечисленных типов. Его @code{car} --- это оператор, а
@code{cdr} --- список операндов:

@lisp
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
@end lisp

@end itemize

@comment @subsubheading Derived expressions
@subsubheading Производные выражения

Некоторые особые формы языка можно определить через выражения,
включающие другие особые формы, вместо того, чтобы задавать их напрямую.
Как пример рассмотрим @code{cond}, который можно реализовать как гнездо
выражений @code{if}. Например, задачу вычисления выражения

@lisp
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
@end lisp

@noindent
можно свести к задаче вычисления следующего выражения, состоящего из
форм @code{if} и @code{begin}:

@lisp
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
@end lisp

@noindent
Такая реализация обработки @code{cond} упрощает интерпретатор, поскольку
она уменьшает количество особых форм, для которых требуется явно
описывать процесс вычисления.

Мы включаем в интерпретатор синтаксические процедуры, которые определяют
доступ к частям выражения @code{cond}, а также процедуру
@code{cond->if}, которая преобразует выражения @code{cond} в выражения
@code{if}. Анализ случаев начинается с @code{cond} и состоит из списка
ветвей-вариантов вида предикат-действие. Вариант считается
умолчательным, если его предикатом является символ
@code{else}.@footnote{Значение выражения @code{cond}, когда все предикаты
ложны, а вариант по умолчанию @code{else} отсутствует, в языке Scheme не
определено; здесь мы решили сделать его ложным.}

@lisp
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                        @r{; no @code{else} clause}
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
@end lisp

@noindent
Выражения (вроде @code{cond}), которые мы желаем реализовать через
синтаксические преобразования, называются (@newterm{derived expressions}).
Выражения @code{let} также являются производными
(см. @ref{Упражнение 4.6}).@footnote{Практические
Lisp-системы предоставляют механизм, который дает пользователю
возможность добавлять новые производные выражения и определять их
значения через синтаксические преобразования, не внося изменений в
вычислитель. Такое преобразование, определяемое пользователем,
называется (@newterm{macro}). Добавить простой механизм для определения макросов
легко, однако в получающемся языке возникают сложные проблемы конфликта
имен. Множество исследований посвящено поиску механизмов определения
макросов, в которых такие проблемы не возникают. См., например,
Kohlbecker 1986, Clinger and Rees 1991 и Hanson 1991.}

@quotation
@strong{@anchor{Упражнение 4.2}Упражнение 4.2:}
Хьюго Дум хочет переупорядочить ветви @code{eval} так, чтобы
ветвь для вызова процедур располагалась перед веткой для присваивания.
Он утверждает, что при этом интерпретатор станет эффективнее: поскольку
в программах обычно больше вызовов процедур, чем присваиваний,
определений и т. д., его усовершенствованный @code{eval} обычно будет
рассматривать меньше вариантов, чем исходный, при распознавании типа
выражения.

@enumerate a.

@item
Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением @code{(define x 3)}?)

@item
Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до
того, как он проверяет все остальные типы выражений. Помогите ему,
изменив синтаксис интерпретируемого языка так, чтобы вызовы процедур
начинались с символа @code{call}. Например, вместо @code{(factorial 3)}
нам теперь придется писать @code{(call factorial 3)}, а вместо
@code{(+ 1 2)} --- @code{(call + 1 2)}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.3}Упражнение 4.3:}
Перепишите @code{eval} так, чтобы диспетчеризация
происходила в стиле, управляемом данными. Сравните результат с
дифференцированием, управляемым данными, из @ref{Упражнение 2.73}.
(Можно использовать @code{car} составного выражения в качестве типа
этого выражения, так как это хорошо сочетается с синтаксисом, реализованным
в этом разделе.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.4}Упражнение 4.4:} Вспомним определения особых
форм @code{and} и @code{or} из @ref{Глава 1}:

@itemize @bullet

@item
@code{and:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается ложным, возвращается ложь; оставшиеся выражения не
вычисляются. Если все выражения оказываются истинными, возвращается
значение последнего из них. Если нет ни одного выражения, возвращается
истина.

@item
@code{or:} выражения вычисляются слева направо. Если значение какого-то
из них оказывается истинным, возвращается это значение; оставшиеся
выражения не вычисляются. Если все выражения оказываются ложными, или
нет ни одного выражения, возвращается ложь.

@end itemize

Введите @code{and} и @code{or} в качестве новых особых форм
интерпретатора, определив соответствующие синтаксические процедуры и
процедуры выполнения @code{eval-and} и @code{eval-or}. В качестве
альтернативы покажите, как можно реализовать @code{and} и @code{or} в
виде производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.5}Упражнение 4.5:}
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
@code{cond}, @code{(@math{\langle}@var{πроверка}@math{\rangle} =>
@math{\langle}@var{πотребитель}@math{\rangle})}.  Если результат
вычисления @math{\langle}@var{πроверки}@math{\kern0.08em\rangle}
оказывается истинным значением, то вычисляется
@math{\langle}@var{πотребитель}@math{\kern0.08em\rangle}. Его значение
должно быть одноместной процедурой; эта процедура вызывается со значением
@math{\langle}@var{πроверки}@math{\kern0.08em\rangle} в качестве аргумента,
и результат этого вызова возвращается как значение выражения @code{cond}.
Например:

@lisp
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
@end lisp

@noindent
имеет значение 2. Измените обработку @code{cond} так, чтобы она
поддерживала этот расширенный синтаксис.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.6}Упражнение 4.6:}
Выражения @code{let} производны, поскольку

@lisp
(let ((@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{πер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
эквивалентно

@lisp
((lambda (@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{πер}@math{_{\monoit{n}}\rangle})
   @math{\langle}@var{тело}@math{\rangle})
 @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}
 @dots{}
 @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle})
@end lisp

Напишите синтаксическое преобразование @code{let->combination}, которое
сводит вычисление @code{let}-выражений к вычислению комбинаций
указанного вида, и добавьте соответствующую ветку для обработки
@code{let} к @code{eval}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.7}Упражнение 4.7:}
Особая форма @code{let*} подобна @code{let}, но только
связывания переменных в @code{let*} происходят последовательно, и каждое
следующее связывание происходит в окружении, где видны все предыдущие.
Например,

@lisp
(let* ((x 3)  (y (+ x 2))  (z (+ x y 5)))
  (* x z))
@end lisp

@noindent
возвращает значение 39. Объясните, каким образом можно переписать
выражение @code{let*} в виде набора вложенных выражений @code{let}, и
напишите процедуру @code{let*->nested-lets}, которая проделывает это
преобразование. Если мы уже реализовали @code{let}
(@ref{Упражнение 4.6}) и хотим теперь расширить
интерпретатор так, чтобы он обрабатывал @code{let*}, достаточно ли будет
добавить в @code{eval} ветвь, в которой действием записано

@lisp
(eval (let*->nested-lets exp) env)
@end lisp

@noindent
или нужно явным образом преобразовывать @code{let*} в набор
непроизводных выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.8}Упражнение 4.8:}
<<Именованный @code{let}>> --- это вариант , который имеет
вид

@lisp
(let @math{\langle}@var{var}@math{\rangle} @math{\langle}@var{bindings}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@math{\langle}@var{связывание}@math{\rangle} и
@math{\langle}@var{тело}@math{\rangle} такие же, как и в обычном
@code{let}, но только @math{\langle}@var{переменная}@math{\rangle}
связана в @math{\langle}@var{теле}@math{\rangle} с процедурой, у
которой тело @math{\langle}@var{тело}@math{\rangle}, а имена
параметров --- переменные в
@math{\langle}@var{связываниях}@math{\rangle}. Таким образом, можно
неоднократно выполнять @math{\langle}@var{тело}@math{\rangle}, вызывая
процедуру по имени @math{\langle}@var{переменная}@math{\rangle}.
Например, итеративную процедуру для порождения чисел Фибоначчи
(@ref{1.2.2}) можно переписать при помощи именованного @code{let} как

@lisp

(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
@end lisp

Измените преобразование @code{let->combination} из
упражнения @ref{Упражнение 4.6} так, чтобы оно поддерживало именованный
@code{let}.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.9}Упражнение 4.9:}
Во многих языках имеются различные конструкции для
построения циклов, например, @code{do}, @code{for}, @code{while} и
@code{until}. В Scheme итеративные процессы можно выразить через обычные
вызовы процедур, так что особые конструкции не дают никакого
существенного выигрыша в вычислительной мощности. С другой стороны,
часто они удобны. Придумайте какие-нибудь конструкции для итерации,
дайте примеры их использования и покажите, как их реализовать в виде
производных выражений.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.10}Упражнение 4.10:}
При помощи абстракции данных мы смогли написать процедуру
@code{eval} так, что она не зависит от конкретного синтаксиса
интерпретируемого языка. Чтобы проиллюстрировать это свойство,
разработайте новый синтаксис для Scheme, изменив процедуры из этого
раздела и ничего не трогая в @code{eval} и @code{apply}.
@end quotation

@comment @subsection Evaluator Data Structures
@subsection Структуры данных интерпретатора
@node	4.1.3, 4.1.4, 4.1.2, 4.1

Помимо внешнего синтаксиса выражений, реализация интерпретатора должна
определить также внутренние структуры данных, с которыми она работает во
время выполнения программы, в частности, представление процедур и
окружений, а также истинных и ложных значений.

@comment @subsubheading Testing of predicates
@subsubheading Проверка предикатов

В условных выражениях мы воспринимаем в качестве истины все, кроме
специального ложного объекта @code{false}.

@lisp
(define (true? x)  (not (eq? x false)))
(define (false? x) (eq? x false))
@end lisp

@comment @subsubheading Representing procedures
@subsubheading Представление процедур

Работая с примитивами, мы предполагаем, что у нас есть следующие
процедуры:

@itemize @bullet

@item
@code{(apply-primitive-procedure @math{\langle}@var{процедура}@math{\rangle}
@math{\langle}@var{аргументы}@math{\rangle})}

@noindent
применяет данную элементарную процедуру к значениям аргументов из списка
@math{\langle}@var{аргументы}@math{\rangle} и возвращает результат
вызова.

@item
@code{(primitive-procedure? @math{\langle}@var{процедура}@math{\rangle})}

@noindent
проверяет, является ли @math{\langle}@var{процедура}@math{\rangle}
элементарной.

@end itemize

@noindent
Эти механизмы работы с элементарными процедурами подробнее описаны в
@ref{Часть 4.1.4}.

Составная процедура строится из параметров, те́ла процедуры и окружения
при помощи конструктора @code{make-procedure}:

@lisp
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
@end lisp

@comment @subsubheading Operations on Environments
@subsubheading Действия над окружениями

Интерпретатору нужно иметь несколько операций, действующих над
окружениями. Как объясняется в @ref{3.2},
окружение представляет собой последовательность кадров, а каждый кадр
является таблицей связываний, соотносящих переменные с их значениями.
Для работы с окружениями мы используем следующие операции:

@itemize @bullet

@item
@code{(lookup-variable-value @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
возвращает значение, связанное с символом
@math{\langle}@var{πеременная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle}, либо сообщает об ошибке,
если переменная не связана.

@item
@code{(extend-environment @math{\langle}@var{πеременные}@math{\rangle} @math{\langle}@var{значения}@math{\rangle} @math{\langle}@var{исх-окр}@math{\rangle})}
возвращает новое окружение, состоящее из нового кадра, в котором символы
из списка  @math{\langle}@var{πеременные}@math{\rangle} связаны с
соответствующими элементами списка
@math{\langle}@var{значения}@math{\rangle}, а объемлющим окружением
является окружение @math{\langle}@var{исх-окр}@math{\rangle}.

@item
@code{(define-variable! @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
добавляет к первому кадру @math{\langle}@var{окружение}@math{\rangle}
новое связывание, которое сопоставляет
@math{\langle}@var{πеременная}@math{\rangle}
@math{\langle}@var{значение}@math{\rangle}.

@item
@code{(set-variable-value! @math{\langle}@var{πеременная}@math{\rangle} @math{\langle}@var{значение}@math{\rangle} @math{\langle}@var{окружение}@math{\rangle})}
изменяет связывание @math{\langle}@var{πеременная}@math{\rangle} в
@math{\langle}@var{окружение}@math{\rangle} так, что в дальнейшем ей
будет соответствовать @math{\langle}@var{значение}@math{\rangle}, либо
сообщает об ошибке, если переменная не связана.

@end itemize

@noindent
Чтобы реализовать все эти операции, мы представляем окружение в виде
списка кадров. Объемлющее окружение живет в @code{cdr} этого списка.
Пустое окружение --- это просто пустой список.

@lisp
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
@end lisp

@noindent
Каждый кадр в окружении представляется в виде пары списков: список
переменных, связанных в кадре, и список значений.@footnote{В
нижеследующем коде кадры не являются настоящей абстракцией данных:
@code{set-variable-value!} и @code{define-variable!} явным образом
изменяют значения в кадре при помощи @code{set-car!}. Назначение
процедур работы с кадрами --- сделать код операций над окружениями
простым для чтения.}

@lisp
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
@end lisp

@noindent
Чтобы расширить окружение новым кадром, который связывает переменные со
значениями, мы порождаем кадр, который состоит из списка переменных и
списка значений, и присоединяем его к окружению. Если количество
переменных и количество значений не совпадают, сообщаем об ошибке.

@lisp
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
@end lisp

@noindent
Чтобы найти переменную в окружении, мы просматриваем список переменных в
первом кадре. Если находим нужную переменную, то возвращаем
соответствующий элемент списка значений. Если мы не находим переменную в
текущем кадре, то ищем в объемлющем окружении, и так далее. Если мы
добираемся до пустого окружения, нужно сообщить об ошибке
<<неопределенная переменная>>.

@lisp
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы присвоить переменной новое значение в указанном окружении, мы ищем
переменную, точно так же, как в @code{lookup-variable-value}, и изменяем
соответствующее значение, когда его находим.

@lisp
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
@end lisp

@noindent
Чтобы определить переменную, мы просматриваем первый кадр в поисках
связывания для нее, и изменяем связывание, если его удается найти (так
же, как в @code{set-variable-value!}). Если связывания не существует, мы
присоединяем его к первому кадру.

@lisp
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))
@end lisp

@noindent
Описанный здесь метод --- только один из многих способов представления
окружений. Поскольку мы при помощи абстракции данных отделили конкретную
реализацию от остальных частей интерпретатора, при желании мы можем
сменить представление окружений.
(См. @ref{Упражнение 4.11}.) В Lisp-системе промышленного
качества быстрота операций над окружениями --- особенно обращения к
переменной --- очень сильно влияет на общую производительность.
Представление, описанное здесь, при всей своей концептуальной простоте
неэффективно и, скорее всего, его не стали бы использовать в рабочей
системе.@footnote{Недостаток этого представления (как и варианта из
@ref{Упражнение 4.11}) состоит в том, что вычислителю может
понадобиться просматривать слишком много кадров, чтобы найти связывание
конкретной переменной. Такой подход называется (@newterm{deep binding}).
Один из способов избежать такой потери производительности --- использовать
стратегию под названием (@newterm{lexical addressing}), которая обсуждается в
@ref{5.5.6}.}

@quotation
@strong{@anchor{Упражнение 4.11}Упражнение 4.11:}
Вместо того, чтобы представлять кадр в виде списка
списков, его можно представить как список связываний, где каждое
связывание является парой из имени и значения. Перепишите операции с
окружениями в соответствии с этим альтернативным представлением.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.12}Упражнение 4.12:}
Процедуры @code{set-variable-value!},
@code{define-variable!} и @code{lookup-variable-value} можно выразить
посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.13}Упражнение 4.13:}
Scheme позволяет создавать новые связывания через
@code{define}, но не дает никакого способа избавиться от связывания.
Реализуйте в интерпретаторе особую форму @code{make-unbound!}, которая
изымает связывание данного символа из окружения, в котором
@code{make-unbound!} выполняется. Задача определена не до конца.
Например, нужно ли удалять связывания в других кадрах, кроме первого?
Дополните спецификацию и объясните свой выбор вариантов.
@end quotation

@comment @subsection Running the Evaluator as a Program
@subsection Выполнение интерпретатора как программы
@node	4.1.4, 4.1.5, 4.1.3, 4.1

Написав интерпретатор, мы получаем в руки описание (выраженное на Lisp)
процесса вычисления лисповских выражений. Одно из преимуществ наличия
описания в виде программы в том, что эту программу можно запустить. У
нас внутри Лиспа есть работающая модель того, как сам Лисп вычисляет
выражения. Она может служить средой для экспериментов с правилами
вычисления, и дальше в этой главе мы такими экспериментами и займемся.

Программа-вычислитель в конце концов сводит выражения к применению
элементарных процедур. Следовательно, единственное, что нам требуется
для запуска интерпретатора, --- создать механизм, который обращается к
нижележащей Лисп-системе и моделирует вызовы элементарных процедур.

Нам нужно иметь связывание для каждого имени элементарной процедуры,
чтобы, когда @code{eval} выполняет вызов примитива, у него был объект,
который можно передать в @code{apply}. Поэтому мы выстраиваем глобальное
окружение, связывающее особые объекты с именами элементарных процедур,
которые могут появляться в вычисляемых нами выражениях. Кроме того,
глобальное окружение включает связывания для символов и @code{false},
так что их можно использовать как переменные в вычисляемых выражениях.

@lisp
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))
@end lisp

@noindent
Как именно мы представляем объекты-элементарные процедуры, не имеет
значения. Требуется только, чтобы их можно было распознавать и
применять, вызывая процедуры @code{primitive-procedure?} и
@code{apply-primitive-procedure}. Мы решили представлять примитивы в
виде списка, начинающегося с символа @code{primitive} и содержащего
процедуру нижележащего Лиспа, которая реализует данный примитив.

@lisp
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
@end lisp

@noindent
@code{setup-environment} получит имена и реализации элементарных
процедур из списка:@footnote{Любую процедуру, определенную в нижележащем
Лиспе, можно использовать как примитив для метациклического
интерпретатора. Имя примитива, установленного в интерпретаторе, не
обязательно должно совпадать с именем его реализации в нижележащем
Лиспе; здесь имена одни и те же потому, что метациклический
интерпретатор реализует саму Scheme. Так, например, мы могли бы написать
в списке @code{primitive-procedures} что-нибудь вроде
@code{(list 'first car)} или
@code{(list 'square (lambda (x) (* x x)))}.}

@lisp
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        @math{\langle}@var{другие πримитивы}@math{\rangle} ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
@end lisp

@noindent
Чтобы вызвать элементарную процедуру, мы просто применяем
процедуру-реализацию к аргументам, используя нижележащую
Lisp-систему.@footnote{@code{apply-in-underlying-scheme} --- это процедура
@code{apply}, которой мы пользовались в предыдущих главах. Процедура
@code{apply} метациклического интерпретатора (@ref{4.1.1}) имитирует работу
этого примитива. Наличие двух процедур с одинаковым именем ведет к технической
проблеме при запуске интерпретатора, поскольку определение @code{apply}
метациклического интерпретатора загородит определение примитива. Можно
избежать этого, переименовав метациклический @code{apply}, и избавиться
таким образом от конфликта с именем элементарной процедуры. Мы же вместо
этого приняли решение сохранить ссылку на исходный @code{apply}, выполнив

@lisp
(define apply-in-underlying-scheme apply)
@end lisp

@noindent
прежде, чем определили @code{apply} в интерпретаторе. Теперь мы можем
обращаться к исходной версии @code{apply} под другим именем.}

@lisp
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Для удобства работы с метациклическим интерпретатором мы организуем
(@newterm{driver loop}), который моделирует цикл чтения-выполнения-печати
нижележащей Лисп-системы. Этот цикл печатает (@newterm{prompt}), считывает входное
выражение, вычисляет это выражение в глобальном окружении и
распечатывает результат. Перед каждым результатом мы помещаем (output
prompt), чтобы отличить значение выражения от всего прочего, что может
быть напечатано.@footnote{Элементарная процедура ожидает ввода от
пользователя и возвращает ближайшее полное выражение, которое он
напечатает. Например, если пользователь напечатает @code{(+ 23 x)},
результатом @code{read} будет трехэлементный список из символа @code{+},
числа 23 и символа @code{x}. Если пользователь введет @code{'x},
результатом @code{read} будет двухэлементный список из символа
@code{quote} и символа @code{x}.}

@lisp
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
@end lisp

@noindent
Мы пользуемся специальной процедурой вывода @code{user-print}, чтобы не
печатать окружение составных процедур, которое может быть очень длинным
списком, и даже может содержать циклы.

@lisp
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
@end lisp

@noindent
Теперь для запуска интерпретатора нам остается только
проинициализировать глобальное окружение и войти в управляющий цикл. Вот
пример работы интерпретатора:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)

@i{;;; M-Eval input:}
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
@i{;;; M-Eval value:}
@i{ok}
@i{;;; M-Eval input:}
(append '(a b c) '(d e f))
@i{;;; M-Eval value:}
@i{(a b c d e f)}
@end lisp

@c @sp 1
@quotation
@strong{@anchor{Упражнение 4.14}Упражнение 4.14:}
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение @code{map}
и запускает несколько тестовых программ с его использованием. Они
замечательно работают. Хьюго, со своей стороны, ввел системную версию
@code{map} как примитив метациклического интерпретатора. Когда он
пытается его выполнить, все ломается самым ужасным образом. Объясните,
почему у Хьюго @code{map} не работает, а у Евы работает.
@end quotation

@comment @subsection Data as Programs
@subsection Данные как программы
@node	4.1.5, 4.1.6, 4.1.4, 4.1

При рассмотрении программы на Лиспе, вычисляющей лисповские выражения,
может быть полезна аналогия. Одна из возможных точек зрения на значение
программы состоит в том, что программа описывает абстрактную (возможно,
бесконечно большую) машину. Рассмотрим, например, знакомую нам программу
для вычисления факториалов:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Можно считать эту программу описанием машины, которая содержит узлы для
вычитания, умножения и проверки на равенство, двухпозиционный
переключатель и еще одну факториал-машину. (Факториал-машина получается
бесконечной, поскольку она содержит другую факториал-машину внутри
себя.) На рисунке @ref{Рисунок 4.2} изображена потоковая диаграмма
факториал-машины, которая показывает, как спаяны ее части.

Подобным образом, мы можем рассматривать вычислитель как особого рода
машину, которой подается в виде сырья описание другой машины. Обработав
свои входные данные, вычислитель перестраивает себя так, чтобы
моделировать описываемую машину. Например, если мы скормим вычислителю
определение @code{factorial}, как показано на
рисунке @ref{Рисунок 4.3}, он сможет считать факториалы.

@float
@quotation
@anchor{Рисунок 4.2}
@ifinfo
@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.

@example
    +-----------------------------------+
    | factorial                   |1    |
    |              |1             V     |
    |              |           +-----+  |
    |              V           | #   |  |
    |           +-----+        |     |  |
6 --------*-----|  =  |------->|   #-+-----> 720
    |     |     +-----+        |  /  |  |
    |     |                    | #   |  |
    |     |                    +-----+  |
    |     |                       ^     |
    |     |                       |     |
    |     |                    +--+--+  |
    |     *------------------->|  *  |  |
    |     |                    +-----+  |
    |     V                       ^     |
    |  +-----+    +-----------+   |     |
    |  |  -  +--->| factorial +---+     |
    |  +-----+    +-----------+         |
    |     ^                             |
    |     |1                            |
    +-----------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.2,84mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.2:} The factorial program, viewed as an abstract machine.}
@sp 0.9
@end iftex
@end quotation
@end float

С этой точки зрения, наш вычислитель-интерпретатор выглядит как
(@newterm{universal machine}). Она имитирует другие машины, представленные
в виде Lisp-программ.@footnote{То, что машины описаны на языке Лисп,
несущественно. Если дать нашему интерпретатору программу на Лиспе,
которая ведет себя как вычислитель для какого-нибудь другого языка,
скажем, Си, то вычислитель для Лиспа будет имитировать вычислитель для
Си, который, в свою очередь, способен сымитировать любую машину,
описанную в виде программы на Си. Подобным образом, написание
интерпретатора Лиспа на Си порождает программу на Си, способную
выполнить любую программу на Лиспе. Главная идея здесь состоит в том,
что любой вычислитель способен имитировать любой другой. Таким образом,
понятие <<того, что в принципе можно вычислить>> (если не принимать во
внимание практические вопросы времени и памяти, потребной для
вычисления), независимо от языка компьютера и выражает глубинное понятие
(computability). Это впервые было ясно показано Аланом М. Тьюрингом
(1912-1954), чья статья 1936 года заложила основы теоретической
информатики. В этой статье Тьюринг представил простую модель
вычислений, --- теперь известную как (@newterm{Turing machine}), --- и
утверждал, что любой <<эффективный процесс>> выразим в виде программы
для такой машины. (Этот аргумент известен как (@newterm{Church-Turing thesis}).)
Затем Тьюринг реализовал универсальную машину, т. е. машину Тьюринга,
которая работает как вычислитель для программ машин Тьюринга. При помощи
этой схемы рассуждений он показал, что существуют коррекно поставленные
задачи, которые не могут быть решены машиной Тьюринга
(см. @ref{Упражнение 4.15}), а следовательно не могут быть
сформулированы в виде <<эффективного процесса>>. Позднее Тьюринг внес
фундаментальный вклад и в развитие практической информатики. Например,
ему принадлежит идея структурирования программ с помощью подпрограмм
общего назначения. Биографию Тьюринга можно найти в Hodges 1983.} Это
замечательное устройство. Попробуйте представить себе аналогичный
вычислитель для электрических схем. Это была бы схема, которой на вход
поступает сигнал, кодирующий устройство какой-то другой схемы, например,
фильтра. Восприняв этот вход, наша схема-вычислитель стала бы работать
как фильтр, соответствующий описанию. Такая универсальная электрическая
схема имеет почти невообразимую сложность. Удивительно, что
интерпретатор программ --- сам по себе программа довольно
простая.@footnote{Некоторые считают странным, что вычислитель,
реализованный с помощью относительно простой процедуры, способен
имитировать программы, более сложные, чем он сам. Существование
универсальной машины-вычислителя --- глубокое и важное свойство
вычисления. (recursion theory), отрасль математической логики,
занимается логическими пределами вычислимости. В прекрасной книге
Дугласа Хофштадтера <<Гёдель, Эшер, Бах>> (Hofstadter 1979) исследуются
некоторые из этих идей.}

@float
@quotation
@anchor{Рисунок 4.3}
@ifinfo
@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.

@example
                   +--------+
            6 ---->|  eval  |----> 720
                   +--------+
                       /
             . . .    /  . . .
       . . .       ../. .      .
     .                           ..
    .   (define (factorial n)      . . .
   .      (if (= n 1)                   . .
    .         1                            .
    .         (* (factorial (- n 1)) n)))   .
      . .                       . .        .
          . .  . .      . . . .     . . . .
                   . ..
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap4/Fig4.3,69mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.3:} The evaluator emulating a factorial machine.}
@sp 0.9
@end iftex
@end quotation
@end float

Еще одна замечательная черта интерпретатора заключается в том, что он
служит мостом между объектами данных, которыми манипулирует язык
программирования, и самим языком. Представим себе, что работает
программа интерпретатора (реализованная на Лиспе), и что пользователь
вводит выражения в интерпретатор и рассматривает результаты. С точки
зрения пользователя, входное выражение вроде @code{(* x x)} является
выражением языка программирования, которое интерпретатор должен
выполнить. Однако с точки зрения интерпретатора это всего лишь список (в
данном случае, список из трех символов: @code{*}, @code{x} и @code{x}), с
которым нужно работать по ясно очерченным правилам.

Нас не должно смущать, что программы пользователя являются данными для
интерпретатора. На самом деле, иногда бывает удобно игнорировать это
различие и, предоставляя пользовательским программам доступ к
@code{eval}, давать пользователю возможность явным образом вычислить
объект данных как выражение Лиспа. Во многих диалектах Лиспа имеется
элементарная процедура @code{eval}, которая в виде аргументов берет
выражение и окружение, и вычисляет выражение в указанном
окружении.@footnote{Предупреждение: эта процедура @code{eval} --- не то
же самое, что процедура @code{eval}, реализованная нами в @ref{4.1.1},
потому что она работает с @emph{настоящими} окружениями, а не с
искусственными структурами окружений, которые мы построили в @ref{4.1.3}.
С этими настоящими
окружениями пользователь не может работать, как с обычными списками; к
ним нужно обращаться через @code{eval} или другие специальные операции.
Подобным образом, элементарная процедура @code{apply}, упомянутая
раньше, не то же самое, что метациклическая @code{apply}, поскольку она
использует настоящие процедуры Scheme, а не объекты-процедуры, которые
мы конструировали в разделах @ref{4.1.3} и @ref{4.1.4}.} Таким образом, как

@lisp
(eval '(* 5 5) user-initial-environment)
@end lisp

@noindent
так и

@lisp
(eval (cons '* (list 5 5)) user-initial-environment)
@end lisp

@noindent
возвращают результат 25.@footnote{Реализация MIT Scheme имеет процедуру
@code{eval}, а также символ , связанный с исходным окружением, в котором
вычисляются выражения.}

@quotation
@strong{@anchor{Упражнение 4.15}Упражнение 4.15:}
Если даны одноаргументная процедура @code{p} и объект
@code{a}, то говорят, что @code{p} <<останавливается>> на @code{a}, если
выражение @code{(p a)} возвращает значение (а не печатает сообщение об
ошибке или выполняется вечно). Покажите, что невозможно написать
процедуру @code{halts?}, которая бы точно определяла для любой процедуры
@code{p} и любого объекта @code{a}, останавливается ли @code{p} на
@code{a}. Используйте следующее рассуждение: если бы имелась такая
процедура @code{halts?}, можно было бы написать следующую программу:

@lisp
(define (run-forever) (run-forever))
(define (try p)
  (if (halts? p p) (run-forever) 'halted))
@end lisp

Теперь рассмотрите выражение @code{(try try)} и покажите, что любое
возможное завершение (остановка или вечное выполнение) нарушает
требуемое поведение @code{halts?}.@footnote{Хотя здесь мы предположили,
что @code{halts?} получает процедурный объект, заметим, что рассуждение
остается в силе даже в том случае, когда на вход подается текст
процедуры и ее окружение. В этом и состоит знаменитая (Halting Theorem)
Тьюринга, в которой был дан первый пример (non-computable) задачи,
т. е. корректно поставленного задания, которое невозможно выполнить с
помощью вычислительной процедуры.}
@end quotation

@comment @subsection Internal Definitions
@subsection Внутренние определения
@node	4.1.6, 4.1.7, 4.1.5, 4.1

Наша модель вычислений с окружениями и метациклический интерпретатор
выполняют определения по очереди, расширяя кадр окружения на одно
определение за раз. Это особенно удобно для диалоговой разработки
программы, когда программисту нужно свободно смешивать вызовы процедур с
определениями новых процедур. Однако если мы внимательно поразмыслим над
внутренними определениями, с помощью которых реализуется блочная
структура (введенная в @ref{1.1.8}), то мы увидим, что пошаговое расширение
окружения --- одно имя за другим --- может оказаться не лучшим способом
определения локальных переменных.

Рассмотрим процедуру с внутренними определениями, например

@lisp
(define (f x)
  (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)  (if (= n 0) false (even? (- n 1))))
  @math{\langle}@var{остаток тела @code{f}}@math{\rangle})
@end lisp

@noindent
Здесь нам хочется, чтобы имя @code{odd?} в теле процедуры @code{even?}
ссылалось на процедуру @code{odd?}, которая определена позже, чем
@code{even?}. Область действия имени @code{odd?} --- это все тело
@code{f}, а не только та его часть, которая лежит за точкой внутри
@code{f}, где определяется @code{odd?}. В самом деле, ели заметить, что
сама @code{odd?} определена с помощью @code{even?} --- так что
@code{even?} и @code{odd?} являются взаимно рекурсивными
процедурами, --- то становится ясно, что единственная
удовлетворительная интерпретация двух @code{define} --- рассматривать
их так, как будто @code{even?} и @code{odd?} были добавлены в окружение
одновременно. В общем случае, сферой действия локального имени является
целиком тело процедуры, в котором вычисляется @code{define}.

В нынешнем виде интерпретатор будет вычислять вызовы @code{f} правильно,
но причина этого <<чисто случайная>>: поскольку определения внутренних
процедур расположены в начале, никакие их вызовы не вычисляются, пока
они все не определены. Следовательно, к тому времени, когда выполняется
@code{even?}, @code{odd?} уже определена. Фактически, последовательный
механизм вычисления дает те же результаты, что и механизм,
непосредственно реализующий одновременное определение, для всякой
процедуры, где внутренние определения стоят в начале тела, а вычисление
выражений для определяемых переменных не использует ни одну из этих
переменных. (Пример процедуры, которая не удовлетворяет этим
требованиям, так что последовательное определение не равносильно
одновременному, можно найти в @ref{Упражнение 4.19}.)@footnote{Нежелание
зависеть в программах от этого механизма вычисления побудило нас написать
<<администрация ответственности не несет>> в примечании @ref{Сноска 28} в
@ref{Глава 1}.
Настаивая на том, чтобы внутренние определения стояли в начале тела и не
использовали друг друга во время вычисления самих определений, стандарт
IEEE Scheme дает авторам реализаций некоторую свободу при выборе
механизма вычисления этих определений. Выбор того или иного правила
вычисления может показаться мелочью, которая влияет только на
интерпретацию <<плохих>> программ. Однако в @ref{5.5.6} мы увидим, что
через переход к модели с одновременным определением внутренних
переменных можно избежать некоторых досадных трудностей, которые бы в
противном случае возникли при написании компилятора.}

Однако имеется простой способ обрабатывать определения так, чтобы у
локально определенных имен оказалась действительно общая сфера
действия, --- достаточно лишь создать все будущие внутренние переменные
текущего окружения, прежде чем начнется вычисление какого-либо из
выражений, возвращающих значение. Можно это сделать, например, путем
синтаксического преобразования @code{lambda}-выражений. Прежде чем
выполнять тело выражения @code{lambda}, мы <<прочесываем>> его и
уничтожаем все внутренние определения. Локально определенные переменные
будут созданы через @code{let}, а затем получат значения посредством
присваивания. Например, процедура

@lisp
(lambda @math{\langle}@var{πеременные}@math{\rangle}
  (define u @math{\langle}@var{e1}@math{\rangle})
  (define v @math{\langle}@var{e2}@math{\rangle})
  @math{\langle}@var{e3}@math{\rangle})
@end lisp

@noindent
преобразуется в

@lisp
(lambda @math{\langle}@var{πеременные}@math{\rangle}
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u @math{\langle}@var{e1}@math{\rangle})
    (set! v @math{\langle}@var{e2}@math{\rangle})
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

@noindent
где @code{unassigned*} --- специальный символ, который при поиске
переменной вызывает сообщение об ошибке, если программа пытается
использовать значение переменной, которой ничего еще не присвоено.

Альтернативная стратегия поиска внутренних определений показана в
упражнении @ref{Упражнение 4.18}. В отличие от преобразования,
продемонстрированного только что, она навязывает программисту следующее
ограничение: значение каждой определяемой переменной должно вычисляться
без обращения к значениям других определяемых
переменных.@footnote{Стандарт IEEE Scheme допускает различные стратегии
реализации. В нем говорится, что программист обязан подчиняться этому
ограничению, но реализация может его не проверять. Некоторые реализации
Scheme, включая MIT Scheme, используют преобразование, показанное выше.
В таких реализациях будут работать некоторые из программ, которые это
ограничение нарушают.}

@quotation
@strong{@anchor{Упражнение 4.16}Упражнение 4.16:}
В этом упражнении мы реализуем только что описанный метод
обработки внутренних определений. Мы предполагаем, что интерпретатор
поддерживает @code{let} (см. упражнение @ref{Упражнение 4.6}).

@enumerate a.

@item
Измените процедуру @code{lookup-variable-value} (@ref{4.1.3}) так, чтобы она,
обнаруживая в качестве значения символ @code{*unassigned*}, сообщала об ошибке.

@item
Напишите процедуру , которая берет тело процедуры и возвращает его
эквивалент без внутренних определений, выполняя описанное нами
преобразование.

@item
Вставьте @code{scan-out-defines} в интерпретатор, либо в
@code{make-procedure}, либо в @code{procedure-body} (см. @ref{4.1.3}).
Какое из этих мест лучше? Почему?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.17}Упражнение 4.17:}
Нарисуйте диаграммы окружения, которое находится в силе в
момент выполнения выражения @emph{@math{\langle}e3@math{\rangle}} из
процедуры выше по тексту, и сравните его устройство при последовательной
обработке определений и при описанном выше преобразовании. Откуда в
преобразованной программе берется дополнительный кадр? Объясните, почему
это различие никогда не отражается на поведении корректных программ.
Придумайте, как заставить интерпретатор реализовать правило
<<одновременной>> сферы действия для внутренних определений без создания
дополнительного кадра.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.18}Упражнение 4.18:} Рассмотрим альтернативную
стратегию обработки определений, которая переводит пример из текста в

@lisp
(lambda @math{\langle}@var{переменные}@math{\rangle}
  (let ((u '*unassigned*) (v '*unassigned*))
    (let ((a @math{\langle}@var{e1}@math{\rangle}) (b @math{\langle}@var{e2}@math{\rangle}))
      (set! u a)
      (set! v b))
    @math{\langle}@var{e3}@math{\rangle}))
@end lisp

Здесь @code{a} и @code{b} представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру @code{solve} из @ref{3.5.4}:

@lisp
(define (solve f y0 dt)
  (define  y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

Будет ли эта процедура работать, если внутренние определения
преобразуются так, как предлагается в этом упражнении? А если так, как в
тексте раздела? Объясните.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.19}Упражнение 4.19:}
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том,
каким должен быть результат выражения

\enlargethispage{\baselineskip}

@lisp
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
@end lisp

Бен говорит, что следует действовать согласно последовательному правилу
для @code{define}: @code{b} равно 11, затем @code{a} определяется как 5,
так что общий результат равен 16. Лиза возражает, что взаимная рекурсия
требует правила одновременной сферы действия для внутренних определений
и нет причин рассматривать имена процедур отдельно от прочих имен. То
есть она выступает за механизм, реализованный в @ref{Упражнение 4.16}.
При этом @code{a} оказывается не
определено в момент, когда вычисляется @code{b}. Следовательно, по
мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с обоими.
Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение @code{a} должно использоваться при
вычислении @code{b}. Следовательно, по мнению Евы, @code{a} должно
равняться 5, @code{b} должно быть 15, а общий результат 20. Какую из
этих точек зрения Вы поддерживаете (если у Вас нет своей четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?@footnote{Авторы MIT Scheme согласны с
Лизой, и вот почему: в принципе права Ева --- определения следует
рассматривать как одновременные. Однако придумать универсальный
эффективный механизм, который вел бы себя так, как она требует, кажется
трудным. Если же такого механизма нет, то лучше порождать ошибку в
сложных случаях параллельных определений (мнение Лизы), чем выдавать
неверный ответ (как хочет Бен).}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.20}Упражнение 4.20:}
Поскольку внутренние определения выглядят
последовательными, а на самом деле параллельны, некоторые предпочитают
их вовсе избегать и вместо этого пользуются особой формой @code{letrec}.
@code{Letrec} выглядит так же, как @code{let}, поэтому неудивительно,
что переменные в нем связываются одновременно и имеют одинаковую для
всех сферу действия. Можно переписать процедуру-пример @code{f} из
текста без внутренних определений, но при этом в точности с тем же
значением, так:

@lisp
(define (f x)
  (letrec
    ((even? (lambda (n)
              (if (= n 0) true  (odd?  (- n 1)))))
     (odd?  (lambda (n)
              (if (= n 0) false (even? (- n 1))))))
    @math{\langle}@var{остаток тела @code{f}}@math{\rangle}))
@end lisp

Выражение @code{letrec} имеет вид

@lisp
(letrec ((@math{\langle}@var{πер}@math{_{\mono{1}}\rangle} @math{\langle}@var{выр}@math{_{\mono{1}}\rangle}) @dots{} (@math{\langle}@var{πер}@math{_{\monoit{n}}\rangle} @math{\langle}@var{выр}@math{_{\monoit{n}}\rangle}))
  @math{\langle}@var{тело}@math{\rangle})
@end lisp

@noindent
и является вариантом @code{let}, в котором выражения
@math{\langle}@var{выр}@math{_k\rangle},
устанавливающие начальные значения для переменных
@math{\langle}@var{πер}@math{_k\rangle}, вычисляются
в окружении, которое включает все связывания @code{letrec}. Это делает
возможным рекурсию между связываниями, к примеру, взаимную рекурсию
@code{even?} и @code{odd?} в последнем примере, или вычисление
факториала 10 через

@lisp
(letrec
  ((fact (lambda (n)
           (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
@end lisp

@enumerate a.

@item
Реализуйте @code{letrec} как производное выражение, переводя выражение
@code{letrec} в выражение @code{let}, как показано в тексте раздела или
в упражнении @ref{Упражнение 4.18}. То есть переменные @code{letrec}
должны создаваться в @code{let}, а затем получать значение через
@code{set!}.

@item
Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся @code{define} внутри процедуры, то
пусть пользуются обычным @code{let}. Покажите, что́ в его рассуждениях
неверно. Нарисуйте диаграмму, показывающую окружение, в котором
выполняется @math{\langle}@var{остаток тела @code{f}}@math{\rangle} во
время вычисления выражения @code{(f 5)}, если @code{f} определена как в
этом упражнении. Нарисуйте диаграмму окружений для того же вычисления,
но только с @code{let} на месте @code{letrec} в определении @code{f}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.21}Упражнение 4.21:}
Как ни удивительно, интуитивная догадка Хьюго (в @ref{Упражнение 4.20})
оказывается верной. Действительно,
можно строить рекурсивные процедуры без использования @code{letrec} (и
даже без @code{define}), только способ это сделать намного тоньше, чем
казалось Хьюго. Следующее выражение вычисляет факториал 10 с помощью
рекурсивной процедуры:@footnote{В этом примере показан программистский
трюк, позволяющий формулировать рекурсивные процедуры без помощи
@code{define}. Самый общий прием такого рода называется (Y operator), и
с его помощью можно реализовать рекурсию в <<чистом
@math{\lambda}-исчислении>>. (Подробности о лямбда-исчислении можно
найти в Stoy 1977, а демонстрацию @math{Y}-оператора на Scheme в Gabriel
1988.)}

@lisp
((lambda (n)
   ((lambda (fact) (fact fact n))
    (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
 10)
@end lisp

@enumerate a.

@item
Проверьте, что это выражение на самом деле считает факториалы (вычисляя
его). Постройте аналогичное выражение для вычисления чисел Фибоначчи.

@item
Рассмотрим следующую процедуру, включающую взаимно рекурсивные
внутренние определения:

@lisp
(define (f x)
  (define (even? n)
    (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)
    (if (= n 0) false (even? (- n 1))))
  (even? x))
@end lisp

Восстановите пропущенные фрагменты так, чтобы получилось альтернативное
определение @code{f}, где нет ни внутренних определений, ни @code{letrec}:

@lisp
(define (f x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))))
@end lisp
@end enumerate
@end quotation

@comment @subsection Separating Syntactic Analysis from Execution
@subsection Отделение синтаксического анализа от выполнения
@node	4.1.7,  , 4.1.6, 4.1

Написанный нами интерпретатор прост, но очень неэффективен, потому что
синтаксический анализ выражений перемешан в нем с их выполнением. Таким
образом, сколько раз выполняется программа, столько же раз анализируется
ее синтаксис. Рассмотрим, например, вычисление @code{(factorial 4)},
если дано следующее определение факториала:

@lisp
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
@end lisp

@noindent
Каждый раз, когда вызывается @code{factorial}, интерпретатор должен
определить, что тело процедуры является условным выражением, и извлечь
его предикат. Только после этого он может вычислить предикат и поступить
в соответствии с его значением. Каждый раз, когда вычисляется выражение
@code{(* (factorial (- n 1)) n)} или подвыражения
@code{(factorial (- n 1))} и @code{(- n 1)}, интерпретатор должен
произвести анализ случаев внутри @code{eval}, выяснить, что выражение
является вызовом процедуры, а также извлечь его оператор и операнды.
Такой анализ недёшев. Проделывать его многократно --- неразумно.

Можно преобразовать интерпретатор так, чтобы синтаксический анализ
проводился только один раз, и повысить таким образом эффективность
работы.@footnote{Такое преобразование является неотъемлемой частью
процесса компиляции, который мы рассмотрим в @ref{Глава 5}.
Джонатан Рис написал для проекта T интерпретатор Scheme с похожей
структурой приблизительно в 1982 голу (Rees and Adams 1982). Марк Фили
(Feeley 1986, см. также Feeley and Lapalme 1987) независимо изобрел этот
метод в своей дипломной работе.} Мы разбиваем процедуру @code{eval},
которая принимает выражение и окружение, на две части. @code{analyze}
берет только выражение. Она выполняет синтаксический анализ и возвращает
новую @emph{исполнительную процедуру} (@newterm{execution procedure}). В этой
процедуре упакована работа, которую придется проделать при выполнении
выражения. Исполнительная процедура берет в качестве аргумента окружение
и завершает вычисление. При этом экономится работа, потому что
@code{analyze} будет для каждого выражения вызываться только один раз, а
исполнительная процедура, возможно, многократно.

После разделения анализа и выполнения @code{eval} превращается в

@lisp
(define (eval exp env) ((analyze exp) env))
@end lisp

@noindent
Результатом вызова @code{analyze} является исполнительная процедура,
которая применяется к окружению. @code{Analyze} содержит тот же самый
анализ, который делал исходный @code{eval} из @ref{4.1.1}, однако процедуры,
между которыми мы выбираем, только анализируют, а не окончательно выполняют
выражение.

@lisp
(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else (error "Unknown expression type: ANALYZE" exp))))
@end lisp

\enlargethispage{\baselineskip}

@noindent
Вот самая простая из процедур анализа, которая обрабатывает
самовычисляющиеся выражения. Ее результатом является исполнительная
процедура, которая игнорирует свой аргумент-окружение и просто
возвращает само выражение:

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
@end lisp

@noindent
В случае кавычки мы можем добиться некоторого выигрыша, извлекая
закавыченное выражение только один раз на стадии анализа, а не на стадии
выполнения.

@lisp
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
@end lisp

@noindent
Поиск переменной нужно проводить на стадии выполнения, поскольку при
этом требуется знать окружение.@footnote{Есть, впрочем, важная часть
поиска переменной, которую все-таки @emph{можно} осуществить во время
синтаксического анализа. Как мы покажем в @ref{5.5.6}, можно
определить позицию в структуре окружения, где будет находиться нужное
значение, и таким образом избежать необходимости искать в окружении
элемент, который соответствует переменной.}

@lisp
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
@end lisp

@noindent
Анализ присваивания, @code{analyze-assignment}, также должен отложить
само присваивание до времени выполнения, когда будет в наличии
окружение. Однако возможность (рекурсивно) проанализировать выражение
@code{assignment-value} сразу, на стадии анализа, --- это большой
выигрыш в эффективности, поскольку теперь это выражение будет
анализироваться только однажды. То же верно и для определений:

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
@end lisp

@noindent
Для условных выражений мы извлекаем и анализируем предикат, следствие и
альтернативу на стадии анализа.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
@end lisp

@noindent
При анализе выражения @code{lambda} также достигается значительный
выигрыш в эффективности: тело @code{lambda} анализируется только один
раз, а процедура, получающаяся в результате выполнения @code{lambda},
может применяться многократно.

@lisp
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
@end lisp

@noindent
Анализ последовательности выражений (в @code{begin} или в теле
@code{lambda}-выражения) более сложен.@footnote{См. @ref{Упражнение 4.23},
в котором объясняются некоторые подробности обработки последовательностей.}
Каждое выражение в последовательности анализируется, и для каждого
получается исполнительная процедура. Эти исполнительные процедуры
комбинируются в одну общую исполнительную процедуру, которая принимает в
качестве аргумента окружение и последовательно вызывает каждую из
частичных исполнительных процедур, передавая ей окружение как аргумент.

@lisp
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@noindent
Для вызова процедуры мы анализируем оператор и операнды и строим
исполнительную процедуру, которая вызывает исполнительную процедуру
оператора (получая при этом объект-процедуру, которую следует применить)
и исполнительные процедуры операндов (получая аргументы). Затем мы все
это передаем в @code{execute-application}, аналог @code{apply} из @ref{4.1.1}.
@code{Execute-application} отличается от @code{apply} тем, что тело
составной процедуры уже проанализировано, так что нет нужды в дальнейшем
анализе. Вместо этого мы просто вызываем исполнительную процедуру для
тела, передавая ей расширенное окружение.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env)
       (map (lambda (aproc) (aproc env))
            aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@noindent
В нашем новом интерпретаторе используются те же структуры данных,
синтаксические процедуры и вспомогательные процедуры времени выполнения,
что и в разделах @ref{4.1.2}, @ref{4.1.3} и @ref{4.1.3}.

@endpage
@quotation
@strong{@anchor{Упражнение 4.22}Упражнение 4.22:}
Расширьте интерпретатор из этого раздела так, чтобы он
поддерживал @code{let}. (См. упражнение @ref{Упражнение 4.6}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.23}Упражнение 4.23:}
Лиза П. Хакер не понимает, зачем делать
@code{analyze-sequence} такой сложной. Все остальные процедуры
анализа --- простые трансформации соответствующих вычисляющих процедур
(или ветвей @code{eval}) из @ref{4.1.1}. Лиза ожидала, что
@code{analyze-sequence} будет выглядеть так:

@lisp
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (lambda (env)
      (execute-sequence procs env))))
@end lisp

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше
работы по вычислению последовательности во время анализа. В Лизиной
исполнительной процедуре вызовы частичных исполнительных процедур,
вместо того, чтобы быть встроенными, перебираются в цикле. В результате,
хотя отдельные выражения в последовательности оказываются
проанализированы, сама последовательность анализируется во время
выполнения.

Сравните две версии @code{analyze-sequence}. Рассмотрите, например,
обычный случай (типичный для тел процедур), когда в последовательности
только одно выражение. Какую работу будет делать исполнительная
процедура, предложенная Лизой? А процедура из текста раздела? Как
соотносятся эти две процедуры в случае последовательности из двух
выражений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.24}Упражнение 4.24:}
Спроектируйте и проведите несколько экспериментов, чтобы
сравнить скорость исходного метациклического вычислителя и его версии из
этого раздела. С помощью результатов этих опытов оцените долю времени,
которая тратится на анализ и на собственно выполнение в различных
процедурах.
@end quotation

@comment @section Variations on a Scheme --- Lazy Evaluation
@section Scheme с вариациями: ленивый интерпретатор
@node	4.2, 4.3, 4.1, Chapter 4

Теперь, имея в своем распоряжении интерпретатор, выраженный в виде
программы на Лиспе, мы можем экспериментировать с различными вариантами
строения языка, просто модифицируя этот интерпретатор. В самом деле,
часто изобретение нового языка начинается с того, что пишут
интерпретатор, который встраивает новый язык в существующий язык
высокого уровня. Например, если нам хочется обсудить какую-то деталь
предлагаемой модификации Лиспа с другим членом Лисп-сообщества, мы можем
предъявить ему интерпретатор, в котором эта модификация реализована.
Тогда наш адресат может поэкспериментировать с новым интерпретатором и
послать в ответ свои замечания в виде дальнейших модификаций. Реализация
на высокоуровневой основе не только упрощает проверку и отладку
вычислителя; такое встраивание к тому же позволяет разработчику
слизывать@footnote{Слизывать (@emph{snarf}): <<Брать, в особенности
большой документ или файл, с целью использовать с разрешения владельца
или без оного>>. Пролизывать (@emph{snarf down}): <<Слизывать, иногда с
дополнительным значением восприятия, переработки или понимания>>. (Эти
определения были слизаны из Steele et al. 1983. См. также Raymond
1993.)} черты языка-основы, как наш встроенный интерпретатор Лиспа
использовал примитивы и структуру управления нижележащего Лиспа. Только
позже (да и то не всегда) разработчику приходится брать на себя труд
построения полной реализации на низкоуровневом языке или в аппаратуре. В
этом разделе и следующем мы изучаем некоторые вариации на тему Scheme,
которые значительно увеличивают ее выразительную силу.

@menu
* 4-2-1::            Нормальный πорядок вычислений и аππликативный
* 4-2-2::            Интерπретатор с ленивым вычислением
* 4-2-3::            Потоки как ленивые сπиски
@end menu

@comment @subsection Normal Order and Applicative Order
@subsection Нормальный порядок вычислений и аппликативный порядок
@node	4.2.1, 4.2.2, 4.2, 4.2

В @ref{1.1}, где мы начали обсуждение моделей вычисления, мы указали, что
Scheme --- язык с (@newterm{applicative-order language}), а именно, что все
аргументы процедур в Scheme вычисляются в момент вызова. Напротив, в языках с
(@newterm{normal-order language}) вычисление аргументов процедур задерживается
до момента, когда действительно возникает нужда в их значениях. Если
вычисление аргументов процедур откладывается как можно дольше (например,
до того момента, когда они требуются какой-либо элементарной процедуре),
то говорят о @emph{ленивом вычислении} (@newterm{lazy evaluation}).
@footnote{Терминологическая разница между выражениями <<ленивый>> и
<<нормальный порядок вычислений>> несколько размыта.
Обычно <<ленивый>> относится к механизмам конкретных интерпретаторов, а
<<нормальный порядок>> к семантике языков независимо от способа
реализации. Однако разделение здесь не жесткое, и часто эти термины
употребляются как синонимы.} Рассмотрим процедуру

@lisp
(define (try a b) (if (= a 0) 1 b))
@end lisp

@noindent
Выполнение @code{(try 0 (/ 1 0))} в Scheme приводит к ошибке. При
ленивых вычислениях никакой ошибки не возникнет. Вычисление выражения
даст результат 1, поскольку к аргументу @code{(/ 1 0)} обращаться не
понадобится.

Примером использования ленивых вычислений может служить процедура
@code{unless}:

@lisp
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
@end lisp

@noindent
которую можно использовать в выражениях вроде

@lisp
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0") 0))
@end lisp

@noindent
В аппликативном языке это не будет работать, потому что и обычное
значение, и значение исключения будут выполнены еще до вызова
@code{unless} (См. упражнение @ref{Упражнение 1.6}). Преимущество
ленивых вычислений в том, что некоторые процедуры, например, та же
@code{unless}, могут выполнять полезные действия, даже если вычисление
некоторых их аргументов способно привести к ошибке или бесконечному
циклу.

Если тело процедуры начинает выполняться прежде, чем вычисляется ее
аргумент, то процедура называется (non-strict) по этому аргументу. Если
же аргумент вычисляется прежде, чем происходит вход в процедуру, то
процедура называется (strict) по этому аргументу.@footnote{Термины
<<строгий>> и <<нестрогий>> означают, в сущности, то же самое, что
<<аппликативный>> и <<нормальный>> порядок вычислений, но только они
относятся к отдельным процедурам и их аргументам, а не к языку в целом.
На конференциях по языкам программирования можно услышать, как
кто-нибудь говорит: <<В языке Hassle с нормальным порядком вычислений
есть несколько строгих примитивов. Остальные процедуры принимают
аргументы через ленивое вычисление>>.} В чисто аппликативном языке все
процедуры строги по всем своим аргументам. В языке с чисто нормальным
порядком вычислений все составные процедуры нестроги по всем своим
аргументам, а элементарные процедуры могут быть и такими, и такими.
Бывают также языки (см. упражнение @ref{Упражнение 4.31}), которые
дают программисту возможность явно обозначать строгость определяемых им
процедур.

Яркий пример процедуры, которой может быть полезно оказаться
нестрогой, --- это @code{cons} (и вообще почти любой конструктор
структур данных). Можно производить полезные вычисления, составлять из
элементов структуры данных и работать с ними, даже если значения
элементов неизвестны. Вполне имеет смысл задача, например, посчитать
длину списка, не зная значений его отдельных элементов. В
@ref{4.2.3} мы развиваем эту идею и реализуем потоки из @ref{Глава 3}
в виде списков, составленных из нестрогих @code{cons}-пар.

@quotation
@strong{@anchor{Упражнение 4.25}Упражнение 4.25:}
Предположим, что мы (в обычной Scheme с аппликативным
порядком вычислений) определяем @code{unless} как показано выше, а затем
определяем @code{factorial} через @code{unless}:

@lisp
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
@end lisp

Что произойдет, если мы попытаемся вычислить @code{(factorial 5)}? Будут
ли наши определения работать в языке с нормальным порядком вычислений?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.26}Упражнение 4.26:}
Бен Битобор и Лиза П. Хакер расходятся во мнениях о
важности ленивых вычислений для реализации конструкций вроде
@code{unless}. Бен указывает, что при аппликативном порядке
@code{unless} можно реализовать как особую форму. Лиза отвечает, что в
таком случае @code{unless} будет просто синтаксисом, а не процедурой,
которую можно использовать в сочетании с процедурами высших порядков.
Проясните детали в обеих позициях. Покажите, как реализовать
@code{unless} в виде производного выражения (вроде @code{cond} или
@code{let}), и приведите пример ситуации, когда имеет смысл, чтобы
@code{unless} была процедурой, а не особой формой.
@end quotation

@comment @subsection An Interpreter with Lazy Evaluation
@subsection Интерпретатор с ленивым вычислением
@node	4.2.2, 4.2.3, 4.2.1, 4.2

В этом разделе мы реализуем язык с нормальным порядком вычислений,
который отличается от Scheme только тем, что все составные процедуры по
всем аргументам нестроги. Элементарные процедуры по-прежнему будут
строгими. Совсем несложно, модифицируя интерпретатор из раздела
@ref{4.1.1}, добиться, чтобы интерпретируемый
язык вел себя таким образом. Почти что все требуемые изменения
сосредоточены вокруг механизма процедурного вызова.

Основная идея состоит в том, что при вызове процедуры интерпретатор
должен определить, какие аргументы требуется вычислить, а какие
задержать. Задержанные аргументы не вычисляются, а преобразуются в
объекты, называемые (@newterm{thunks}).@footnote{Название <<санк>> было
придумано в неформальной группе, которая обсуждала реализацию вызова по имени в
Алголе 60. Было замечено, что большую часть анализа (<<обдумывания>>,
@emph{thinking about}) выражения можно производить во время компиляции;
таким образом, во время выполнения выражение будет уже большей частью
<<обдумано>> (@emph{thunk about} --- намеренно неверно образованная
английская форма) (Ingerman et al. 1960).} В санке должна содержаться
информация, необходимая, чтобы вычислить значение аргумента, когда оно
потребуется, и сделать это так, как будто оно вычислено во время вызова.
Таким образом, санк должен содержать выражение-аргумент и окружение, в
котором вычисляется вызов процедуры.

Процесс вычисления санка называется (@newterm{forcing}).@footnote{Это
аналогично использованию слова @code{force} (<<вынудить>>,
<<заставить>>) для задержанных объектов, при помощи которых в @ref{Глава 3}
представлялись потоки. Основная разница между тем, что мы делаем здесь,
и тем, чем мы занимались в @ref{Глава 3},
состоит в том, что теперь мы встраиваем задержку и вынуждение в
интерпретатор, и они применяются автоматически и единообразно во всем
языке.} Вообще говоря, санк вынуждается только тогда, когда требуется
его значение: когда он передается в элементарную процедуру, использующую
его значение; когда он служит предикатом в условном выражении; или когда
он является значением оператора, который нужно применить как процедуру.
Мы должны решить, будем ли мы (@newterm{memoize}) санки, как мы делали с
задержанными объектами в @ref{3.5.1}.
При использовании мемоизации, когда санк вынуждается в первый раз, он
запоминает вычисленное значение. Последующие вызовы только возвращают
запомненное значение, не вычисляя его заново. Мы делаем выбор в пользу
мемоизации, поскольку для многих приложений это эффективнее. Здесь,
однако, имеются тонкости.@footnote{Ленивые вычисления, совмещенные с
мемоизацией, иногда называют методом передачи аргументов с
(@newterm{call by need}), в отличие от (@newterm{call-by-name}). (Вызов
по имени, введенный в Алголе 60, аналогичен немемоизированному ленивому
вычислению.) Как проектировщики языка мы можем сделать интерпретатор
мемоизирующим или немемоизирующим, или же оставить это на усмотрение
программистов (упражнение @ref{Упражнение 4.31}). Как можно было ожидать
из @ref{Глава 3}, этот выбор вызывает к жизни вопросы, особенно тонкие и
запутанные в присутствии присваивания. (См. упражнения @ref{Упражнение 4.27}
и @ref{Упражнение 4.29}.) В замечательной статье Клингера (Clinger 1982)
делается попытка прояснить многомерную путаницу, которая здесь возникает.}

@comment @subsubheading Modifying the evaluator
@subsubheading Преобразование интерпретатора

Основная разница между ленивым интерпретатором и интерпретатором из @ref{4.1}
состоит в обработке вызовов процедур внутри @code{eval} и @code{apply}.

Ветка @code{application?} в @code{eval} принимает вид

@lisp
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
@end lisp

@noindent
Это почти тот же код, что был в ветке @code{application?} в @code{eval}
из @ref{}. Однако при ленивом
вычислении мы зовем @code{apply} с выражениями операндов, а не с
аргументами, которые получаются при их вычислении. Мы также передаем
@code{apply} окружение, поскольку оно понадобится для построения санков,
если нам хочется, чтобы аргуметы вычислялись с задержкой. Оператор мы
по-прежнему вычисляем, потому что сама применяемая процедура нужна
@code{apply}, чтобы выбрать действие на основании ее типа (элементарная
или составная) и применить ее.

Всякий раз, когда нам требуется собственно значение выражения, мы вместо
простого @code{eval} пользуемся процедурой

@lisp
(define (actual-value exp env)
  (force-it (eval exp env)))
@end lisp

@noindent
чтобы, если значение выражения является санком, оно было вынуждено.

Наша новая версия @code{apply} также почти совпадает с версией из @ref{4.1.1}.
Разница состоит в том, что @code{eval} передает ей невычисленные выражения:
для элементарных процедур (они строгие) мы вычисляем все аргументы и затем
вызываем примитив; для составных процедур (они нестрогие) мы прежде применения
процедуры замораживаем все аргументы.

@lisp
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))   @r{; изменение}
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)  @r{; изменение}
           (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY"
                     procedure))))
@end lisp

@noindent
Процедуры, обрабатывающие аргументы, почти такие же, как @code{list-of-values}
из @ref{4.1.1}, но только @code{list-of-delayed-args} замораживает аргументы,
вместо того, чтобы их вычислять, а в @code{list-of-arg-values} вместо
@code{eval} используется @code{actual-value}:

@lisp
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))
(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
@end lisp

@noindent
Кроме того, нам требуется изменить в интерпретаторе обработку @code{if},
где вместо @code{eval} мы должны вызывать @code{ actual-value}, чтобы
значение предикатного выражения вычислялось прежде, чем мы проверим,
истинно оно или ложно:

@lisp
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
@end lisp

@noindent
Наконец, нужно изменить процедуру @code{driver-loop} (@ref{4.1.4}), чтобы она
звала @code{actual-value} вместо @code{eval}. Таким образом, если
задержанное значение добирается до цикла чтение-вычисление-печать, то
оно, прежде чем печататься, будет разморожено. Кроме того, чтобы
показать, что работа идет с ленивым интерпретатором, мы изменим подсказки:

@lisp
(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value
            input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
@end lisp

@noindent
Внеся эти изменения, мы можем запустить интерпретатор и протестировать
его. Успешное вычисление выражения @code{try}, описанного в @ref{4.2.1},
показывает, что интерпретатор проводит ленивое вычисление:

@lisp
(define the-global-environment (setup-environment))
(driver-loop)
@i{;;; L-Eval input:}
(define (try a b) (if (= a 0) 1 b))
@i{;;; L-Eval value:}
@i{ok}
@i{;;; L-Eval input:}
(try 0 (/ 1 0))
@i{;;; L-Eval value:}
@i{1}
@end lisp

@comment @subsubheading Representing thunks
@subsubheading Представление санков

Наш интерпретатор должен устроить работу так, чтобы при применении
процедур к аргументам порождались санки, и чтобы потом они вынуждались.
Выражение в санке должно запаковываться вместе с окружением, так, чтобы
потом можно было по ним вычислить аргумент. Чтобы вынудить санк, мы
просто извлекаем из него выражение и окружение, и вычисляем выражение в
окружении. Мы используем при этом не @code{eval}, а @code{actual-value},
так что если результат выражения сам окажется санком, мы и его вынудим,
и так пока не доберемся до не-санка.

@lisp
(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
@end lisp

@noindent
Простой способ упаковать выражение вместе с окружением --- создать
список из выражения и окружения. Таким образом, мы порождаем санк так:

@lisp
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr  thunk))
(define (thunk-env thunk) (caddr thunk))
@end lisp

@noindent
Однако на самом деле нам в интерпретаторе нужны не такие санки, а
мемоизированные. Мы сделаем так, чтобы санк при вынуждении превращался в
вычисленный санк. Для этого мы будем заменять хранимое в нем выражение
на значение и менять метку санка, чтобы можно было понять, что он уже
вычислен.@footnote{Заметим, что, вычислив выражение, мы еще и стираем из
санка окружение. Это не влияет на то, какие значения возвращает
интерпретатор. Однако при этом экономится память, поскольку стирание
ссылки из санка на @code{env}, когда она становится больше не нужна,
позволяет подвергнуть эту структуру (@newterm{garbage collection}) и заново
использовать ее память. Мы обсудим это в @ref{5.3}.

Подобным образом можно было бы разрешить собирать как мусор ненужные
окружения в мемоизированных задержанных объектах из @ref{3.5.1}:
@code{memo-proc}, сохранив значение процедуры @code{proc}, делала бы
что-нибудь вроде @code{(set! proc '())}, чтобы забыть саму процедуру
(включающую окружение, где было вычислено @code{delay}).}

@lisp
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk)
  (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj)
                                     (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj)
                     result)     @r{; replace @code{exp} with its value}
           (set-cdr! (cdr obj)
                     '())        @r{; forget unneeded @code{env}}
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
@end lisp

@noindent
Заметим, что одна и та же процедура @code{delay-it} работает и с
мемоизацией, и без нее.

@quotation
@strong{@anchor{Упражнение 4.27}Упражнение 4.27:}
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

@lisp
(define count 0)
(define (id x) (set! count (+ count 1)) x)
@end lisp

Вставьте пропущенные значения в данной ниже последовательности действий
и объясните свои ответы.@footnote{Это упражнение показывает, что
взаимодействие между ленивыми вычислениями и побочными эффектами может
быть весьма запутанным. Ровно этого можно было ожидать после обсуждения в
@ref{Глава 3}.}

@lisp
(define w (id (id 10)))
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
w
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.28}Упражнение 4.28:}
@code{Eval}, передавая оператор в @code{apply}, вычисляет
его не при помощи @code{eval}, а через @code{actual-value}, чтобы
вынудить. Приведите пример, который показывает, что такое вынуждение
необходимо.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.29}Упражнение 4.29:}
Придумайте пример программы, которая, по Вашему мнению,
будет работать намного медленнее без мемоизации, чем с мемоизацией.
Рассмотрим, помимо этого, следующую последовательность действий, в
которой процедура @code{id} определена как в
упражнении @ref{Упражнение 4.27}, а счетчик @code{count} начинает с 0:

@lisp
(define (square x) (* x x))
@i{;;; L-Eval input:}
(square (id 10))
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@i{;;; L-Eval input:}
count
@i{;;; L-Eval value:}
@math{\langle}@var{response}@math{\rangle}
@end lisp

Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.30}Упражнение 4.30:}
Пабло Э. Фект, бывший программист на языке C,
беспокоится, что ленивый интерпретатор не вынуждает выражения в
последовательности, и оттого некоторые побочные эффекты могут никогда не
произойти. Поскольку ни у одного выражения в последовательности, помимо
конечного, значение не используется (выражение стоит там только ради
своего эффекта, например, чтобы присвоить значение переменной или
что-нибудь напечатать), у значения такого выражения не может
впоследствии быть применения, для которого его потребуется вынудить
(например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
@code{eval-sequence} из @ref{4.1.1}
так, чтобы она вместо @code{eval} использовала @code{actual-value}:

@lisp
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
@end lisp

@enumerate a.

@item
Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
@code{for-each} из упражнения @ref{Упражнение 2.23} --- важный пример
последовательности с побочными эффектами:

@lisp
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
@end lisp

Он утверждает, что интерпретатор из текста (с исходным @code{eval-sequence})
правильно работает с этой процедурой:

@lisp
@i{;;; L-Eval input:}
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
@i{57}
@i{321}
@i{88}
@i{;;; L-Eval value:}
@i{done}
@end lisp

Объясните, почему Бен прав насчет поведения @code{for-each}.

@item
Пабло соглашается с Беном по поводу примера с @code{for-each}, но
говорит, что, предлагая изменить @code{eval-sequence}, он имел в виду
другой тип программ. Он определяет в ленивом интерпретаторе следующие
две процедуры:

@lisp
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
@end lisp

Какие значения вернут @code{(p1 1)} и @code{(p2 1)} с исходной
@code{eval-sequence}? Каковы будут значения с изменением, которое
предлагает Пабло?

@item
Пабло указывает также, что изменение @code{eval-sequence}, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

@item
Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.31}Упражнение 4.31:}
Подход, принятый в этом разделе, нехорош тем, что вносит
изменение в Scheme, не сохраняя ее семантику. Было бы приятнее
реализовать ленивые вычисления как (@newterm{upward-compatible extension}), то
есть так, чтобы обычные программы на Scheme работали как прежде. Этого
можно добиться, расширив синтаксис определений процедур, так, чтобы
пользователь мог решать, нужно ли задерживать аргументы. При этом можно
еще предоставить пользователю выбор между задержкой с мемоизацией и без
нее. Например, определение

@lisp
(define (f a (b lazy) c (d lazy-memo))
  @dots{})
@end lisp

@noindent
делало бы @code{f} процедурой от четырех аргументов, причем первый и
третий вычисляются при вызове процедуры, второй задерживается, а
четвертый задерживается и мемоизируется. Таким образом, обыкновенные
определения процедур будут задавать такое же поведение, как в обычной
Scheme, а добавление декларации @code{lazy-memo} к каждому параметру
каждой составной процедуры приведет к поведению, как у ленивого
интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового
синтаксиса @code{define}. Кроме того, надо будет добиться, чтобы
@code{eval} и @code{apply} определяли, когда надо задерживать аргументы,
и соответствующим образом задерживали и вынуждали их. Наконец, придется
обеспечить,чтобы вынуждение было с мемоизацией или без оной, смотря по
обстоятельствам.
@end quotation

@comment @subsection Streams as Lazy Lists
@subsection Потоки как ленивые списки
@node	4.2.3,  , 4.2.2, 4.2

В @ref{3.5.1} мы показали, как реализовать потоки в виде задержанных списков.
Мы ввели особые формы @code{delay} и @code{cons-stream}, которые позволили нам
строить <<обещания>> вычислить @code{cdr} потока, не выполняя эти
обещания до более позднего времени. Можно было бы использовать этот же
метод и вводить новые особые формы всякий раз, когда нам требуется
детальное управление процессом вычисления, но это было бы весьма
неуклюже. Прежде всего, особая форма, в отличие от процедуры, не
является полноправным объектом, и ее нельзя использовать в сочетании с
процедурами высших порядков.@footnote{Это как раз тот вопрос, который
возник по отношению к процедуре @code{unless} в @ref{Упражнение 4.26}.}
Кроме того, нам пришлось ввести
потоки как новый тип объектов данных, похожий на списки, но отличный от
них, и из-за этого потребовалось заново переписать для работы с потоками
множество обычных операций над списками (@code{map}, @code{append} и
тому подобное).

Когда у нас есть ленивое вычисление, списки и потоки можно считать одним
и тем же типом, так что не возникает нужды в особых формах и в отдельных
наборах операций для списков и потоков. Все, что нам требуется, --- это
так устроить дела, чтобы @code{cons} оказалась нестрогой. Можно сделать
это, расширив интерпретатор и разрешив нестрогие элементарные процедуры,
а затем реализовать @code{cons} как одну из таких процедур. Однако проще
вспомнить (из @ref{2.1.3}), что
вообще не существует особой нужды реализовывать @code{cons} как
примитив. Вместо этого можно представлять пары в виде
процедур:@footnote{Это процедурное представление, описанное в
упражнении @ref{Упражнение 2.4}. В сущности, подошла бы и любая другая
процедурная реализация (например, на основе передачи сообщений).
Обратите внимание, что внести эти определения в ленивый интерпретатор
можно, просто набрав их в управляющем цикле. Если мы изначально включили
@code{cons}, @code{car} и @code{cdr} как примитивы в глобальное
окружение, они будут переопределены. (См. также @ref{Упражнение 4.33} и @ref{Уπражнение 4.34}.)}

@lisp
(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))
@end lisp

@noindent
Выраженные через эти базовые операции, стандартные определения операций
над списками будут работать как с бесконечными списками (потоками), так
и с конечными, а потоковые операции можно определить как операции над
списками. Вот несколько примеров:

@lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items)) (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
(define ones (cons 1 ones))
(define integers (cons 1 (add-lists ones integers)))
@i{;;; L-Eval input:}
(list-ref integers 17)
@i{;;; L-Eval value:}
@i{18}
@end lisp

@noindent
Заметим, что ленивые списки еще ленивее, чем потоки в @ref{Глава 3}:
задерживается не только @code{cdr} списка, но и @code{car}.
@footnote{Благодаря этому можно реализовать задержанные версии
не только последовательностей, но и более общих видов списковых
структур. В Hughes 1990 обсуждаются некоторые применения <<ленивых
деревьев>>.} На самом деле, даже доступ к @code{car} или @code{cdr}
ленивой пары не обязательно вынуждает значение элемента списка. Значение
будет вынуждено только тогда, когда это действительно нужно ---
например, чтобы использовать его в качестве аргумента примитива или
напечатать в качестве ответа.

Ленивые пары также помогают с решением проблемы, которая возникла в @ref{3.5.4},
где мы обнаружили, что формулировка потоковых моделей систем с циклами
может потребовать оснащения программы явными операциями @code{delay},
помимо тех, что встроены в @code{cons-stream}. При ленивом вычислении
все аргументы процедур единообразно задерживаются. Например, можно
реализовать процедуры для интегрирования списка и решения
дифференциальных уравнений так, как мы изначально намеревались в @ref{3.5.4}:

@lisp
(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) int)))
  int)
(define (solve f y0 dt)
  (define  y (integral dy y0 dt))
  (define dy (map f y))
  y)
@i{;;; L-Eval input:}
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
@i{;;; L-Eval value:}
@i{2.716924}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.32}Упражнение 4.32:}
Приведите несколько примеров, которые показывают разницу между потоками из
@ref{Глава 3} и <<более ленивыми>> списками, описанными в этом разделе.
Как можно воспользоваться этой дополнительной ленивостью?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.33}Упражнение 4.33:}
Бен Битобор проверяет вышеописанную реализацию при помощи выражения

@lisp
(car '(a b c))
@end lisp

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что <<списки>>. которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями
@code{cons}, @code{car} и @code{cdr}. Измените работу интерпретатора с
закавыченными выражениями так, чтобы при вводе списковых выражений в
цикле управления получались настоящие ленивые списки.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.34}Упражнение 4.34:}
Измените управляющий цикл интерпретатора так, чтобы
ленивые пары и списки печатались каким-либо разумным образом. (Как Вы
собираетесь работать с бесконечными списками)? Вероятно, понадобится
также изменить представление ленивых пар, чтобы при печати интерпретатор
их распознавал и печатал особым образом.
@end quotation

@comment @section Variations on a Scheme --- Nondeterministic Computing
@section Scheme с вариациями --- недетерминистское вычисление
@node	4.3, 4.4, 4.2, Chapter 4

В этом разделе мы расширяем интерпретатор Scheme так, чтобы он поддерживал
парадигму программирования, называемую (@newterm{nondeterministic computing}),
встраивая в интерпретатор средства поддержки автоматического поиска. Это
значительно более глубокое изменение в языке, чем введение ленивых вычислений в
@ref{Часть 4.2}.

Подобно обработке потоков, недетерминистское вычисление полезно в
задачах типа <<порождение и проверка>>. Рассмотрим такую задачу: даются
два списка натуральных чисел, и требуется найти пару чисел --- одно из
первого списка, другое из второго, --- сумма которых есть простое число. В
@ref{2.2.3} мы уже рассмотрели, как это можно сделать при помощи операций над
конечными последовательностями, а в @ref{3.5.3} ---
при помощи бесконечных потоков. Наш подход состоял в том, чтобы породить
последовательность всех возможных пар и отфильтровать ее, выбирая пары,
в которых сумма есть простое число. Порождаем ли мы на самом деле
сначала всю последовательность, как в @ref{Глава 2},
или чередуем порождение и фильтрацию, как в @ref{Глава 3},
несущественно для общей картины того, как организовано вычисление.

\enlargethispage{\baselineskip}

При недетерминистском подходе используется другой образ. Просто
представим себе, что мы (каким-то образом) выбираем число из первого
списка и число из второго списка, а затем предъявляем (при помощи
какого-то механизма) требование, чтобы их сумма была простым числом. Это
выражается следующей процедурой:

@lisp
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
@end lisp

@noindent
Может показаться, что эта процедура просто переформулирует задачу, а не
указывает способ ее решить. Однако это законная недетерминистская
программа.@footnote{Мы предполагаем, что уже заранее определена процедура
@code{prime?}, которая проверяет числа на простоту. Даже если такая
процедура определена, @code{prime-sum-pair} может подозрительно
напоминать бестолковую попытку определения квадратного корня на
псевдо-Лиспе из начала @ref{1.1.7}.
На самом деле, подобного рода процедура вычисления квадратного корня
может быть сформулирована в виде недетерминистской программы. Вводя в
интерпретатор механизм поиска, мы размываем границу между чисто
декларативными описаниями и императивными спецификациями способов
вычислить ответ. В @ref{4.4} мы пойдем еще дальше в этом направлении.}

Основная идея здесь состоит в том, что выражениям в недетерминистском
языке разрешается иметь более одного возможного значения. Например,
@code{an-element-of} может вернуть любой элемент данного списка. Наш
интерпретатор недетерминистских программ будет автоматически выбирать
возможное значение и запоминать, что он выбрал. Если впоследствии
какое-либо требование не будет выполнено, интерпретатор попробует другой
вариант выбора и будет перебирать варианты, пока вычисление не
закончится успешно или пока варианты не иссякнут. Подобно тому, как
ленивый интерпретатор освобождал программиста от заботы о деталях
задержки и вынуждения значений, недетерминистский интерпретатор
позволяет ему не заботиться о том, как происходит выбор.

Поучительно будет сравнить различные понятия времени, складывающиеся при
недетерминистских вычислениях и обработке потоков. При обработке потоков
ленивые вычисления используются для того, чтобы устранить связь между
временем, когда строится поток возможных ответов, и временем, когда
порождаются собственно ответы. Интерпретатор создает иллюзию, что все
возможные ответы предоставлены нам во вневременной последовательности.
При недетерминистских вычислениях выражение представляет собой
исследование множества возможных миров, каждый из которых определяется
множеством выбранных вариантов. Некоторые возможные миры приводят в
тупик, другие дают полезные ответы. Вычислитель недетерминистских
программ создает иллюзию, что время разветвляется, и что у наших
программ есть различные возможные истории исполнения. Если мы
оказываемся в тупике, мы можем вернуться к последней точке выбора и
продолжить путь по другой ветке.

Описываемый в этом разделе интерпретатор недетерминистских программ
называется @code{amb}-интерпретатор, потому что он основан на новой
особой форме @code{amb}. Мы можем ввести вышеприведенное определение
@code{prime-sum-pair} в управляющем цикле @code{amb}-интерпретатора
(наряду с определениями @code{prime?}, @code{an-element-of} и @code{require})
и запустить процедуру:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}
@end lisp

@noindent
Возвращенное значение было получено после того, как интерпретатор сделал
несколько попыток выбора из каждого списка, последняя из которых
оказалась успешной.

В @ref{4.3.1} и показывается, как она поддерживает недетерминизм через механизм
поиска, встроенный в интерпретатор. В @ref{4.3.2} приводятся примеры
недетерминистских программ, а @ref{4.3.3} содержит подробности
того, как реализовать @code{amb}-интерпретатор путем модификации
обычного интерпретатора Scheme.

@menu
* 4-3-1::            Amb и Search
* 4-3-2::            Примеры недетерминистских πрограмм
* 4-3-3::            Реализация @code{amb}-интерπретатора
@end menu

@comment @subsection Amb and Search
@subsection @code{Amb} и @code{search}
@node	4.3.1, 4.3.2, 4.3, 4.3

Чтобы расширить Scheme и поддержать недетерминистское программирование,
мы вводим новую особую форму @code{amb}.@footnote{Идея недетерминистского
программирования с помощью @code{amb}-выражений впервые была описана
Джоном Маккарти в 1961 году (см. McCarthy 1967).} Выражение

@lisp
(amb @math{\langle}@var{e}@math{_{\mono{1}}\rangle} @math{\langle}@var{e}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{e}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
возвращает <<произвольным образом>> значение одного из @math{n}
выражений @math{\langle}@math{e_i}@math{\rangle}.  Например, выражение

@lisp
(list (amb 1 2 3) (amb 'a 'b))
@end lisp

@noindent
имеет шесть возможных значений:

@lisp
@code{(1 a)} @code{(1 b)} @code{(2 a)} @code{(2 b)} @code{(3 a)} @code{(3 b)}
@end lisp

@noindent
@code{amb} с одним вариантом возвращает обыкновенное (одно) значение.

@noindent
@code{amb} без вариантов --- выражение @code{(amb)} --- является
выражением без приемлемых значений. С операционной точки зрения,
выполнение выражения @code{(amb)} приводит к <<неудаче>> в вычислении:
выполнение обрывается, и никакого значения не возвращается. При помощи
этого выражения можно следующим образом выразить требование, чтобы
выполнялось предикатное выражение @code{p}:

@lisp
(define (require p) (if (not p) (amb)))
@end lisp

@noindent
Через @code{amb} и @code{require} можно реализовать процедуру
@code{an-element-of}, используемую выше:

@lisp
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
@end lisp

@noindent
Если список пуст, @code{an-element-of} терпит неудачу. В противном
случае он произвольным образом возвращает либо первый элемент списка,
либо элемент, выбранный из хвоста списка.

Можно также выразить выбор из бесконечного множества. Следующая
процедура произвольным образом возвращает целое число, большее или
равное некоторому данному @code{n}:

@lisp
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
@end lisp

@noindent
Это похоже на потоковую процедуру @code{integers-starting-from}, описанную в
@ref{3.5.2}, но есть важное различие: потоковая процедура возвращает поток,
который представляет последовательность всех целых чисел, начиная с
@code{n}, а процедура, написанная через @code{amb}, выдает одно целое
число.@footnote{На самом деле, различие между произвольным выбором с
возвратом единственного значения и возвратом всех возможных значений
выбора определяется в некоторой степени точкой зрения. С точки зрения
того кода, который использует значение, недетерминистский выбор
возвращает одно значение. С точки зрения программиста, проектирующего
код, недетерминистский выбор потенциально возвращает все возможные
значения, а вычисление разветвляется, вследствие чего каждое значение
исследуется отдельно.}

Мысля абстрактно, мы можем представить, что выполнение выражения
@code{amb} заставляет время разветвиться, и на каждой ветке оно
продолжается с одним из возможных значений выбора. Мы говорим, что @code{amb}
представляет собой (@newterm{nondeterministic choice point}). Если бы у
нас была машина с достаточным числом процессоров, которые можно было бы
динамически выделять, то поиск можно было бы реализовать напрямую.
Выполнение происходило бы, как в последовательной машине, пока не
встретится выражение @code{amb}. В этот момент выделялись и
инициализировались бы дополнительные процессоры, которые продолжали бы
все параллельные потоки выполнения, обусловленные выбором. Каждый
процессор продолжал бы последовательное выполнение одного из потоков,
как если бы он был единственным, пока поток не оборвется, потерпев
неудачу, не разделится сам или не завершится.@footnote{Можно возразить,
что этот механизм безнадежно неэффективен. Чтобы решить какую-нибудь
просто сформулированную задачу таким образом, могут потребоваться
миллионы процессоров, и бо́льшую часть времени бо́льшая часть этих
процессоров будет ничем не занята. Это возражение нужно воспринимать в
контексте истории. Память раньше точно так же считалась дорогим
ресурсом. В 1964 году мегабайт памяти стоил 400 000 долларов. Сейчас в
каждом персональном компьютере имеется много мегабайтов памяти, и
бо́льшую часть времени бо́льшая часть этой памяти не используется. Трудно
недооценить стоимость электроники при массовом производстве.}

С другой стороны, если у нас есть машина, которая способна выполнять
только один процесс (или небольшое число параллельных процессов),
альтернативы приходится рассматривать последовательно. Можно представить
себе интерпретатор, который в каждой точке выбора произвольным образом
выбирает, по какой ветке продолжить выполнение. Однако случайный выбор
может легко привести к неудачам. Можно было бы запускать такой
интерпретатор многократно, делая случайный выбор и надеясь, что в конце
концов мы получим требуемое значение, но лучше проводить (systematic
search) среди всех возможных путей выполнения. @code{Amb}-интерпретатор,
который мы разработаем в этом разделе, реализует систематический поиск
следующим образом: когда интерпретатор встречает выражение @code{amb},
он сначала выбирает первый вариант. Такой выбор может в дальнейшем
привести к другим точкам выбора. В каждой точке выбора интерпретатор
сначала будет выбирать первый вариант. Если выбор приводит к неудаче,
интерпретатор автомагически@footnote{Автомагически: <<Автоматически, но
при этом таким способом, который говорящий почему-либо (обычно либо
из-за его сложности, либо уродливости, или даже тривиальности) не
склонен объяснять>>. (Steele 1983; Raymond 1993)} (backtracks) к
последней точке выбора и пробует следующий вариант. Если в какой-то
точке выбора варианты исчерпаны, интерпретатор возвращается к предыдущей
точке выбора и продолжает оттуда. Такой процесс реализует стратегию
поиска, которую называют (depth-first search) или (chronological
backtracking).@footnote{У встраивания стратегий автоматического
поиска в языки программирования долгая и пестрая история. Первые
предположения, что недетерминистские алгоритмы можно изящно реализовать
в языке программирования с поиском и автоматическим возвратом,
высказывались Робертом Флойдом (Floyd 1967). Карл Хьюитт (Hewitt 1969)
изобрел язык программирования Плэнер (Planner), который явным образом
поддерживал автоматический хронологический поиск в возвратом,
обеспечивая встроенную стратегию поиска в глубину. Сассман, Виноград и
Чарняк (Sussman, Winograd, and Charniak 1971) реализовали подмножество
этого языка, названное ими МикроПлэнер (MicroPlanner), которое
использовалось в работе по автоматическому решению задач и планированию
действий роботов. Похожие идеи, основанные на логике и доказательстве
теорем, привели к созданию в Эдинбурге и Марселе изящного языка Пролог
(Prolog) (который мы обсудим в @ref{4.4}).
Разочаровавшись в автоматическом поиске, Макдермот и Сассман (McDermott
and Sussman 1972) разработали язык Коннивер (Conniver), в котором
имелись механизмы, позволявшие программисту управлять стратегией поиска.
Однако это оказалось слишком громоздким, и Сассман и Столлман (Sussman
and Stallman 1975) нашли более удобный в обращении подход, когда
исследовали методы символьного анализа электрических цепей. Они
разработали схему нехронологического поиска с возвратом, которая была
основана на отслеживании логических зависимостей, связывающих факты, и
стала известна как метод (@newterm{dependency-directed backtracking}). При всей
своей сложности, их метод позволял строить достаточно эффективные
программы, так как почти не проводилось излишнего поиска. Дойл (Doyle
1979) и Макаллестер (McAllester 1978; McAllester 1980) обобщили и
сделали более ясными идеи Столлмана и Сассмана, разработав новую
парадигму для формулирования поиска, называемую сейчас (truth
maintenance). Все современные системы решения задач основаны на
какой-либо форме поддержания истины. У Форбуса и де Клеера (Forbus and
deKleer 1993) можно найти обсуждение изящных способов строить системы с
поддержанием истины и приложения, в которых используется поддержание
истины. Заби, Макаллестер и Чепман (Zabih, McAllester, and Chapman 1987)
описывают недетерминистское расширение Scheme, основанное на @code{amb};
оно похоже на интерпретатор, обсуждаемый в этом разделе, но более
сложно, поскольку использует поиск с возвратом, управляемый
зависимостями, а не хронологический. Уинстон (Winston 1992) дает
введение в обе разновидности поиска с возвратом.}.

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора не совсем обычен. Он
считывает выражение и печатает значение первого успешного вычисления,
как в примере с @code{prime-sum-pair} в начале раздела. Если нам хочется
увидеть значение следующего успешного выполнения, мы можем попросить
интерпретатор вернуться и попробовать породить значение следующего
успешного выполнения. Для этого нужно ввести символ . Если вводится
какое-то другое выражение, а не @code{try-again}, интерпретатор начнет
решать новую задачу, отбрасывая неисследованные варианты предыдущей. Вот
пример работы с интерпретатором:

@lisp
@i{;;; Amb-Eval input:}
(prime-sum-pair '(1 3 5 8) '(20 35 110))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(3 20)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(3 110)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(8 35)}

@i{;;; Amb-Eval input:}
try-again
@i{;;; There are no more values of}
@i{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}

@i{;;; Amb-Eval input:}
(prime-sum-pair '(19 27 30) '(11 36 58))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(30 11)}
@end lisp

@quotation
@strong{@anchor{Упражнение 4.35}Упражнение 4.35:}
Напишите процедуру @code{an-integer-between}, которая
возвращает целое число, лежащее между двумя заданными границами. С ее
помощью можно следующим образом реализовать процедуру для поиска
Пифагоровых троек, то есть троек чисел @math{(i, j, k)} между заданными
границами, таких, что @math{i \leq j} и @math{i^2 + j^2 = k^2}:

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.36}Упражнение 4.36:}
В упражнении @ref{Упражнение 3.69} рассматривалась задача
порождения потока @emph{всех} Пифагоровых троек, без всякой верхней
границы диапазона целых чисел, в котором надо искать. Объясните, почему
простая замена @code{an-integer-between} на
@code{an-integer-startingfrom} в процедуре из
упражнения @ref{Упражнение 4.35} не является адекватным способом
порождения произвольных Пифагоровых троек. Напишите процедуру, которая
решает эту задачу. (Это значит, что Вам нужно написать процедуру, для
которой многократный запрос @code{try-again} в принципе способен
породить все Пифагоровы тройки.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.37}Упражнение 4.37:}
Бен Битобор утверждает, что следующий метод порождения
Пифагоровых троек эффективнее, чем приведенный в
упражнении @ref{Упражнение 4.35}. Прав ли он? (Подсказка: найдите,
сколько вариантов требуется рассмотреть.)

@lisp
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
@end lisp
@end quotation

@comment @subsection Examples of Nondeterministic Programs
@subsection Примеры недетерминистских программ
@node	4.3.2, 4.3.3, 4.3.1, 4.3

В @ref{4.3.3} описывается реализация @code{amb}-интерпретатора. Однако
для начала мы приведем несколько примеров его использования. Преимущество
недетерминистского программирования состоит в том, что можно отвлечься от
деталей процесса поиска, а следовательно, выражать программы на более высоком
уровне абстракции.

@comment @subsubheading Logic Puzzles
@subsubheading Логические загадки

Следующая задача (взятая из Dinesman 1968) --- типичный представитель
большого класса простых логических загадок.

@quotation
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах
пятиэтажного дома. Бейкер живет не на верхнем этаже. Купер живет не на
первом этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер
живет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?
@end quotation

@noindent
Можно впрямую определить, кто на каком этаже живет, перечислив все
возможности и наложив данные нам ограничения.@footnote{В нашей программе
используется следующая процедура, определяющая, все ли элементы списка
отличны друг от друга:

@lisp
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
@end lisp

@noindent
Процедура @code{member} подобна @code{memq}, но на равенство проверяет с
помощью @code{equal?}, а не @code{eq?}.}

@lisp
(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
        (smith    (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)       (list 'cooper cooper)
          (list 'fletcher fletcher) (list 'miller miller)
          (list 'smith smith))))
@end lisp

@noindent
Выполнение выражения @code{(multiple-dwelling)} дает следующий результат:

@lisp
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
@end lisp

@noindent
Эта простая процедура работает, но работает очень медленно. В
@ref{Упражнение 4.39} и @ref{Уπражнение 4.40} обсуждаются возможные улучшения.

@quotation
@strong{@anchor{Упражнение 4.38}Упражнение 4.38:}
Измените процедуру @code{multiple-dwelling}, отказавшись
от требования, что Смит и Флетчер живут не на соседних этажах. Сколько
решений имеется у измененной загадки?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.39}Упражнение 4.39:}
Влияет ли порядок ограничений в процедуре
@code{multiple-dwelling} на ответ? Влияет ли он на время, необходимое
для поиска ответа? Если Вы считаете, что он имеет значение, то покажите,
как можно ускорить программу, переупорядочив ограничения. Если Вы
считаете, что порядок значения не имеет, объясните, почему.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.40}Упражнение 4.40:}
Сколько возможных соответствий между людьми и этажами
имеется в задаче о проживании, если учитывать требование, что все живут
на разных этажах, и если его не учитывать? Крайне неэффективно порождать
все возможные соответствия между людьми и этажами, а затем полагаться на
то, что поиск с возвратом отсечет лишнее. Например, большая часть
ограничений зависит только от одной или двух переменных, соответствующих
людям, и их можно было бы проверять раньше, чем этажи выбраны для всех
действующих лиц. Напишите и продемонстрируйте значительно более
эффективную недетерминистскую процедуру, которая бы решала задачу,
порождая только те варианты, которые еще не исключены благодаря
предыдущим ограничениям. (Подсказка: потребуется набор вложенных
выражений @code{let}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.41}Упражнение 4.41:}
Напишите процедуру для решения задачи о проживании на обычной Scheme.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.42}Упражнение 4.42:}
Решите задачу <<Лгуньи>> (из Phillips 1934):

Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что
каждая девочка должна написать домой о результатах экзамена и при этом
сделать одно верное и одно неверное утверждение. Вот соответствующие
выдержки из их писем:

@itemize @bullet

@item
Бетти: <<Китти была на экзамене второй, а я только третьей>>.

@item
Этель: <<Вам будет приятно узнать, что я написала лучше всех. Второй была Джоан>>.

@item
Джоан: <<Я была третьей, а бедная Этель последней>>.

@item
Китти: <<Я оказалась второй. Мэри была только четвертой>>.

@item
Мэри: <<Я была четвертой. Первое место заняла Бетти>>.

@end itemize

В каком порядке на самом деле расположились отметки девочек?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.43}Упражнение 4.43:}
Решите с помощью @code{amb}-интерпретатора следующую
задачу.@footnote{Задача взята из книжки <<Занимательные загадки>>,
опубликованной в 60-е годы издательством Литтон Индастриз. Книжка
приписывает задачу газете <<Кэнзас стейт энджинир>>.}

У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей тоже.
Эти четверо друзей --- полковник Даунинг, мистер Холл, сэр Барнакл Худ
и доктор Паркер. У каждого из них тоже есть по дочери, и каждый из них
назвал свою яхту в честь дочери одного из своих друзей. Яхта сэра
Барнакла называется Габриэлла, яхта мистера Мура --- Лорна, а у мистера
Холла яхта Розалинда. Мелисса, яхта полковника Даунинга, названа в честь
дочери сэра Барнакла. Отец Габриэллы владеет яхтой, названной в честь
дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно (см.
упражнение @ref{Упражнение 4.40}). Кроме того, определите, сколько
будет решений, если не указывается, что фамилия Мэри Энн --- Мур.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.44}Упражнение 4.44:} В упражнении
@ref{Упражнение 2.42} описывалась <<задача о восьми ферзях>>, в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.
@end quotation

@comment @subsubheading Parsing natural language
@subsubheading Синтаксический анализ естественного языка

Программы, которые должны принимать на входе естественный язык, обычно
прежде всего пытаются провести (@newterm{parsing}) ввода, то есть сопоставить
входному тексту какую-то грамматическую структуру. Например, мы могли бы
попытаться распознавать простые предложения, состоящие из артикля, за
которым идет существительное, а вслед за ними глагол, например @emph{The
cat eats} (<<Кошка ест>>). Чтобы выполнять такой анализ, нам нужно уметь
определять части речи, к которым относятся отдельные слова. Мы можем для
начала составить несколько списков, которые задают классы
слов:@footnote{Здесь мы используем соглашение, что первый элемент списка
обозначает часть речи, к которой относятся остальные слова списка.}

@lisp
(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
@end lisp

@noindent
Нам также нужна (@newterm{grammar}), то есть набор правил, которые описывают,
как элементы грамматической структуры составляются из меньших элементов.
Простейшая грамматика может постановить, что предложение всегда состоит
из двух частей --- именной группы, за которой следует глагол, --- и
что именная группа состоит из артикля и имени существительного. С такой
грамматикой предложение @emph{The cat eats} разбирается так:

@lisp
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
@end lisp

@noindent
Мы можем породить такой разбор при помощи простой программы, в которой
для каждого грамматического правила имеется своя процедура. Чтобы
разобрать предложение, мы определяем две его составные части и
возвращаем список из этих элементов, помеченный символом @code{sentence}:

@lisp
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
@end lisp

@noindent
Подобным образом, разбор именной группы состоит в поиске артикля и
существительного:

@lisp
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
@end lisp

@noindent
На самом нижнем уровне разбор сводится к многократной проверке, является
ли следующее неразобранное слово элементом списка слов для данной части
речи. Чтобы реализовать это, мы заводим глобальную переменную
@code{*unparsed*}, содержащую еще неразобранный ввод. Каждый раз,
проверяя слово, мы требуем, чтобы @code{*unparsed*} не была пустым
списком и чтобы ее значение начиналось со слова из указанного списка.
Если это так, мы убираем слово из @code{*unparsed*} и возвращаем его
вместе с частью речи (которую можно найти в голове
списка).@footnote{Обратите внимание, что @code{parse-word} изменяет
список необработанных слов при помощи @code{set!}. Для того, чтобы это
работало, @code{amb}-интерпретатор при возврате должен отменять действия
операций @code{set!}.}

@lisp
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
@end lisp

@noindent
Чтобы запустить разбор, нужно только присвоить переменной @code{*unparsed*}
весь имеющийся ввод, попытаться проанализировать предложение и убедиться,
что ничего не осталось в конце:

@lisp
(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*)) sent))
@end lisp

Теперь мы можем опробовать анализатор и убедиться, что он работает на
нашем простом примере:

@lisp
@i{;;; Amb-Eval input:}
(parse '(the cat eats))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@end lisp
@smalllisp
@i{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}
@end smalllisp

@noindent
@code{amb}-интерпретатор здесь удобно использовать потому, что
ограничения на разбор легко выражаются при помощи @code{require}. Однако
по-настоящему достоинства автоматического поиска с возвратом проявляются
тогда, когда мы обращаемся к более сложным грамматикам, где имеются
варианты декомпозиции единиц.

Добавим к грамматике список предлогов:

@lisp
(define prepositions '(prep for to in by with))
@end lisp

@noindent
и определим предложную группу (например, @emph{for the cat}, <<для
кошки>>) как последовательность из предлога и именной группы:

@lisp
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
@end lisp

@noindent
Теперь мы можем сказать, что предложение --- это именная группа, за
которой следует глагольная группа, а глагольная группа --- это либо
глагол, либо глагольная группа, дополненная предложной
группой@footnote{Заметим, что это определение рекурсивно --- за
глаголом может следовать любое число предложных групп.}:

@lisp
(define (parse-sentence)
  (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend
          (list 'verb-phrase
                verb-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
@end lisp

@noindent
Раз уж мы занялись этим делом, можно также уточнить определение именной
группы и разрешить выражения вроде @emph{a cat in the class} (<<кошка в
аудитории>>). То, что раньше называлось именной группой, теперь мы будем
называть простой именной группой, а именная группа теперь может быть
либо простой именной группой, либо именной группой, которая дополняется
предложной группой:

@lisp
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend
          (list 'noun-phrase
                noun-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
@end lisp

@noindent
Обновленная грамматика позволяет разбирать более сложные предложения.
Например,

@lisp
(parse '(the student with the cat sleeps in the class))
@end lisp

@noindent
дает

@lisp
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase
   (prep in)
   (simple-noun-phrase (article the) (noun class)))))
@end lisp

@noindent
Заметим, что входное предложение может иметь более одного законного
анализа. В предложении @emph{The professor lectures to the student with
the cat} (<<Профессор читает лекцию студенту с кошкой>>) может иметься в
виду, что профессор вместе с кошкой читают лекцию, или что кошка --- у
студента. Наша недетерминистская программа находит оба варианта:

@lisp
(parse '(the professor lectures to the student with the cat))
@end lisp

@noindent
дает

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase
    (prep to)
    (simple-noun-phrase (article the) (noun student))))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat)))))
@end lisp

@noindent
Если πоπросить интерπретатор πоискать еще, πолучится

@lisp
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase
    (simple-noun-phrase (article the) (noun student))
    (prep-phrase
     (prep with)
     (simple-noun-phrase (article the) (noun cat)))))))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.45}Упражнение 4.45:}
Согласно заданной выше грамматике, следующее предложение
можно проанализировать пятью различными способами: @emph{The professor
lectures to the student in the class with the cat} (<<Профессор читает
лекцию студенту в аудитории с кошкой>>). Покажите эти пять разборов и
объясните разницу в оттенках значения между ними.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.46}Упражнение 4.46:} Интерпретаторы в разделах
@ref{4.1} и @ref{4.2} не определяют, в каком порядке вычисляются операнды
при вызове процедуры. Мы увидим, что @code{amb}-интерпретатор вычисляет их
слева направо. Объясните, почему программа разбора не стала бы работать, если
бы операнды вычислялись в каком-нибудь другом порядке.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.47}Упражнение 4.47:}
Хьюго Дум говорит, что поскольку глагольная группа --- это
либо глагол, либо глагольная группа плюс предложная группа, было бы
намного естественнее определить процедуру @code{parse-verb-phrase} так
(и то же сделать для именных групп):

@lisp
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
@end lisp

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в @code{amb}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.48}Упражнение 4.48:}
Дополните описанную выше грамматику так, чтобы она могла
работать с более сложными предложениями. Например, можно позволить
именным и глагольным группам включать прилагательные и наречия, или же
можно обрабатывать сложные предложения.@footnote{Грамматики такого рода
могут быть сколь угодно сложными, но по сравнению с настоящей обработкой
естественного языка они остаются игрушкой. Настоящее понимание
естественного языка компьютером требует сложного сочетания
синтаксического анализа с интерпретацией значения. С другой стороны,
даже простые анализаторы могут быть полезны для поддержки гибких
командных языков в программах вроде систем поиска информации. Уинстон
(Winston 1992) описывает вычислительные подходы к пониманию настоящего
естественного языка, а также применение простых грамматик в командных
языках.}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.49}Упражнение 4.49:}
Лизу П. Хакер больше интересует не анализ предложений, а
их порождение. Она замечает, что если изменить процедуру
@code{parse-word} так, чтобы она игнорировала <<входное предложение>>,
всегда заканчивалась успехом и порождала подходящее слово, мы сможем
использовать те же программы, которые мы написали для анализа, для
порождения предложений. Реализуйте идею Лизы и покажите первые
пять-шесть порожденных предложений.@footnote{Несмотря на то, что идея
Лизы (будучи удивительно простой) дает результат, порождаемые
предложения оказываются довольно скучными --- они не отображают
возможные предложения нашего языка никаким интересным образом. Дело в
том, что грамматика рекурсивна во многих местах, а метод Лизы
<<проваливается>> в одну из рекурсий и там застревает. Как с этим можно
бороться, Вы увидите в упражнении @ref{Упражнение 4.50}.}
@end quotation

@comment @subsection Implementing the @code{amb} Evaluator
@subsection Реализация @code{amb}-интерпретатора
@node	4.3.3,  , 4.3.2, 4.3

Выполнение выражения в обыкновенной Scheme может вернуть результат,
может вообще не завершиться, и, наконец, может закончиться сообщением об
ошибке. В недетерминистской Scheme при выполнении выражения, в
дополнение ко всему этому, может еще обнаружиться тупик, и в этом случае
вычисление должно откатиться к предыдущей точке выбора. Интерпретация
недетерминистской Scheme осложняется из-за этой дополнительной
возможности.

Мы построим @code{amb}-интерпретатор для недетерминистской Scheme,
модифицировав анализирующий интерпретатор из @ref{4.1.7}.@footnote{В
@ref{4.2} мы решили реализовать ленивый интерпретатор как модификацию
обыкновенного метациклического интерпретатора из @ref{4.1.1}. Напротив,
здесь в основу @code{amb}-интерпретатора мы кладем анализирующий
интерпретатор из @ref{4.1.7},
поскольку исполнительные процедуры этого интерпретатора служат удобной
базой для реализации поиска с возвратом.} Как и в анализирующем
интерпретаторе, вычисление выражения происходит путем вызова
исполнительной процедуры, которая получается при анализе этого
выражения. Разница между интерпретацией обыкновенной Scheme и
недетерминистской Scheme будет полностью сводиться к исполнительным
процедурам.

@comment @subsubheading Execution procedures and continuations
@subsubheading Исполнительные процедуры и продолжения

Напомним, что исполнительные процедуры обыкновенного интерпретатора
принимают один аргумент: окружение, в котором происходит вычисление
выражения. В противоположность этому, исполнительные процедуры
@code{amb}-интерпретатора принимают три аргумента: окружение и две
процедуры, называемые (@newterm{continuation procedures}). Вычисление выражения
будет заканчиваться вызовом одного из этих продолжений: если результатом
вычисления является значение, то зовется (@newterm{success continuation}) с этим
значением в качестве аргумента; если вычисление натыкается на тупик,
вызывается (@newterm{failure continuation}). Построение и вызов соответствующих
продолжений служит механизмом, с помощью которого в недетерминистском
интерпретаторе реализуется поиск с возвратом.

Задача продолжения успеха --- принять значение и продолжить вычисление.
Помимо этого значения, продолжение успеха получает дополнительное
продолжение неудачи, которое нужно будет вызвать, если использование
значения приведет в тупик.

Задача продолжения неудачи --- попробовать другую ветвь
недетерминистского процесса. Главная особенность недетерминистского
языка состоит в том, что выражения могут представлять собой точки выбора
между вариантами. Выполнение такого выражения должно продолжиться
согласно одному из указанных взаимоисключающих вариантов, несмотря на
то, что заранее неизвестно, какие варианты приведут к приемлемым
результатам. При обработке такой ситуации интерпретатор выбирает один из
вариантов и передает его значение продолжению успеха. Кроме того, он
строит и передает вместе со значением продолжение неудачи, которое потом
можно вызвать, чтобы рассмотреть другой вариант.

Неудача возникает во время вычисления (то есть, зовется продолжение
неудачи), когда пользовательская программа явным образом отказывается от
текущего рассматриваемого варианта (например, вызов @code{require} может
привести к выполнению @code{(amb)}, а это выражение всегда терпит
неудачу --- см. @ref{4.3.1}). В этом месте
продолжение неудачи вернет нас к последней по времени точке и оттуда
направит по другому варианту. Если же в этой точке выбора больше не
осталось вариантов, то запускается неудача в предыдущей точке выбора, и
так далее. Кроме того, продолжения неудачи запускаются управляющим
циклом в ответ на запрос @code{try-again}, чтобы найти еще одно значение
последнего выражения.

Помимо того, если на какой-то ветке процесса, возникшей в результате
выбора, происходит операция с побочным эффектом (например, присваивание
переменной), то может понадобиться отменить побочный эффект, если
процесс наткнется на неудачу, прежде чем будет сделан новый выбор. Этого
мы добиваемся, заставив операцию с побочным эффектом порождать
продолжение неудачи, которое отменяет эффект и отправляет неудачу
дальше.

\enlargethispage{\baselineskip}

Итак, продолжения неудачи порождаются
@itemize @bullet

@item
в выражениях @code{amb} --- чтобы обеспечить механизм выбора
альтернативных вариантов, если текущий выбор, сделанный внутри
@code{amb}, приведет к тупику;

@item
в управляющем цикле верхнего уровня --- чтобы иметь возможность
сообщить о неудаче, когда перебраны все альтернативы;

@item
в присваиваниях --- чтобы во время отката перехватывать неудачи и
отменять присваивания.
@end itemize

@noindent
Неудачи возбуждаются только тогда, когда программа заходит в тупик. Это
происходит

@itemize @bullet

@item
если пользовательская программа выполняет выражение @code{(amb)};

@item
если пользователь печатает @code{try-again} в управляющем цикле.

@end itemize

@noindent
Кроме того, продолжения неудачи вызываются при обработке неудачи:

@itemize @bullet

@item
Когда продолжение неудачи, порожденное присваиванием, заканчивает отмену
побочного эффекта, оно вызывает то предложение неудачи, которое оно само
перехватило, и посредством его отправляет неудачу назад до точки выбора,
которая привела к присваиванию, либо до верхнего уровня.

@item
Когда продолжение неудачи для @code{amb} исчерпывает все варианты
выбора, оно вызывает продолжение неудачи, которое изначально было дано
@code{amb}, и посредством его распространяет неудачу до предыдущей точки
выбора, либо до верхнего уровня.
@end itemize

@comment @subsubheading Structure of the evaluator
@subsubheading Структура интерпретатора

Процедуры представления синтаксиса и данных в @code{amb}-интерпретаторе,
а также базовая процедура @code{analyze}, совпадают с соответствующими
процедурами в интерпретаторе из @ref{4.1.7}, только здесь требуются
дополнительные синтаксические процедуры для анализа особой формы @code{amb}:
@footnote{Мы предполагаем, что интерпретатор поддерживает @code{let} (см.
@ref{Упражнение 4.22}), который мы использовали в недетерминистских программах.}

@lisp
(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
@end lisp

@noindent
Кроме того, требуется добавить в процедуру разбора @code{analyze} ветку,
которая будет распознавать эту особую форму и порождать соответствующую
исполнительную процедуру:

@lisp
((amb? exp) (analyze-amb exp))
@end lisp

@noindent
Процедура верхнего уровня @code{ambeval} (сходная с версией @code{eval},
приведенной в @ref{4.1.7}) анализирует данное выражение и применяет полученную
исполнительную процедуру к данному окружению и двум данным продолжениям:

@lisp
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
@end lisp

@noindent
Продолжение успеха представляет собой процедуру от двух аргументов:
только что полученного значения и продолжения неудачи, которое нужно
будет применить, если обработка значения впоследствии приведет к
неудаче. Продолжение неудачи представляет собой процедуру без
аргументов. Таким образом, общая форма исполнительной процедуры такова:

@lisp
(lambda (env succeed fail)
  @r{;; @code{succeed} выглядит как @code{(lambda (value fail) @dots{})}}
  @r{;; @code{fail} выглядит как @code{(lambda () @dots{})}}
  @dots{})
@end lisp

@noindent
Например

@lisp
(ambeval @math{\langle}@var{вурыжение}@math{\rangle}
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
@end lisp

@noindent
попытается вычислить данное выражение, и вернет либо его значение (если
вычисление будет успешным), либо символ @code{failed} (если вычисление
потерпит неудачу). Вызов @code{ambeval} в нижеприведенном управляющем
цикле использует намного более сложные процедуры продолжения, которые
возвращаются к выполнению цикла и поддерживают запрос @code{try-again}.

Сложность @code{amb}-интерпретатора по большей части заключается в
механизмах передачи продолжений, когда исполнительные процедуры вызывают
друг друга. Читая код в этом разделе, следует сравнивать каждую
исполнительную процедуру с соответствующей процедурой обыкновенного
интерпретатора из @ref{4.1.7}.

@comment @subsubheading Simple expressions
@subsubheading Простые выражения

Исполнительные процедуры для простейших видов выражений здесь, в
сущности, такие же, как и в обычном интерпретаторе, не считая того, что
здесь надо уметь управлять продолжениями. Исполнительные процедуры
просто зовут продолжение успеха, давая ему значение выражения, и
передают дальше продолжение неудачи, которое получили сами.

@lisp
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env) fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env) fail))))
@end lisp

@noindent
Заметим, что поиск переменной всегда <<успешен>>. Если процедуре
@code{lookup-variable-value} не удается найти значение, она, как обычно,
сообщает об ошибке. Такая <<неудача>> означает ошибку в программе:
ссылку на несвязанную переменную; это не означает, что нам нужно
пробовать какой-либо другой вариант недетерминистского выбора вместо
того, который исполняется сейчас.

@comment @subsubheading Conditionals and sequences
@subsubheading Условные выражения и последовательности

Обработка условных выражений также похожа на соответствующий процесс в
обычном интерпретаторе. Исполнительная процедура, порождаемая в
@code{analyze-if}, зовет исполнительную процедуру предиката @code{pproc}
с продолжением успеха, которое, проверив, истинно ли значение предиката,
в соответствии с этим выполняет либо следствие, либо альтернативу. Если
выполнение @code{pproc} терпит неудачу, вызывается исходное продолжение
неудачи, переданное в выражение @code{if}.

@lisp
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             @r{;; πродолжение усπеха πри вычислении πредиката}
             @r{;; и получении @code{pred-value}}
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             @r{;; πродолжение неудачи πри вычислении πредиката}
             fail))))
@end lisp

@noindent
Последовательности тоже обрабатываются так же, как и в предыдущем
интерпретаторе, если не считать махинаций в подпроцедуре
@code{sequentially}, которые требуются для передачи продолжений. А
именно, чтобы выполнить последовательно @code{a} и @code{b}, мы вызываем
@code{a} с продолжением успеха, вызывающим @code{b}.

@lisp
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         @r{;; πродолжение усπеха πри вызове @code{a}}
         (lambda (a-value fail2)
           (b env succeed fail2))
         @r{;; πродолжение неудачи πри вызове @code{a}}
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
@end lisp

@comment @subsubheading Definitions and assignments
@subsubheading Определения и присваивания

Определения --- еще один случай, когда обработка продолжений сопряжена
с известными трудностями, поскольку требуется сначала вычислить
выражение, которое будет значением определяемой переменной, а затем уже
ее собственно определить. Ради этого процедура вычисления значения
@code{vproc} вызывается со следующими аргументами: окружение,
продолжение успеха и продолжение неудачи. Если вычисление @code{vproc}
происходит успешно и дает значение @code{val} для определяемой
переменной, то переменная определяется и успех распространяется далее:

@lisp
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
@end lisp

@noindent
Присваивания устроены интереснее. Это первый случай, когда мы
действительно используем продолжения, а не просто передаем их из
процедуры в процедуру. Исполнительная процедура для присваивания
начинается так же, как и процедура для определения. Сначала она пытается
получить новое значение, которое надо присвоить переменной. Если
вычисление @code{vproc} терпит неудачу, неудачно и все присваивание.

Однако если @code{vproc} выполняется удачно, и мы действительно
выполняем присваивание, то нам нужно рассмотреть возможность, что
текущая ветка вычисления позже, может быть, приведет к неудаче. Тогда
нам понадобится откатиться к моменту до присваивания. Таким образом, нам
нужно уметь отменить присваивание в процессе возврата@footnote{Мы не
заботились об отмене определений, поскольку можно предположить, что
внутренние определения изымаются (@ref{4.1.6}).}

Этого мы добиваемся, передавая @code{vproc} продолжение успеха
(отмеченное ниже комментарием <<@emph{1*}>>), которое сохраняет старое
значение переменной, прежде чем присвоить ей новое значение и продолжить
вычисление. Продолжение неудачи, которое передается вместе со значением
присваивания (и отмечено ниже комментарием <<@emph{2*}>>),
восстанавливает старое значение переменной, прежде чем продолжить откат.
То есть, успешное присваивание дает продолжение неудачи, которое
перехватит последующую неудачу; неудача, которая в противном случае
вызвала бы @code{fail2}, вместо этого зовет эту процедуру, а она
отменяет присваивание и уже затем зовет @code{fail2}.

@lisp
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        @r{; *1*}
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    @r{; *2*}
                            (set-variable-value!
                             var old-value env)
                            (fail2)))))
             fail))))
@end lisp

@comment @subsubheading Procedure applications
@subsubheading Вызов процедур

Исполнительная процедура для вызовов не содержит никаких новшеств, кроме
сложных технических деталей работы с продолжениями. Сложность возникает
внутри @code{analyze-application} и обусловлена необходимостью следить
за продолжениями успеха и неудачи при вычислении операндов. Мы вычисляем
операнды с помощью процедуры @code{get-args}, а не простого @code{map},
как в обыкновенном интерпретаторе.

@lisp
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
@end lisp

@noindent
Заметьте, как в @code{get-args} для движения через @code{cdr} по списку
исполнительных процедур @code{aproc} и сборки через @code{cons}
получающегося списка аргументов каждая @code{aproc} в списке вызывается
с продолжением успеха, которое рекурсивно зовет @code{get-args}. Каждый
из этих рекурсивных вызовов @code{get-args} имеет продолжение успеха,
значение которого --- @code{cons} свежеполученного аргумента со списком
уже собранных аргументов:

@lisp
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       @r{;; πродолжение усπеха для этой @code{aproc}}
       (lambda (arg fail2)
         (get-args
          (cdr aprocs)
          env
          @r{;; πродолжение усπеха для}
          @r{;; рекурсивного вызова @code{get-args}}
          (lambda (args fail3)
            (succeed (cons arg args) fail3))
          fail2))
       fail)))
@end lisp

@noindent
Собственно вызов процедуры, который выполняет
@code{execute-application}, осуществляется так же, как и в обыкновенном
интерпретаторе, не считая того, что необходимо управлять продолжениями.

@lisp
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else
         (error "Unknown procedure type: EXECUTE-APPLICATION"
                proc))))
@end lisp

@comment @subsubheading Evaluating @code{amb} expressions
@subsubheading Выполнение выражений @code{amb}

Особая форма @code{amb} --- ключевой элемент недетерминистского языка.
Здесь лежит сущность процесса интерпретации и обоснование необходимости
отслеживать продолжения. Исполнительная процедура для @code{amb}
определяет цикл @code{try-next}, который перебирает исполнительные
процедуры для всех возможных значений выражения @code{amb}. Каждая из
исполнительных процедур вызывается с продолжением неудачи, которое
попробует выполнить следующий вариант. Когда вариантов больше не
остается, все выражение @code{amb} терпит неудачу.

@lisp
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda () (try-next (cdr choices))))))
      (try-next cprocs))))
@end lisp

@comment @subsubheading Driver loop
@subsubheading Управляющий цикл

Управляющий цикл @code{amb}-интерпретатора сложен из-за наличия
механизма, позволяющего пользователю заново попытаться выполнить
выражение. Цикл использует процедуру @code{internal-loop}, которая в
качестве аргумента принимает процедуру @code{try-again}. Наш замысел
состоит в том, чтобы вызов @code{try-again} переходил к следующему
нерассмотренному варианту в недетерминистском вычислении. Процедура
@code{internal-loop} либо зовет @code{try-again}, если пользователь
набирает @code{try-again} в управляющем цикле, либо запускает новое
вычисление, вызывая @code{ambeval}.

Продолжение неудачи в этом вызове @code{ambeval} сообщает пользователю,
что значений больше нет, и перезапускает управляющий цикл.

Продолжение успеха для вызова @code{ambeval} устроено тоньше. Мы
печатаем вычисленное значение, а потом заново запускаем внутренний цикл
с процедурой @code{try-again}, которая сможет попробовать следующий
вариант. Этот переход к следующему варианту выражается процедурой
@code{next-alternative}, которая передана вторым аргументом в
продолжение успеха. Обычно мы считаем этот второй аргумент продолжением
неудачи, которое придется использовать, если текущая ветвь исполнения
потерпит неудачу. Однако в данном случае мы завершили успешное
вычисление, так что <<неудачный>> вариант можно позвать для того, чтобы
найти дополнительные успешные варианты вычисления.

@lisp
(define input-prompt  ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline) (display ";;; Starting a new problem ")
            (ambeval
             input
             the-global-environment
             @r{;; @code{ambeval} усπех}
             (lambda (val next-alternative)
               (announce-output output-prompt)
               (user-print val)
               (internal-loop next-alternative))
             @r{;; @code{ambeval} неудача}
             (lambda ()
               (announce-output
                ";;; There are no more values of")
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline) (display ";;; There is no current problem")
     (driver-loop))))
@end lisp

@noindent
Самый первый вызов @code{internal-loop} использует процедуру
@code{try-again}, которая жалуется, что не было дано никакой задачи, и
возобновляет управляющий цикл. Такое поведение требуется, если
пользователь набирает @code{try-again}, еще не задав выражение для
вычисления.

@quotation
@strong{@anchor{Упражнение 4.50}Упражнение 4.50:}
Реализуйте новую особую форму @code{ramb}, которая подобна
@code{amb}, однако перебирает варианты не слева направо, а в случайном
порядке. Покажите, как такая форма может пригодиться в Лизиной задаче из
упражнения @ref{Упражнение 4.49}
@end quotation

@quotation
@strong{@anchor{Упражнение 4.51}Упражнение 4.51:}
Реализуйте новую разновидность присваивания
@code{permanent-set!} --- присваивание, которое не отменяется при
неудачах. Например, можно выбрать два различных элемента в списке и
посчитать, сколько для этого потребовалось попыток, следующим образом:

@lisp
(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{(a b 2)}
@i{;;; Amb-Eval input:}
try-again
@i{;;; Amb-Eval value:}
@i{(a c 3)}
@end lisp

Какие значения были бы напечатаны, если бы мы вместо
@code{permanent-set!} использовали здесь обычный @code{set!}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.52}Упражнение 4.52:}
Реализуйте новую конструкцию @code{if-fail}, которая
позволяет пользователю перехватить неудачу при выполнении выражения.
@code{If-fail} принимает два выражения. Первое она выполняет как обычно
и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения, как в
следующем примере:

@lisp
@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{all-odd}

@i{;;; Amb-Eval input:}
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
@i{;;; Starting a new problem}
@i{;;; Amb-Eval value:}
@i{8}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.53}Упражнение 4.53:} Если у нас есть
@code{permanent-set!}, описанное в упражнении @ref{Упражнение 4.51}, и
@code{if-fail} из упражнения @ref{Упражнение 4.52}, то каков будет
результат вычисления

@lisp
(let ((pairs '()))
  (if-fail
   (let ((p (prime-sum-pair '(1 3 5 8)
                            '(20 35 110))))
     (permanent-set! pairs (cons p pairs))
     (amb))
   pairs))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.54}Упражнение 4.54:}
Если бы мы не догадались, что конструкцию можно
реализовать как обычную процедуру с помощью @code{amb}, так что
пользователь сам может определить ее в своей недетерминистской
программе, то нам пришлось бы задать эту конструкцию в виде особой
формы. Потребовались бы синтаксические процедуры

@lisp
(define (require? exp)
  (tagged-list? exp 'require))
(define (require-predicate exp)
  (cadr exp))
@end lisp

@noindent
новая ветвь разбора в @code{analyze}:

@lisp
((require? exp) (analyze-require exp))
@end lisp

@noindent
а также процедура @code{analyze-require}, которая обрабатывает выражения
@code{require}. Допишите следующее определение @code{analyze-require}:

@lisp
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if @math{\langle}??@math{\rangle}
                   @math{\langle}??@math{\rangle}
                   (succeed 'ok fail2)))
             fail))))

@end lisp
@end quotation


@comment @section Logic Programming
@section Логическое программирование
@node	4.4,  , 4.3, Chapter 4

В @ref{Глава 1} мы подчеркивали, что информатика имеет дело с императивным
знанием (<<как сделать>>), в то время как математика имеет дело с декларативным
знанием (<<что такое>>). Действительно, языки программирования требуют,
чтобы программист, выражая свои знания, указывал методы пошагового
решения определенных задач. С другой стороны, языки высокого уровня
обеспечивают в рамках своих реализаций существенный объем
методологических знаний, которые освобождает пользователя от забот о
многих деталях того, как проходит описываемое вычисление.

Большинство языков программирования, включая Лисп, построены вокруг
вычисления значений математических функций. Языки, ориентированные на
выражения, (такие, как Лисп, Фортран и Алгол) пользуются тем, что
выражение, описывающее значение функции, можно интерпретировать и как
способ вычислить это значение. По этой причине большинство языков
программирования имеют уклон в однонаправленные вычисления (вычисления
со строго определенными входом и выходом). Имеются, однако, совсем
другие языки программирования, в которых этот уклон ослаблен. Пример
такого языка мы видели в @ref{3.3.5},
где объектами вычисления были арифметические ограничения. В системе
ограничений направление и порядок вычислений определены не столь четко;
стало быть, чтобы провести вычисление, система должна содержать в себе
более детальное знание <<как сделать>>, чем в случае с обычным
арифметическим вычислением. Однако это не значит, что пользователь вовсе
не отвечает за то, чтобы обеспечить систему императивным знанием.
Существует множество сетей, которые задают одно и то же множество
ограничений, и пользователю нужно выбрать из множества математически
эквивалентных сетей одну подходящую, чтобы описать нужное вычисление.

Недетерминистский интерпретатор программ из @ref{4.3}
тоже представляет собой отход от представления, что программирование
связано с построением алгоритмов для вычисления однонаправленных
функций. В недетерминистском языке у выражений может быть более одного
значения, и оттого вычисление работает с отношениями, а не с функциями,
у которых значение только одно. Логическое программирование расширяет
эту идею, сочетая реляционный взгляд на программирование с мощной
разновидностью символьного сопоставления с образцом, которую называют
(@newterm{unification}).@footnote{Логическое программирование выросло из долгой
традиции исследований по автоматическому доказательству теорем. Ранние
программы доказательства теорем достигали лишь скромных результатов, так
как они полностью перебирали пространство возможных доказательств.
Крупный прорыв, который сделал такой поиск осмысленным, случился в
начале 1960х годов, когда были открыты (unification algorithm) и
(resolution principle) (Robinson 1965). Резолюцию использовали,
например, Грин и Рафаэль (Green and Raphael 1968, см. также Green 1969)
как основу дедуктивной системы вопрос-ответ. Большую часть этого периода
исследователи сосредотачивались на алгоритмах, которые гарантированно
находят решение, если оно существует. Такими алгоритмами было трудно
управлять, и трудно было указать им направление доказательства. Хьюитт
(Hewitt 1969) нашел возможность сочетать управляющую структуру языка
программирования с операциями системы логического манипулирования, и это
привело к появлению работы по автоматическому поиску, упомянутой в
@ref{4.3.1} (@ref{Сноска 4.47}).
В то же самое время в Марселе Кольмероэ разрабатывал системы обработки
естественного языка, основанные на правилах (см. Colmerauer et al.
1973). Для представления этих правил он изобрел язык Пролог. Ковальски
(Kowalski 1973; Kowalski 1979) в Эдинбурге обнаружил, что выполнение
программы на Прологе можно интерпретировать как доказательство теорем (с
использованием метода доказательства, называемого линейной резолюцией
Хорновских форм). Слияние этих двух линий привело к возникновению
традиции логического программирования. Таким образом, в споре о
приоритетах в области логического программирования французы могут
указать на корни Пролога в Марсельском университете, а британцы на
работы, сделанные в университете Эдинбурга. А по мнению исследователей
из MIT, обе эти группы разработали логическое программирование, когда
пытались понять, что же хотел сказать Хьюитт в своей блистательной, но
трудночитаемой диссертации. Историю логического программирования можно
найти в Robinson 1983.}

Когда этот подход работает, он служит весьма мощным способом написания
программ. Отчасти эта мощь проистекает из того, что один факт вида <<что
такое>> можно использовать для решения нескольких различных задач с
разными компонентами <<как сделать>>. Для примера рассмотрим операцию
@code{append}, которая в качестве аргументов принимает два списка и
объединяет их элементы в один список. В процедурном языке вроде Лиспа
можно определить @code{append} через базовый конструктор списков
@code{cons}, как в @ref{2.2.1}:

@lisp

(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
@end lisp

@noindent
Эту процедуру можно рассматривать как перевод на Лисп следующих двух
правил; первое покрывает случай, когда первый список пуст, а второе ---
случай непустого списка, представляющего собой @code{cons} двух частей:

@itemize @bullet

@item
Для любого списка @code{y}, @code{append} пустого списка и @code{y} дает
@code{y}.

@item
Для любых @code{u}, @code{v}, @code{y} и @code{z}, @code{append} от
@code{(cons u v)} и @code{y} дает @code{(cons u z)}, если @code{append}
от @code{v} и @code{y} дает @code{z}.@footnote{Соответствие между
правилами и процедурой такое: пусть @code{x} из процедуры (когда
@code{x} непустой) соответствует @code{(cons u v)} из правила. Тогда
@code{z} из правила соответствует @code{append} от @code{(cdr x)} и @code{y}.}

@end itemize

@noindent
С помощью процедуры @code{append} мы можем решать задачи типа

@quotation
Найти @code{append} от @code{(a b)} и @code{(c d)}.
@end quotation

@noindent
Однако тех же двух правил достаточно для решения следующих типов
вопросов, на которые процедура ответить не может:

@quotation
Найти список @code{y}, такой, что @code{append} @code{(a b)} и @code{y}
дает @code{(a b c d)}.

Найти все такие @code{x} и @code{y}, что @code{append} от них дает
@code{(a b c d)}.
@end quotation

@noindent
В языке логического программирования, когда программист пишет
<<процедуру>> @code{append}, он формулирует два правила, приведенные
выше. Знание <<как сделать>> автоматически обеспечивается
интерпретатором, что позволяет использовать одну эту пару правил для
ответа на все три типа вопросов об @code{append}.@footnote{Это ни в коем
случае не освобождает программиста полностью от решения задачи, как
вычислить ответ. Существует множество математически эквивалентных
наборов правил для отношения @code{append}, и только некоторые из них
можно превратить в эффективное средство для вычисления в каком-либо
направлении. Вдобавок, иногда информация <<что такое>> ничего не говорит
о том, @emph{как} вычислить ответ, --- возьмем, например, задачу найти
такое @math{y}, что @math{y^2 = x}.}

У современных языков логического программирования (включая тот, который
мы сейчас реализуем) есть существенные недостатки, а именно: их общие
методы <<как сделать>> порой заводят в ненужные бесконечные циклы или
вызывают нежелательное поведение другого рода. Логическое
программирование сейчас активно исследуется в информатике.@footnote{Пик
интереса к логическому программированию пришелся на начало 80-х, когда
японское правительство инициировало амбициозный проект, целью которого
было построение сверхбыстрых компьютеров, оптимизированных для
логических языков программирования. Скорость таких компьютеров
предполагалось измерять в LIPS (Logical Inferences Per Second --- число
логических выводов в секунду), а не в обычных FLOPS (FLoating-point
Operations Per Second --- число операций с плавающей точкой в секунду).
Несмотря на то, что в рамках проекта удалось создать аппаратное и
программное обеспечение, которое изначально планировалось, интересы
международной компьютерной промышленности сместились в другом
направлении. Обзор и оценку японского проекта можно найти в Feigenbaum
and Shrobe 1993. К тому же и в сообществе логических программистов
возник интерес к реляционному программированию на основе других методов,
помимо простого сопоставления с образцом, например, к работе с
численными ограничениями --- вроде тех, которые присутствуют в системе
распространения ограничений из @ref{3.3.5}.}

Ранее в этой главе мы изучили технологию реализации интерпретаторов и
описали те ее элементы, которые необходимы в интерпретаторе
Лисп-подобного языка (в сущности, любого традиционного языка). Теперь мы
воспользуемся этими идеями при рассмотрении интерпретатора для языка
логического программирования. Мы называем этот язык (query language),
поскольку он весьма удобен для извлечения информации из баз данных при
помощи (queries), то есть выраженных на нашем языке вопросов. Несмотря
на то, что язык запросов сильно отличается от Лиспа, его удобно
обсуждать в терминах той же самой общей схемы, которую мы использовали
до сих пор: как набор элементарных составляющих, дополненных средствами
комбинирования, которые позволяют нам сочетать простые составляющие и
получать при этом сложные, и средствами абстракции, которые позволяют
нам рассматривать сложные составляющие как единые концептуальные
единицы. Интерпретатор языка логического программирования существенно
сложнее, чем интерпретатор языка типа Лиспа. Тем не менее, нам предстоит
убедиться, что наш интерпретатор языка запросов содержит многие из тех
же элементов, которые были в интерпретаторе из @ref{4.1}. В частности, у
нас будет часть <<eval>>, которая классифицирует выражения в соответствии
с типом, и часть <<apply>>, которая реализует механизм абстракции языка
(процедуры в случае Лиспа и (rules) в случае логического
программирования). Кроме того, в реализации центральную роль будет
играть структура данных, построенная из кадров и определяющая
соотношение между символами и связанными с ними значениями. Еще одна
интересная сторона нашей реализации языка запросов --- то, что мы
существенным образом используем потоки, введенные в
@ref{Глава 3}.

@menu
* 4-4-1::            Дедуктивный поиск информации
* 4-4-2::            Как действует система обработки запросов
* 4-4-3::            Является ли логическое программирование математической логикой?
* 4-4-4::            Реализация запросной системы
@end menu

@comment @subsection Deductive Information Retrieval
@subsection Дедуктивный поиск информации
@node	4.4.1, 4.4.2, 4.4, 4.4

Логическое программирование хорошо приспособлено для построения
интерфейсов к базам данных, служащих для поиска информации. Язык
запросов, который мы реализуем в этой главе, спроектирован именно для
такого использования.

Чтобы показать, чем занимается система запросов, мы покажем, как с ее
помощью управлять базой данных персонала для <<Микрошафт>>, процветающей
компании из окрестностей Бостона со специализацией в области высоких
технологий. Язык предоставляет возможность поиска информации о
сотрудниках, производимого с помощью образцов; он также может
осуществлять логический вывод на основании общих правил.

@comment @subsubheading A sample data base
@subsubheading База данных

База данных персонала <<Микрошафт>> содержит (@newterm{assertions}) о
сотрудниках компании. Вот информация о Бене Битоборе, местном компьютерном гуру:

@lisp
@code{(адрес (Битобор Бен) (Сламервилл (Ридж Роуд) 10))}
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(зарплата (Битобор Бен) 60000)}
@end lisp

Каждое утверждение представляет собой список (в данном случае тройку).
элементы которого сами могут быть списками.

В качестве местного гуру Бен отвечает за компьютерный отдел компании и
руководит двумя программистами и одним техником. Вот информация о них:

@lisp
@code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(зарплата (Хакер Лиза П) 40000)}
@code{(начальник (Хакер Лиза П) (Битобор Бен))}

@code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(зарплата (Фект Пабло Э) 35000)}
@code{(начальник (Фект Пабло Э) (Битобор Бен))}

@code{(адрес (Поправич Дайко) (Бостон (Бэй Стейт Роуд) 22))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@code{(зарплата (Поправич Дайко) 25000)}
@code{(начальник (Поправич Дайко) (Битобор Бен))}
@end lisp

Имеется также программист-стажер, над которым начальствует Лиза:

@lisp
@code{(адрес (Дум Хьюго) (Сламервилл (Пайн Три Роуд) 80))}
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@code{(зарплата (Дум Хьюго) 30000)}
@code{(начальник (Дум Хьюго) (Хакер Лиза П))}
@end lisp

Все эти служащие работают в компьютерном отделе, на что указывает слово
@code{компьютеры} в начале описания их должностей.

Бен --- служащий высокого ранга. Его начальник --- сам глава компании:

@lisp
@code{(начальник (Битобор Бен) (Уорбак Оливер))}

@code{(адрес (Уорбак Оливер) (Суэлсли (Топ Хип Роуд)))}
@code{(должность (Уорбак Оливер) (администрация большая шишка))}
@code{(зарплата (Уорбак Оливер) 150000)}
@end lisp

Помимо компьютерного отдела, руководимого Беном, в компании имеется
бухгалтерия, где работает главный бухгалтер со своим помощником:

@lisp
@code{(адрес (Скрудж Эбин) (Уэстон (Шейди Лейн) 10))}
@code{(должность (Скрудж Эбин) (бухгалтерия главный бухгалтер))}
@code{(зарплата (Скрудж Эбин) 75000)}
@code{(начальник (Скрудж Эбин) (Уорбак Оливер))}

@code{(адрес (Крэтчит Роберт) (Олстон (Норт Гарвард Стрит) 16))}
@code{(должность (Крэтчит Роберт) (бухгалтерия писец))}
@code{(зарплата (Крэтчит Роберт) 18000)}
@code{(начальник (Крэтчит Роберт) (Скрудж Эбин))}
@end lisp

Есть еще секретарь главы компании:

@lisp
@code{(адрес (Фиден Кон) (Сламервилл (Онион Сквер) 5))}
@code{(должность (Фиден Кон) (администрация секретарь))}
@code{(зарплата (Фиден Кон) 25000)}
@code{(начальник (Фиден Кон) (Уорбак Оливер))}
@end lisp

Данные содержат также утверждения о том, какой род работы могут
выполнять сотрудники, имеющие другую должность. Например, компьютерный
гуру способен выполнять работу как компьютерного программиста, так и
компьютерного техника:

@lisp
@code{(может-замещать (компьютеры гуру) (компьютеры программист))}
@code{(может-замещать (компьютеры гуру) (компьютеры техник))}
@end lisp

Программист может выполнять работу стажера:

@lisp
@code{(может-замещать (компьютеры программист)
                (компьютеры программист стажер))}
@end lisp

Кроме того, как всем известно,

@lisp
@code{(может-замещать (администрация секретарь)
                (администрация большая шишка))}
@end lisp

@comment @subsubheading Simple queries
@subsubheading Простые запросы

Язык запросов дает пользователям возможность извлекать информацию из
базы данных, формулируя запросы в ответ на приглашение системы.
Например, чтобы найти всех программистов, можно сказать

@lisp
@i{;;; Ввод заπроса:}
@end lisp
@example
(должность ?x (компьютеры программист))
@end example

Система выведет следующие результаты:

@lisp
@i{;;; Результаты заπроса:}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@end lisp

@noindent
Входной запрос указывает, что мы ищем в базе данных записи,
соответствующие некоторому (@newterm{pattern}). В этом примере образец указывает,
что запись должна состоять из трех элементов, из которых первый является
символом @code{должность}, второй может быть чем угодно, а третий
представляет собой список @code{(компьютеры программист)}. <<Что
угодно>>, которое может стоять на второй позиции в искомом списке,
изображается (@newterm{pattern variable}) @code{?x}. В общем случае переменная
образца --- это символ, который мы считаем именем переменной,
предваряемый знаком вопроса. Несколько позже мы увидим, почему имеет
смысл давать переменным образца имена, а не просто ставить в образцы
@code{?}, означающее <<что угодно>>. Система отвечает на простой запрос,
выводя все записи в базе данных, соответствующие введенному образцу.

В образце может содержаться более одной переменной. Например,
@lisp
(address ?x ?y)
@end lisp

@noindent
выводит адреса всех служащих.

В образце может совсем не быть переменных. В этом случае запрос просто
проверяет, содержится ли запись в базе. Если да, будет одна подходящая
под образец запись; если нет, ни одной.

Одна и та же переменная может встречаться в образце в нескольких местах,
и это означает, что одинаковое <<что угодно>> должно встретиться в
каждом из этих мест. Ради этого переменным и даются имена. Например,

@lisp
(supervisor ?x ?x)
@end lisp

@noindent
находит всех сотрудников, которые сами себе начальники (впрочем, в нашей
пробной базе таковых не имеется).

Запросу

@lisp
(job ?x (computer ?type))
@end lisp

@noindent
соответствуют все записи о должностях, в которых третий элемент является
двухэлементным списком, а первый элемент в нем @code{компьютеры}:

@lisp
@code{(должность (Битобор Бен) (компьютеры гуру))}
@code{(должность (Хакер Лиза П) (компьютеры программист))}
@code{(должность (Фект Пабло Э) (компьютеры программист))}
@code{(должность (Поправич Дайко) (компьютеры техник))}
@end lisp

@noindent
Этому образцу @emph{не} соответствует запись

@lisp
@code{(должность (Дум Хьюго) (компьютеры программист стажер))}
@end lisp

@noindent
поскольку третий элемент здесь является списком из трех элементов, а
третий элемент образца указывает, что элементов должно быть два. Если бы
нам захотелось изменить образец так, чтобы третий элемент мог быть любым
списком, который начинается с @code{компьютеры}, мы могли бы
написать@footnote{Здесь используется точечная запись, введенная в
упражнении @ref{Упражнение 2.20}.}

@lisp
@code{(должность ?x (компьютеры . ?type))}
@end lisp

@noindent
Например,

@lisp
@code{(компьютеры . ?type)}
@end lisp

@noindent
соответствуют данные

@lisp
@code{(компьютеры программист стажер)}
@end lisp

@noindent
причем @code{?type} равняется списку @code{(программист стажер)}. Тому
же образцу соответствуют данные

@lisp
@code{(компьютеры программист)}
@end lisp

@noindent
где @code{?type} равняется списку @code{(программист)}, и данные

@lisp
@code{(компьютеры)}
@end lisp

@noindent
где @code{?type} равняется пустому списку @code{()}.

Можно следующим образом описать обработку простых запросов в нашем языке:

@itemize @bullet

@item
Система находит все присваивания переменным в образце запроса, которые
(@newterm{satisfy}) запросу --- то есть, все наборы значений переменных, такие,
что если переменные образца (@newterm{instantiated with}), то есть замещаются,
своими значениями, то результат находится в базе данных.

@item
Система отвечает на запрос, перечисляя все конкретизации образца с
удовлетворяющими ему присваиваниями переменным.

@end itemize

@noindent
Заметим, что в случае, когда образец не содержит переменных, запрос
сводится к выяснению, находится ли образец в базе. Если да, то нулевое
присваивание, не сообщающее значений никаким переменным, удовлетворяет
запросу к текущей базе данных.

@quotation
@strong{@anchor{Упражнение 4.55}Упражнение 4.55:}
Постройте простые запросы, которые извлекают из базы
данных следующую информацию:

@enumerate

@item
Все сотрудники, начальником которых является Бен Битобор.

@item
Имена и должности всех работников бухгалтерии.

@item
Имена и адреса всех сотрудников, живущих в Сламервилле.

@end enumerate
@end quotation

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Простые запросы являются элементарными операциями языка запросов. Чтобы
порождать составные операции, язык предоставляет средства
комбинирования. Один из элементов, превращающих язык запросов в язык
логического программирования --- то, что средства комбинирования
запросов отражают средства комбинирования, используемые при построении
логических выражений: @code{and} (и), @code{or} (или) и @code{not} (не).
(Здесь @code{and}, @code{or} и @code{not} --- это не элементарные
выражения Лиспа, а операции, встроенные в язык запросов.)

Мы можем найти адреса всех программистов с помощью @code{and} так:

@lisp
(and (@code{должность} ?person (@code{компьютеры программист}))
     (@code{адрес} ?person ?where))
@end lisp

@noindent
Получаем на выводе

@lisp
(and @code{(должность (Хакер Лиза П) (компьютеры программист))}
     @code{(адрес (Хакер Лиза П) (Кембридж (Массачусетс Авеню) 78)))}

(and @code{(должность (Фект Пабло Э) (компьютеры программист))}
     @code{(адрес (Фект Пабло Э) (Кембридж (Эймс Стрит) 3)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(and @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

@noindent
удовлетворяют все наборы значений переменных образца, которые
одновременно удовлетворяют @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Как и в случае с простыми запросами, система при обработке составного
запроса находит все присваивания переменным образца, удовлетворяющие
запросу, и затем печатает все конкретизации запроса этими значениями.

Другой метод построения составных запросов --- через @code{or}.
Например,

@lisp
(or @code{(начальник ?x (Битобор Бен))}
    @code{(начальник ?x (Хакер Лиза П)))}
@end lisp

@noindent
найдет всех сотрудников, над которыми начальствует Бен Битобор или Лиза
П. Хакер:

@lisp
(or @code{(начальник (Хакер Лиза П) (Битобор Бен))}
    @code{(начальник (Хакер Лиза П) (Хакер Лиза П)))}

(or @code{(начальник (Фект Пабло Э) (Битобор Бен))}
    @code{(начальник (Фект Пабло Э) (Хакер Лиза П)))}

(or @code{(начальник (Поправич Дайко) (Битобор Бен))}
    @code{(начальник (Поправич Дайко) (Хакер Лиза П)))}

(or @code{(начальник (Дум Хьюго) (Битобор Бен))}
    @code{(начальник (Дум Хьюго) (Хакер Лиза П)))}
@end lisp

@noindent
В общем случае, запросу

@lisp
(or @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle} @math{\langle}@var{запрос}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{запрос}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяют все наборы значений переменных образца, которые
удовлетворяют по крайней мере одному из @math{\langle}@var{запросу}@math{_1\rangle} @dots{} @math{\langle}@var{запросу}@math{_n\rangle}.

Кроме того, составные запросы можно порождать при помощи @code{not}.
Например,

@lisp
(and @code{(начальник ?x (Битобор Бен))}
     (not @code{(должность ?x (компьютеры программист))}))
@end lisp

@noindent
ищет всех сотрудников, для которых начальник Бен Битобор, не являющихся
программистами. В общем случае, запросу

@lisp
(not @math{\langle}@var{запрос}@math{_{\mono{1}}\rangle})
@end lisp

@noindent
удовлетворяют все присваивания переменным образца, которые не удовлетворяют
@math{\langle}@var{запросу}@math{_1\rangle}.@footnote{Это
описание @code{not} верно только для простых случаев. На самом деле
поведение этой конструкции более сложное. Мы исследуем тонкости
@code{not} в разделах @ref{Часть 4.4.2} и @ref{Часть 4.4.3}.}

Последняя комбинирующая форма называется @code{lisp-value}. Когда она
стоит в начале образца, она указывает, что следующий элемент является
предикатом Лиспа, который требуется применить к остальным
(конкретизированным) элементам как к аргументам. В общем случае, образец

@lisp
(lisp-value @math{\langle}@var{предикат}@math{\rangle} @math{\langle}@var{arg}@math{_{\mono{1}}\rangle} @dots{} @math{\langle}@var{arg}@math{_{\monoit{n}}\rangle})
@end lisp

удовлетворяется теми присваиваниями переменным образца, для которых
применение @math{\langle}@var{предиката}@math{\rangle} к конкретизированным
@math{\langle}@var{arg}@math{_1\rangle} @dots{}
@math{\langle}@var{arg}@math{_n\rangle} дает истину.
Например, чтобы найти всех сотрудников с зарплатой выше 30000 долларов,
можно написать@footnote{@code{lisp-value} имеет смысл использовать
только для тех операций, которых нет в языке запросов. В частности, с
его помощью не следует проверять равенство (так как для этого
предназначено сопоставление в языке запросов) и неравенство (так как это
можно сделать посредством правила @code{same}, приведенного ниже).}

@lisp
(and (salary ?person ?amount) (lisp-value > ?amount 30000))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.56}Упражнение 4.56:}
Сформулируйте составные запросы для получения следующей
информации:

@enumerate a.

@item
имена всех сотрудников, у которых начальником Бен Битобор, и их адреса;

@item
все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой Бена;

@item
все сотрудники, у которых начальник не относится к компьютерному отделу,
вместе с именем и должностью их начальника.

@end enumerate

@end quotation

@comment @subsubheading Rules
@subsubheading Правила

В дополнение к элементарным и составным запросам, наш язык обладает
средством абстракции запросов. Это @newterm{rules}. Правило

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
говорит, что двое людей живут рядом друг с другом, если они живут в
одном городе. Выражение @code{not} в конце необходимо для того, чтобы
правило не говорило про всех людей, что они живут сами около себя.
Отношение @code{same} (тот же самый) определяется очень простым
правилом:@footnote{Заметим, что правило @code{same} не нужно для того,
чтобы сделать два объекта одинаковыми: достаточно просто использовать
одну и ту же переменную образца --- тогда у нас с самого начала будет
иметься только один объект, а не два. Например, обратите внимание на
@code{?town} в правиле @code{lives-near} или @code{?middle-manager} в
правиле @code{wheel} ниже. @code{same} оказывается полезным, когда нам
хочется, чтобы два объекта различались, как @code{?person-1} и
@code{?person-2} в правиле @code{lives-near}. При том, что
использование одной переменной в двух местах в запросе требует, чтобы в
обоих местах присутствовало одно значение, использование разных
переменных не означает, что значения различаются. (Значения,
присваиваемые различным переменным образца, могут быть как разными, так
и одинаковыми.)}

@lisp
(rule (same ?x ?x))
@end lisp

@noindent
Следующее правило объявляет, что сотрудник является <<wheel>>, если он
начальствует над кем-нибудь, кто сам является начальником:

@lisp
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
@end lisp

@noindent
В общем случае правило выглядит как

@lisp
(rule @math{\langle}@var{conclusion}@math{\rangle} @math{\langle}@var{body}@math{\rangle})
@end lisp

@noindent
где @math{\langle}@var{conclusion}@math{\rangle} --- это образец, а
@math{\langle}@var{body}@math{\rangle} --- произвольный
запрос.@footnote{Кроме того, мы разрешаем иметь правила без тела, вроде
@code{same}, и будем полагать, что такое правило означает, что
заключение удовлетворяется любыми значениями переменных.} Можно
считать, что правило представляет собой большое (даже бесконечное)
множество утверждений, а именно, все конкретизации заключения при помощи
присваиваний переменным, удовлетворяющих телу правила. Когда мы
описывали простые запросы (образцы), мы сказали, что присваивание
переменным удовлетворяет образцу в том случае, когда конкретизированный
образец имеется в базе данных. Однако образец не обязательно должен явно
присутствовать в базе данных как утверждение. Это может быть неявное
утверждение, следующее из правила. Например, запрос

@lisp
(lives-near ?x (Bitdiddle Ben))
@end lisp

@noindent
выдает

@lisp
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
@end lisp

@noindent
Чтобы найти всех программистов, живущих около Бена Битобора, можно
спросить

@lisp
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
@end lisp

@noindent
Как и в случае с составными процедурами, правила можно использовать
внутри других правил (как мы видели в @code{lives-near}), и они даже
могут быть рекурсивными. Например, правило

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
@end lisp

@noindent
говорит, что служащий подчиняется руководителю, если руководитель
командует им непосредственно или (рекурсивно) непосредственный начальник
служащего подчиняется руководителю.

@quotation
@strong{@anchor{Упражнение 4.57}Упражнение 4.57:}
Определите правило, которое говорит, что служащий 1 может
заменить служащего 2, если либо служащий 1 имеет ту же должность, что и
служащий 2, либо человек с должностью служащего 1 может выполнять работу
служащего 2, и при этом служащие 1 и 2 --- разные люди. Используя это
правило, составьте запросы, которые находят следующую информацию:

@enumerate a.

@item
все служащие, которые могут заменить П.Э. Фекта.

@item
все служащие, которые могут заменить кого-то, кто получает больше их
самих, с указанием двух зарплат.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.58}Упражнение 4.58:}
Определите правило, которое говорит, что человек
<<независим>> в своем отделе, если он работает в этом отделе, но у него
нет начальника, который работает в том же отделе.

@end quotation

@quotation
@strong{@anchor{Упражнение 4.59}Упражнение 4.59:}
Бен Битобор пропускает слишком много совещаний. Опасаясь
потерять из-за этой глупой привычки работу, он решает, что с ней надо
что-то делать. Он добавляет данные обо всех еженедельных совещаниях в
базу данных <<Микрошафт>> в виде следующих утверждений:

@lisp
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
@end lisp

Все эти утверждения сообщают о совещаниях отделов. Кроме того, Бен
вводит утверждение о совещании всей компании, которое относится ко всем
отделам. Все сотрудники компании должны ходить на это совещание.

@lisp
(meeting whole-company (Wednesday 4pm))
@end lisp

@enumerate a.

@item
В пятницу утром Бен хочет спросить у базы данных, какие совещания
происходят в этот день. Как ему надо составить запрос?

@item
Лиза П. Хакер недовольна. Она считает, что намного полезнее было бы,
если бы можно было спрашивать о совещаниях, указывая свое имя. Она пишет
правило, гласящее, что совещания, куда служащему надо ходить, это
совещания всей компании и совещания отдела, где он работает. Допишите
тело Лизиного правила.

@lisp
(rule (meeting-time ?person ?day-and-time)
      @math{\langle}@var{rule-body}@math{\rangle})
@end lisp

@item
Лиза приходит на работу в среду и хочет узнать, на какие совещания ей
нужно идти в этот день. Если имеется правило @code{время-совещания}, то
какой запрос ей надо подать?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.60}Упражнение 4.60:}
Подав запрос

@lisp
(lives-near ?person (Hacker Alyssa P))
@end lisp

Лиза П. Хакер может найти людей, которые живут с ней рядом, и с
которыми она вместе может ездить на работу. С другой стороны, когда она
пытается найти все пары людей, живущих друг около друга, при помощи
запроса

@lisp
(lives-near ?person-1 ?person-2)
@end lisp

@noindent
она видит, что каждая подходящая пара людей попадается в выводе дважды,
например

@lisp
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
@end lisp

Почему так происходит? Можно ли получить список людей, живущих рядом
друг с другом, в котором каждая пара появлялась бы по одному разу? Ответ
объясните.
@end quotation

@comment @subsubheading Logic as programs
@subsubheading Логика как программы

Можно рассматривать правило как своего рода логическую импликацию:
@emph{если} присваивание значений переменным образца удовлетворяет телу,
@emph{то} оно удовлетворяет заключению. Следовательно, можно считать,
что язык запросов способен производить (@newterm{logical deduction}) на основании
правил. В качестве примера рассмотрим операцию @code{append}, описанную
в начале @ref{4.4}. Как мы уже сказали,
@code{append} характеризуется следующими двумя правилами:

@itemize @bullet

@item
Для любого списка @code{y}, @code{append} пустого списка и @code{y} дает
@code{y}

@item
Для любых @code{u}, @code{v}, @code{y} и @code{z}, @code{append} от
@code{(cons u v)} и @code{y} дает @code{(cons u z)}, если @code{append}
от @code{v} и @code{y} дает @code{z}.

@end itemize

@noindent
Чтобы выразить это в нашем языке запросов, мы определяем два правила для
отношения

@lisp
(append-to-form x y z)
@end lisp

@noindent
которое можно интерпретировать как <<@code{append} от @code{x} и
@code{y} дает @code{z}>>:

@lisp
(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
@end lisp

@noindent
В первом правиле нет тела, и это означает, что следствие выполняется для
любого значения @code{?y}. Обратите также внимание, как во втором
правиле @code{car} и @code{cdr} списка изображаются с использованием
точечной записи.

При помощи этих двух правил мы можем формулировать запросы, которые
вычисляют @code{append} от двух списков:

@lisp
@i{;;; Ввод запроса:}
(append-to-form (a b) (c d) ?z)
@i{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
Удивительнее то, что мы с помощью тех же правил можем задать вопрос
<<Какой список, будучи добавлен к @code{(a b)}, дает @code{(a b c d)}?>>
Это делается так:

@lisp
@i{;;; Ввод запроса:}
(append-to-form (a b) ?y (a b c d))
@i{;;; Результаты запроса:}
(append-to-form (a b) (c d) (a b c d))
@end lisp

@noindent
Можно также запросить все пары списков, @code{append} от которых дает
@code{(a b c d)}:

@lisp
@i{;;; Ввод запроса:}
(append-to-form ?x ?y (a b c d))
@i{;;; Результаты запроса:}
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
@end lisp

@noindent
Может показаться, что, используя правила для вывода ответов на
перечисленные запросы, система демонстрирует немалый интеллект. На самом
же деле, как мы увидим в следующем разделе, при разборе правил она
следует хорошо определенному алгоритму. К сожалению, хотя в случае с
@code{append} результаты впечатляют, в более сложных ситуациях общие
методы могут не сработать, как мы увидим в @ref{4.4.3}.

@quotation
@strong{@anchor{Упражнение 4.61}Упражнение 4.61:}
Следующие правила определяют отношение @code{next-to},
которое находит в списке соседние элементы:

@lisp
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
@end lisp

Каков будет ответ на следующие запросы?

@lisp
(?x next-to ?y in (1 (2 3) 4))
(?x next-to  1 in (2 1 3 1))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.62}Упражнение 4.62:}
Определите правила, которые реализуют операцию
@code{last-pair} из упражнения @ref{Упражнение 2.17}, которая
возвращает последнюю пару непустого списка. Проверьте Ваши правила на
таких запросах, как @code{(last-pair (3) ?x)},
@code{(last-pair (1 2 3) ?x)} и @code{(last-pair (2 ?x) (3))}. Правильно
ли Ваши правила работают с запросами вида @code{(last-pair ?x (3))}?

@end quotation

@quotation
@strong{@anchor{Упражнение 4.63}Упражнение 4.63:}
Следующая база данных (см. книгу Бытия, 4) содержит
генеалогию сыновей Ады вплоть до Адама, через Каина:

@example
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)
@end example

@comment @lisp
@comment (son Adam Cain)
@comment (son Cain Enoch)
@comment (son Enoch Irad)
@comment (son Irad Mehujael)
@comment (son Mehujael Methushael)
@comment (son Methushael Lamech)
@comment (wife Lamech Ada)
@comment (son Ada Jabal)
@comment (son Ada Jubal)
@comment @end lisp

Сформулируйте правила, такие как <<Если @math{S} сын @math{F}, а
@math{F} сын @math{G}, то @math{S} внук @math{G}>> и <<Если @math{W}
жена @math{M}, а @math{S} сын @math{W}, то @math{S} также сын @math{M}>>
(предполагается, что в библейские времена это в большей степени
соответствовало истине, чем теперь). Эти правила должны позволить
системе найти внука Каина; сыновей Ламеха; внуков Мафусала. (В
упражнении @ref{Упражнение 4.69} можно найти правила, с помощью
которых выводятся более сложные родственные связи.)
@end quotation

@comment @subsection How the Query System Works
@subsection Как действует система обработки запросов
@node	4.4.2, 4.4.3, 4.4.1, 4.4

В @ref{4.4.4} мы представим
реализацию интерпретатора запросов в виде набора процедур. В этом
разделе дается обзор системы и объясняется ее общая структура, без
низкоуровневых деталей реализации. После того, как мы опишем
интерпретатор, нам легче будет понять его ограничения и некоторые
тонкости, в которых логические операции языка запросов отличаются от
операций математической логики.

Должно быть очевидно, что вычислителю запросов требуется какая-то
разновидность поиска, чтобы сопоставлять запросы с фактами и правилами в
базе данных. Одним из способов сделать это была бы реализация системы
запросов в виде недетерминистской программы с использованием
@code{amb}-интерпретатора из @ref{4.3}
(см. упражнение @ref{Упражнение 4.78}). Другая возможность состоит в
том, чтобы управлять поиском при помощи потоков. Наша реализация
использует этот второй подход.

Запросная система организована вокруг двух основных операций, которые
называются @emph{сопоставление с образцом} (@newterm{pattern matching}) и
(@newterm{unification}). Сначала мы опишем сопоставление с образцом и объясним,
как эта операция, вместе с организацией информации в виде потоков
кадров, позволяет нам реализовывать как простые, так и составные
запросы. Затем мы обсудим унификацию --- обобщение сопоставления с
образцом, которое требуется для реализации правил. Наконец, мы покажем,
как части интерпретатора связываются воедино процедурой,
классифицирующей выражения, подобно тому, как @code{eval} разбирает
выражения в интерпретаторе, описанном в @ref{4.1}.

@endpage
@comment @subsubheading Pattern matching
@subsubheading Сопоставление с образцом

(@newterm{pattern matcher}) --- это программа, которая проверяет, соответствует
ли некоторая структура данных указанному образцу. Например, список
@code{((a b) c (a b))} соответствует образцу @code{(?x c ?x)} при
значении переменной @code{?x}, равном @code{(a b)}. Этот же список
соответствует образцу @code{(?x ?y ?z)} при значениях переменных
@code{?x} и @code{?z}, равных @code{(a b)} и значении @code{?y}, равном
@code{b}. Однако он не соответствует образцу @code{(?x a ?y)}, поскольку
этот образец требует, чтобы вторым элементом списка был символ @code{a}.

Сопоставитель, который используется в запросной системе, принимает на
входе образец, структуру данных и (@newterm{frame}), в котором указываются
связывания для различных переменных образца. Он проверяет, соответствует
ли структура данных образцу без противоречия со связываниями переменных,
уже находящимися в кадре. Если да, то сопоставитель возвращает кадр,
дополнив его связываниями, определенными во время сопоставления. Если
нет, он указывает, что сопоставление неудачно.

Например, сопоставление образца @code{(?x ?y ?x)} со списком
@code{(a b a)} при пустом начальном кадре вернет кадр, в котором
переменная @code{?x} связана со значением @code{a}, а @code{?y} со
значением @code{b}. Попытка сопоставления того же списка с тем же
образцом при начальном кадре, в котором указывается, что @code{?y}
связывается с @code{a}, окажется неудачной. Попытка сопоставления с теми
же данными и образцом, при начальном кадре, в котором @code{?y} связана
со значением @code{b}, а @code{?x} несвязана, вернет исходный кадр,
дополненный связыванием @code{a} для @code{?x}.

Сопоставитель --- единственный механизм, необходимый для обработки
простых образцов, не содержащих правил. Например, чтобы обработать запрос:

@lisp
(job ?x (computer programmer))
@end lisp

@noindent
--- мы просматриваем все утверждения в базе данных и выбираем те,
которые соответствуют образцу при пустом начальном кадре. Для каждого
найденного утверждения мы подставляем в образец значение @code{?x} из
кадра, полученного при сопоставлении.

@endpage
@comment @subsubheading Streams of frames
@subsubheading Потоки кадров

Проверка образцов по отношению к кадрам организована посредством
потоков. Получив кадр, процесс сопоставления просматривает элементы базы
данных один за другим. Для каждого входа базы данных сопоставитель
порождает либо специальный символ, указывающий, что сопоставление
оказалось неудачным, либо расширение кадра. Из результатов сопоставления
всей базы данных собирается поток, и этот поток пропускается через
фильтр, отбрасывающий неудачи. Получается поток всех кадров, которые
расширяют данный кадр за счет сопоставления с каким-либо утверждением из
базы.@footnote{Поскольку сопоставление --- в общем случае весьма дорогая
операция, нам хотелось бы избежать применения полного сопоставителя к
каждому элементу базы данных. Обычное решение этой проблемы --- разбить
процесс на грубое (быстрое) сопоставление и окончательное сопоставление.
Грубое сопоставление отфильтровывает базу и находит кандидатуры на
окончательное сопоставление. Если действовать аккуратно, можно построить
базу данных таким образом, что часть работы грубого сопоставителя
проделывается при построении базы, а не в момент отбора кандидатов. Это
называется (@newterm{indexing}) базы данных. Существует множество приемов и схем
индексирования баз данных. Наша реализация, которую мы описываем
@ref{4.4.4}, содержит простейший вариант такой оптимизации.}

В нашей системе запрос принимает входной поток кадров и для каждого
кадра применяет вышеописанную операцию сопоставления, как показано на
рис. @ref{Рисунок 4.4}. А именно, для каждого кадра во входном потоке
запрос генерирует новый поток, содержащий все расширения этого кадра,
порожденные сопоставлением с утверждениями из базы. Затем все эти потоки
собираются в один громадный поток, который содержит все возможные
расширения всех кадров входного потока. Этот поток и есть результат
запроса.

Чтобы ответить на простой запрос, мы применяем его к потоку, который
состоит из одного пустого кадра. Поток на выходе содержит все расширения
пустого кадра (то есть, все ответы на наш запрос). Затем на основе этого
потока кадров создается поток копий исходного образца запроса, в которых
переменные конкретизированы значениями из всех кадров, и этот поток в
конце концов печатается.

@float
@c @quotation
@anchor{Рисунок 4.4}
@ifinfo
@strong{Рисунок 4.4:} A query processes a stream of frames.

@example
                                  output stream
  input stream   +-------------+  of frames,
  of frames      |    query    |  filtered and extended
---------------->|             +------------------------->
                 | (job ?x ?y) |
                 +-------------+
                        ^
                        |
               stream of assertions
                  from data base
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap4/Fig4.4,102mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 4.4:} A query processes a stream of frames.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Изящество реализации с потоками кадров по-настоящему проявляется при
работе с составными запросами. При обработке составных запросов мы
пользуемся тем, что наш сопоставитель умеет требовать, чтобы
сопоставление не противоречило указанному кадру. Например, чтобы
обработать @code{and} от двух запросов, скажем,

@lisp
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
@end lisp

@noindent

(неформально, <<найти всех сотрудников, способных выполнять работу
программиста-стажера>>), сначала мы находим все записи базы, отвечающие
образцу

@lisp
(can-do-job ?x (computer programmer trainee))
@end lisp

@float
@quotation
@anchor{Рисунок 4.5}
@ifinfo
@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced
by operating on the stream of frames in series.

@example
                +----------------------+
                |       (and A B)      |
  input stream  |                      |  output stream
  of frames     |   +---+       +---+  |  of frames
------------------->| A +------>| B +-------------------->
                |   +---+       +---+  |
                |     ^           ^    |
                |     |           |    |
                |     +-----*-----+    |
                +-----------|----------+
                            |
                        data base
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap4/Fig4.5,93mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 4.5:} The @code{and} combination of two queries is produced by operating on the stream of frames in series.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Получается поток кадров, каждый из которых содержит связывание для @code{?x}.
Затем для всех кадров этого потока мы находим записи, соответствующие образцу

@lisp
(job ?person ?x)
@end lisp

@noindent
таким образом, чтобы не менять уже известное связывание переменной
@code{?x}. Каждое новое сопоставление породит кадр, в котором будут
содержаться связывания для @code{?x} и @code{?person}. @code{And} от
двух запросов можно рассматривать как последовательное применение двух
составляющих запросов, как показано на рис. @ref{Рисунок 4.5}. Кадры,
прошедшие через первый запрос, фильтруются и расширяются вторым
запросом.

@float
@anchor{Рисунок 4.6}
@ifinfo
@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced
by operating on the stream of frames in parallel and merging the results.

@example
           +---------------------------+
           |          (or A B)         |
           |    +---+                  |
input      | +->| A |------------+     |  output
stream of  | |  +---+            V     |  stream of
frames     | |    ^          +-------+ |  frames
-------------*    |          | merge +--------------->
           | |    |          +-------+ |
           | |    |              ^     |
           | |    |   +---+      |     |
           | +------->| B +------+     |
           |      |   +---+            |
           |      |     ^              |
           |      |     |              |
           |      +--*--+              |
           +---------|-----------------+
                     |
                 data base
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap4/Fig4.6,107mm,,,.pdf}
@sp 0.4
@caption{@strong{Рисунок 4.6:} The @code{or} combination of two queries is produced by operating on the stream of frames in parallel and merging the results.}
@sp 0.4
@end iftex
@end float

На рисунке @ref{Рисунок 4.6} показан аналогичный метод для вычисления
@code{or} от двух запросов через параллельное выполнение двух
составляющих запросов. Каждый запрос отдельно расширяет входной поток
кадров. Затем два получившихся потока сливаются и образуют окончательный
поток-результат.

Даже из этого высокоуровневого описания ясно, что обработка составных
запросов может занимать много времени. Например, поскольку запрос может
породить более одного выходного кадра для каждого входного, а каждый
подзапрос в @code{and} принимает входные кадры от предыдущего
подзапроса, в наихудшем случае число сопоставлений, которые должен
произвести запрос @code{and}, растет экспоненциально с числом
подзапросов (см. упражнение @ref{Упражнение 4.76}).@footnote{Впрочем,
такой экспоненциальный взрыв в запросах @code{and} происходит редко,
поскольку, как правило, дополнительные условия не увеличивают, а
уменьшают число порождаемых кадров.} Несмотря на то, что системы для
обработки простых запросов вполне могут быть практически полезны,
обработка сложных запросов чрезвычайно трудоемка.@footnote{Имеется
обширная литература по системам управления базами данных, в которой
основной темой является эффективная обработка сложных запросов.}

С точки зрения потока кадров, запрос @code{not} работает как фильтр,
уничтожающий все кадры, для которых его подзапрос можно удовлетворить.
Например, имея образец

@lisp
(not (job ?x (computer programmer)))
@end lisp

@noindent
мы для каждого кадра во входном потоке пытаемся породить расширенные
кадры, которые удовлетворяют образцу
@code{(job ?x (computer programmer))}. Все кадры, для которых
такие расширения существуют, мы изымаем из входного потока. В результате
получается поток, состоящий только из тех кадров, в которых связывание
для @code{?x} не удовлетворяет @code{(job ?x (computer programmer))}.
Например, при обработке запроса

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
@end lisp

@noindent
первый подзапрос породит кадры со связанными значениями @code{?x} и
@code{?y}. Затем выражение @code{not} отфильтрует этот поток, удалив все
кадры, в которых значение @code{?x} удовлетворяет ограничению, что
@code{?x} является программистом.@footnote{Существует тонкое различие
между реализацией @code{not} в виде фильтра и значением отрицания в
математической логике.
См. @ref{4.3.3}.}

Особая форма @code{lisp-value} реализуется при помощи подобного же
фильтра для потоков кадров. При помощи каждого кадра из потока мы
конкретизируем все переменные образца, а затем применяем лисповский
предикат. Все кадры, для которых предикат оказывается ложным, мы удаляем
из входного потока.

@comment @subsubheading Unification
@subsubheading Унификация

Чтобы обрабатывать правила языка запросов, нам нужно уметь находить
правила, в которых заключения соответствуют данному входному образцу.
Заключения правил подобны утверждениям, но только в них могут
содержаться переменные, так что нам требуется обобщенный вариант
сопоставления с образцом, --- называемый (@newterm{unification}), --- в котором
как <<образец>>, так и <<данные>> могут содержать переменные.

Унификатор берет два образца, в каждом из которых могут быть константы и
переменные, и определяет, возможно ли присвоить переменным значения,
которые сделают два образца одинаковыми. Если да, то он возвращает кадр,
содержащий эти значения. Например, при унификации @code{(?x a ?y)} и
@code{(?y ?z a)} получится кадр, в котором все три переменные @code{?x},
@code{?y} и @code{?z} связаны со значением @code{a}. С другой стороны,
унификация @code{(?x ?y a)} и @code{(?x b ?y)} потерпит неудачу,
поскольку не имеется такого значения для @code{?y}, которое бы сделало
два образца одинаковыми. (Чтобы вторые элементы образцов оказались
равными, @code{?y} должно равняться @code{b}; однако, чтобы совпали
третьи элементы, @code{?y} обязан быть @code{a}.) Подобно сопоставителю,
унификатор, используемый в системе запросов, принимает на входе кадр и
проводит унификации, не противоречащие содержимому этого кадра.

Алгоритм унификации --- самая технически сложная часть запросной
системы. При наличии сложных образцов может показаться, что для
унификации требуются дедуктивные способности. Например, чтобы
унифицировать @code{(?x ?x)} и @code{((a ?y c) (a b ?z))}, алгоритм
обязан вычислить, что @code{?x} должен быть равен @code{(a b c)},
@code{?y} должен быть @code{b}, а @code{?z} должен быть равен @code{c}.
Можно считать, что этот процесс решает систему уравнений, описывающую
компоненты образцов. В общем случае это будут взаимозависимые уравнения,
для решения которых требуются существенные преобразования.@footnote{В
одностороннем сопоставлении с образцом все уравнения, которые содержат
переменные, заданы явно и уже решены относительно неизвестного
(переменной образца).} К примеру, унификацию @code{(?x ?x)} и
@code{((a ?y c) (a b ?z))} можно рассматривать как систему уравнений

@lisp
?x  =  (a ?y c)
?x  =  (a b ?z)
@end lisp

@noindent
Из этих уравнений следует, что

@lisp
(a ?y c)  =  (a b ?z)
@end lisp

@noindent
а отсюда, в свою очередь, что

@lisp
 a  =  a,
?y  =  b,
 c  =  ?z,
@end lisp

@noindent
и, следовательно,

@lisp
?x = (a b c)
@end lisp

@noindent
При успешном сопоставлении с образцом все переменные оказываются
связанными, и значения, с которыми они связаны, содержат только
константы. Это верно и для всех примеров унификации, которые мы до сих
пор рассмотрели. Однако в общем случае успешная унификация может не
полностью определить значения переменных; какие-то переменные могут
остаться неопределенными, а значения других сами могут содержать
переменные.

Рассмотрим унификацию @code{(?x a)} и @code{((b ?y) ?z)}. Можно
вычислить, что @code{?x = (b ?y)}, а @code{a = ?z}, но ничего больше
нельзя сказать о значениях @code{?x} и @code{?y}. Унификация
заканчивается успешно, поскольку, естественно, можно сделать образцы
одинаковыми, присвоив значения @code{?x} и @code{?y}. Поскольку
сопоставление никак не ограничивает значение, которое может принимать
переменная @code{?y}, никакого ее значения не оказывается в
кадре-результате. Однако результат ограничивает значение @code{?x}.
Какое бы значение не имела переменная @code{?y}, @code{?x} должен
равняться @code{(b ?y)}. Таким образом, в кадр помещается связывание
@code{?x} со значением @code{(b ?y)}. Если позже значение @code{?y}
оказывается определенным (путем сопоставления с образцом или унификации,
которая должна соответствовать этому кадру) и добавляется в кадр,
значение, связанное с @code{?x}, будет ссылаться на него.@footnote{Можно
считать, что унификация находит наиболее общий образец, который является
специализацией двух входных образцов. А именно, унификация @code{(?x a)}
и @code{((b ?y) ?z)} равна @code{((b ?y) a)}, а унификация
@code{(?x a ?y)} и @code{(?y ?z a)}, описанная выше, равна
@code{(a a a)}. Однако в нашей реализации удобнее считать, что
результатом унификации является не образец, а кадр.}

@comment @subsubheading Applying rules
@subsubheading Применение правил

Главной операцией в компоненте запросной системы, который производит
логический вывод на основе правил, является унификация. Чтобы увидеть,
как этот компонент работает, рассмотрим обработку запроса, содержащего
обращение к правилу, например:

@lisp
(lives-near ?x (Hacker Alyssa P))
@end lisp

@noindent
Обрабатывая этот запрос, сначала мы при помощи описанной ранее
обыкновенной процедуры сопоставления смотрим, имеются ли в базе данных
утверждения, которые сопоставляются с данным образцом. (В данном случае
таковых не окажется, поскольку в нашей базе данных нет никаких прямых
утверждений о том, кто около кого живет.) На следующем шаге мы пытаемся
унифицировать образец-запрос с заключением каждого правила. Мы
обнаруживаем, что образец унифицируется с заключением правила

@lisp
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
@end lisp

@noindent
и получается кадр, в котором переменная @code{?person-2} связана со
значением @code{(Hacker Alyssa P)}, а переменная @code{?x} связана с
(должна иметь то же значение, что и) @code{?person-1}. Теперь по
отношению к этому кадру мы вычисляем составной запрос, содержащийся в
теле правила. Успешные сопоставления расширят кадр, сообщив значение
переменной @code{?person-1}, а соответственно, и @code{?x}, которую мы
можем использовать при конкретизации исходного образца-запроса.

В общем случае обработчик запросов при применении правила, когда он
пытается распознать образец-запрос в кадре, который содержит связывания
для некоторых переменных образца, использует следующий метод:

@itemize @bullet

@item
Унифицировать запрос с заключением правила и получить (если унификация
успешна) расширение исходного кадра.

@item
По отношению к расширенному кадру вычислить запрос, который является
телом правила.

@end itemize

@noindent
Обратите внимание, насколько это похоже на метод применения процедуры в
интерпретаторе @code{eval/apply} для Лиспа:

@itemize @bullet

@item
Связать параметры процедуры с ее аргументами и получить кадр,
расширяющий исходное окружение процедуры.

@item
По отношению к расширенному окружению вычислить выражение, которое
является телом процедуры.
@end itemize

@noindent
Подобие двух вычислителей неудивительно. Точно так же, как в Лиспе
средством абстракции являются определения процедур, в языке запросов
средством абстракции являются определения правил. В каждом случае мы
развертываем абстракцию, создавая соответствующие связывания и вычисляя
тело правила либо процедуры по отношению к расширенной среде.

@comment @subsubheading Simple queries
@subsubheading Простые запросы

В этом разделе мы уже рассматривали, как вычислять простые запросы при
отсутствии правил. Теперь, разобравшись, как применяются правила, мы
можем описать, как простые запросы вычисляются с помощью как правил, так
и утверждений.

Получая запрос-образец и поток кадров, мы порождаем для каждого входного
кадра два новых потока:

@itemize @bullet

@item
поток расширенных кадров, получаемых сопоставлением образца со всеми
утверждениями базы данных (при помощи сопоставителя), а также

@item
поток расширенных кадров, полученных применением всех возможных правил
(при помощи унификатора).@footnote{Поскольку унификация является
обобщением сопоставления, можно было бы упростить систему и порождать
оба потока с помощью унификатора. Однако обработка простого случая с
помощью обычного сопоставителя показывает, как сопоставление (а не
полноразмерная унификация) может само по себе быть полезным.}
@end itemize

@noindent
Соединение двух этих потоков порождает поток, который состоит изо всех
способов, которыми данный образец можно удовлетворить в соответствии с
исходным кадром. Эти потоки (по одному на каждый кадр входного потока)
соединяются, и получается единый большой поток. Окончательный поток,
таким образом, состоит изо всех способов, которыми какой-либо кадр
входного потока может быть расширен так, чтобы получалось сопоставление
с данным запросом.

@comment @subsubheading The query evaluator and the driver loop
@subsubheading Вычислитель запросов и управляющий цикл

Несмотря на сложность встроенных операций сопоставления, система
организована подобно интерпретатору любого языка. Процедура,
координирующая операции сопоставления, называется и играет роль,
аналогичную процедуре @code{eval} для Лиспа. @code{qeval} принимает на
входе запрос и поток кадров. Ее выходом служит поток кадров,
соответствующих успешным сопоставлениям с запросом, которые расширяют
какой-либо кадр во входном потоке, как показано на
рис. @ref{Рисунок 4.4}. Подобно @code{eval}, @code{qeval} распознает
различные типы выражений (запросов) и для каждого из них вызывает
соответствующую процедуру. Имеется по процедуре для каждой особой формы
(@code{and}, @code{or}, @code{not} и @code{lisp-value}) и еще одна для
простых запросов.

Управляющий цикл, аналогичный процедуре @code{driver-loop} из других
интерпретаторов этой главы, считывает запросы с терминала. Для каждого запроса
он вызывает @code{qeval} с запросом и потоком, состоящим из одного пустого кадра.
Получается поток всех возможных сопоставлений (всех возможных расширений
пустого кадра). Для каждого кадра в выходном потоке управляющий цикл
конкретизирует входной запрос с использованием значений переменных,
имеющихся в кадре. Затем этот поток конкретизированных запросов
печатается.@footnote{Мы используем потоки (а не списки) кадров потому,
что рекурсивное применение правил может порождать бесконечное число
значений, удовлетворяющих запросу. Здесь существенно задержанное
вычисление, осуществляемое потоками: система будет печатать ответы один
за другим по мере их порождения, независимо от того, получается ли
конечное или бесконечное количество ответов.}

Кроме того, управляющий цикл распознает особую команду @code{assert!},
которая говорит, что на вход поступает не запрос, а новое утверждение
или правило, которое следует добавить в базу данных. Например,

@lisp
(assert! (job (Bitdiddle Ben)
              (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
@end lisp

@direntry
@lisp
(assert! (должность (Битобор Бен) (компьютеры гуру)))
(assert! (rule (шишка ?person)
               (and (начальник ?middle-manager ?person)
                    (начальник ?x ?middle-manager))))
@end lisp
@end direntry

@comment @subsection Is Logic Programming Mathematical Logic?
@subsection Является ли логическое программирование математической логикой?
@node	4.4.3, 4.4.4, 4.4.2, 4.4

На первый взгляд может показаться, что средства комбинирования,
используемые в языке запросов, совпадают с операторами математической
логики --- @code{and}, @code{or} и отрицанием @code{not}, а при применении
правил языка запросов производится корректный логический вывод.
@footnote{То, что конкретный метод
логического вывода корректен --- утверждение не тривиальное. Требуется
доказать, что исходя из истинных посылок, можно придти только к истинным
заключениям. В применении правил используется , известный метод вывода,
который говорит, что если истинны утверждения @math{A} и @emph{из
@math{A} следует @math{B}}, то можно заключить истинность утверждения
@math{B}.} Однако такая идентификация языка запросов с математической
логикой неверна, поскольку язык запросов обладает (@newterm{control structure}),
которая интерпретирует логические утверждения процедурным образом. Часто
из этой структуры управления можно извлечь пользу. Например, чтобы найти
начальников всех программистов, можно сформулировать запрос двумя
логически эквивалентными способами:

@lisp
(and (job ?x (computer programmer)) (supervisor ?x ?y))
@end lisp

@direntry
@lisp
(and (должность ?x (компьютеры программист))
     (начальник ?x ?y))
@end lisp
@end direntry

@noindent
и

@lisp
(and (supervisor ?x ?y) (job ?x (computer programmer)))
@end lisp

@direntry
@lisp
(and (начальник ?x ?y)
     (должность ?x (компьютеры программист)))
@end lisp
@end direntry

@noindent
Если в компании намного больше начальников, чем программистов (обычный
случай), то первую форму использовать выгоднее, чем вторую, поскольку
для каждого промежуточного результата (кадра), порождаемого первым
подзапросом @code{and}, требуется просмотреть базу данных.

Цель логического программирования состоит в том, чтобы дать программисту
способ разбить вычислительную задачу на две отдельные подзадачи: <<что>>
требуется посчитать и <<как>> это сделать. Этого добиваются, выделив
подмножество утверждений математической логики --- достаточно мощное,
чтобы описать все, что захочется вычислить, но при этом достаточно
слабое, чтобы иметь управляемую процедурную реализацию. Идея состоит в
том, чтобы, с одной стороны, программа, выраженная на языке логического
программирования, была эффективной, и компьютер мог бы ее исполнить.
Управление (<<как>> считать) определяется порядком вычислений языка. У
нас должна быть возможность определять порядок выражений и порядок
подвыражений в них так, чтобы вычисление проходило правильным и
эффективным способом. В то же самое время мы должны быть способны
рассматривать результат вычислений (<<что>> считать) как простое
следствие законов логики.

Наш язык запросов можно рассматривать в качестве именно такого
процедурно интерпретируемого подмножества математической логики.
Утверждение представляет простой факт (атомарную пропозицию). Правило
представляет импликацию, говорящую, что заключение истинно в случаях,
когда истинно тело правила. Правило обладает естественной процедурной
интерпретацией: чтобы доказать заключение правила, требуется доказать
его тело. Следовательно, правила описывают вычисления. Однако поскольку
правила можно рассматривать и как формулы математической логики, мы
можем оправдать любой <<вывод>>, производимый логической программой,
показав, что того же результата можно достичь, работая строго в рамках
логики.@footnote{Это утверждение нужно ограничить соглашением: говоря о
<<выводе>>, производимом логической программой, мы предполагаем, что
вычисление имеет конец. К сожалению, даже это ограниченное утверждение
оказывается ложным для нашей реализации языка запросов (а также для
программ на Прологе и большинстве других современных математических
языков) из-за использования @code{not} и @code{lisp-value}. Как будет
описано ниже, примитив @code{not}, реализованный в языке запросов, не
всегда имеет то же значение, что отрицание в математической логике, а
использование @code{lisp-value} вызывает дополнительные сложности. Можно
было бы реализовать язык, согласованный с математической логикой, если
просто убрать из него @code{not} и @code{lisp-value} и согласиться
писать программы с использованием исключительно простых запросов,
@code{and} и @code{or}. Однако при этом оказалась бы ограничена
выразительная сила языка. Одна из основных тем исследований в логическом
программировании --- поиск способов более тесного согласования с
математической логикой без чрезмерной потери выразительной силы.}

@comment @subsubheading Infinite loops
@subsubheading Бесконечные циклы

Вследствие процедурной интерпретации логических программ для решения
некоторых задач можно построить безнадежно неэффективные программы.
Частным случаем неэффективности является ситуация, когда программа при
работе над выводом впадает в бесконечный цикл. Возьмем простой пример:
предположим, что мы строим базу данных знаменитых супружеских пар, в том
числе

@lisp
(assert! (married Minnie Mickey))
@end lisp

@direntry
@lisp
(assert! (супруг Минни Микки))
@end lisp
@end direntry

@noindent
Если теперь мы спросим

@lisp
(married Mickey ?who)
@end lisp

@direntry
@lisp
(супруг Микки ?who)
@end lisp
@end direntry

@noindent
мы не получим ответа, поскольку система не знает, что если @math{A}
является супругом @math{B}, то @math{B} является супругом @math{A}.
Поэтому мы вводим правило

@lisp
(assert! (rule (married ?x ?y) (married ?y ?x)))
@end lisp

@direntry
@lisp
(assert! (rule (супруг ?x ?y)
               (супруг ?y ?x)))
@end lisp
@end direntry

@noindent
и снова делаем запрос

@lisp
(married Mickey ?who)
@end lisp

@direntry
@lisp
(супруг Микки ?who)
@end lisp
@end direntry

К сожалению, это вводит систему в бесконечный цикл следующим образом:

@itemize @bullet

@item
Система обнаруживает, что применимо правило @code{married}; а именно,
заключение @code{(married ?x ?y)} успешно унифицируется с
образцом-запросом @code{(married Mickey ?who)} и получается кадр, в
котором переменная @code{?x} связана со значением @code{Mickey}, а
переменная @code{?y} со значением @code{?who}. Интерпретатор должен,
таким образом, выполнить в этом кадре запрос @code{(married ?y ?x)} ---
в сущности, выполнить запрос @code{(married ?who Mickey)}.

@item
Один ответ находится как утверждение в базе данных:
@code{(married Minnie Mickey)}.

@item
Применимо также и правило @code{married}, так что интерпретатор снова
выполняет его тело, которое теперь равно @code{(married Mickey ?who)}.

@end itemize

@noindent
Теперь система оказалась в бесконечном цикле. В сущности, найдет ли
система простой ответ @code{(married Minnie Mickey)} прежде, чем окажется в
цикле, зависит от деталей реализации, связанных с порядком, в котором
система проверяет записи базы данных. Это простой пример циклов, которые
могут возникнуть. Наборы взаимосвязанных правил могут привести к циклам,
которые значительно труднее предвидеть, а возникновение цикла может
зависеть от порядка подвыражений в @code{and}
(см. упражнение @ref{Упражнение 4.64}) или от низкоуровневых деталей,
связанных с порядком обработки запросов в системе.@footnote{Это проблема
не собственно логики, а процедурной интерпретации логики, которую дает
наш интерпретатор. В данном случае можно написать интерпретатор, который
не попадет в цикл. Например, можно пронумеровать доказательства,
выводимые из наших утверждений и правил, по ширине, а не по глубине.
Однако в такой системе оказывается труднее использовать порядок правил в
программах. Одна из попыток встроить в такую программу тонкое управление
вычислениями описана в deKleer et al. 1977. Еще один метод, который не
ведет к столь же сложным проблемам с управлением, состоит в добавлении
специальных знаний, например, детекторов для каких-то типов циклов
(см. упражнение @ref{Упражнение 4.67}). Однако общую схему надежного
предотвращения бесконечных путей в рассуждениях построить невозможно.
Представьте себе дьявольское правило вида <<чтобы доказать истинность
@math{P(x)}, докажите истинность @math{P(f(x))}>> для какой-нибудь хитро
выбранной функции @math{f}.}

@comment @subsubheading Problems with @code{not}
@subsubheading Проблемы с @code{not}

Еще одна особенность запросной системы связана с @code{not}. Рассмотрим
следующие два запроса к базе данных из @ref{4.4.1}:

@lisp
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
@end lisp

@direntry
@lisp
(and (начальник ?x ?y)
     (not (должность ?x (компьютеры программист))))

(and (not (должность ?x (компьютеры программист)))
     (начальник ?x ?y))
@end lisp
@end direntry

Эти два запроса приводят к различным результатам. Первый запрос сначала
находит все записи в базе данных, соответствующие образцу
@code{(supervisor ?x ?y)}, затем фильтрует полученные кадры, удаляя те, в
которых значение @code{?x} удовлетворяет образцу
@code{(job ?x (computer programmer))}. Второй запрос сначала
фильтрует входные кадры, пытаясь удалить те, которые удовлетворяют
образцу @code{(job ?x (computer programmer))}. Поскольку
единственный входной кадр пуст, он проверяет базу данных и смотрит, есть
ли там записи, соответствующие
@code{(job ?x (computer programmer))}. Поскольку, как правило,
такие записи имеются, выражение @code{not} удаляет пустой кадр, и
остается пустой поток кадров. Следовательно, весь составной запрос также
возвращает пустой поток.

Сложность состоит в том, что наша реализация @code{not} предназначена
только для того, чтобы служить фильтром для значений переменных. Если
выражение @code{not} обрабатывается с кадром, в котором часть переменных
остается несвязанными (как @code{?x} в нашем примере), система выдаст
неверный результат. Подобные сложности возникают и с использованием
@code{lisp-value} --- предикат Lisp не сможет работать, если часть из
его аргументов несвязана. См. упражнение @ref{Упражнение 4.77}.

Есть еще один, значительно более серьезный аспект, в котором @code{not}
языка запросов отличается от отрицания в математической логике. В логике
мы считаем, что выражение <<не @math{P}>> означает, что @math{P} ложно.
Однако в системе запросов <<не @math{P}>> означает, что @math{P}
невозможно доказать на основе информации из базы данных. Например, имея
базу данных из @ref{4.4.1},
система радостно выведет разнообразные отрицательные утверждения,
например, что Бен Битобор не любитель бейсбола, что на улице нет дождя,
и что 2 + 2 не равно 4.@footnote{Рассмотрим запрос
@code{(not (baseball-fan (Bitdiddle Ben))}. Система обнаруживает,
что записи @code{(baseball-fan (Bitdiddle Ben))} в базе нет, так что
пустой кадр образцу не соответствует и не удаляется из исходного потока
кадров. Таким образом, результатом запроса является пустой кадр, он
используется для конкретизации запроса, и выходит
@code{(not (baseball-fan (Bitdiddle Ben)))}.} Иными словами,
операция @code{not} в языках логического программирования отражает так
называемую (closed world assumption) и считает, что вся релевантная
информация включена в базу данных.@footnote{Обсуждение и защита такой
интерпретации @code{not} содержится в статье Кларка (Clark 1978).}

@quotation
@strong{@anchor{Упражнение 4.64}Упражнение 4.64:}
Хьюго Дум по ошибке уничтожил в базе данных правило @code{outranked-@/by}
(@ref{4.4.1}). Обнаружив это, он быстро набивает правило заново, только, к
сожалению, по ходу дела вносит небольшое изменение:

@lisp
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person
                           ?middle-manager))))
@end lisp

@direntry
@lisp
(rule (подчиняется ?staff-person ?boss)
      (or (начальник ?staff-person ?boss)
          (and (подчиняется ?middle-manager ?boss)
               (начальник ?staff-person ?middle-manager))))
@end lisp
@end direntry

Сразу после того, как Хьюго ввел информацию в систему, Кон Фиден хочет
посмотреть, кому подчиняется Бен Битобор. Он вводит запрос

@lisp
(outranked-by (Bitdiddle Ben) ?who)
@end lisp

@direntry
@lisp
(подчиняется (Битобор Бен) ?who)
@end lisp
@end direntry

После ответа система проваливается в бесконечный цикл. Объясните,
почему.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.65}Упражнение 4.65:}
П.Э. Фект, ожидая собственного продвижения по иерархии,
дает запрос, который находит всех @code{wheel} (используя правило из @ref{4.4.1}):

@lisp
(wheel ?who)
@end lisp

@direntry
@lisp
(шишка ?who)
@end lisp
@end direntry

К его удивлению, система отвечает

@lisp
@i{;;; Результаты запроса:}
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
@end lisp

@direntry
@lisp
@i{;;; Результаты запроса:}
(шишка (Уорбак Оливер))<F9>
(шишка (Битобор Бен))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
@end lisp
@end direntry

Почему система упоминает Оливера Уорбака четыре раза?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.66}Упражнение 4.66:}
Бен работал над обобщением системы запросов так, чтобы
можно было собирать статистику о компании. Например, чтобы найти сумму
зарплат всех программистов, можно было бы сказать

@lisp
(sum ?amount (and (job ?x (computer programmer))
                  (salary ?x ?amount)))
@end lisp

@direntry
@lisp
(sum ?amount
     (and (должность ?x (компьютеры программист))
          (зарплата ?x ?amount)))
@end lisp
@end direntry

В общем случае новая система Бена допускает запросы вида

@lisp
(accumulation-function @math{\langle}@var{переменная}@math{\rangle} @math{\langle}@var{запрос-образец}@math{\rangle})
@end lisp

@noindent
где в виде @code{accumulation-function} могут выступать @code{sum}
(сумма), @code{average} (среднее) или @code{maximum} (максимум). Бен
думает, что реализовать это расширение будет проще простого. Он просто
скормит образец-запрос функции @code{qeval} и получит поток кадров.
Затем он пропустит поток через функцию-отображение, которая из каждого
кадра извлечет значение указанной переменной, и получившийся поток
значений отдаст функции-накопителю. Когда Бен заканчивает свою
реализацию и собирается ее опробовать, мимо проходит Пабло, все еще
смущенный результатом запроса из упражнения @ref{Упражнение 4.65}.
Когда Пабло показывает Бену полученный им от системы ответ, Бен
хватается за голову: <<Моя простая схема накопления не будет работать!>>

Что понял Бен? Опишите, как он мог бы исправить ситуацию.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.67}Упражнение 4.67:}
Придумайте, как в запросную систему можно вставить
детектор циклов, который избегает простых зацикливаний, вроде показанных
в тексте и в упражнении @ref{Упражнение 4.64}. Общая идея состоит в
том, что система должна хранить в каком-то виде историю текущей цепи
рассуждений и не начинать обработку запроса, если она уже над ним
работает. Опишите, информация какого вида (образцы и кадры) включается в
историю и как можно проводить проверку. (После того, как Вы изучите в
деталях реализацию запросной системы из @ref{4.4.4}, Вы можете захотеть
изменить систему и включить в нее свой детектор циклов.)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.68}Упражнение 4.68:}
Определите правила, с помощью которых реализуется операция
из упражнения @ref{Упражнение 2.18}, возвращающая список, элементы
которого те же, что и в исходном, но идут в обратном порядке.
(Подсказка: используйте @code{append-to-form}.) Могут ли Ваши правила
ответить и на запрос @code{(reverse (1 2 3) ?x)}, и на
@code{(reverse ?x (1 2 3))}?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.69}Упражнение 4.69:}
Начав с базы данных и правил, сформулированных Вами в
упражнении @ref{Упражнение 4.63}, постройте правила для добавления
приставок <<пра>> в отношение @code{внук}. Система должна уметь понять,
что Ирад --- правнук Адама, а Иавал и Иувал приходятся Адаму
прапрапрапраправнуками. (Подсказка: представляйте, например, утверждение
об Ираде как @code{((great grandson) Adam Irad)}. Напишите правила, которые
определяют, заканчивается ли список словом @code{grandson}. С помощью этого
определите правило, которое позволяет вывести отношение
@code{((great . ?rel) ?x ?y)}, где список @code{?rel} оканчивается на
@code{grandson}.) Проверьте свои правила на запросах
@code{((great grandson) ?g ?ggs)} и @code{(?relationship Adam Irad)}.
@end quotation

@comment @subsection Implementing the Query System
@subsection Реализация запросной системы
@node	4.4.4,  , 4.4.3, 4.4

В @ref{4.4.2} описывалось, как работает запросная система. Теперь мы
представляем полную реализацию системы во всех деталях.

@menu
* 4-4-4-1::          Управляющий цикл и конкретизация
* 4-4-4-1::          Вычислитель
* 4-4-4-1::          Поиск утверждений с помощью сопоставления с образцом
* 4-4-4-1::          Правила и унификация
* 4-4-4-1::          Ведение базы данных
* 4-4-4-1::          Операции над потоками
* 4-4-4-1::          Процедуры определяющие синтаксис запросов
* 4-4-4-1::          Кадры и связывания
@end menu

@comment @subsubsection The Driver Loop and Instantiation
@subsubsection Управляющий цикл и конкретизация
@node 4.4.4.1, 4.4.4.2, 4.4.4, 4.4.4

Управляющий цикл запросной системы читает входные выражения. Если
выражение является правилом или утверждением, которое требуется добавить
в базу данных, то происходит добавление. В противном случае
предполагается, что выражение является запросом. Управляющий цикл
передает запрос вычислителю @code{qeval} вместе с начальным потоком,
состоящим из одного пустого кадра. Результатом вычисления является поток
кадров, порожденных заполнением переменных запроса значениями,
найденными в базе данных. С помощью этих кадров порождается новый поток,
состоящий из копий исходного запроса, в которых переменные
конкретизированы значениями из потока кадров. Этот последний поток
печатается на терминале:

@lisp
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
@end lisp

@noindent
Здесь, как и в других интерпретаторах из этой главы, мы пользуемся
абстрактным синтаксисом языка запросов. Реализация синтаксиса выражений,
включая предикат @code{assertion-to-be-added?} и селектор
@code{add-assertion-body}, дается в
@ref{4.4.4.7}. Процедура
@code{add-rule-or-assertion!} определяется в
@ref{4.4.4.5}.

Прежде чем обрабатывать входное выражение, управляющий цикл преобразует
его синтаксис в форму, которая делает обработку эффективнее. При этом
меняется представление переменных образца. Когда запрос
конкретизируется, то все переменные, которые остались несвязанными,
преобразуются, прежде чем печататься, обратно во входное представление.
Эти преобразования производятся процедурами @code{query-syntax-process}
и @code{contract-question-mark}
(@ref{4.4.4.7}).

Чтобы конкретизировать выражение, мы его копируем, заменяя при этом все
переменные выражения их значениями из данного кадра. Значения сами по
себе конкретизируются, поскольку и они могут содержать переменные
(например, если @code{?x} внутри @code{exp} связано в результате
унификации со значением @code{?y}, а уже @code{?y} связано со значением
5). Действие, которое требуется предпринять, если переменную не удается
конкретизировать, задается процедурным аргументом @code{instantiate}.

@lisp
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
@end lisp

@noindent
Процедуры, управляющие связываниями, определяются в
@ref{4.4.4.8}.

@comment @subsubsection The Evaluator
@subsubsection Вычислитель
@node 4.4.4.2, 4.4.4.3, 4.4.4.1, 4.4.4

Процедура @code{qeval}, вызываемая из @code{query-driver-loop}, является
основным вычислителем запросной системы. Она принимает на входе запрос и
поток кадров и возвращает поток расширенных кадров. Особые формы она
распознает через диспетчеризацию, управляемую данными, при помощи
@code{get} и @code{put}, в точности так же, как мы реализовывали
обобщенные операции в @ref{Глава 2}.
Все запросы, которые не распознаются как особая форма, считаются
простыми запросами и обрабатываются процедурой @code{simple-query}.

@lisp
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
@end lisp

@noindent
Селекторы @code{type} и @code{contents}, определяемые в
@ref{4.4.4.7}, реализуют абстрактный синтаксис особых форм.

@comment @subsubheading Simple queries
@subsubheading Простые запросы

Процедура @code{simple-query} обрабатывает простые запросы. В качестве
аргументов она принимает простой запрос (образец) и поток кадров, а
возвращает поток, порожденный путем расширения каждого кадра всеми
результатами успешного сопоставления записей базы данных с запросом.

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
@end lisp

@noindent
Для каждого кадра из входного потока мы с помощью @code{find-assertions}
(@ref{4.4.4.3})
сопоставляем образец со всеми утверждениями из базы данных, получая при
этом поток расширенных кадров. Кроме того, с помощью @code{apply-rules}
(@ref{4.4.4.4}) мы применяем все
подходящие правила и получаем при этом еще один поток расширенных
кадров. Два этих потока сливаются (при помощи
@code{stream-append-delayed} из @ref{4.4.4.6}) и дают на выходе поток,
перечисляющий все способы, которыми исходный запрос можно удовлетворить
в соответствии с исходным кадром
(см. упражнение @ref{Упражнение 4.71}). Потоки от отдельных входных
кадров соединяются через @code{stream-flatmap} (@ref{4.4.4.6}) в один большой поток,
содержащий все способы, которыми можно расширить кадры из входного
потока и получить сопоставление с исходным запросом.

@comment @subsubheading Compound queries
@subsubheading Составные запросы

Запросы с операцией @code{and} обрабатываются так, как показано на
рис. @ref{Рисунок 4.5}, процедурой @code{conjoin}. @code{conjoin}
принимает в качестве аргументов конъюнкты и поток кадров, а возвращает
поток расширенных кадров. Сначала она обрабатывает поток кадров и
получает поток всех их возможных расширений, удовлетворяющих первому
запросу конъюнкции. Затем, используя этот новый поток кадров, она
рекурсивно применяет @code{conjoin} к остальным конъюнктам.

@lisp
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts) frame-stream))))
@end lisp

@noindent
Выражение

@lisp
(put 'and 'qeval conjoin)
@end lisp

настраивает процедуру @code{ qeval} так, чтобы она при обнаружении формы
@code{and} вызывала @code{conjoin}.

Запросы @code{or} обрабатываются подобным же образом, как показано на
рис. @ref{Рисунок 4.6}. Выходные потоки отдельных дизъюнктов @code{or}
вычисляются раздельно и смешиваются при помощи процедуры
@code{interleave-delayed} из @ref{4.4.4.6}.
(См. упражнения @ref{Упражнение 4.71}.)

@lisp
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
(put 'or 'qeval disjoin)
@end lisp

Предикаты и селекторы для синтаксиса конъюнктов и дизъюнктов даны в
@ref{4.4.4.7}.

@comment @subsubheading Filters
@subsubheading Фильтры

Запросы @code{not} обрабатываются так, как описано в @ref{4.4.2}. Мы
пытаемся расширить каждый кадр входного потока так, чтобы удовлетворялся
отрицаемый запрос, и включаем данный кадр в поток-результат только в том
случае, если расширить его нельзя.

@lisp
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null?
          (qeval (negated-query operands)
                 (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
@end lisp

@noindent
@code{lisp-value} --- фильтр, подобный @code{not}. Образец расширяется
с помощью каждого кадра из входного потока, применяется указанный
предикат, и кадры, для которых он возвращает ложное значение,
исключаются из входного потока. Если остаются несвязанные переменные
запроса, возникает ошибка.

@lisp
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var: -- LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
@end lisp

@noindent
Процедура @code{execute}, которая применяет предикат к аргументам,
должна вызвать @code{eval} от предикатного выражения, чтобы получить
применяемую процедуру. Однако она не должна вычислять аргументы,
поскольку это сами аргументы и есть, а не выражения, вычисление которых
(на Лиспе) даст нам аргументы. Обратите внимание, что @code{execute}
реализована с помощью @code{eval} и @code{apply} из нижележащей
Lisp-системы.

@lisp
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
@end lisp

Особая форма @code{always-true} порождает запрос, который всегда
удовлетворяется. Она игнорирует свое подвыражение (обычно пустое) и
попросту пропускает через себя все кадры входного потока.
@code{Always-true} используется в селекторе @code{rule-body}
(@ref{4.4.4.7}) чтобы дать тела правилам, для которых тела не определены
(то есть правилам, заключения которых всегда удовлетворяются).

@lisp
(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
@end lisp

Селекторы, которые определяют синтаксис @code{not} и @code{lisp-value},
определены в @ref{4.4.4.7}.

@comment @subsubsection Finding Assertions@* by Pattern Matching
@subsubsection Поиск утверждений с помощью сопоставления с образцом
@node 4.4.4.3, 4.4.4.4, 4.4.4.2, 4.4.4

Процедура @code{find-assertions}, вызываемая из @code{simple-query}
(@ref{4.4.4.2}), принимает на входе образец и
кадр. Она возвращает поток кадров, каждый из которых расширяет исходный
кадр сопоставлением данного образца с записью базы данных. Она
пользуется @code{fetch-assertions} (@ref{4.4.4.5}), чтобы найти поток
всех утверждений базы, которые следует проверять на сопоставление с
данными образцом и кадром. Мы используем @code{fetch-assertions} потому,
что часто можно с помощью простых тестов исключить множество записей в
базе данных из числа кандидатов на успешное сопоставление. Система
продолжала бы работать, если бы мы исключили @code{fetch-assertions} и
попросту проверяли поток всех утверждений базы, но при этом вычисление
было бы менее эффективным, поскольку пришлось бы делать намного больше
вызовов сопоставителя.

@lisp
(define (find-assertions pattern frame)
  (stream-flatmap
    (lambda (datum) (check-an-assertion datum pattern frame))
    (fetch-assertions pattern frame)))
@end lisp

Процедура @code{check-an-assertion} принимает в качестве аргументов
образец, объект данных (утверждение) и кадр, и возвращает либо
одноэлементный поток с расширенным кадром, либо, если сопоставление
неудачно, @code{the-empty-stream}.

@lisp
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
@end lisp

Сопоставитель как таковой возвращает либо символ @code{failed}, либо
расширение данного кадра. Основная идея сопоставителя состоит в том,
чтобы сравнивать образец с данными, элемент за элементом, и собирать при
этом связывания переменных образца. Если образец и объект данных
совпадают, то сопоставление оказывается успешным, и мы возвращаем поток
собранных связываний. В противном случае, если образец является
переменной, мы расширяем имеющийся кадр, связывая переменную с данными,
если это не противоречит уже имеющимся в кадре связываниям. Если и
образец, и данные являются парами, мы (рекурсивно) сопоставляем
@code{car} образца с @code{car} данных и получаем кадр; затем с этим
кадром мы сопоставляем @code{cdr} образца с @code{cdr} данных. Если ни
один из этих случаев не применим, сопоставление терпит неудачу, и мы
возвращаем символ @code{failed}.

@lisp
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match
           (cdr pat)
           (cdr dat)
           (pattern-match (car pat) (car dat) frame)))
        (else 'failed)))
@end lisp

Вот процедура, которая расширяет кадр, добавляя к нему новое связывание,
если это не противоречит уже имеющимся в кадре связываниям:

@lisp
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
@end lisp

Если для переменной в кадре нет связывания, мы просто добавляем к нему
новое связывание этой переменной с элементом данных. В противном случае
мы вызываем сопоставитель в данном кадре от элемента данных и имеющегося
значения переменной в кадре. Если хранимое значение содержит только
константы, (а это всегда так будет, если оно само было создано
процедурой @code{extend-if-consistent} во время сопоставления с
образцом), то это сопоставление просто проверит, совпадает ли хранимое
значение с новым. Если да, то кадр вернется неизменным; если нет,
вернется символ неудачи. Однако если хранимое в кадре значение было
создано при унификации (см. @ref{4.4.4.4}), то оно может
содержать переменные образца. Рекурсивное сопоставление хранимого
образца с новым элементом данных добавит или проверит связывания
переменных в этом образце. Предположим, к примеру, что у нас есть кадр,
в котором переменная @code{?x} связана с выражением @code{(f ?y)}, а
@code{?y} несвязана, и что теперь мы хотим расширить этот кадр, связав
@code{?x} со значением @code{(f b)}. Мы ищем в кадре @code{?x} и видим,
что она связана с @code{(f ?y)}. Теперь нам нужно сопоставить
@code{(f ?y)} с предлагаемым новым значением @code{(f b)} в том же самом
кадре. В конце концов это сопоставление расширяет кадр, добавив
связывание @code{?y} с @code{b}. @code{?X} по-прежнему связано с
@code{(f ?y)}. Мы никогда не изменяем хранимое связывание и никогда не
храним более одного связывания для одной и той же переменной.

Процедуры, при помощи которых @code{extend-if-consistent} работает со
связываниями, определены в @ref{4.4.4.8}.

@comment @subsubheading Patterns with dotted tails
@subsubheading Образцы с точечными хвостами

Если в образце содержится точка, за которой следует переменная образца,
то переменная сопоставляется с остатком списка (а не со следующим его
элементом), как и следовало ожидать от точечной записи, описанной в
упражнении @ref{Упражнение 2.20}. Несмотря на то, что реализованный
нами сопоставитель на занимается специально поиском точек, работает он в
этом случае так, как ему следует. Это происходит потому, что лисповский
примитив @code{read}, с помощью которого @code{query-driver-loop}
считывает запрос и представляет его в виде списковой структуры,
обрабатывает точки особым образом.

Когда @code{read} встречает точку, вместо того, чтобы сделать следующее
выражение очередным элементом списка (@code{car} в ячейке @code{cons},
@code{cdr} которой будет остатком списка), он делает его @code{cdr}ом
списковой структуры. Например, списковая структура, которую @code{read}
порождает при чтении образца @code{(computer ?type)} могла бы быть
построена с помощью выражения
@code{(cons 'computer (cons '?type '()))}, а та, которая получается
при чтении @code{(computer . ?type)}, могла бы получиться при
вычислении @code{(cons 'computer '?type)}.

Таким образом, когда @code{pattern-match} рекурсивно сравнивает
@code{car}-ы и @code{cdr}-ы списка данных и образца, содержащего точку, он
в конце концов сопоставляет переменную после точки (она служит
@code{cdr} образца) с подсписком списка данных, и связывает переменную с
этим списком. Например, сопоставление образца
@code{(computer . ?type)} со списком
@code{(computer programmer trainee)} сопоставит переменную
@code{?type} с подсписком @code{(programmer trainee)}.

@comment @subsubsection Rules and Unification
@subsubsection Правила и унификация
@node 4.4.4.4, 4.4.4.5, 4.4.4.3, 4.4.4

Процедура @code{apply-rules} --- это аналог @code{find-assertion} (@ref{4.4.4.3}).
Она принимает на входе образец и кадр, а порождает поток расширенных кадров,
применяя правила из базы данных. @code{Stream-flatmap} отображает через
@code{apply-rule} поток возможно применимых правил (отобранных процедурой
@code{fetch-rules} из @ref{4.4.4.5}) и склеивает получившиеся потоки кадров.

@lisp
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
@end lisp

Процедура @code{apply-a-rule} применяет правила способом, описанным в
@ref{4.4.2}. Сначала она дополняет
кадр-аргумент, унифицируя в его рамках заключение правила с образцом.
Если это удается, она выполняет в получившемся кадре тело правила.

Однако прежде всего программа переименовывает все переменные в правиле и
дает им уникальные новые имена. Это делается потому, что мы не хотим,
чтобы переменные из различных применений правил смешивались друг с
другом. К примеру, если в двух правилах используется переменная
@code{?x}, то каждое из них может добавить связывание этой переменной к
кадру, в котором оно применяется. Однако эти два @code{?x} не имеют друг
к другу никакого отношения, и мы не должны обманываться и считать, что
два связывания этих переменных обязаны соответствовать друг другу.
Вместо переименования переменных мы могли бы придумать более хитрую
структуру окружений; однако выбранный здесь подход с
переименованиями --- самый простой, хотя и не самый эффективный.
(См. упражнение @ref{Упражнение 4.79}.) Вот процедура
@code{apply-a-rule}:

@lisp
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
@end lisp

Селекторы @code{rule-body} и @code{conclusion}, извлекающие части
правил, описаны в @ref{4.4.4.7}.

Чтобы породить уникальные имена переменных, мы связываем с каждым
применением правила уникальный идентификатор (например, число) и цепляем
его к исходным именам переменных. Например, если идентификатор
применения правила равен 7, мы можем заменить все @code{?x} в правиле на
@code{?x-7}, а все @code{?y} на @code{?y-7}. (Процедуры
@code{make-new-variable} и @code{new-rule-application-id} содержатся
среди синтаксических процедур в @ref{4.4.4.7}.)

@lisp
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
@end lisp

Алгоритм унификации реализуется в виде процедуры, которая принимает на
входе два образца и кадр, а возвращает либо расширенный кадр, либо
символ @code{failed}. Унификатор в основном подобен сопоставителю, но
только он симметричен --- переменные разрешаются с обеих сторон
сопоставления. Процедура @code{unify-match} подобна
@code{pattern-match}, за исключением нового отрезка кода (отмеченного
знаком <<@code{***}>>), где обрабатывается случай, когда объект на правой
стороне сопоставления является переменной.

@lisp
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame)) @r{; ***}
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
@end lisp

При унификации, как и при одностороннем сопоставлении с образцом, нам
нужно принимать предлагаемое расширение кадра только в том случае, когда
оно не противоречит имеющимся связываниям. Процедура
@code{extend-if-possible}, используемая при унификации, подобна
@code{extend-if-consistent} из сопоставителя, за исключением двух
проверок, отмеченных в программе значком <<@code{***}>>. В первом случае,
если переменная, которую мы пытаемся сопоставить, не найдена, но
значение, с которым мы ее сопоставляем, само является (другой)
переменной, требуется проверить, нет ли у этой второй переменной
значения, и если да, сопоставить его. Если же обе стороны сопоставления
несвязаны, мы любую из них можем связать с другой.

Вторая проверка связана с попытками связать переменную с образцом,
который ее саму содержит. Такая ситуация может возникнуть, когда в обоих
образцах повторяются переменные. Рассмотрим, например, унификацию
образцов @code{(?x ?x)} и
@code{(?y @math{\langle}@var{выражение, содержащее @code{?y}}@math{\rangle})}
в кадре, где не связаны ни @code{?x}, ни @code{?y}. Сначала @code{?x}
сопоставляется с @code{?y}, и возникает связывание переменной @code{?x} с
@code{?y}. Затем та же переменная @code{?x} сопоставляется с данным выражением,
которое включает @code{?y}. Поскольку @code{?x} уже связана со значением
@code{?y}, это приводит к тому, что с выражением сопоставляется
@code{?y}. Если мы считаем, что унификатор занят поиском набора значений
для переменных, которые делают образцы одинаковыми, то значит, эти
образцы содержат инструкции найти такое значение @code{?y}, чтобы
@code{?y} был равен выражению, содержащему @code{?y}. Общего метода для
решения таких задач не существует, так что мы такие связывания
отвергаем; эти случаи распознаются предикатом
@code{ depends-on?}.@footnote{В общем случае унификация @code{?y} с
выражением, содержащим @code{?y}, требует нахождения неподвижной точки
уравнения @code{?y} = @math{\langle}@var{выражение, содержащее ?y}@math{\rangle}. Иногда
возможно синтаксическим образом создать выражение, которое кажется
решением уравнения. Например, кажется, что @code{?y = (f y)} имеет
неподвижную точку @code{(f (f (f @dots{} )))}, которую мы можем получить,
начав с выражения @code{(f ?y)} и систематически подставляя
@code{(f ?y)} вместо @code{?y}. К сожалению, не у всякого такого
уравнения имеется осмысленная неподвижная точка. Вопросы, возникающие
здесь, подобны вопросам работы с бесконечными последовательностями в
математике. Например, мы знаем, что решение уравнения @math{y = 1 + y/2}
равно 2. Если мы начнем с выражения @math{1 + y/2} и будем подставлять
@ifinfo

@example
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ...
@end example

@end ifinfo
@tex
$$ 2 = y = 1 + {y \over 2} = 1 + {1\over2}\left(1 + {y \over 2}\right) =
	1 + {1\over2} + {y \over 4} = \dots , $$
@end tex
@noindent
что ведек к
@ifinfo

@example
2 = 1 + 1/2 + 1/4 + 1/8 + ...
@end example

@end ifinfo
@tex
$$ 2 = 1 + {1\over2} + {1\over4} + {1\over8} + \dots. $$
@end tex
@noindent
Однако если мы попытаемся проделать те же преобразования, использовав тот факт,
что решение уравнения @math{y = 1 + 2y} равно -1, то получим
@ifinfo

@example
-1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ...
@end example

@end ifinfo
@tex
$$ -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \dots, $$
@end tex
@noindent
что ведет к
@ifinfo

@example
-1 = 1 + 2 + 4 + 8 + ...
@end example

@end ifinfo
@tex
$$ -1 = 1 + 2 + 4 + 8 + \dots. $$
@end tex
@noindent

Несмотря на то, что формальные преобразования, ведущие к этим двум
уравнениям, одинаковы, первый результат является верным утверждением о
бесконечных последовательностях, а второй нет. Подобным образом и при
работе с унификациями работа с произвольными синтаксически правильными
выражениями может привести к ошибкам.} С другой стороны, нам не хочется
отвергать попытки связать переменную саму с собой. Рассмотрим, например,
унификацию @code{(?x ?x)} с @code{(?y ?y)}. Вторая попытка связать
@code{?x} с @code{?y} вызывает сопоставление @code{?y} (старое значение
@code{?x}) с @code{?y} (новым значением @code{?x}). Этот случай
обрабатывается веткой @code{equal?} внутри @code{unify-match}.

@lisp
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                     @r{; ***}
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)    @r{; ***}
           'failed)
          (else (extend var val frame)))))
@end lisp

Процедура @code{depends-on?} --- это предикат. Он проверяет, зависит ли
выражение, которое предлагается сделать значением переменной образца, от
этой переменной. Это нужно делать по отношению к текущему кадру,
поскольку выражение может содержать вхождения переменной, уже обладающей
значением, которое, в свою очередь, зависит от нашей переменной. По
структуре @code{depends-on?} представляет собой простой рекурсивный
обход дерева, во время которого мы по необходимости подставляем значения
переменных.

@lisp
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
@end lisp

@comment @subsubsection Maintaining the Data Base
@subsubsection Ведение базы данных
@node 4.4.4.5, 4.4.4.6, 4.4.4.4, 4.4.4

Одна из важных задач при разработке логических языков
программирования --- так организовать работу, чтобы при проверке
каждого образца просматривалось как можно меньше ненужных записей из
базы. В нашей системе, помимо того, что мы храним все утверждения в
одном большом потоке, мы в отдельных потоках храним утверждения,
@code{car}ы которых являются константными символами, в таблице,
индексируемой по этим символам. Чтобы получить утверждения, которые
могут сопоставляться с образцом, мы сначала смотрим, не является ли
@code{car} образца константным символом. Если это так, то мы возвращаем
(сопоставителю для проверки) все хранимые утверждения с тем же
@code{car}. Если @code{car} образца не является константным символом, мы
возвращаем все хранимые утверждения. Более изысканные методы могли бы
использовать еще информацию из кадра, либо пытаться оптимизировать и тот
случай, когда @code{car} образца не является константным символом. Мы
избегаем встраивания критериев для индексации (использование @code{car},
обработка только случая с константными символами) в программу: вместо
этого мы вызываем предикаты и селекторы, реализующие эти критерии.

@lisp
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
@end lisp

Процедура @code{get-stream} ищет поток в таблице и, если ничего там не
находит, возвращает пустой поток.

@lisp
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
@end lisp

Правила хранятся подобным же образом, с использованием @code{car}
заключения правила. Однако в заключениях правил могут стоять
произвольные образцы, и таким образом, они отличаются от утверждений
тем, что могут содержать переменные. Образец, в @code{car} которого
стоит константный символ, может сопоставляться не только с правилами, у
которых @code{car} заключения содержит тот же символ, но и с правилами,
где в начале заключения стоит переменная. Таким образом, при поиске
правил, которые могут сопоставляться с образцом, у которого в начале
константный символ, мы возвращаем как правила с этим символом в
@code{car} заключения, так и правила с переменной в начале заключения.
Ради этого мы храним правила с переменными в начале заключения в
отдельном потоке, который находится в таблице под индексом @code{?}.

@lisp
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
@end lisp

Процедура @code{add-rule-or-assertion!} вызывается из @code{query-driver-loop},
когда требуется добавить к базе данных правило или утверждение. Каждая запись
сохраняется в индексе, если это требуется, а также в общем потоке правил либо
утверждений базы данных.

@lisp
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
@end lisp

@noindent
Чтобы вставить в базу утверждение или правило, мы проверяем, можно ли
его проиндексировать. Если да, то мы сохраняем его в соответствующем
потоке.

@lisp
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream
                assertion
                current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
@end lisp

Следующие процедуры определяют, как используется индекс базы данных.
Образец (утверждение или заключение правила) сохраняется в таблице, если
он начинается с переменной или константного символа.

@lisp
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
@end lisp

Ключ, под которым образец сохраняется в таблице --- это либо @code{?}
(если он начинается с переменной), либо константный символ из его
начала.

@lisp
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
@end lisp

Для поиска записей, которые могут соответствовать образцу, используется
индекс в том случае, когда образец начинается с константного символа.

@lisp
(define (use-index? pat) (constant-symbol? (car pat)))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.70}Упражнение 4.70:}
Какова цель выражений @code{let} в процедурах
@code{add-assertion!} и @code{add-rule!}? Что неправильно в следующем
варианте @code{add-assertion!}? Подсказка: вспомните определение
бесконечного потока единиц из
@ref{3.5.2}: @code{(define ones (cons-stream 1 ones))}.

@lisp
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
@end lisp
@end quotation

@comment @subsubsection Stream Operations
@subsubsection Операции над потоками
@node 4.4.4.6, 4.4.4.7, 4.4.4.5, 4.4.4

В запросной системе используется несколько операций над потоками, помимо
представленных в @ref{Глава 3}.

Процедуры @code{stream-append-delayed} и @code{interleave-delayed}
подобны @code{stream-append} и @code{interleave} (@ref{3.5.3}),
но только они принимают задержанный аргумент (как процедура @code{integral}
из @ref{3.5.4}).  В некоторых случаях это откладывает зацикливание
(см. упражнение @ref{Упражнение 4.71}).

@lisp
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed
        (stream-cdr s1)
        delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed
        (force delayed-s2)
        (delay (stream-cdr s1))))))
@end lisp

Процедура @code{stream-flatmap}, которая многократно используется в
интерпретаторе, чтобы применить процедуру ко всем элементам потока
кадров и соединить получающиеся потоки кадров, является потоковым
аналогом процедуры @code{flatmap} для обычных списков, введенной в @ref{2.2.3}.
Однако, в отличие от обычного @code{flatmap}, потоки мы собираем с
помощью чередующего процесса, а не просто сцепляем их
(см. упражнения @ref{Упражнение 4.72}).

@lisp
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
@end lisp

Кроме того, интерпретатор пользуется следующей простой процедурой для
порождения потока, который состоит из одного элемента:

@lisp
(define (singleton-stream x) 
  (cons-stream x the-empty-stream))
@end lisp

@comment @subsubsection Query Syntax Procedures
@subsubsection Процедуры, определяющие синтаксис запросов
@node 4.4.4.7, 4.4.4.8, 4.4.4.6, 4.4.4

Процедуры @code{type} и @code{contents}, используемые в @code{qeval}
(@ref{4.4.4.2}), указывают, что особая форма определяется символом в ее
@code{car}. Это те же процедуры, что @code{type-tag} и @code{contents} из
@ref{2.4.2}, с точностью до сообщения об ошибке.

@lisp
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))

(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
@end lisp

Следующие процедуры, вызываемые из @code{query-driver-loop} (@ref{4.4.4.1}),
указывают, что утверждения и правила добавляются в базу данных при помощи
выражений вида @code{(assert! @math{\langle}@var{правило-или-утверждение
(rule-or-assertion)}@math{\rangle})}:

@lisp
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp) (car (contents exp)))
@end lisp

Вот синтаксические определения для особых форм @code{and}, @code{or},
@code{not} и @code{lisp-value} (@ref{4.4.4.2}):

@lisp
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
@end lisp

@noindent
Следующие три процедуры определяют синтаксис правил:

@lisp
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule)) '(always-true) (caddr rule)))
@end lisp

@noindent
@code{query-driver-loop} (@ref{4.4.4.1}) вызывает
@code{query-syntax-process}, чтобы преобразовать переменные образца в
выражении, имеющие форму @code{?symbol}, к внутреннему формату
@code{(? symbol)}. Это означает, что образец вроде
@code{(должность ?x ?y)} на самом деле представляется внутри системы как
@code{(должность (? x) (? y))}. Это повышает эффективность обработки
запросов, потому что позволяет системе проверять, является ли выражение
переменной, путем проверки @code{car} (не является ли @code{car}
символом @code{?}), вместо того, чтобы извлекать из символа буквы.
Преобразование синтаксиса осуществляется следующей
процедурой:@footnote{Большинство Лисп-систем позволяет пользователю
изменять обыкновенную процедуру @code{read} и осуществлять такие
преобразования путем определения (reader macro characters). Закавыченные
выражения уже обрабатываются таким образом: процедура чтения
автоматически переводит @code{'expression} в @code{(quote expression)},
прежде чем выражение видит интерпретатор. Можно было бы устроить
преобразование @code{?expression} в @code{(? expression)} таким же
образом; однако ради большей ясности мы здесь представили процедуру
преобразования явно.

@code{expand-question-mark} и @code{contract-question-mark} используют
несколько процедур, имя которых содержит @code{string}. Это примитивы
языка Scheme.}

@lisp
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
@end lisp

@noindent
После того, как переменные таким образом преобразованы, переменные в
образцах --- это списки, начинающиеся с @code{?}, а константные символы
(которые требуется распознавать для индексирования базы данных,
@ref{4.4.4.5}) --- это просто символы.

@lisp
(define (var? exp) (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
@end lisp

@noindent
Во время применения правил при помощи следующих процедур порождаются
уникальные переменные (@ref{4.4.4.4}).
Уникальным идентификатором правила служит число, которое увеличивается
при каждом применении правила:

@lisp
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
@end lisp

Когда @code{query-driver-loop} конкретизирует запрос для печати ответа,
она преобразует все несвязанные переменные запроса обратно к печатной
форме при помощи

@lisp
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?" 
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
@end lisp

@comment @subsubsection Frames and Bindings
@subsubsection Кадры и связывания
@node 4.4.4.8,  , 4.4.4.7, 4.4.4

Кадры представляются как списки связываний, которые, в свою очередь,
являются парами вида <<переменная-значение>>:

@lisp
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding) (car binding))
(define (binding-value binding) (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
@end lisp

@quotation
@strong{@anchor{Упражнение 4.71}Упражнение 4.71:}
Хьюго Дум не понимает, почему процедуры (@ref{4.4.4.2})
@code{simple-query} и @code{disjoin} реализованы через явные операции
@code{delay}, а не следующим образом:

@lisp
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append
        (find-assertions query-pattern frame)
        (apply-rules query-pattern frame)))
   frame-stream))

(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts)
                frame-stream)
       (disjoin (rest-disjuncts disjuncts)
                frame-stream))))
@end lisp

Можете ли Вы дать примеры запросов, с которыми эти простые определения
приведут к нежелательному поведению?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.72}Упражнение 4.72:}
Почему @code{adjoin} и @code{stream-flatmap} чередуют
потоки, а не просто их сцепляют? Приведите примеры, которые показывают,
что чередование работает лучше. (Подсказка: зачем мы пользовались
@code{interleave} в @ref{3.5.3}?)
@end quotation

@quotation
@strong{@anchor{Упражнение 4.73}Упражнение 4.73:}
Почему @code{flatten-stream} использует @code{delay} явно?
Что было бы неправильно в таком определении:

@lisp
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 4.74}Упражнение 4.74:}
Лиза П. Хакер предлагает использовать в @code{negate},
@code{lisp-value} и @code{find-assertions} упрощенную версию . Она
замечает, что в этих случаях процедура, которая отображает поток кадров,
всегда порождает либо пустой поток, либо поток из одного элемента, и
поэтому при слиянии этих потоков незачем использовать чередование.

@enumerate a.

@item
Заполните пропущенные выражения в программе Лизы.

@lisp
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))
(define (simple-flatten stream)
  (stream-map @math{\langle}??@math{\rangle}
              (stream-filter @math{\langle}??@math{\rangle} stream)))
@end lisp

@item
Если мы изменяем систему таким образом, меняется ли ее поведение?

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 4.75}Упражнение 4.75:}
Реализуйте в языке запросов новую особую форму . Выражение
@code{unique} должно быть успешно, если в базе данных ровно одна запись,
удовлетворяющая указанному запросу. Например запрос

@lisp
(unique (job ?x (computer wizard)))
@end lisp

@noindent
@direntry
@lisp
(unique (должность ?x (компьютеры гуру)))
@end lisp
@end direntry

@noindent
должен печатать одноэлементный поток

@lisp
(unique (job (Bitdiddle Ben) (computer wizard)))
@end lisp

@direntry
@lisp
(unique (должность (Битобор Бен) (компьютеры гуру)))
@end lisp
@end direntry

поскольку Бен --- единственный компьютерный гуру, а

@lisp
(unique (job ?x (computer programmer)))
@end lisp

@direntry
@lisp
(unique (должность ?x (компьютеры программист)))
@end lisp
@end direntry

должно печатать пустой поток, поскольку программистов больше одного.
Более того,

@lisp
(and (job ?x ?j) (unique (job ?anyone ?j)))
@end lisp

@direntry
@lisp
(and (должность ?x ?j) (unique (должность ?anyone ?j)))
@end lisp
@end direntry

должно перечислять все должности, на которых работает по одному
человеку, а также самих этих людей.

Реализация @code{unique} состоит из двух частей. Первая заключается в
том, чтобы написать процедуру, которая обрабатывает эту особую форму, а
вторая в том, чтобы заставить @code{qeval} распознавать форму и вызывать
ее процедуру. Вторая часть тривиальна, поскольку @code{qeval} написана в
стиле программирования, управляемого данными. Если Ваша процедура
называется @code{uniquely-asserted}, то нужно только написать

@lisp
(put 'unique 'qeval uniquely-asserted)
@end lisp

и @code{qeval} будет передавать управление этой процедуре для всех
запросов, у которых в @code{type} (@code{car}) стоит символ
@code{unique}.

Собственно задача состоит в том, чтобы написать процедуру
@code{uniquely-asserted}. В качестве входа она должна принимать
@code{contents} (@code{cdr}) запроса @code{unique} и поток кадров. Для
каждого кадра в потоке она должна с помощью @code{qeval} находить поток
всех расширений, удовлетворяющих данному запросу. Потоки, в которых
число элементов не равно одному, должны отбрасываться. Оставшиеся потоки
нужно собирать в один большой поток. Он и становится результатом запроса
@code{unique}. Эта процедура подобна реализации особой формы @code{not}.

Проверьте свою реализацию, сформировав запрос, который находит всех
служащих, которые начальствуют ровно над одним человеком.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.76}Упражнение 4.76:}
Наша реализация @code{and} в виде последовательной
комбинации запросов (рисунок @ref{Рисунок 4.5}) изящна, но
неэффективна, поскольку при обработке второго запроса приходится
просматривать базу данных для каждого кадра, порожденного первым
запросом. Если в базе данных @math{N} записей, а типичный запрос
порождает число записей, пропорциональное @math{N} (скажем, @math{N/k}),
то проход базы данных для каждого кадра, порожденного первым запросом,
потребует @math{N^2/k} вызовов сопоставителя. Другой подход может
состоять в том, чтобы обрабатывать два подвыражения запроса @code{and}
по отдельности а затем искать совместимые пары входных кадров. Если
каждый запрос порождает @math{N/k} кадров, то нам придется проделать
@math{N^2/k^2} проверок на совместимость --- в @math{k} раз меньше, чем
число сопоставлений при нашем теперешнем методе.

Постройте реализацию @code{and} с использованием этой стратегии. Вам
придется написать процедуру, которая принимает на входе два кадра,
проверяет связывания в этих кадрах на совместимость и, если они
совместимы, порождает кадр, в котором множества связываний слиты. Эта
операция подобна унификации.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.77}Упражнение 4.77:}
В @ref{4.4.3} мы видели,
что выражения @code{not} и @code{lisp-value} могут заставить язык
запросов выдавать <<неправильные>> значения, если эти фильтрующие
операции применяются к кадрам с несвязанными переменными. Придумайте
способ избавиться от этого недостатка. Одна из возможностей состоит в
том, чтобы проводить <<задержанную>> фильтрацию, цепляя к кадру
<<обещание>> провести ее, которое выполняется только тогда, когда
связано достаточно переменных, чтобы операция стала возможна. Можно
ждать и проводить фильтрацию только тогда, когда выполнены все остальные
операции. Однако из соображений эффективности хотелось бы фильтровать
как можно раньше, чтобы уменьшить число порождаемых промежуточных
кадров.
@end quotation

@quotation
@strong{@anchor{Упражнение 4.78}Упражнение 4.78:}
Перестройте язык запросов в виде недетерминистской
программы, реализуемой интерпретатором из @ref{4.3}, а
не в виде процесса обработки потоков. При таком подходе каждый запрос
будет порождать один ответ (а не поток всех возможных ответов), а
пользователь может ввести @code{try-again} и получить следующий ответ.
Вы увидите, что существенная часть механизмов, которые мы построили в
этом разделе, заменяется недетерминистским поиском и перебором с
возвратами. Однако помимо этого, Вы обнаружите, что новый язык запросов
отличается в тонких деталях поведения от реализованного нами в этом
разделе. Можете ли Вы привести примеры, показывающие эти отличия?
@end quotation

@quotation
@strong{@anchor{Упражнение 4.79}Упражнение 4.79:}
Когда мы реализовывали в @ref{4.1} интерпретатор, мы видели,
как можно избежать конфликтов между именами параметров процедур при
помощи локальных окружений. Например, при вычислении

@lisp
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
@end lisp

@noindent
не возникает смешения между @code{x} из @code{square} и @code{x} из
@code{sum-of-squares}, поскольку тело каждой процедуры мы вычисляем в
окружении, которое специально построено для связывания локальных
переменных. В запросной системе мы избегаем конфликтов имен при
применении правил с помощью другой стратегии. Каждый раз при применении
правила мы переименовываем переменные и даем им новые имена, которые
обязаны быть уникальными. Аналогичная стратегия в интерпретаторе Лиспа
заключалась бы в том, чтобы отменить внутренние окружения и просто
переименовывать переменные в теле процедуры каждый раз, как мы ее
вызываем.

Реализуйте для языка запросов метод применения правил, который
использует не переименования, а окружения. Рассмотрите, можно ли
использовать Вашу систему окружений для построения в языке запросов
конструкций для работы с большими системами, например аналога блочной
структуры процедур для правил. Можно ли связать это с проблемой ведения
рассуждений в контексте (например: <<Если бы я предположил, что истинно
@math{P}, то я смог бы доказать @math{A} и @math{B}>>) в качестве метода
решения задач? (Это упражнение не имеет однозначного решения. Хороший
ответ, скорее всего, мог бы служить темой диссертации.)
@end quotation

