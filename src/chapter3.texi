@comment @chapter Modularity, Objects, and State
@chapter Модульность, объекты и состояние
@node    Chapter 3, Chapter 4, Chapter 2, Top

@c @sp 0.5

@quotation
Mεταβάλλον ὰναпαύεται\\
(Изменяясь, оно остается неподвижным)\\
---Heraclitus
@end quotation

@quotation
Plus @,{c}a change, plus c'est la m@^{e}me chose.\\
---Alphonse Karr
@end quotation

@c @sp 1.0

@noindent
\lettrine{В} {предыдущих главах} мы ввели основные элементы, из которых строятся
программы. Мы видели, как элементарные процедуры и элементарные данные,
сочетаясь, образуют составные сущности; мы стали понимать, что без
абстракции нельзя справиться со сложностью больших систем. Однако этих
инструментов недостаточно для разработки программ. Для эффективного
синтеза программ требуются также организационные принципы, которые
помогали бы нам сформулировать общий проект программы. В частности, нам
нужны стратегии для построения больших программ по принципу
(@newterm{modularity}): чтобы программы <<естественным>> образом делились на
логически цельные куски, которые можно разрабатывать и поддерживать
независимо друг от друга.

Существует мощная стратегия разработки, которая особенно хорошо подходит
для построения программ, моделирующих физические системы: воспроизводить
в структуре программы структуру моделируемой системы. Для каждого
объекта в системе мы строим соответствующий ему вычислительный объект.
Для каждого действия в системе определяем в рамках нашей вычислительной
модели символьную операцию. Используя эту стратегию, мы надеемся, что
расширение нашей модели на новые объекты или действия не потребует
стратегических изменений в программе, а позволит обойтись только
добавлением новых символьных аналогов этих объектов или действий. Если
наша организация системы окажется удачной, то для добавления новых
возможностей или отладки старых нам придется работать только с
ограниченной частью системы.

Таким образом, способ, которым мы организуем большую программу, в
значительной степени диктуется нашим восприятием моделируемой системы. В
этой главе мы исследуем две важных организационных стратегии, которые
соответствуют двум достаточно различным взглядам на мир и структуру
систем. Первая из них сосредотачивается на (objects), и большая система
рассматривается как собрание индивидуальных объектов, поведение которых
может меняться со временем. Альтернативная стратегия строится вокруг
(streams) информации в системе, во многом подобно тому, как в
электронике рассматриваются системы обработки сигналов.

Как подход, основанный на объектах, так и подход, основанный на потоках,
высвечивают важные вопросы, касающиеся языков программирования. При
работе с объектами нам приходится думать о том, как вычислительный
объект может изменяться и при этом сохранять свою индивидуальность.
Из-за этого нам придется отказаться от подстановочной модели вычислений
(раздел @ref{1.1.5}) в
пользу более механистичной и в то же время менее привлекательной
теоретически (@newterm{environment model}). Сложности, связанные с объектами, их
изменением и индивидуальностью являются фундаментальным следствием из
потребности ввести понятие времени в вычислительные модели. Эти
сложности только увеличиваются, когда мы добавляем возможность
параллельного выполнения программ. Получить наибольшую отдачу от
потокового подхода удается тогда, когда моделируемое время отделяется от
порядка событий, происходящих в компьютере в процессе вычисления. Мы
достигнем этого при помощи метода, называемого (@newterm{delayed evaluation}).

@menu
* 3-1::              Присваивание и внутреннее состояние объектов::
* 3-2::              Модель вычислений с окружениями::
* 3-3::              Моделирование при помощи изменяемых данных::
* 3-4::              Параллелизм время имеет значение::
* 3-5::              Потоки::
@end menu

@comment @section Assignment and Local State
@section Присваивание и внутреннее состояние объектов
@node	3.1, 3.2, Chapter 3, Chapter 3

Обычно мы считаем, что мир состоит из отдельных объектов, и у каждого из
них есть состояние, которое изменяется со временем. Мы говорим, что
объект <<обладает состоянием>>, если на поведение объекта влияет его
история. Например, банковский счет обладает состоянием потому, что ответ
на вопрос <<Могу ли я снять 100 долларов?>> зависит от истории занесения
и снятия с него денег. Состояние объекта можно описать набором из одной
или более (@newterm{state variables}), которые вместе содержат достаточно
информации, чтобы определить текущее поведение объекта. В простой
банковской системе состояние счета можно охарактеризовать его текущим
балансом, вместо того, чтобы запоминать всю историю транзакций с этим
счетом.

@endpage
Если система состоит из многих объектов, они редко совершенно независимы
друг от друга. Каждый из них может влиять на состояние других при помощи
актов взаимодействия, связывающих переменные состояния одного объекта с
переменными других объектов. На самом деле, взгляд, согласно которому
система состоит из отдельных объектов, полезнее всего в том случае,
когда ее можно разделить на несколько подсистем, в каждой из которых
внутренние связи сильнее, чем связи с другими подсистемами.

Такая точка зрения на систему может служить мощной парадигмой для
организации вычислительных моделей системы. Чтобы такая модель была
модульной, ее требуется разделить на вычислительные объекты,
моделирующие реальные объекты системы. Каждый вычислительный объект
должен содержать собственные (@newterm{local state variables}), описывающие
состояние реального объекта. Поскольку объекты в моделируемой системе
меняются со временем, переменные состояния соответствующих
вычислительных объектов также должны изменяться. Если мы решаем, что
поток времени в системе будет моделироваться временем, проходящим в
компьютере, то нам требуется способ строить вычислительные объекты,
поведение которых меняется по мере выполнения программы. В частности,
если нам хочется моделировать переменные состояния обыкновенными
символическими именами в языке программирования, в языке должен иметься
(@newterm{assignment operator}), который позволял бы изменять значение,
связанное с именем.

@menu
* 3-1-1::            Внутренние переменные состояния::
* 3-1-2::            Преимущества присваивания::
* 3-1-3::            Издержки связанные с введением присваивания::
@end menu

@comment @subsection Local State Variables
@subsection Внутренние переменные состояния
@node	3.1.1, 3.1.2, 3.1, 3.1

Чтобы показать, что мы имеем в виду, говоря о вычислительном объекте,
состояние которого меняется со временем, давайте промоделируем ситуацию
снятия денег с банковского счета. Воспользуемся для этого процедурой
@code{withdraw}, которая в качестве аргумента принимает сумму, которую
требуется снять. Если на счету имеется достаточно средств, чтобы
осуществить операцию, то @code{withdraw} возвращает баланс, остающийся
после снятия. В противном случае @code{withdraw} возвращает сообщение
<<Недостаточно денег на счете>>. Например, если вначале на счету
содержится 100 долларов, мы получим следующую последовательность
результатов:

@lisp
(withdraw 25)
@i{75}
(withdraw 25)
@i{50}
(withdraw 60)
@i{"Insufficient funds"}
(withdraw 15)
@i{35}
@end lisp

@noindent
Обратите внимание, что выражение @code{(withdraw 25)}, будучи вычислено
дважды, дает различные результаты. Это новый тип поведения для
процедуры. До сих пор все наши процедуры можно было рассматривать как
описания способов вычисления математических функций. Вызов процедуры
вычислял значение функции для данных аргументов, и два вызова одной и
той же процедуры с одинаковыми аргументами всегда приводили к
одинаковому результату.@footnote{На самом деле это не совсем правда. Одно
исключение --- генератор случайных чисел из
раздела @ref{1.2.6}.
Второе связано с таблицами операций и типов, которые мы ввели в
разделе @ref{2.4.3},
где значения двух вызовов @code{get} с одними и теми же аргументами
зависели от того, какие были в промежутке между ними вызовы @code{put}.
С другой стороны, пока мы не ввели присваивание, мы лишены возможности
самим создавать такие процедуры.}

При реализации @code{withdraw} мы используем переменную @code{balance},
которая показывает остаток денег на счете, и определяем @code{withdraw}
в виде процедуры, которая обращается к этой переменной. Процедура
@code{withdraw} проверяет, что значение @code{balance} не меньше, чем
значение аргумента @code{amount}. Если это так, @code{withdraw}
уменьшает значение @code{balance} на @code{amount} и возвращает новое
значение @code{balance}. В противном случае она возвращает сообщение
<<Недостаточно денег на счете>>. Вот определения @code{balance} и
@code{withdraw}:

@lisp
(define balance 100)
(define (withdraw amount)
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
@end lisp

@noindent
Значение переменной @code{balance} уменьшается, когда мы выполняем
выражение

@lisp
(set! balance (- balance amount))
@end lisp

@noindent
Здесь используется особая форма , синтаксис которой выглядит так:

@lisp
(set! @math{\langle}@var{имя}@math{\rangle} @math{\langle}@var{новое-значение}@math{\rangle})
@end lisp

@noindent
Здесь @math{\langle}@var{имя}@math{\kern0.04em\rangle}  --- символ, а
@math{\langle}@var{новое-значение}@math{\kern0.04em\rangle} -- произвольное
выражение. @code{set!} заменяет значение
@math{\langle}@var{имени}@math{\kern0.04em\rangle} на результат, полученный при
вычислении @math{\langle}@var{нового-значения}@math{\kern0.04em\rangle}.
В данном случае, мы изменяем @code{balance} так, что его новое значение будет
результатом вычитания @code{amount} из предыдущего значения
@code{balance}.@footnote{Значение выражения @code{set!} зависит от
реализации. @code{set!} нужно использовать только ради эффекта, который
оно оказывает, а не ради значения, которое оно возвращает.

Имя @code{set!} отражает соглашение, принятое в Scheme: операциям,
которые изменяют значения переменных (или структуры данных, как мы
увидим в разделе @ref{3.3}) даются имена с
восклицательным знаком на конце. Это напоминает соглашение называть
предикаты именами, которые оканчиваются на вопросительный знак.}

Кроме того, @code{withdraw} использует особую форму , когда проверка
@code{if} выдает истину, и требуется вычислить два выражения: сначала
уменьшить @code{balance}, а затем вернуть его значение. В общем случае
вычисление выражения

@lisp
(begin @math{\langle}@var{выражение}@math{_{\mono{1}}\rangle} @math{\langle}@var{выражение}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{выражение}@math{_{\monoit{k}}\rangle})
@end lisp

@noindent
приводит к последовательному вычислению выражений от
@math{\langle\kern0.06em}@var{выражения}@math{_1\rangle} до
@math{\langle\kern0.06em}@var{выражения}@math{_k\rangle}, и
значение последнего выражения
@math{\langle\kern0.06em}@var{выражения}@math{_k\rangle}
возвращается в качестве значения всей формы @code{begin}.@footnote{Неявно
мы уже использовали в своих программах @code{begin}, поскольку в Scheme
тело процедуры может быть последовательностью выражений. Кроме того, в
каждом подвыражении @code{cond} следствие может состоять не из одного
выражения, а из нескольких.}

Хотя процедура @code{withdraw} и работает так, как мы того хотели,
переменная @code{balance} представляет собой проблему. @code{balance},
как она описана выше, является переменной, определенной в глобальном
окружении, и любая процедура может прочитать или изменить ее значение.
Намного лучше было бы, если бы @code{balance} можно было сделать
внутренней переменной для @code{withdraw}, так, чтобы только
@code{withdraw} имела доступ к ней напрямую, а любая другая
процедура --- только посредством вызовов @code{withdraw}. Так можно
будет более точно смоделировать представление о @code{balance} как о
внутренней переменной состояния, с помощью которой @code{withdraw}
следит за состоянием счета.

Сделать @code{balance} внутренней по отношению к @code{withdraw} мы
можем, переписав определение следующим образом:

@lisp
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
@end lisp

@noindent
Здесь мы, используя @code{let}, создаем окружение с внутренней
переменной @code{balance}, которой вначале присваивается значение 100.
Внутри этого локального окружения мы при помощи @code{lambda} определяем
процедуру, которая берет в качестве аргумента @code{amount} и действует
так же, как наша старая процедура @code{withdraw}. Эта процедура ---
возвращаемая как результат выражения @code{let}, --- и есть
@code{new-withdraw}. Она ведет себя в точности так же, как, как
@code{withdraw}, но ее переменная @code{balance} недоступна для всех
остальных процедур.@footnote{По терминологии, принятой при описании
языков программирования, переменная @code{balance}
@emph{инкапсулируется} (is encapsulated) внутри процедуры
@code{new-withdraw}. Инкапсуляция отражает общий принцип проектирования
систем, известный как (@newterm{the hiding principle}): систему можно сделать
более модульной и надежной, если защищать ее части друг от друга; то
есть, разрешать доступ к информации только тем частям системы, которым
<<необходимо это знать>>.}

@code{set!} в сочетании с локальными переменными --- общая стратегия
программирования, которую мы будем использовать для построения
вычислительных объектов, обладающих внутренним состоянием. К сожалению,
при использовании этой стратегии возникает серьезная проблема: когда мы
только вводили понятие процедуры, мы ввели также подстановочную модель
вычислений (раздел @ref{1.1.5})
для того, чтобы объяснить, что означает применение процедуры к
аргументам. Мы сказали, что оно должно интерпретироваться как вычисление
тела процедуры, в котором формальные параметры заменяются на свои
значения. К сожалению, как только мы вводим в язык присваивание,
подстановка перестает быть адекватной моделью применения процедуры.
(Почему это так, мы поймем в разделе @ref{3.1.3}.) В
результате, с технической точки зрения мы сейчас не умеем объяснить,
почему процедура @code{new-withdraw} ведет себя именно так, как описано
выше. Чтобы действительно понять процедуры, подобные
@code{new-withdraw}, нам придется разработать новую модель применения
процедуры. В разделе @ref{3.2} мы
введем такую модель, попутно объяснив @code{set!} и локальные
переменные. Однако сначала мы рассмотрим некоторые вариации на тему,
заданную @code{new-withdraw}.

Следующая процедура, @code{make-withdraw}, создает <<обработчики снятия
денег со счетов>>. Формальный параметр @code{balance}, передаваемый в
@code{make-withdraw}, указывает начальную сумму денег на
счету.@footnote{В отличие от предыдущей процедуры @code{new-withdraw},
здесь нам необязательно использовать @code{let}, чтобы сделать
@code{balance} локальной переменной, поскольку формальные параметры и
так локальны. Это станет яснее после обсуждения модели вычисления с
окружениями в разделе @ref{3.2}.  (См. также @ref{3.10})}

@lisp
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Недостаточно денег на счете")))
@end lisp

@noindent
При помощи @code{make-withdraw} можно следующим образом создать два
объекта @code{W1} и @code{W2}:

@lisp
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
@i{50}
(W2 70)
@i{30}
(W2 40)
@i{"Недостаточно денег на счете"}
(W1 40)
@i{10}
@end lisp

@noindent
Обратите внимание, что @code{W1} и @code{W2} --- полностью независимые
объекты, каждый со своей локальной переменной @code{balance}. Снятие
денег с одного счета не влияет на другой.

Мы можем создавать объекты, которые будут разрешать не только снятие
денег, но и их занесение на счет, и таким образом можно смоделировать
простые банковские счета. Вот процедура, которая возвращает
объект-<<банковский счет>> с указанным начальным балансом:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  dispatch)
@end lisp

@noindent
Каждый вызов @code{make-account} создает окружение с локальной
переменной состояния @code{balance}. Внутри этого окружения
@code{make-account} определяет процедуры @code{deposit} и
@code{withdraw}, которые обращаются к @code{balance}, а также
дополнительную процедуру @code{dispatch}, которая принимает
<<сообщение>> в качестве ввода, и возвращает одну из двух локальных
процедур. Сама процедура @code{dispatch} возвращается как значение,
которое представляет объект-банковский счет. Это не что иное, как стиль
программирования с (@newterm{message passing}), который мы видели в
разделе @ref{2.4.3},
но только здесь мы его используем в сочетании с возможностью изменять
локальные переменные.

@code{make-account} можно использовать следующим образом:

@lisp
(define acc (make-account 100))
((acc 'withdraw) 50)
@i{50}
((acc 'withdraw) 60)
@i{"Недостаточно денег на счете"}
((acc 'deposit) 40)
@i{90}
((acc 'withdraw) 60)
@i{30}
@end lisp

@noindent
Каждый вызов @code{acc} возвращает локально определенную процедуру
@code{deposit} или @code{withdraw}, которая затем применяется к
указанной сумме. Точно так же, как это было с @code{make-withdraw},
второй вызов @code{make-account}

@lisp
(define acc2 (make-account 100))
@end lisp

@noindent
создает совершенно отдельный объект-счет, который поддерживает свою
собственную переменную @code{balance}.

@quotation
@strong{@anchor{Упражнение 3.1}Упражнение 3.1:}
Накопитель (@newterm{accumulator}) --- это процедура, которая
вызывается с одним численным аргументом и собирает свои аргументы в
сумму. При каждом вызове накопитель возвращает сумму, которую успел
накопить. Напишите процедуру @code{make-accumulator}, порождающую
накопители, каждый из которых поддерживает свою отдельную сумму. Входной
параметр @code{make-accumulator} должен указывать начальное значение
суммы; например,

@lisp
(define A (make-accumulator 5))
(A 10)
@i{15}
(A 10)
@i{25}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.2}Упражнение 3.2:}
При тестировании программ удобно иметь возможность
подсчитывать, сколько раз за время вычислений была вызвана та или иная
процедура. Напишите процедуру @code{make-monitored}, принимающую в
качестве параметра процедуру @code{f}, которая сама по себе принимает
один входной параметр. Результат, возвращаемый
@code{make-monitored} --- третья процедура, назовем ее @code{mf},
которая подсчитывает, сколько раз она была вызвана, при помощи
внутреннего счетчика. Если на входе @code{mf} получает специальный
символ @code{how-many-calls?}, она возвращает значение счетчика. Если же
на вход подается специальный символ @code{reset-count}, @code{mf}
обнуляет счетчик. Для любого другого параметра @code{mf} возвращает
результат вызова @code{f} с этим параметром и увеличивает счетчик.
Например, можно было бы сделать отслеживаемую версию процедуры
@code{sqrt}:

@lisp
(define s (make-monitored sqrt))
(s 100)
@i{10}
(s 'how-many-calls?)
@i{1}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.3}Упражнение 3.3:}
Измените процедуру @code{make-account} так, чтобы она
создавала счета, защищенные паролем. А именно, @code{make-account}
должна в качестве дополнительного аргумента принимать символ, например

@lisp
(define acc (make-account 100 'secret-password))
@end lisp

Получившийся объект-счет должен обрабатывать запросы, только если они
сопровождаются паролем, с которым счет был создан, а в противном случае
он должен жаловаться:

@lisp
((acc 'secret-password 'withdraw) 40)
@i{60}
((acc 'some-other-password 'deposit) 50)
@i{"Incorrect password"}
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.4}Упражнение 3.4:}
Модифицируйте процедуру @code{make-account} из
упражнения @ref{}, добавив еще одну локальную переменную,
так, чтобы, если происходит более семи попыток доступа подряд с неверным
паролем, вызывалась процедура @code{call-the-cops} (вызвать полицию).

@comment @subsection The Benefits of Introducing Assignment
@subsection Преимущества присваивания
@node	3.1.2, 3.1.3, 3.1.1, 3.1

Как нам предстоит увидеть, введение присваивания в наш язык
программирования ведет к множеству сложных концептуальных проблем. Тем
не менее, представление о системе как о наборе объектов, имеющих
внутреннее состояние, --- мощное средство для обеспечения модульности
проекта. В качестве примера рассмотрим строение процедуры @code{rand},
которая, будучи вызванной, каждый раз возвращает случайное целое число.

Вовсе не так просто определить, что значит <<случайное>>. Вероятно,
имеется в виду, что последовательные обращения к @code{rand} должны
порождать последовательность чисел, которая обладает статистическими
свойствами равномерного распределения. Здесь мы не будем обсуждать
способы порождения подобных последовательностей. Вместо этого
предположим, что у нас есть процедура @code{rand-update}, которая
обладает следующим свойством: если мы начинаем с некоторого данного
числа @math{x_1} и строим последовательность

@lisp
@math{x_2} = (rand-update @math{x_1})
@math{x_3} = (rand-update @math{x_2})
@end lisp

@noindent
то последовательность величин @math{x_1}, @math{x_2}, @math{x_3}, @dots{}
будет обладать требуемыми математическими свойствами.@footnote{Один из
распространенных способов реализации @code{rand-update} состоит в том,
чтобы положить новое значение @math{x} равным
@math{ax+b} по модулю @math{m}, где @math{a}, @math{b} и @math{m} --- соответствующим образом
подобранные целые числа. Глава 3 книги Knuth 1981 содержит подробное
обсуждение методов порождения последовательностей случайных чисел и
обеспечения их статистических свойств. Обратите внимание, что
@code{rand-update} вычисляет математическую функцию: если ей дважды дать
один и тот же вход, она вернет одинаковый результат. Таким образом,
последовательность чисел, порождаемая @code{rand-update}, никоим образом
не <<случайна>>, если мы настаиваем на том, что в последовательности
<<случайных>> чисел следующее число не должно иметь никакого отношения к
предыдущему. Отношение между <<настоящей>> случайностью и так
называемыми (@newterm{pseudo-random}) последовательностями, которые порождаются
путем однозначно определенных вычислений и тем не менее обладают нужными
статистическими свойствами, --- непростой вопрос, связанный со сложными
проблемами математики и философии. Для прояснения этих вопросов много
сделали Колмогоров, Соломонофф и Хайтин; обсуждение можно найти в
Chaitin 1975.}

Мы можем реализовать @code{rand} как процедуру с внутренней переменной
состояния @code{x}, которая инициализируется некоторым заранее заданным
значением @code{random-init}. Каждый вызов @code{rand} вычисляет
@code{rand-update} от текущего значения @code{x}, возвращает это
значение как случайное число, и, кроме того, сохраняет его как новое
значение @code{x}.

@lisp
(define rand (let ((x random-init))
               (lambda ()
                 (set! x (rand-update x))
                 x)))
@end lisp

@noindent
Разумеется, ту же последовательность случайных чисел мы могли бы
получить без использования присваивания, просто напрямую вызывая
@code{rand-update}. Однако это означало бы, что всякая часть программы,
которая использует случайные числа, должна явно запоминать текущее
значение @code{x}, чтобы передать его как аргумент @code{rand-update}.
Чтобы понять, насколько это было бы неприятно, рассмотрим использование
случайных чисел для реализации т.н. (@newterm{Monte Carlo simulation}).

Метод Монте-Карло состоит в том, чтобы случайным образом выбирать
тестовые точки из большого множества и затем делать выводы на основании
вероятностей, оцениваемых по результатам тестов. Например, можно
получить приближенное значение @math{\pi}, используя тот факт, что для
двух случайно выбранных целых чисел вероятность отсутствия общих
множителей (то есть, вероятность того, что их наибольший общий делитель
будет равен 1) составляет @math{6/\pi^2}.@footnote{Эта теорема доказана
Э. Чезаро. Обсуждение и доказательство можно найти в разделе 4.5.2
книги Knuth 1981.}. Чтобы получить приближенное значение @math{\pi}, мы
производим большое количество тестов. В каждом тесте мы случайным
образом выбираем два числа и проверяем, не равен ли их НОД единице. Доля
тестов, которые проходят, дает нам приближение к @math{6/\pi^2}, и
отсюда мы получаем приближенное значение @math{\pi}.

В центре нашей программы находится процедура @code{monte-carlo}, которая
в качестве аргументов принимает количество попыток тестирования, а также
сам тест --- процедуру без аргументов, возвращающую при каждом вызове
либо истину, либо ложь. @code{monte-carlo} запускает тест указанное
количество раз и возвращает число, обозначающее долю попыток, в которых
тест вернул истинное значение.

@lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
   (= (gcd (rand) (rand)) 1))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1)
                 (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1)
                 trials-passed))))
  (iter trials 0))
@end lisp

@noindent
Теперь попробуем осуществить то же вычисление, используя
@code{rand-update} вместо @code{rand}, как нам пришлось бы поступить,
если бы у нас не было присваивания для моделирования локального
состояния:

@lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))
(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
@end lisp

@noindent
Хотя программа по-прежнему проста, в ней обнаруживается несколько
болезненных нарушений принципа модульности. В первой версии программы
нам удалось, используя @code{rand}, выразить метод Монте-Карло напрямую
как обобщенную процедуру @code{monte-carlo}, которая в качестве
аргумента принимает произвольную процедуру @code{experiment}. Во втором
варианте программы, где у генератора случайных чисел нет локального
состояния, @code{random-gcd-test} приходится непосредственно возиться со
случайными числами @code{x1} и @code{x2} и передавать в итеративном
цикле @code{x2} в качестве нового входа @code{rand-update}. Из-за того,
что обработка случайных чисел происходит явно, структура накопления
результатов тестов начинает зависеть от того, что наш тест использует
именно два случайных числа, тогда как для других тестов Монте-Карло
может потребоваться, скажем, одно или три. Даже процедура верхнего
уровня @code{estimate-pi} вынуждена заботиться о том, чтобы предоставить
начальное значение случайного числа. Поскольку внутренности генератора
случайных чисел просачиваются наружу в другие части программы, задача
изолировать идею метода Монте-Карло так, чтобы применять ее затем к
другим задачам, осложняется. В первом варианте программы присваивание
инкапсулирует состояние генератора случайных чисел внутри @code{rand},
так что состояние генератора остается независимым от остальной программы.

Общее явление, наблюдаемое на примере с методом Монте-Карло, таково: с
точки зрения одной части сложного процесса кажется, что другие части
изменяются со временем. Они обладают скрытым локальным состоянием. Если
мы хотим, чтобы структура программ, которые мы пишем, отражала такое
разделение на части, мы создаем вычислительные объекты (например,
банковские счета или генераторы случайных чисел), поведение которых
изменяется со временем. Состояние мы моделируем при помощи локальных
переменных, а изменение состояния --- при помощи присваивания этим
переменным.

Здесь возникает соблазн закрыть обсуждение и сказать, что, введя
присваивание и метод сокрытия состояния в локальных переменных, мы
обретаем способность структурировать системы более модульным образом,
чем если бы нам пришлось всем состоянием манипулировать явно, с
передачей дополнительных параметров. К сожалению, как мы увидим, все не
так просто.

@quotation
@strong{@anchor{Упражнение 3.5}Упражнение 3.5:}
@emph{Интегрирование методом Монте-Карло} (@newterm{Monte Carlo integration}) --- способ приближенного вычисления определенных
интегралов при помощи моделирования методом Монте-Карло. Рассмотрим
задачу вычисления площади фигуры, описываемой предикатом @math{P(x,y)},
который истинен для точек @math{(x,y)}, принадлежащих фигуре, и ложен
для точек вне фигуры. Например, область, содержащаяся в круге с радиусом
3 и центром в точке @math{(5,7)}, описывается предикатом, проверяющим
@math{(x-5)^2 + (y-7)^2 \le 3^2}. Чтобы оценить площадь фигуры,
описываемой таким предикатом, для начала выберем прямоугольник, который
содержит нашу фигуру. Например, прямоугольник с углами @math{(2,4)} и
@math{(8,10)}, расположенными по диагонали, содержит вышеописанный круг.
Нужный нам интеграл --- площадь той части прямоугольника, которая лежит
внутри фигуры. Мы можем оценить интеграл, случайным образом выбирая
точки @math{(x,y)}, лежащие внутри прямоугольника, и проверяя для каждой
точки @math{P(x,y)}, чтобы определить, лежит ли точка внутри фигуры.
Если мы проверим много точек, доля тех, которые окажутся внутри области,
даст нам приближенное значение отношения площадей фигуры и
прямоугольника. Таким образом, домножив это значение на площадь
прямоугольника, мы получим приближенное значение интеграла.

Реализуйте интегрирование методом Монте-Карло в виде процедуры
@code{estimate-integral}, которая в качестве аргументов принимает
предикат @code{P}, верхнюю и нижнюю границы прямоугольника @code{x1},
@code{x2}, @code{y1} и @code{y2}, а также число проверок, которые мы
должны осуществить, чтобы оценить отношение площадей. Ваша процедура
должна использовать ту же самую процедуру @code{monte-carlo}, которая
выше использовалась для оценки значения @math{\pi}. Оцените @math{\pi}
при помощи @code{estimate-integral}, измерив площадь единичного круга.

Вам может пригодиться процедура, которая выдает число, случайно
выбранное внутри данного отрезка. Нижеприведенная процедура
@code{random-in-range} решает эту задачу, используя процедуру
@code{random}, введенную в разделе @ref{1.2.6},
которая возвращает неотрицательное число меньше своего
аргумента.@footnote{В MIT Scheme есть такая процедура. Если @code{random}
на вход дается точное целое число (как в разделе @ref{1.2.6}),
она возвращает точное целое число, но если ей дать десятичную дробь (как
в этом примере), она и возвращает десятичную дробь.}

@lisp
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.6}Упражнение 3.6:}
Полезно иметь возможность сбросить генератор случайных чисел,
чтобы получить последовательность, которая начинается с некоторого
числа. Постройте новую процедуру @code{rand}, которая вызывается с
аргументом. Этот аргумент должен быть либо символом @code{generate},
либо символом @code{reset}. Процедура работает так:
@code{(rand 'generate)} порождает новое случайное число;
@code{((rand 'reset)}@math{\;\langle}@var{новое-значение}@math{\kern0.11em\rangle}@code{)}
сбрасывает внутреннюю переменную состояния в указанное
@math{\langle}@var{новое-значение}@math{\kern0.08em\rangle}. Таким образом,
сбрасывая значения, можно получать повторяющиеся последовательности. Эта
возможность очень полезна при тестировании и отладке программ,
использующих случайные числа.
@end quotation

@comment @subsection The Costs of Introducing Assignment
@subsection Издержки, связанные с введением присваивания
@node	3.1.3,  , 3.1.2, 3.1
Как мы только что видели, операция @code{set!} позволяет моделировать
объекты, обладающие внутренним состоянием. Однако за это преимущество
приходится платить. Наш язык программирования нельзя больше описывать
при помощи подстановочной модели применения процедур, которую мы ввели в
разделе @ref{1.1.5}.
Хуже того, не существует простой модели с <<приятными>> математическими
свойствами, которая бы адекватно описывала работу с объектами и
присваивание в языках программирования.

Пока мы не применяем присваивание, два вычисления одной и той же
процедуры с одними и теми же аргументами всегда дают одинаковый
результат. Стало быть, можно считать, что процедуры вычисляют
математические функции. Соответственно, программирование, в котором
присваивание не используется (как у нас в первых двух главах этой
книги), известно как (@newterm{functional programming}).

Чтобы понять, как присваивание усложняет ситуацию, рассмотрим упрощенную
версию @code{make-withdraw} из раздела @ref{3.1.1}, которая не проверяет,
достаточно ли на счете денег:

@lisp
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
(define W (make-simplified-withdraw 25))
(W 20)
@i{5}
(W 10)
@i{-5}
@end lisp

@noindent
Сравним эту процедуру со следующей процедурой @code{make-decrementer},
которая не использует @code{set!}:

@lisp
(define (make-decrementer balance)
  (lambda (amount)
    (- balance amount)))
@end lisp

@noindent
@code{make-decrementer} возвращает процедуру, которая вычитает свой
аргумент из определенного числа @code{balance}, но при последовательных
вызовах ее действие не накапливается, как при использовании
@code{make-simplified-withdraw}:

@lisp
(define d (make-decrementer 25))
(d 20)
@i{5}
(d 10)
@i{15}
@end lisp

@noindent
Мы можем объяснить, как работает @code{make-decrementer}, при помощи
подстановочной модели. Например, рассмотрим, как вычисляется выражение

@lisp
((make-decrementer 25) 20)
@end lisp

@noindent
Сначала мы упрощаем операторную часть комбинации, подставляя в теле
@code{make-decrementer} вместо @code{balance} 25. Выражение сводится к

@lisp
((lambda (amount) (- 25 amount)) 20)
@end lisp

@noindent
Теперь мы применяем оператор к операнду, подставляя 20 вместо
@code{amount} в теле @code{lambda}-выражения:

@lisp
(- 25 20)
@end lisp

@noindent
Окончательный результат равен 5.

Посмотрим, однако, что произойдет, если мы попробуем применить подобный
подстановочный анализ к @code{make-simplified-withdraw}:

@lisp
((make-simplified-withdraw 25) 20)
@end lisp

@noindent
Сначала мы упрощаем оператор, подставляя вместо @code{balance} 25 в теле
@code{makesimplified-withdraw}. Таким образом, наше выражение сводится
к.@footnote{Мы не производим подстановку вхождения @code{balance} в
выражение @code{set!}, поскольку @math{\langle}@var{имя}@math{\kern0.08em\rangle} 
в @code{set!} не вычисляется. Если бы мы провели подстановку, получилось
бы @code{(set! 25 (- 25 amount))}, а это не имеет никакого смысла.}

@lisp
((lambda (amount) (set! balance (- 25 amount)) 25) 20)
@end lisp

@noindent
Теперь мы применяем оператор к операнду, подставляя в теле
@code{lambda}-выражения 20 вместо @code{amount}:

@lisp
(set! balance (- 25 20)) 25
@end lisp

@noindent
Если бы мы следовали подстановочной модели, нам пришлось бы сказать, что
вычисление процедуры состоит в том, чтобы сначала присвоить переменной
@code{balance} значение 5, а затем в качестве значения вернуть 25. Но
это дает неверный ответ. Чтобы получить правильный ответ, нам пришлось
бы как-то отличить первое вхождение @code{balance} (до того, как
сработает @code{set!}) от второго (после выполнения @code{set!}).
Подстановочная модель на это не способна.

Проблема здесь состоит в том, что подстановка предполагает, что символы
в нашем языке --- просто имена для значений. Но как только мы вводим
@code{set!} и представление, что значение переменной может изменяться,
переменная уже не может быть всего лишь именем. Теперь переменная
некоторым образом соответствует месту, в котором может храниться
значение, и значение это может меняться. В разделе @ref{3.2} мы увидим, как в
нашей модели вычислений роль этого <<места>> играют окружения.

@comment @subsubheading Sameness and change
@subsubheading Тождественность и изменение

Проблема, которая здесь встает, глубже, чем просто поломка определенной
модели вычислений. Как только мы вводим в наши вычислительные модели
понятие изменения, многие другие понятия, которые до сих пор были ясны,
становятся сомнительными. Рассмотрим вопрос, что значит, что две вещи
суть <<одно и то же>>.

Допустим, мы два раза зовем @code{make-decrementer} с одним и тем же
аргументом, и получаем две процедуры:

@lisp
(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))
@end lisp

@noindent
Являются ли @code{D1} и @code{D2} одним и тем же объектом? Можно
сказать, что да, поскольку @code{D1} и @code{D2} обладают одинаковым
поведением --- каждая из этих процедур вычитает свой аргумент из 25. В
сущности, в любом вычислении можно подставить @code{D1} вместо
@code{D2}, и результат не изменится.

Напротив, рассмотрим два вызова @code{make-simplified-withdraw}:

@lisp
(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))
@end lisp

@noindent
Являются ли @code{W1} и @code{W2} одним и тем же? Нет, конечно, потому
что вызовы @code{W1} и @code{W2} приводят к различным результатам, как
показывает следующая последовательность вычислений:

@lisp
(W1 20)
@i{5}
(W1 20)
@i{-15}
(W2 20)
@i{5}
@end lisp

@noindent
Хотя @code{W1} и @code{W2} <<равны друг другу>> в том смысле, что оба
они созданы вычислением одного и того же выражения
@code{(make-simplified-withdraw 25)}, неверно, что в любом выражении
можно заменить @code{W1} на @code{W2}, не повлияв при этом на результат
его вычисления.

Язык, соблюдающий правило, что в любом выражении <<одинаковое можно
подставить вместо одинакового>>, не меняя его значения, называется
(@newterm{referentially transparent}). Если мы включаем в свой компьютерный язык
@code{set!}, его референциальная прозрачность нарушается. Становится
сложно определить, где можно упростить выражение, подставив вместо него
равносильное. Следовательно, рассуждать о программах, в которых
используется присваивание, оказывается гораздо сложнее.

С потерей референциальной прозрачности становится сложно формально
описать понятие о том, что два объекта -- один и тот же объект. На самом
деле, смысл выражения <<то же самое>> в реальном мире, который наши
программы моделируют, сам по себе недостаточно ясен. В общем случае, мы
можем проверить, являются ли два как будто бы одинаковых объекта одним и
тем же, только изменяя один из них и наблюдая, изменился ли таким же
образом и другой. Но как мы можем узнать, <<изменился>> ли объект?
Только рассмотрев один и тот же объект дважды и проверив, не различается
ли некоторое его свойство между двумя наблюдениями. Таким образом, мы не
можем определить <<изменение>>, не имея заранее понятия
<<идентичности>>, а идентичность мы не можем определить, не рассмотрев
результаты изменений.

В качестве примера того, как эти вопросы возникают в программировании,
рассмотрим ситуацию, где у Петра и у Павла есть по банковскому счету в
100 долларов. Здесь не все равно, смоделируем мы это через

@lisp
(define peter-acc (make-account 100))
(define paul-acc (make-account 100))
@end lisp

@noindent
или

@lisp
(define peter-acc (make-account 100))
(define paul-acc peter-acc)
@end lisp

@noindent
В первом случае, два счета различны. Действия, которые производит Петр,
не меняют счет Павла, и наоборот. Однако во втором случае мы сказали,
что @code{paul-acc} --- это @emph{та же самая вещь}, что и
@code{peter-acc}. Теперь у Петра и у Павла есть совместный банковский
счет, и если Петр возьмет сколько-то с @code{peter-acc}, то у Павла на
@code{paul-acc} будет меньше денег. При построении вычислительных
моделей сходство между этими двумя несовпадающими ситуациями может
привести к путанице. В частности, в случае с совместным счетом может
особенно мешать то, что у одного объекта (банковского счета) есть два
имени (@code{peter-acc} и @code{paul-acc}); если мы ищем в программе все
места, где может меняться @code{paul-acc}, надо смотреть еще и где
меняется @code{peter-acc}.@footnote{Когда у вычислительного объекта
имеется несколько имён, эти имена называются (aliasing). Ситуация с
совместным банковским счетом --- простой пример псевдонимов. В
разделе @ref{3.3} мы увидим значительно
более сложные примеры, скажем, <<различные>> составные структуры с
общими частями. Если мы забудем, что <<побочным эффектом>> в результате
изменения одного объекта может стать изменение <<другого>> объекта,
поскольку <<разные>> объекты --- на самом деле один и тот же под
разными псевдонимами, то могут возникнуть ошибки. Эти так называемые
(side-effect bugs) настолько трудно обнаруживать и анализировать, что
некоторые исследователи выступали с предложениями не допускать в языках
программирования побочные эффекты и псевдонимы (@ref{Lampson et al. 1981};
@ref{Morris et al. 1980}).}

В связи с этими замечаниями обратите внимание на то, что если бы Петр и
Павел могли только проверять свой платежный баланс, но не менять его, то
вопрос <<один ли у них счет?>> не имел бы смысла. В общем случае, если
мы никогда не меняем объекты данных, то можно считать, что каждый объект
представляет собой в точности совокупность своих частей. Например,
рациональное число определяется своим числителем и знаменателем. Однако
при наличии изменений такой взгляд становится ошибочным, поскольку
теперь у каждого объекта есть <<индивидуальность>>, которая отличается
от тех частей, из которых он состоит. Банковский счет останется <<тем же
самым>> счетом, даже если мы снимем с него часть денег; и наоборот,
можно иметь два разных счета с одинаковым состоянием. Такие
сложности --- следствие не нашего языка программирования, а нашего
восприятия банковского счета как объекта. Скажем, рациональное число мы
обычно не рассматриваем как изменяемый объект со своей
индивидуальностью, у которого можно было бы изменить числитель и
по-прежнему иметь дело с <<тем же>> числом.

@comment @subsubheading Pitfalls of imperative programming
@subsubheading Ловушки императивного программирования

В противоположность функциональному программированию, стиль
программирования, при котором активно используется присваивание,
называется (@newterm{imperative programming}). Кроме того, что возникают сложности
с вычислительными моделями, программы, написанные в императивном стиле,
подвержены таким ошибкам, которые в функциональных программах не
возникают. Вспомним, к примеру, итеративную программу для вычисления
факториала из
раздела @ref{1.2.1}:

@lisp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
@end lisp

@noindent
Вместо того, чтобы передавать аргументы во внутреннем итеративном цикле,
мы могли бы написать процедуру в более императивном стиле с
использованием присваивания для обновления значений переменных
@code{product} и @code{counter}:

@lisp
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))
@end lisp

@noindent
Результаты, выдаваемые программой, при этом не меняются, но возникает
маленькая ловушка. Как определить порядок присваиваний? В имеющемся виде
программа корректна. Однако если бы мы записали присваивания в обратном
порядке:

@lisp
(set! counter (+ counter 1))
(set! product (* counter product))
@end lisp

@noindent
--- получился бы другой, неверный результат. Вообще, программирование с
использованием присваивания заставляет нас тщательно следить за порядком
присваиваний, так, чтобы в каждом использовалась правильная версия
значения переменных, которые меняются. В функциональных программах такие
сложности просто не возникают.@footnote{Поэтому странно и смешно, что
вводные курсы программирования часто читаются в глубоко императивном
стиле. Может быть, сказываются остатки распространенного в 60-е и 70-е
годы представления, что программы, которые вызывают процедуры,
непременно будут менее эффективны, чем те, которые производят
присваивания. (@ref{Steele 1977} развенчивает этот аргумент.) С другой
стороны, возможно, считается, что новичкам легче представить пошаговое
присваивание, чем вызов процедуры. Так или иначе, программистам часто
приходится заботиться о вопросе <<присвоить сначала эту переменную или
ту?>>, а это усложняет программирование и затемняет важные идеи.}

Сложность императивных программ еще увеличивается, если мы начинаем
рассматривать приложения, где одновременно выполняется несколько
процессов. К этому мы еще вернемся в разделе @ref{3.4}. Однако сначала
мы обратимся к задаче построения вычислительной модели для выражений,
содержащих присваивание, а также изучим, как использовать объекты с
локальным состоянием при проектировании моделирующих программ.

@quotation
@strong{@anchor{Упражнение 3.7}Упражнение 3.7:}
Рассмотрим объекты-банковские счета, создаваемые процедурой
@code{make-account}, и снабженные паролями, как это описано в
упражнении @ref{Упражнение 3.3}. Предположим, что наша банковская
система требует от нас умения порождать совместные счета. Напишите
процедуру @code{make-joint}, которая это делает. @code{make-joint}
должна принимать три аргумента. Первый из них --- защищенный паролем
счет. Второй обязан совпадать с паролем, с которым этот счет был создан,
иначе @code{make-joint} откажется работать. Третий аргумент --- новый
пароль. Например, если банковский счет @code{peter-account} был создан с
паролем @code{open-sesame}, то

@lisp
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
@end lisp

@noindent
позволит нам проводить операции с @code{peter-account}, используя имя
@code{paul-acc} и пароль @code{rosebud}. Вам может потребоваться
переработать решение упражнения @ref{Упражнение 3.3}, чтобы добавить
эту новую возможность.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.8}Упражнение 3.8:} Когда в разделе @ref{1.1.3} мы
определяли модель вычислений, мы сказали, что первым шагом при
вычислении выражения является вычисление его подвыражений. Однако мы
нигде не указали порядок, в котором проходит вычисление подвыражений
(слева направо или справа налево). Когда мы вводим присваивание,
порядок, в котором вычисляются аргументы процедуры, может повлиять на
результат. Определите простую процедуру @code{f}, так, чтобы вычисление

@lisp
(+ (f 0) (f 1))
@end lisp

возвращало 0, если аргументы @code{+} вычисляются
слева направо, и 1, если они вычисляются справа налево.
@end quotation

@comment @section The Environment Model of Evaluation
@section Модель вычислений с окружениями
@node	3.2, 3.3, 3.1, Chapter 3


Когда в @ref{Глава 1} мы вводили понятие составной процедуры, то для того,
чтобы определить, что значит применение процедуры к аргументам, мы пользовались
подстановочной моделью вычислений (@ref{1.1.5}):

@itemize @bullet

@item
Чтобы применить составную процедуру к аргументам, нужно вычислить тело
процедуры, подставив вместо каждого формального параметра
соответствующий ему аргумент.

@end itemize

@noindent
Как только мы вводим в язык программирования присваивание, это
определение перестает быть адекватным. А именно, в @ref{3.1.3} указывалось,
что в присутствии присваивания переменную уже нельзя рассматривать
просто как имя для значения. Переменная должна каким-то образом
обозначать <<место>>, где значение может храниться. В нашей новой модели
вычислений такие места будут находиться в структурах, которые мы
называем (@newterm{environments}).

Окружение представляет собой последовательность (@newterm{frames}). Каждый кадр
есть (возможно, пустая) таблица (@newterm{bindings}), которые сопоставляют имена
переменных соответствующим значениям. (Каждый кадр должен содержать не
более одного связывания для каждой данной переменной.) Кроме того, в
каждом кадре имеется указатель на (@newterm{enclosing environment}), кроме тех
случаев, когда в рамках текущего обсуждения окружение считается
(@newterm{global}). (@newterm{value of a variable}) по отношению к данному окружению есть
значение, которое находится в связывании для этой переменной в первом
кадре окружения, содержащем такое связывание. Если в последовательности
кадров ни один не указывает значения для данной переменной, говорят, что
переменная (@newterm{unbound}) в окружении.

На рисунке @ref{Рисунок 3.1} изображена простая структура окружений,
которая состоит из трех кадров, помеченных числами I, II и III. На этой
диаграмме A, B, C и D --- указатели на окружения. C и D указывают на
одно и то же окружение. В кадре II связываются переменные @code{z} и
@code{x}, а в кадре I переменные @code{y} и @code{x}. В окружении D
переменная @code{x} имеет значение 3. В окружении B значение переменной
@code{x} также равно 3. Это определяется следующим образом: мы
рассматриваем первый кадр в последовательности (кадр III) и не находим
там связывания для переменной @code{x}, так что мы переходим к
объемлющему окружению D и находим связывание в кадре I. С другой
стороны, в окружении A значение переменной @code{x} равно 7, поскольку
первый кадр окружения (кадр II) содержит связывание @code{x} со
значением 7. По отношению к окружению A говорится, что связывание
@code{x} со значением 7 в кадре II (@newterm{shadows}) связывание @code{x} со
значением 3 в кадре I.

@float
@quotation
@anchor{Рисунок 3.1}
@ifinfo
@strong{Рисунок 3.1:} A simple environment structure.

@example
           +--------+
           |      I |
           | x: 3   |
           | y: 5   |
           +--------+
              ^  ^
              |  |
            C |  | D
+---------+   |  |   +----------+
|      II |   |  |   |      III |
| z: 6    +---+  +---+ m: 1     |
| x: 7    |          | y: 2     |
+---------+          +----------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.1,48mm,,,.pdf}
@sp 0.4
@center @caption{@strong{Рисунок 3.1:} A simple environment structure.}
@sp 0.7
@end iftex
@end quotation
@end float

Окружение играет важную роль в процессе вычисления, поскольку оно
определяет контекст, в котором выражение должно вычисляться. В самом
деле, можно сказать, что выражения языка программирования сами по себе
не имеют значения. Выражение приобретает значение только по отношению к
окружению, в контексте которого оно вычисляется. Даже интерпретация
столь простого выражения, как @code{(+ 1 1)}, зависит от нашего
понимания, что мы работаем в контексте, где @code{+} является символом
сложения. Таким образом, в нашей модели мы всегда будем говорить о
вычислении выражения относительно некоторого окружения. При описании
взаимодействия с интерпретатором мы будем предполагать, что существует
глобальное окружение, состоящее из одного кадра (без объемлющего
окружения), и что глобальное окружение содержит значения для символов,
обозначающих элементарные процедуры. Например, информация о том, что
@code{+} служит символом сложения, выражается как утверждение, что в
глобальном окружении символ @code{+} связан с элементарной процедурой
сложения.

@menu
* 3-2-1::            Правила вычисления
* 3-2-2::            Применение простых процедур
* 3-2-3::            Кадры как хранилище внутреннего состояния
* 3-2-4::            Внутренние определения
@end menu

@comment @subsection The Rules for Evaluation
@subsection Правила вычисления
@node	3.2.1, 3.2.2, 3.2, 3.2

Общее описание того, как интерпретатор вычисляет комбинацию, остается
таким же, как оно было введено в
@ref{1.1.3}:

@itemize @bullet

@item
Для того, чтобы вычислить комбинацию, нужно:

@end itemize

@enumerate 1

@item
Вычислить подвыражения комбинации.@footnote{Присваивание вносит одну
тонкость в шаг 1 правила вычисления. Как показано в
упражнении @ref{Упражнение 3.8}, присваивание позволяет нам писать
выражения, которые имеют различные значения в зависимости от того, в
каком порядке вычисляются подвыражения комбинации. Таким образом, чтобы
быть точными, мы должны были бы указать порядок вычислений на шаге 1
(например, слева направо или справа налево). Однако этот порядок всегда
должен рассматриваться как деталь реализации, и писать программы,
которые зависят от порядка вычисления аргументов, не следует. К примеру,
продвинутый компилятор может оптимизировать программу, изменяя порядок,
в котором вычисляются подвыражения.}

@item
Применить значение выражения-оператора к значениям выражений-операндов.

@end enumerate

@noindent
Модель вычисления с окружениями заменяет подстановочную модель,
по-своему определяя, что значит применить составную процедуру к
аргументам.

В модели вычисления с окружениями процедура всегда представляется в виде
пары, состоящей из кода и указателя на некое окружение. Процедура
создается единственным способом: вычислением @code{lambda}-выражения.
Такое вычисление дает в качестве результата процедуру, код которой
берется из тела @code{lambda}-выражения, а окружение совпадает с
окружением, в котором было вычислено выражение, чьим значением является
процедура. Например, рассмотрим определение процедуры

@lisp
(define (square x)
  (* x x))
@end lisp

@noindent
которое вычисляется в глобальном окружении. Синтаксис определения
процедуры --- всего лишь синтаксический сахар для подразумеваемой
@code{lambda}. С тем же успехом можно было написать выражение

@lisp
(define square
  (lambda (x) (* x x)))
@end lisp

@noindent
которое вычисляет @code{(lambda (x) (* x x))} и связывает символ
@code{square} с полученным значением, все это в глобальном окружении.

параметры: @code{x}

тело: @code{(* x x)}

Рис. @ref{Рисунок 3.2} показывает результат вычисления
@code{lambda}-выражения. Объект-процедура представляет собой пару, код
которой указывает, что процедура принимает один формальный параметр, а
именно @code{x}, а тело ее @code{(* x x)}. Окружение процедуры --- это
указатель на глобальное окружение, поскольку именно в нем вычислялось
@code{lambda}-выражение, при помощи которого процедура была порождена. К
глобальному кадру добавилось новое связывание, которое сопоставляет
процедурный объект символу @code{square}. В общем случае @code{define}
создает определения, добавляя новые связывания в кадры.

@float
@quotation
@anchor{Рисунок 3.2}
@ifinfo
@strong{Рисунок 3.2:} Environment structure produced by
evaluating @code{(define (square x) (* x x))} in the global environment.

@example
           +----------------------+
           | other variables      |
global --->|                      |
env        | square: --+          |
           +-----------|----------+
                       |       ^
(define (square x)     |       |
  (* x x))             V       |
                   .---.---.   |
                   | O | O-+---+
                   `-|-^---'
                     |
                     V
                   parameters: x
                   body: (* x x)
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.2b,49mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 3.2:} Environment structure produced by evaluating @* @code{(define (square x) (* x x))} in the global environment.}
@sp 0.8
@end iftex
@end quotation
@end float

Теперь, когда мы рассмотрели, как процедуры создаются, мы можем описать,
как они применяются. Модель с окружениями говорит: чтобы применить
процедуру к аргументам, создайте новое окружение, которое содержит кадр,
связывающий параметры со значениями аргументов. Объемлющим окружением
для нового кадра служит окружение, на которое указывает процедура.
Теперь требуется выполнить тело процедуры в этом новом окружении.

Чтобы проиллюстрировать, как работает это новое правило, на
рис. @ref{Рисунок 3.3} показана структура окружений, создаваемая при
вычислении выражения @code{(square 5)} в глобальном окружении, если
@code{square} --- процедура, порожденная на рисунке @ref{Рисунок 3.2}.
Применение процедуры приводит к созданию нового окружения, которое на
рисунке обозначено как E1, и это окружение начинается с кадра, в котором
@code{x}, формальный параметр процедуры, связан с аргументом 5.
Указатель, который ведет из этого кадра вверх, показывает, что
объемлющим для этого окружения является глобальное. Глобальное окружение
выбирается потому, что именно на него ссылается процедурный объект
@code{square}. Внутри E1 мы вычисляем тело процедуры, @code{(* x x)}.
Поскольку значение @code{x} в E1 равно 5, результатом будет
@code{(* 5 5)}, или 25.

@float
@quotation
@anchor{Рисунок 3.3}
@ifinfo
@strong{Рисунок 3.3:} Environment created by evaluating
@code{(square 5)} in the global environment.

@example
          +------------------------------------+
          | other variables                    |
global -->|                                    |
env       | square: --+                        |
          +-----------|---------------------+--+
                      |       ^             ^
(square 5)            |       |             |
                      V       |             |
                  .---.---.   |         +---+--+
                  | O | O-+---+   E1 -->| x: 5 |
                  `-|-^---'             +------+
                    |
                    V
                  parameters: x
                  body: (* x x)
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.3b,78mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 3.3:} Environment created by evaluating @code{(square 5)} in the global environment.}
@sp 0.7
@end iftex
@end quotation
@end float

параметры: @code{x}

тело: @code{(* x x)}

Модель вычисления с окружениями можно вкратце описать двумя правилами:

@itemize @bullet

@item
Процедурный объект применяется к набору аргументов при помощи создания
кадра, связывания формальных параметров процедуры с аргументами вызова,
и, наконец, вычисления тела процедуры в контексте этого свежесозданного
окружения. В качестве объемлющего окружения новый кадр имеет окружение,
содержащееся в применяемом процедурном объекте.

@item
Процедура создается при вычислении @code{lambda}-выражения по отношению
к некоторому окружению. Получающийся процедурный объект есть пара,
состоящая из текста @code{lambda}-выражения и указателя на окружение, в
котором процедура была создана.

@end itemize

@noindent
Кроме того, мы указываем, что когда символ определяется при помощи
@code{define}, в текущем кадре окружения создается связывание, и символу
присваивается указанное значение.@footnote{Если в текущем кадре уже
имелось связывание для указанной переменной, то это связывание
изменяется. Это правило удобно, поскольку позволяет переопределять
символы; однако оно означает, что при помощи @code{define} можно
изменять значение символов, а это влечет за собой все проблемы,
связанные с присваиванием, без явного использования @code{set!}. По этой
причине некоторые предпочитают, чтобы переопределение существующего
символа вызывало предупреждение или сообщение об ошибке.} Наконец, мы
описываем поведение @code{set!}, операции, из-за которой нам,
собственно, и пришлось ввести модель с окружениями. Вычисление выражения
@code{(set!}@math{\;\langle}@var{переменная}@math{\kern0.08em\rangle}@math{\;\langle}@var{значение}@math{\kern0.08em\rangle}@code{)} в
некотором окружении заставляет интерпретатор найти связывание переменной
в окружении и изменить это связывание так, чтобы оно указывало на новое
значение. А именно, нужно найти первый кадр окружения, в котором
содержится связывание для переменной, и изменить этот кадр. Если
переменная в окружении не связана, @code{set!} сигнализирует об ошибке.

Все эти правила вычисления, хотя они значительно сложнее, чем в
подстановочной модели, достаточно просты. Более того, модель вычислений,
несмотря на свою абстрактность, дает правильное описание того, как
интерпретатор вычисляет выражения. В @ref{Глава 4} мы
увидим, как эта модель может служить основой для реализации работающего
интерпретатора. В последующих разделах анализ нескольких примеров
программ раскрывает некоторые детали этой модели.

@comment @subsection Applying Simple Procedures
@subsection Применение простых процедур
@node	3.2.2, 3.2.3, 3.2.1, 3.2

Когда в @ref{1.1.5} мы
описывали подстановочную модель, мы показали, как вычисление комбинации
@code{(f 5)} дает результат 136, если даны следующие определения:

@lisp
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
@end lisp

@noindent
Теперь мы можем проанализировать тот же самый пример, используя модель с
окружениями. На рисунке @ref{Рисунок 3.4} изображены три процедурных
объекта, созданные вычислением в глобальном окружении определений
@code{f}, @code{square}, и @code{sum-of-squares}. Каждый процедурный
объект состоит из куска кода и указателя на глобальное окружение.

@float
@c @quotation
@anchor{Рисунок 3.4}
@ifinfo
@strong{Рисунок 3.4:} Procedure objects in the global frame.

@example
          +--------------------------------------------+
          | sum-of-squares:                            |
global -->| square:                                    |
env       | f: --+                                     |
          +------|--------------+--------------+-------+
                 |     ^        |     ^        |     ^
                 |     |        |     |        |     |
                 V     |        V     |        V     |
             .---.---. |    .---.---. |    .---.---. |
             | O | O-+-+    | O | O-+-+    | O | O-+-+
             `-|-^---'      `-|-^---'      `-|-^---'
               |              |              |
               V              V              V
   parameters: a          parameters: x  parameters: x, y
   body: (sum-of-squares  body: (* x x)  body: (+ (square x)
           (+ a 1)                                (square y))
           (* a 2))
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.4a,106mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 3.4:} Procedure objects in the global frame.}
@sp 0.7
@end iftex
@c @end quotation
@end float

На рисунке @ref{Рисунок 3.5} мы видим структуру окружений, созданную
вычислением выражения @code{(f 5)}. Вызов @code{f} создает новое
окружение E1, начинающееся с кадра, в котором @code{a}, формальный
параметр @code{f}, связывается с аргументом 5. В окружении E1 мы
вычисляем тело @code{f}:

@lisp
(sum-of-squares (+ a 1) (* a 2))
@end lisp

@noindent
To evaluate this combination, we first evaluate the subexpressions.  The first
Для вычисления этой комбинации сначала мы вычисляем подвыражения.
Значение первого подвыражения, @code{sum-of-squares} --- процедурный
объект. (Обратите внимание, как мы находим этот объект: сначала мы
просматриваем первый кадр E1, который не содержит связывания для
переменной @code{sum-of-squares}. Затем мы переходим в объемлющее
окружение, а именно глобальное, и там находим связывание, которое
показано на рис. @ref{Рисунок 3.4}.) В оставшихся двух подвыражениях
элементарные операции @code{+} и @code{*} применяются при вычислении
комбинаций @code{(+ a 1)} и @code{(* a 2)}, и дают, соответственно,
результаты 6 и 10.

\enlargethispage{\baselineskip}

Теперь мы применяем процедурный объект @code{sum-of-squares} к
аргументам 6 и 10. При этом создается новое окружение E2, в котором
формальные параметры @code{x} и @code{y} связываются со значениями
аргументов. Внутри E2 мы вычисляем комбинацию
@code{(+ (square x) (square y))}. Для этого нам требуется вычислить
@code{(square x)}, причем значение @code{square} мы находим в глобальном
окружении, а @code{x} равен 6. Мы опять создаем новое окружение, E3, где
@code{x} связан со значением 6, и где мы вычисляем тело @code{square},
то есть @code{(* x x)}. Кроме того, как часть вычисления
@code{sum-of-squares}, нам нужно вычислить подвыражение
@code{(square y)}, где @code{y} равен 10. Этот второй вызов
@code{square} создает еще одно окружение E4, в котором @code{x},
формальный параметр @code{square}, связан со значением 10. Внутри E4 нам
нужно вычислить @code{(* x x)}.

@float
@c @quotation
@anchor{Рисунок 3.5}
@ifinfo
@strong{Рисунок 3.5:} Environments created by evaluating
@code{(f 5)} using the procedures in @ref{Рисунок 3.4}.

@example
          +-----------------------------------------------------+
global -->|                                                     |
env       +-----------------------------------------------------+
            ^              ^                ^               ^
(f 5)       |              |                |               |
        +------+       +-------+        +------+        +-------+
  E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
        |      |       | y: 10 |        |      |        |       |
        +------+       +-------+        +------+        +-------+
   (sum-of-squares   (+ (square x)       (* x x)         (* x x)
     (+ a 1)            (square u))
     (+ a 2))
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.5a,100mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 3.5:} Environments created by evaluating @code{(f 5)} using the procedures in @ref{Рисунок 3.4}.}
@sp 0.9
@end iftex
@c @end quotation
@end float

Важно заметить, что каждый вызов @code{square} создает новое окружение с
новым связыванием для @code{x}. Теперь мы видим, как разделение кадров
служит для того, чтобы разные локальные переменные по имени @code{x} не
смешивались. Заметим, кроме того, что все кадры, созданные процедурой
@code{square}, указывают на глобальное окружение, поскольку указатель
именно на это окружение содержится в процедурном объекте @code{square}.

После того, как подвыражения вычисляются, они возвращают значения.
Значения, порожденные двумя вызовами @code{square}, складываются в
@code{sum-of-squares}, и этот результат возвращается процедурой
@code{f}. Поскольку сейчас наше внимание сосредоточено на структурах
окружений, мы не будем здесь разбираться, как значения передаются от
вызова к вызову; однако на самом деле это важная часть процесса
вычисления, и мы детально рассмотрим ее в
@ref{Глава 5}.

@quotation
@strong{@anchor{Упражнение 3.9}Упражнение 3.9:}
В @ref{1.2.1} мы с помощью подстановочной модели анализировали две процедуры
вычисления факториала, рекурсивную

@lisp
(define (factorial n)
  (if (= n 1) 1 (* n (factorial (- n 1)))))
@end lisp

@noindent
и итеративную

@lisp
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
@end lisp

Продемонстрируйте, какие структуры окружений возникнут при вычислении
@code{(factorial 6)} с каждой из версий процедуры
@code{factorial}.@footnote{Модель с окружениями неспособна
проиллюстрировать утверждение из @ref{1.2.1},
что интерпретатор может, используя хвостовую рекурсию, вычислять
процедуры, подобные @code{fact-iter}, в фиксированном объеме памяти. Мы
рассмотрим хвостовую рекурсию, когда будем изучать управляющую структуру
интерпретатора в @ref{5.4}.}
@end quotation

@comment @subsection Frames as the Repository of Local State
@subsection Кадры как хранилище внутреннего состояния
@node	3.2.3, 3.2.4, 3.2.2, 3.2

Теперь мы можем обратиться к модели с окружениями и рассмотреть, как
можно с помощью процедур и присваивания представлять объекты, обладающие
внутренним состоянием. В качестве примера возьмем <<обработчик снятия
денег со счета>> из @ref{3.1.1}, который создается вызовом процедуры

@lisp
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
@end lisp

@noindent
Опишем вычисление

@lisp
(define W1 (make-withdraw 100))
@end lisp

@noindent
за которым следует

@lisp
(W1 50)
@i{50}
@end lisp

@noindent
На рисунке @ref{Рисунок 3.6} показан результат определения
@code{make-withdraw} в глобальном окружении. Получается процедурный
объект, который содержит ссылку на глобальное окружение. До сих пор мы
не видим особых отличий от тех примеров, которые мы уже рассмотрели,
кроме того, что тело процедуры само по себе является @code{lambda}-выражением.

@float
@anchor{Рисунок 3.6}
@ifinfo
@quotation
@strong{Рисунок 3.6:} Result of defining @code{make-withdraw} in the global environment.

@example
          +---------------------------+
global -->| make-withdraw: --+        |
env       +------------------|--------+
                             |      ^
                             V      |
                         .---.---.  |
                         | O | O-+--+
                         `-|-^---'
                           |
                           V
         parameters: balance
         body: (lambda (amount)
                 (if (>= balance amount)
                     (begin (set! balance
                                  (- balance amount))
                            balance)
                     "Insufficient funds"))
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.6b,91mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 3.6:} Result of defining @code{make-withdraw} in the global environment.}
@sp 0.8
@end iftex
@end float

@float
@c @quotation
@anchor{Рисунок 3.7}
@ifinfo
@strong{Рисунок 3.7:} Result of evaluating @code{(define W1 (make-withdraw 100))}.

@example
          +-----------------------------------------------+
          | make-withdraw: -----------------------+       |
global -->|                                       |       |
          | W1: --+                               |       |
          +-------|-------------------------------|-------+
                  |                ^              |     ^
                  |                |              V     |
                  |        +-------+------+   .---.---. |
                  |  E1 -->| balance: 100 |   | O | O-+-+
                  |        +--------------+   `-|-^---'
                  V                ^            |
              .---.---.            |            V
            +-+-O | O-+------------+    parameters: balance
            | `---^---'                 body: ...
            V
    parameters: amount
    body: (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds")
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap3/Fig3.7a,100mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 3.7:} Result of evaluating @code{(define W1 (make-withdraw 100))}. }@short
@sp 0.9
@end iftex
@c @end quotation
@end float

Интересная часть вычисления начинается тогда, когда мы применяем
процедуру @code{make-withdraw} к аргументу:

@lisp
(define W1 (make-withdraw 100))
@end lisp

@noindent
Сначала, как обычно, мы создаем окружение E1, где формальный параметр
@code{balance} связан с аргументом 100. Внутри этого окружения мы
вычисляем тело @code{make-withdraw}, а именно @code{lambda}-выражение.
При этом создается новый процедурный объект, код которого определяется
@code{lambda}-выражением, а окружение равно E1, окружению, в котором
вычисляется @code{lambda} при создании процедуры. Полученный процедурный
объект возвращается в качестве значения процедуры @code{make-withdraw}.
Это значение присваивается переменной @code{W1} в глобальном окружении,
поскольку выражение @code{define} вычисляется именно в нем. Получившаяся
структура окружений изображена на рисунке @ref{Рисунок 3.7}.

@float
@c @quotation
@anchor{Рисунок 3.8}
@ifinfo
@strong{Рисунок 3.8:} Environments created by applying the procedure object @code{W1}.

@example
          +---------------------------------------------------+
          | make-withdraw: ...                                |
global -->|                                                   |
env       | W1: --+                                           |
          +-------|-------------------------------------------+
                  |               ^
                  |               |
                  |       +-------+------+ Here is the balance
                  | E1 -->| balance: 100 | that will be changed
                  |       +--------------+ by the set!.
                  V               ^   ^
              .---.---.           |   +----+
              | O | O-+-----------+        |
              `-|-^---'             +------+-----+
                |                   | amount: 50 |
                V                   +------------+
      parameters: amount   (if (>= balance amount)
      body: ...                (begin (set! balance
                                            (- balance amount))
                                      balance)
                               "Insufficient funds")
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.8c,99mm,,,.pdf}
@sp 0.2
@center @caption{@strong{Рисунок 3.8:} Environments created by applying the procedure object @code{W1}. }@short
@sp 0.7
@end iftex
@c @end quotation
@end float

\enlargethispage{\baselineskip}

Теперь можно проанализировать, что происходит, когда @code{W1}
применяется к аргументу:

@lisp
(W1 50)
@i{50}
@end lisp

Для начала мы конструируем кадр, в котором @code{amount}, формальный
параметр @code{W1}, связывается со значением 50. Здесь крайне важно
заметить, что у этого кадра в качестве объемлющего окружения выступает
не глобальное окружение, а E1, поскольку именно на него указывает
процедурный объект @code{W1}. В этом новом окружении мы вычисляем тело
процедуры:

@lisp
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
@end lisp

@noindent
Получается структура окружений, изображенная на
рисунке @ref{Рисунок 3.8}. Вычисляемое выражение обращается к
переменным @code{amount} и @code{balance}. @code{Amount} находится в
первом кадре окружения, а @code{balance} мы найдем, проследовав по
указателю на объемлющее окружение E1.

@float
@quotation
@anchor{Рисунок 3.9}
@ifinfo
@strong{Рисунок 3.9:} Environments after the call to @code{W1}.

@example
           +------------------------------------+
           | make-withdraw: ...                 |
global --->|                                    |
env        | W1: --+                            |
           +-------|----------------------------+
                   |                   ^
                   |                   |
                   |            +------+------+
                   |     E1 --->| balance: 50 |
                   |            +-------------+
                   V                   ^
               .---.---.               |
               | O | O-+---------------+
               `-|-^---'
                 |
                 V
          parameters: amount
          body: ...
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap3/Fig3.9a,96mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.9:} Environments after the call to @code{W1}.}
@sp 1.0
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

Когда выполняется @code{set!}, связывание переменной @code{balance} в E1
изменяется. После завершения вызова @code{W1} значение @code{balance}
равно 50, а @code{W1} по-прежнему указывает на кадр, который содержит
переменную @code{balance}. Кадр, содержащий @code{amount} (тот, в
котором мы выполняли код, изменяющий @code{balance}), больше не нужен,
поскольку создавший его вызов процедуры закончен, и никаких указателей
на этот кадр из других частей окружения нет. В следующий раз, когда мы
позовем @code{W1}, создастся новый кадр, в котором будет связана
переменная @code{amount}, и для которого объемлющим окружением снова
будет E1. Мы видим, что E1 служит <<местом>>, в котором хранится
локальная переменная окружения для процедурного объекта @code{W1}. На
рисунке @ref{Рисунок 3.9} изображена ситуация после вызова @code{W1}.

Рассмотрим, что произойдет, когда мы создадим другой объект для <<снятия
денег>>, вызвав @code{make-withdraw} второй раз:

@lisp
(define W2 (make-withdraw 100))
@end lisp

@float
@c @quotation
@anchor{Рисунок 3.10}
@ifinfo
@strong{Рисунок 3.10:} Using @code{(define W2 (make-withdraw 100))} to create a second object.

@example
         +-------------------------------------------------+
         | make-withdraw: ...                              |
global ->| W2: ---------------------------+                |
env      | W1: --+                        |                |
         +-------|------------------------|----------------+
                 |              ^         |              ^
                 |              |         |              |
                 |       +------+------+  |       +------+-------+
                 |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                 |       +-------------+  |       +--------------+
                 V              ^         V              ^
             .---.---.          |     .---.---.          |
             | O | O-+----------+     | O | O-+----------+
             `-|-^---'                `-|-^---'
               | +----------------------+
               V V
        parameters: amount
        body: ...
@end example
@end ifinfo
@iftex
@sp 1.0
@center @image{fig/chap3/Fig3.10a,108mm,,,.pdf}
@sp 0.7
@caption{@strong{Рисунок 3.10:} Using @code{(define W2 (make-withdraw 100))} to create a second object.}
@sp 1.0
@end iftex
@c @end quotation
@end float

При этом получается структура окружений, изображенная на
рисунке @ref{Рисунок 3.10}. Мы видим, что @code{W2} --- процедурный
объект, то есть пара, содержащая код и окружение. Окружение E2 для
@code{W2} было создано во время вызова @code{make-withdraw}. Оно
содержит кадр со своим собственным связыванием переменной
@code{balance}. С другой стороны, код у @code{W1} и @code{W2} один и тот
же: это код, определяемый @code{lambda}-выражением в теле
@code{make-withdraw}.@footnote{Разделяют ли @code{W1} и @code{W2} общий
физический код, хранимый в компьютере, или каждый из них хранит
собственную копию кода --- это деталь реализации. В интерпретаторе,
который мы создадим в @ref{Глава 4},
код будет общим.} Отсюда мы видим, почему @code{W1} и @code{W2} ведут
себя как независимые объекты. Вызовы @code{W1} работают с переменной
состояния @code{balance}, которая хранится в E1, а вызовы @code{W2} с
переменной @code{balance}, хранящейся в E2. Таким образом, изменения
внутреннего состояния одного объекта не действуют на другой.

@quotation
@strong{@anchor{Упражнение 3.10}Упражнение 3.10:}
В процедуре @code{make-withdraw} локальная переменная
@code{balance} создается в виде параметра @code{make-withdraw}. Можно
было бы создать локальную переменную и явно, используя @code{let}, а
именно:

@lisp
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
@end lisp

Напомним, что в @ref{1.3.2} говорится, что @code{let} всего лишь
синтаксический сахар для вызова процедуры:

@lisp
(let ((@math{\langle}@var{var}@math{\rangle} @math{\langle}@var{exp}@math{\rangle})) @math{\langle}@var{body}@math{\rangle})
@end lisp

@noindent
интерпретируется как альтернативный синтаксис для

@lisp
((lambda (@math{\langle}@var{var}@math{\rangle}) @math{\langle}@var{body}@math{\rangle}) @math{\langle}@var{exp}@math{\rangle})
@end lisp

С помощью модели с окружениями проанализируйте альтернативную версию
@code{makewithraw}. Нарисуйте картинки, подобные приведенным в этом
разделе, для выражений

@lisp
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
@end lisp

Покажите, что две версии @code{make-withdraw} создают объекты с
одинаковым поведением. Как различаются структуры окружений в двух
версиях?
@end quotation

@comment @subsection Internal Definitions
@subsection Внутренние определения
@node	3.2.4,  , 3.2.3, 3.2

В @ref{1.1.8} мы познакомились с идеей, что процедуры могут содержать внутренние
определения, в результате чего возникает блочная структура, как,
например, в следующей процедуре вычисления квадратного корня:

@lisp
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
@end lisp

@noindent
Теперь с помощью модели с окружениями мы можем увидеть, почему эти
внутренние определения работают так, как должны. На
рисунке @ref{Рисунок 3.11} изображен момент во время вычисления
выражения @code{(sqrt 2)}, когда внутренняя процедура
@code{good-enough?} вызвана в первый раз со значением @code{guess},
равным 1.

Рассмотрим структуру окружения. Символ @code{sqrt} в глобальном
окружении связан с процедурным объектом, ассоциированное окружение
которого --- глобальное окружение. Когда мы вызвали процедуру
@code{sqrt}, появилось окружение E1, зависимое от глобального, в котором
параметр @code{x} связан со значением 2. Затем мы вычислили тело
@code{sqrt} внутри E1. Поскольку первое выражение в теле @code{sqrt}
есть

@lisp
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
@end lisp

@noindent
вычисление этого выражения привело к определению процедуры
@code{good-enough?} в окружении E1. Выражаясь более точно, к первому
кадру E1 был добавлен символ @code{good-enough?}, связанный с
процедурным объектом, ассоциированным окружением которого является E1.
Подобным образом в качестве процедур внутри E1 были определены
@code{improve} и @code{sqrt-iter}. Краткости ради на
рис. @ref{Рисунок 3.11} показан только процедурный объект,
соответствующий @code{good-enough?}.

@float
@c @quotation
@anchor{Рисунок 3.11}
@ifinfo
@strong{Рисунок 3.11:} @code{sqrt} procedure with internal definitions.

@example
          +--------------------------------------------------+
global -->| sqrt: --+                                        |
env       |         |                                        |
          +---------|----------------------------------------+
                    V       ^                   ^
                .---.---.   |                   |
     +----------+-O | O-+---+        +----------+------------+
     |          `---^---'            | x: 2                  |
     V                         E1 -->| good-enough?: -+      |
parameters: x                        | improve: ...   |      |
body: (define good-enough? ...)      | sqrt-iter: ... |      |
      (define improve ...)           +----------------|------+
      (define sqrt-iter ...)          ^  ^            |     ^
      (sqrt-iter 1.0)                 |  |            V     |
                            +---------++ |        .---.---. |
                      E2 -->| guess: 1 | |        | O | O-+-+
                            +----------+ |        `-|-^---'
                      call to sqrt-iter  |          |
                                         |          V
                               +---------++    parameters: guess
                         E3 -->| guess: 1 |    body: (< (abs ...)
                               +----------+             ...)
                         call to good-enough?
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap3/Fig3.11a,107mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.11:} @code{sqrt} procedure with internal definitions.}
@sp 0.7
@end iftex
@c @end quotation
@end float

После того, как были определены внутренние процедуры, мы вычислили
выражение @code{(sqrt-iter 1.0)}, по-прежнему в окружении E1. То есть,
процедурный объект, связанный в E1 с именем @code{sqrt-iter}, был вызван
с аргументом 1. При этом появилось окружение E2, в котором @code{guess},
параметр @code{sqrt-iter}, связан со значением 1. В свою очередь,
@code{sqrt-iter} вызвала @code{good-enough?} со значением @code{guess}
(из E2) в качестве аргумента. Получилось еще одно окружение, E3, в
котором @code{guess} (параметр @code{good-enough?}) связан со значением
1. Несмотря на то, что и @code{sqrt-iter}, и @code{good-enough?} имеют
по параметру с одинаковым именем @code{guess}, это две различные
переменные, расположенные в разных кадрах. Кроме того, и E2, и E3 в
качестве объемлющего окружения имеют E1, поскольку как @code{sqrt-iter},
так и @code{good-enough?} в качестве окружения содержат указатель на E1.
Одним из следствий этого является то, что символ @code{x} в теле
@code{good-enough?} обозначает связывание @code{x}, в окружении E1, а
точнее, то значение @code{x}, с которым была вызвана исходная процедура
@code{sqrt}.

Таким образом, модель вычислений с окружениями объясняет две ключевых
особенности, которые делают внутренние определения процедур полезным
способом модуляризации программ:

@itemize @bullet

@item
Имена внутренних процедур не путаются с именами, внешними по отношению к
охватывающей процедуре, поскольку локальные имена процедур будут
связываться в кадре, который процедура создает при своем запуске, а не в
глобальном окружении.

@item
Внутренние процедуры могут обращаться к аргументам охватывающих
процедур, просто используя имена параметров как свободные переменные.
Это происходит потому, что тело внутренней процедуры выполняется в
окружении, подчиненном окружению, где вычисляется объемлющая процедура.

@end itemize

@quotation
@strong{@anchor{Упражнение 3.11}Упражнение 3.11:}
В @ref{3.2.3}
мы видели, как модель с окружениями описывает поведение процедур,
обладающих внутренним состоянием. Теперь мы рассмотрели, как работают
локальные определения. Типичная процедура с передачей сообщений
пользуется и тем, и другим. Рассмотрим процедуру моделирования
банковского счета из @ref{3.1.1}:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else
           (error "Unknown request: MAKE-ACCOUNT"
                  m))))
  dispatch)
@end lisp

Покажите, какая структура окружений создается последовательностью
действий

@lisp
(define acc (make-account 50))
((acc 'deposit) 40)
@i{90}
((acc 'withdraw) 60)
@i{30}
@end lisp

Где хранится внутреннее состояние @code{acc}? Предположим, что мы
определяем еще один счет

@lisp
(define acc2 (make-account 100))
@end lisp

Каким образом удается не смешивать внутренние состояния двух счетов?
Какие части структуры окружений общие у @code{acc} и @code{acc2}?
@end quotation

@comment @section Modeling with Mutable Data
@section Моделирование при помощи изменяемых данных
@node	3.3, 3.4, 3.2, Chapter 3

В @ref{Глава 2}
составные данные использовались как средство построения вычислительных
объектов, состоящих из нескольких частей, с целью моделирования объектов
реального мира, обладающих несколькими свойствами. В этой главе мы ввели
дисциплину абстракции данных, согласно которой структуры данных
описываются в терминах конструкторов, которые создают объекты данных, и
селекторов, которые обеспечивают доступ к частям составных объектов.
Однако теперь мы знаем, что есть еще один аспект работы с данными,
который остался незатронутым в
@ref{Глава 2}.
Желание моделировать системы, которые состоят из объектов, обладающих
изменяющимся состоянием, вызывает потребность не только создавать
составные объекты данных и иметь доступ к их частям, но и изменять их.
Чтобы моделировать объекты с изменяющимся состоянием, мы будем
проектировать абстракции данных, которые, помимо конструкторов и
селекторов, включают (@newterm{mutators}), модифицирующие объекты данных.
Например, моделирование банковской системы требует от нас способности
изменять балансы счетов. Таким образом, структура данных, изображающая
банковский счет, может обладать операцией

@lisp
(set-balance! @math{\langle}@var{account}@math{\rangle} @math{\langle}@var{new-value}@math{\rangle})
@end lisp

@noindent
которая присваивает балансу указанного счета указанное значение. Объекты
данных, для которых определены мутаторы, называются (@newterm{mutable data objects}).

В @ref{Глава 2}
в качестве универсального <<клея>> для построения составных данных мы
ввели пары. Этот раздел мы начинаем с определения мутаторов для пар,
так, чтобы пары могли служить строительным материалом для построения
изменяемых объектов данных. Мутаторы значительно увеличивают
выразительную силу пар и позволяют нам строить структуры данных помимо
последовательностей и деревьев, с которыми мы имели дело в
@ref{2.2}.
Кроме того, мы строим несколько примеров моделей, где сложные системы
представляются в виде множества объектов, обладающих внутренним
состоянием.

@menu
* 3-3-1::            Изменяемая списковая структура
* 3-3-2::            Представление очередей
* 3-3-3::            Представление таблиц
* 3-3-4::            Имитация цифровых схем
* 3-3-5::            Распространение ограничений
@end menu

@comment @subsection Mutable List Structure
@subsection Изменяемая списковая структура
@node	3.3.1, 3.3.2, 3.3, 3.3

Базовые операции над парами --- @code{cons}, @code{car} и @code{cdr} ---
можно использовать для построения списковой структуры и для извлечения
частей списковой структуры, однако изменять списковую структуру они не
позволяют. То же верно и для операций со списками, которые мы до сих пор
использовали, таких, как @code{append} и @code{list}, поскольку эти
последние можно определить в терминах @code{cons}, @code{car} и
@code{cdr}. Для модификации списковых структур нам нужны новые операции.

Элементарные мутаторы для пар называются @code{set-car!} и
@code{set-cdr!}. @code{set-car!} принимает два аргумента, первый из
которых обязан быть парой. Он модифицирует эту пару, подставляя вместо
указателя @code{car} указатель на свой второй
аргумент.@footnote{Значения, которые возвращают @code{set-car!} и
@code{set-cdr!}, зависят от реализации. Подобно @code{set!}, эти
операции должны использоваться исключительно ради своего побочного
эффекта.}

В качестве примера предположим, что переменная @code{x} имеет значением
список @code{((a b) c d)}, а переменная @code{y} список @code{(e f)},
как показано на рисунке @ref{Рисунок 3.12}. Вычисление выражения
@code{(set-car! x y)} изменяет пару, с которой связана переменная
@code{x}, заменяя ее @code{car} на значение @code{y}. Результат этой
операции показан на рисунке @ref{Рисунок 3.13}. Структура @code{x}
изменилась, и теперь ее можно записать как @code{((e f) c d)}. Пары
представляющие список @code{(a b)}, на которые указывал замененный
указатель, теперь отделены от исходной структуры.@footnote{Здесь мы
видим, как операции изменения данных могут создавать <<мусор>>, который
не является частью никакой доступной структуры. В @ref{5.3.2}
мы увидим, что системы управления памятью Лиспа включают (garbage
collector), который находит и освобождает память, используемую ненужными
парами.}

Сравните рисунок @ref{Рисунок 3.13}, на котором представлен результат
выполнения @code{(define z (cons y (cdr x)))}, где @code{x} и @code{y} имеют
исходные значения с рисунком @ref{Рисунок 3.12}. Здесь переменная
@code{z} оказывается связана с новой парой, созданной операцией
@code{cons}; список, который является значением @code{x}, не меняется.

@float[tp]
@quotation
@anchor{Рисунок 3.12}
@ifinfo
@strong{Рисунок 3.12:} Lists @code{x}: @code{((a b) c d)} and @code{y}: @code{(e f)}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       +---------->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | a |         | b |
                   +---+         +---+
                   +---+---+     +---+---+
              y -->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.12b,72mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.12:} Lists @code{x}: @code{((a b) c d)} and @code{y}: @code{(e f)}.}
@sp 0.7
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

@float[bp]
@quotation
@anchor{Рисунок 3.13}
@ifinfo
@strong{Рисунок 3.13:} Effect of @code{(set-car! x y)} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       |           | * | *-+---->| * | / |
       |           +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.13b,72mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.13:} Effect of @code{(set-car! x y)} on the lists in @ref{Рисунок 3.12}. }@short
@sp 0.7
@end iftex
@end quotation
@end float

@float[tp]
@quotation
@anchor{Рисунок 3.14}
@ifinfo
@strong{Рисунок 3.14:} Effect of @code{(define z (cons y (cdr x)))} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+ +-->+-|-+---+     +-|-+---+
       |       |     V             V
       |       |   +---+         +---+
       |       |   | c |         | d |
       |       |   +---+         +---+
       |       |   +---+---+     +---+---+
       +-------+-->| * | *-+---->| * | / |
               |   +-|-+---+     +-|-+---+
     +---+---+ |     V             V
z -->| * | *-+-+   +---+         +---+
     +-|-+---+     | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.14b,72mm,,,.pdf}
@sp 0.7
@caption{@strong{Рисунок 3.14:} Effect of @code{(define z (cons y (cdr x)))} on the lists in @ref{Рисунок 3.12}.}
@sp 0.0
@end iftex
@end quotation
@end float

\enlargethispage{\baselineskip}

@float[bp]
@quotation
@anchor{Рисунок 3.15}
@ifinfo
@strong{Рисунок 3.15:} Effect of @code{(set-cdr! x y)} on the lists in @ref{Рисунок 3.12}.

@example
     +---+---+     +---+---+     +---+---+
x -->| * | * |     | * | *-+---->| * | / |
     +-|-+-|-+     +-|-+---+     +-|-+---+
       |   |         V             V
       |   |       +---+         +---+
       |   |       | c |         | d |
       |   |       +---+         +---+
       |   |       +---+---+     +---+---+
       +---+------>| * | *-+---->| * | / |
           |       +-|-+---+     +-|-+---+
           |         V             V
           |       +---+         +---+
           |       | a |         | b |
           |       +---+         +---+
           +------>+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.15b,72mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.15:} Effect of @code{(set-cdr! x y)} on the lists in @ref{Рисунок 3.12}. }@short
@sp 0.7
@end iftex
@end quotation
@end float

Операция @code{set-cdr!} подобна @code{set-car!}. Единственная разница
состоит в том, что заменяется не указатель @code{car}, а указатель
@code{cdr}. Результат применения @code{(set-cdr! x y)} к спискам,
изображенным на рис. @ref{Рисунок 3.12}, показан на
рис. @ref{Рисунок 3.15}. Здесь указатель @code{cdr} в составе
@code{x} заменился указателем на @code{(e f)}. Кроме того, список
@code{(c d)}, который был @code{cdr}-ом @code{x}, оказывается отделенным
от структуры.

@code{Cons} создает новую списковую структуру, порождая новые пары, а
@code{set-car!} и @code{set-cdr!} изменяют существующие. В сущности, мы
могли бы реализовать @code{cons} при помощи этих двух мутаторов и
процедуры @code{get-new-pair}, которая возвращает новую пару, не
являющуюся частью никакой существующей списковой структуры. Мы порождаем
новую пару, присваиваем ее указателям @code{car} и @code{cdr} нужные
значения, и возвращаем новую пару в качестве результата
@code{cons}.@footnote{@code{get-new-pair} --- одна из операций, которые
требуется предоставить как часть системы управления памятью в рамках
реализации Лиспа. Мы рассмотрим эти вопросы в
@ref{5.3.1}.}

@lisp
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.12}Упражнение 3.12:}
В @ref{2.2.1} была
введена следующая процедура для добавления одного списка к другому:

@lisp
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
@end lisp

@code{append} порождает новый список, по очереди наращивая элементы
@code{x} в начало @code{y}. Процедура @code{append!} подобна
@code{append}, но только она является не конструктором, а мутатором. Она
склеивает списки вместе, изменяя последнюю пару @code{x} так, что ее
@code{cdr} становится равным @code{y}. (Вызов @code{append!} с пустым
@code{x} является ошибкой.)

@lisp
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
@end lisp

Здесь @code{last-pair} --- процедура, которая возвращает последнюю пару
своего аргумента:

@lisp
(define (last-pair x)
  (if (null? (cdr x)) x (last-pair (cdr x))))
@end lisp

Рассмотрим последовательность действий

@lisp
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
@i{(a b c d)}
(cdr x)
@math{\langle}@var{ответ}@math{\rangle}
(define w (append! x y))
w
@i{(a b c d)}
(cdr x)
@math{\langle}@var{ответ}@math{\rangle}
@end lisp

Каковы будут пропущенные @math{\langle}@var{ответы}@math{\rangle}?
Объясните, нарисовав стрелочные диаграммы.

@quotation
@strong{@anchor{Упражнение 3.13}Упражнение 3.13:}
Рассмотрим следующую процедуру @code{make-cycle}, которая
пользуется @code{last-pair} из упражнения @ref{Упражнение 3.12}:

@lisp
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
@end lisp

Нарисуйте стрелочную диаграмму, которая изображает структуру @code{z},
созданную таким кодом:

@lisp
(define z (make-cycle (list 'a 'b 'c)))
@end lisp

Что случится, если мы попробуем вычислить @code{(last-pair z)}?

@quotation
@strong{@anchor{Упражнение 3.14}Упражнение 3.14:}
Следующая процедура, хотя и сложна для понимания, вполне может оказаться полезной:

@lisp
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
@end lisp

@code{loop} пользуется <<временной>> переменной @code{temp}, чтобы
сохранить старое значение @code{cdr} пары @code{x}, поскольку
@code{set-cdr!} на следующей строке его разрушает. Объясните, что за
задачу выполняет @code{mystery}. Предположим, что переменная @code{v}
определена выражением @code{(define v (list 'a 'b 'c 'd)}. Нарисуйте
диаграмму, которая изображает список, являющийся значением @code{v}.
Допустим, что теперь мы выполняем @code{(define w (mystery v))}.
Нарисуйте стрелочные диаграммы, которые показывают структуры @code{v} и
@code{w} после вычисления этого выражения. Что будет напечатано в
качестве значений @code{v} и @code{w}?
@end quotation

@comment @subsubheading Sharing and identity
@subsubheading Разделение данных и их идентичность
В @ref{3.1.3} мы упоминали
теоретические вопросы <<идентичности>> и <<изменения>>, которые
возникают с появлением присваивания. Эти вопросы начинают иметь
практическое значение тогда, когда отдельные пары (@newterm{are shared}) между
различными объектами данных. Рассмотрим, например, структуру, которая
создается таким кодом:

@lisp
(define x (list 'a 'b))
(define z1 (cons x x))
@end lisp

@noindent
Как показано на рис. @ref{Рисунок 3.16}, @code{z1} представляет собой
пару, в которой @code{car} и @code{cdr} указывают на одну и ту же пару
@code{x}. Разделение @code{x} между @code{car} и @code{cdr} пары
@code{z1} возникает оттого, что @code{cons} реализован простейшим
способом. В общем случае построение списков с помощью @code{cons}
приводит к возникновению сложносвязанной сети пар, в которой многие пары
разделяются между многими различными структурами.

В противоположность @ref{Рисунок 3.16}, @ref{Рисунок 3.17} показывает
структуру, которая порождается кодом

@lisp
(define z2 (cons (list 'a 'b) (list 'a 'b)))
@end lisp

@noindent
В этой структуре пары двух списков @code{(a b)} различны, притом, что
сами символы разделяются.@footnote{Пары различаются потому, что каждый
вызов @code{cons} порождает новую пару. Символы разделяются; в Scheme
существует только один символ для каждого данного имени. Поскольку
Scheme не дает возможности изменять символ, это разделение невозможно
заметить. Заметим, кроме того, что именно разделение позволяет нам
сравнивать символы при помощи @code{eq?}, который просто проверяет
равенство указателей.}

@float
@quotation
@anchor{Рисунок 3.16}
@ifinfo
@strong{Рисунок 3.16:} The list @code{z1} formed by @code{(cons x x)}.

@example
      +---+---+
z1 -->| * | * |
      +-|-+-|-+
        V   V
      +---+---+     +---+---+
 x -->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+
        V             V
      +---+         +---+
      | a |         | b |
      +---+         +---+
@end example
@end ifinfo
@iftex
@sp 0.5
@center @image{fig/chap3/Fig3.16b,46mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.16:} The list @code{z1} formed by @code{(cons x x)}.}
@sp 0.7
@end iftex
@end quotation
@end float

@float
@anchor{Рисунок 3.17}
@ifinfo
@quotation
@strong{Рисунок 3.17:} The list @code{z2} formed by @code{(cons (list 'a 'b) (list 'a 'b))}.

@example
      +---+---+     +---+---+     +---+---+
z2 -->| * | *-+---->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+     +-|-+---+
        |             V             V
        |           +---+         +---+
        |           | a |         | b |
        |           +---+         +---+
        |             ^             ^
        |             |             |
        |           +-|-+---+     +-|-+---+
        +---------->| * | *-+---->| * | / |
                    +---+---+     +---+---+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.17b,71mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.17:} The list @code{z2} formed by @code{(cons (list 'a 'b) (list 'a 'b))}.}
@sp 1.0
@end iftex
@end float

Если мы рассматриваем @code{z1} и @code{z2} как списки, они представляют
<<один и тот же>> список @code{((a b) a b)}. Вообще говоря, разделение
данных невозможно заметить, если мы работаем со списками только при
помощи операций @code{cons}, @code{car} и @code{cdr}. Однако если мы
вводим мутаторы, работающие со списковой структурой, разделение данных
начинает иметь значение. Как пример случая, когда разделение влияет на
результат, рассмотрим следующую процедуру, которая изменяет @code{car}
структуры, к которой она применяется:

@lisp
(define (set-to-wow! x) (set-car! (car x) 'wow) x)
@end lisp

@noindent
Несмотря на то, что @code{z1} и @code{z2} имеют <<одинаковую>>
структуру, применение к ним процедуры @code{set-to-wow!} дает различные
результаты. В случае с @code{z1} изменение @code{car} влияет и на
@code{cdr}, поскольку здесь @code{car} и @code{cdr} --- это одна и та же
пара. В случае с @code{z2}, @code{car} и @code{cdr} различны, так что
@code{set-to-wow!} изменяет только @code{car}:

@lisp
z1
@i{((a b) a b)}
(set-to-wow! z1)
@i{((wow b) wow b)}
z2
@i{((a b) a b)}
(set-to-wow! z2)
@i{((wow b) a b)}
@end lisp

@noindent
Один из способов распознать разделение данных в списковых структурах ---
это воспользоваться предикатом @code{eq?}, который мы ввели в
@ref{} как метод проверки двух символов
на равенство. В более общем случае @code{(eq? x y)} проверяет, являются
ли @code{x} и @code{y} одним объектом (то есть, равны ли @code{x} и
@code{y} друг другу как указатели). Так что, если @code{z1} и @code{z2}
определены как на рисунках @ref{Рисунок 3.16},
@code{(eq? (car z1) (cdr z1))} будет истинно, а
@code{(eq? (car z2) (cdr z2))} ложно.

Как будет видно в последующих разделах, с помощью разделения данных мы
значительно расширим репертуар структур данных, которые могут быть
представлены через пары. С другой стороны, разделение сопряжено с
риском, поскольку изменения в одних структурах могут затрагивать и
другие структуры, разделяющие те части, которые подвергаются изменению.
Операции изменения @code{set-car!} и @code{set-cdr!} нужно использовать
осторожно; если у нас нет точного понимания, какие из наших объектов
разделяют данные, изменение может привести к неожиданным
результатам.@footnote{Тонкости работы с разделением изменяемых данных
отражают сложности с понятием <<идентичности>> и <<изменения>>, о
которых мы говорили в @ref{3.1.3}. Там мы
отметили, что введение в наш язык понятия изменения требует, чтобы у
составного объекта была <<индивидуальность>>, которая представляет собой
нечто отличное от частей, из которых он состоит. В Лиспе мы считаем, что
именно эта <<индивидуальность>> проверяется предикатом @code{eq?}, то
есть сравнением указателей. Поскольку в большинстве реализаций Лиспа
указатель --- это, в сущности, адрес в памяти, мы <<решаем проблему>>
определения индивидуальности объектов, постановив, что <<сам>> объект
данных есть информация, хранимая в некотором наборе ячеек памяти
компьютера. Для простых лисповских программ этого достаточно, но такой
метод не способен разрешить общий вопрос <<идентичности>> в
вычислительных моделях.}

@quotation
@strong{@anchor{Упражнение 3.15}Упражнение 3.15:}
Нарисуйте стрелочные диаграммы, объясняющие, как
@code{set-to-wow!} действует на структуры @code{z1} и @code{z2} из этого
раздела.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.16}Упражнение 3.16:}
Бен Битобор решил написать процедуру для подсчета числа пар
в любой списковой структуре. <<Это легко, --- думает он. --- Число пар в
любой структуре есть число пар в @code{car} плюс число пар в @code{cdr}
плюс один на текущую пару>>. И он пишет следующую процедуру:

@lisp
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
@end lisp

Покажите, что эта процедура ошибочна. В частности, нарисуйте диаграммы,
представляющие списковые структуры ровно из трех пар, для которых Бенова
процедура вернет 3; вернет 4; вернет 7; вообще никогда не завершится.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.17}Упражнение 3.17:}
Напишите правильную версию процедуры @code{count-pairs} из
упражнения @ref{Упражнение 3.16}, которая возвращает число различных
пар в любой структуре. (Подсказка: просматривайте структуру, поддерживая
при этом вспомогательную структуру, следящую за тем, какие пары уже были
посчитаны.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.18}Упражнение 3.18:}
Напишите процедуру, которая рассматривает список и
определяет, содержится ли в нем цикл, то есть, не войдет ли программа,
которая попытается добраться до конца списка, продвигаясь по полям
@code{cdr}, в бесконечный цикл. Такие списки порождались в
упражнении @ref{Упражнение 3.13}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.19}Упражнение 3.19:}
Переделайте упражнение @ref{Упражнение 3.18}, используя
фиксированное количество памяти. (Тут нужна достаточно хитрая идея.)
@end quotation

@comment @subsubheading Mutation is just assignment
@subsubheading Изменение как присваивание

Когда мы вводили понятие составных данных, в @ref{2.1.3} мы
заметили, что пары можно представить при помощи одних только процедур:

@lisp
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
@end lisp

@noindent
То же наблюдение верно и для изменяемых данных. Изменяемые объекты
данных можно реализовать при помощи процедур и внутреннего состояния.
Например, можно расширить приведенную реализацию пар, так, чтобы
@code{set-car!} и @code{set-cdr!} обрабатывались по аналогии с
реализацией банковских счетов через @code{make-account} из @ref{3.1.1}:

@lisp
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else
           (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value)
  ((z 'set-car!) new-value) z)
(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value) z)
@end lisp

@noindent
Теоретически, чтобы описать поведение изменяемых данных, не требуется
ничего, кроме присваивания. Как только мы вводим в наш язык @code{set!},
мы сталкиваемся со всеми проблемами, не только собственно присваивания,
но и вообще изменяемых данных.@footnote{С другой стороны, с точки зрения
реализации, присваивание требует модификации окружения, которое само по
себе является изменяемой структурой данных. Таким образом, присваивание
и изменяемость данных обладают равной мощностью: каждое из них можно
реализовать при помощи другого.}

@quotation
@strong{@anchor{Упражнение 3.20}Упражнение 3.20:}
Нарисуйте диаграммы окружений, изображающие выполнение последовательности выражений

@lisp
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
@i{17}
@end lisp

@noindent
с помощью вышеприведенной процедурной реализации пар. (Ср. с
упражнением @ref{Упражнение 3.11}.)
@end quotation

@endpage
@comment @subsection Representing Queues
@subsection Представление очередей
@node	3.3.2, 3.3.3, 3.3.1, 3.3

Мутаторы @code{set-car!} и @code{set-cdr!} позволяют нам строить из пар
такие структуры, какие мы не смогли бы создать только при помощи
@code{cons}, @code{car} и @code{cdr}. В этом разделе будет показано, как
представить структуру данных, которая называется очередь. В
@ref{3.3.3} мы увидим, как реализовать структуру, называемую таблицей.

@float
@quotation
@anchor{Рисунок 3.18}
@ifinfo
@strong{Рисунок 3.18:} Queue operations.

@example
Операция                 Результат
(define q (make-queue))
(insert-queue! q 'a)     a
(insert-queue! q 'b)     a b
(delete-queue! q)        b
(insert-queue! q 'c)     b c
(insert-queue! q 'd)     b c d
(delete-queue! q)        c d
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.18a,70mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 3.18:} Queue operations.}
@sp 0.9
@end iftex
@end quotation
@end float

(@newterm{queue}) представляет собой последовательность, в которую можно добавлять
элементы с одного конца (он называется (@newterm{rear)}) и убирать с другого (он
называется (@newterm{front)}). На рисунке @ref{Рисунок 3.18} изображено, как в
изначально пустую очередь добавляются элементы @code{a} и @code{b}.
Затем @code{a} убирается из очереди, в нее добавляются @code{c} и
@code{d}, потом удаляется @code{b}. Поскольку элементы удаляются всегда
в том же порядке, в котором они были добавлены, иногда очередь называют
буфером (@newterm{FIFO}) (англ. first in, first out --- первым вошел, первым
вышел).

С точки зрения абстракции данных, можно считать, что очередь
определяется следующим набором операций:

@itemize @bullet

@item
конструктор @code{(make-queue)} возвращает пустую очередь (очередь, в
которой нет ни одного элемента).

@item
два селектора:
@code{(empty-queue? @math{\langle}@var{очередь}@math{\rangle})}
проверяет, пуста ли очередь.

@code{(front-queue @math{\langle}@var{очередь}@math{\rangle})}
возвращает объект, находящийся в голове очереди. Если очередь пуста,
он сообщает об ошибке. Очередь не модифицируется.

@item
Два мутатора:
@code{(insert-queue! @math{\langle}@var{очередь}@math{\rangle} @math{\langle}@var{элемант}@math{\rangle})}
вставляет элемент в хвост очереди и возвращает в качестве значения
измененную очередь; @code{(delete-queue! @math{\langle}@var{очередь}@math{\rangle})} удаляет
элемент в голове очереди и возвращает в качестве значения измененную
очередь. Если перед уничтожением элемента очередь оказывается пустой,
выводится  об ошибке.

@end itemize

@noindent
Поскольку очередь есть последовательность элементов, ее, разумеется,
можно было бы представить как обыкновенный список; головой очереди был
бы @code{car} этого списка, вставка элемента в очередь сводилась бы к
добавлению нового элемента в конец списка, а уничтожение элемента из
очереди состояло бы просто во взятии @code{cdr} списка. Однако такая
реализация неэффективна, поскольку для вставки элемента нам пришлось бы
просматривать весь список до конца. Поскольку единственный доступный нам
метод просмотра списка --- это последовательное применение @code{cdr},
такой просмотр требует @math{\Theta(n)} шагов для очереди с @code{n}
членами. Простое видоизменение спискового представления преодолевает
этот недостаток, позволяя нам реализовать операции с очередью так, чтобы
все они требовали @math{\Theta(1)} шагов; то есть, чтобы число шагов
алгоритма не зависело от длины очереди.

Сложность со списковым представлением возникает из-за необходимости
искать конец списка. Искать приходится потому, что, хотя стандартный
способ представления списка в виде цепочки пар дает нам указатель на
начало списка, легкодоступного указателя на конец он не дает.
Модификация, обходящая этот недостаток, состоит в том, чтобы
представлять очередь в виде списка, и держать еще дополнительный
указатель на его последнюю пару. В таком случае, когда требуется
вставить элемент, мы можем просто посмотреть на этот указатель и
избежать за счет этого просмотра всего списка.

Очередь, таким образом, представляется в виде пары указателей,
@code{front-ptr} и @code{rear-ptr}, которые обозначают, соответственно,
первую и последнюю пару обыкновенного списка. Поскольку нам хочется,
чтобы очередь была объектом с собственной индивидуальностью, соединить
эти два указателя можно с помощью @code{cons}, так что собственно
очередь будет результатом @code{cons} двух указателей. Такое
представление показано на рис. @ref{Рисунок 3.19}.

@float
@anchor{Рисунок 3.19}
@ifinfo
@quotation
@strong{Рисунок 3.19:} Implementation of a queue as a list with front and rear pointers.

@example
       +---+---+
  q -->| * | *-+-------------------+
       +-|-+---+                   |
         |                         |
         | front-ptr               | rear-ptr
         V                         V
     +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V
     +---+        +---+        +---+
     | a |        | b |        | c |
     +---+        +---+        +---+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.19b,69mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.19:} Implementation of a queue as a list with front and rear pointers.}
@sp 0.9
@end iftex
@end float

Во время определения операций над очередью мы пользуемся следующими
процедурами, которые позволяют нам читать и записывать указатели на
начало и конец очереди:

@lisp
(define (front-ptr queue) (car queue))
(define (rear-ptr  queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr!  queue item)
  (set-cdr! queue item))
@end lisp

@noindent
Теперь можно реализовать сами операции над очередью. Очередь будет
считаться пустой, если ее головной указатель указывает на пустой список:

@lisp
(define (empty-queue? queue)
  (null? (front-ptr queue)))
@end lisp

@noindent
Конструктор @code{make-queue} возвращает в качестве исходно пустой
очереди пару, в которой и @code{car}, и @code{cdr} являются пустыми
списками:

@lisp
(define (make-queue) (cons '() '()))
@end lisp

При обращении к элементу в голове очереди мы возвращаем @code{car} пары,
на которую указывает головной указатель:

@lisp
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
@end lisp

@float
@quotation
@anchor{Рисунок 3.20}
@ifinfo
@strong{Рисунок 3.20:} Result of using @code{(insert-queue! q 'd)} on the queue of @ref{Рисунок 3.19}.

@example
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         |                                      |
         | front-ptr                            | rear-ptr
         V                                      V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.20b,88mm,,,.pdf}
@sp 0.7
@caption{@strong{Рисунок 3.20:} Result of using @code{(insert-queue! q 'd)} on the queue of @ref{Рисунок 3.19}.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Чтобы вставить элемент в конец очереди, мы используем метод, результат
которого показан на рисунке @ref{Рисунок 3.20}. Первым делом мы
создаем новую пару, @code{car} которой содержит вставляемый элемент, а
@code{cdr} --- пустой список. Если очередь была пуста, мы перенаправляем
на эту пару и головной, и хвостовой указатели. В противном случае, мы
изменяем последнюю пару очереди так, чтобы следующей была новая пара, и
хвостовой указатель тоже перенаправляем на нее же.

@lisp
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
@end lisp

@float
@quotation
@anchor{Рисунок 3.21}
@ifinfo
@strong{Рисунок 3.21:} Result of using @code{(delete-queue!  q)} on the queue of @ref{Рисунок 3.20}.

@example
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         +------------+                         |
            front-ptr |                         | rear-ptr
                      V                         V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.21b,88mm,,,.pdf}
@sp 0.6
@caption{@strong{Рисунок 3.21:} Result of using @code{(delete-queue!  q)} on the queue of @ref{Рисунок 3.20}.}
@sp 0.8
@end iftex
@end quotation
@end float

@noindent
Чтобы уничтожить элемент в голове очереди, мы просто переставляем
головной указатель на второй элемент очереди, а его можно найти в
@code{cdr} первого элемента (см. @ref{Рисунок 3.21}):@footnote{В
случае, если первый элемент --- одновременно и последний, после его
уничтожения головной указатель окажется пустым списком, и это будет
означать, что очередь пуста; нам незачем заботиться о хвостовом
указателе, который по-прежнему будет указывать на уничтоженный элемент,
поскольку @code{empty-queue?} смотрит только на голову.}

@lisp
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else (set-front-ptr! queue (cdr (front-ptr queue)))
              queue)))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.21}Упражнение 3.21:}
Бен Битобор решает протестировать вышеописанную реализацию.
Он вводит процедуры в интерпретаторе Лиспа и тестирует их:

@lisp
(define q1 (make-queue))
(insert-queue! q1 'a)
@i{((a) a)}
(insert-queue! q1 'b)
@i{((a b) b)}
(delete-queue! q1)
@i{((b) b)}
(delete-queue! q1)
@i{(() b)}
@end lisp

<<Ничего не работает! --- жалуется он. --- Ответ интерпретатора
показывает, что последний элемент попадает в очередь два раза. А когда я
оба элемента уничтожаю, второе @code{b} по-прежнему там сидит, так что
очередь не становится пустой, хотя должна бы>>. Ева Лу Атор говорит, что
Бен просто не понимает, что происходит. <<Дело не в том, что элементы
два раза оказываются в очереди, --- объясняет она. --- Дело в том, что
стандартная лисповская печаталка не знает, как устроено представление
очереди. Если ты хочешь, чтобы очередь правильно печаталась, придется
написать специальную процедуру распечатки очередей>>. Объясните, что
имеет в виду Ева Лу. В частности, объясните, почему в примерах Бена на
печать выдается именно такой результат. Определите процедуру
@code{print-queue}, которая берет на входе очередь и выводит на печать
последовательность ее элементов.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.22}Упражнение 3.22:}
Вместо того, чтобы представлять очередь как пару
указателей, можно построить ее в виде процедуры с внутренним состоянием.
Это состояние будет включать указатели на начало и конец обыкновенного
списка. Таким образом, @code{make-queue} будет иметь вид

@lisp
(define (make-queue)
  (let ((front-ptr @dots{} )
        (rear-ptr @dots{} ))
    @math{\langle}@var{definitions of internal procedures}@math{\rangle}
    (define (dispatch m) @dots{})
    dispatch))
@end lisp

Закончите определение @code{make-queue} и реализуйте операции над
очередями с помощью этого представления.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.23}Упражнение 3.23:}
(@newterm{deque}), (double-ended queue, <<двусторонняя очередь>>)
представляет собой последовательность, элементы в которой могут
добавляться и уничтожаться как с головы, так и с хвоста. На деках
определены такие операции: конструктор @code{make-deque}, предикат
@code{empty-deque?}, селекторы @code{front-deque} и @code{rear-deque}, и
мутаторы @code{front-insert-deque!}, @code{rear-insert-deque!},
@code{front-delete-deque!} и @code{rear-delete-deque!}. Покажите, как
представить дек при помощи пар, и напишите реализацию
операций.@footnote{Осторожно, не заставьте ненароком интерпретатор
печатать циклическую структуру (см. упр. @ref{Упражнение 3.13}).}
Все операции должны выполняться за @math{\Theta(1)} шагов.
@end quotation

@comment @subsection Representing Tables
@subsection Представление таблиц
@node	3.3.3, 3.3.4, 3.3.2, 3.3

Когда в @ref{Глава 2} мы изучали различные способы представления множеств, то в
@ref{2.3.3} была упомянута задача поддержания таблицы с идентифицирующими ключами.
При реализации программирования, управляемого данными, в @ref{2.4.3},
активно использовались двумерные таблицы, в которых информация заносится
и ищется с использованием двух ключей. Теперь мы увидим, как такие
таблицы можно строить при помощи изменяемых списковых структур.

@float
@quotation
@anchor{Рисунок 3.22}
@ifinfo
@strong{Рисунок 3.22:} A table represented as a headed list.

@example
 +---+---+    +---+---+    +---+---+    +---+---+
 | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
 +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
   |            |            |            |
   V            V            V            V
+---------+   +---+---+   +---+---+   +---+---+
| *table* |   | * | * |   | * | * |   | * | * |
+---------+   +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                |   |       |   |       |   |
                V   V       V   V       V   V
             +---+ +---+ +---+ +---+ +---+ +---+
             | a | | 1 | | b | | 2 | | c | | 3 |
             +---+ +---+ +---+ +---+ +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.22c,81mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.22:} A table represented as a headed list.}
@sp 0.9
@end iftex
@end quotation
@end float

Сначала рассмотрим одномерную таблицу, где каждый элемент хранится под
отдельным ключом. Ее мы реализуем как список записей, каждая из которых
представляет собой пару, состоящую из ключа и связанного с ним значения.
Пары связаны вместе в список при помощи цепочки пар, в каждой из которых
@code{car} указывают на одну из записей. Эти связующие пары называются
(@newterm{backbone}) таблицы. Для того, чтобы у нас было место, которое мы будем
изменять при добавлении новой записи, таблицу мы строим как
(@newterm{headed list}). У такого списка есть в начале специальная хребтовая
пара, в которой хранится фиктивная <<запись>> --- в данном случае произвольно
выбранный символ @code{*table*}. На рисунке @ref{Рисунок 3.22}
изображена стрелочная диаграмма для таблицы

@lisp
a:  1
b:  2
c:  3
@end lisp

@noindent
Информацию из таблицы можно извлекать при помощи процедуры
@code{lookup}, которая получает ключ в качестве аргумента, а возвращает
связанное с ним значение (либо ложь, если в таблице с этим ключом
никакого значения не связано). @code{Lookup} определена при помощи
операции @code{assoc}, которая требует в виде аргументов ключ и список
записей. Обратите внимание, что @code{assoc} не видит фиктивной записи.
@code{Assoc} возвращает запись, которая содержит в @code{car} искомый
ключ.@footnote{Поскольку @code{assoc} пользуется @code{equal?}, в
качестве ключей она может распознавать символы, числа и списковые
структуры.} Затем @code{lookup} проверяет, что запись, возвращенная
@code{assoc}, не есть ложь, и возвращает значение (то есть @code{cdr})
записи.

@lisp
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
@end lisp

@noindent
Чтобы вставить в таблицу значение под данным ключом, сначала мы с
помощью @code{assoc} проверяем, нет ли уже в таблице записи с этим
ключом. Если нет, мы формируем новую запись, <<с@code{cons}ивая>> ключ
со значением, и вставляем ее в начало списка записей таблицы, после
фиктивной записи. Если же в таблице уже была запись с этим ключом, мы
переставляем @code{cdr} записи на указанное новое значение. Заголовок
таблицы используется как неподвижное место, которое мы можем изменять
при порождении новой записи.@footnote{Таким образом, первая хребтовая
пара является объектом, который представляет <<саму>> таблицу; то есть,
указатель на таблицу --- это указатель на эту пару. Таблица всегда
начинается с одной и той же хребтовой пары. Будь это устроено иначе,
пришлось бы возвращать из @code{insert!} новое начало таблицы в том
случае, когда создается новая запись.}

@lisp
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
@end lisp

@noindent
Для того, чтобы создать таблицу, мы просто порождаем список, содержащий
символ @code{*table*}:

@lisp
(define (make-table)
  (list '*table*))
@end lisp

@comment @subsubheading Two-dimensional tables
@subsubheading Двумерные таблицы

@noindent
В двумерной таблице каждое значение индексируется двумя ключами. Такую
таблицу мы можем построить как одномерную таблицу, в которой каждый ключ
определяет подтаблицу. На рисунке @ref{Рисунок 3.23} изображена
стрелочная диаграмма для таблицы

@example
math:    +:  43        letters:    a:  97
         -:  45                    b:  98
         *:  42
@end example

@noindent
содержащей две подтаблицы (подтаблицам не требуется специального
заголовочного символа, поскольку для этой цели служит ключ,
идентифицирующий подтаблицу).

Когда мы ищем в таблице элемент, сначала при помощи первого ключа мы
находим нужную подтаблицу. Затем при помощи второго ключа мы определяем
запись внутри подтаблицы.

@lisp
(define (lookup key-1 key-2 table)
  (let ((subtable
         (assoc key-1 (cdr table))))
    (if subtable
        (let ((record
               (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
@end lisp

@float
@c @quotation
@anchor{Рисунок 3.23}
@ifinfo
@strong{Рисунок 3.23:} A two-dimensional table.

@example
table
  |
  V
+---+---+   +---+---+   +---+---+
| * | *-+-->| * | *-+-->| * | / |
+-|-+---+   +-|-+---+   +-|-+---+
  V           |           V
+-------+     |         +---+---+   +---+---+   +---+---+
|*table*|     |         | * | *-+-->| * | *-+-->| * | / |
+-------+     |         +-|-+---+   +-|-+---+   +-|-+---+
              |           V           V           V
              |       +-------+     +---+---+   +---+---+
              |       |letters|     | * | * |   | * | * |
              |       +-------+     +-|-+-|-+   +-|-+-|-+
              |                       V   V       V   V
              |                    +---+ +---+ +---+ +---+
              |                    | a | | 97| | b | | 98|
              |                    +---+ +---+ +---+ +---+
              V
            +---+---+   +---+---+   +---+---+   +---+---+
            | * | *-+-->| * | *-+-->| * | *-+-->| * | / |
            +-|-+---+   +-|-+---+   +-|-+---+   +-|-+---+
              V           V           V           V
          +------+      +---+---+   +---+---+   +---+---+
          | math |      | * | * |   | * | * |   | * | * |
          +------+      +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                          V   V       V   V       V   V
                       +---+ +---+ +---+ +---+ +---+ +---+
                       | + | | 43| | - | | 45| | * | | 42|
                       +---+ +---+ +---+ +---+ +---+ +---+
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.23a,103mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.23:} A two-dimensional table.}
@sp 0.9
@end iftex
@c @end quotation
@end float

Чтобы вставить в таблицу новый элемент под двумя ключами, мы при помощи
@code{assoc} проверяем, соответствует ли какая-нибудь подтаблица первому
ключу. Если нет, строим новую подтаблицу, содержащую единственную запись
(@code{key-2}, @code{value}), и заносим ее в таблицу под первым ключом.
Если для первого ключа уже существует подтаблица, мы вставляем новую
запись в эту подтаблицу, используя вышеописанный метод вставки для
одномерных таблиц:

@lisp
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
@end lisp

@comment @subsubheading Creating local tables
@subsubheading Создание локальных таблиц

Операции @code{lookup} и @code{insert!}, которые мы определили,
принимают таблицу в качестве аргумента. Это позволяет писать программы,
которые обращаются более, чем к одной таблице. Другой способ работы с
множественными таблицами заключается в том, чтобы иметь для каждой из
них свои отдельные процедуры @code{lookup} и @code{insert!}. Мы можем
этого добиться, представив таблицу в процедурном виде, как объект,
который поддерживает внутреннюю таблицу как часть своего локального
состояния. Когда ему посылают соответствующее сообщение, этот
<<табличный объект>> выдает процедуру, с помощью которой можно работать
с его внутренним состоянием. Вот генератор двумерных таблиц,
представленных таким способом:

@lisp
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))
@end lisp

@noindent
Использование @code{make-table} позволяет нам реализовать операции @code{get}
и @code{put} из @ref{2.4.3}, так:

@lisp
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
@end lisp

@noindent
@code{get} в качестве аргументов берет два ключа, а @code{put} два ключа
и значение. Обе операции обращаются к одной и той же локальной таблице,
которая инкапсулируется в объекте, созданном посредством вызова
@code{make-table}.

@quotation
@strong{@anchor{Упражнение 3.24}Упражнение 3.24:}
В реализациях таблиц в этом разделе ключи всегда
проверяются на равенство с помощью @code{equal?} (который, в свою
очередь, зовется из @code{assoc}). Это не всегда то, что нужно.
Например, можно представить себе таблицу с числовыми ключами, где не
требуется точного совпадения с числом, которое мы ищем, а нужно только
совпадение с определенной допустимой ошибкой. Постройте конструктор
таблиц @code{make-table}, который в качестве аргумента принимает
процедуру @code{same-key?} для проверки равенства ключей.
@code{make-table} должна возвращать процедуру @code{dispatch}. через
которую можно добраться до процедур @code{lookup} и @code{insert!}
локальной таблицы.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.25}Упражнение 3.25:}
Обобщая случаи одно- и двумерных таблиц, покажите, как
можно реализовать таблицу, в которой элементы хранятся с произвольным
количеством ключей и различные значения могут храниться с различным
количеством ключей. Процедуры @code{lookup} и @code{insert!} должны
принимать на входе список ключей, с которыми требуется обратиться к
таблице.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.26}Упражнение 3.26:}
При поиске в таблице, как она реализована выше, приходится
просматривать список записей. В сущности, это представление с
неупорядоченным списком из @ref{2.3.3}.
Для больших таблиц может оказаться эффективнее организовать таблицу
иначе. Опишите реализацию таблицы, в которой записи (ключ, значение)
организованы в виде бинарного дерева, в предположении, что ключи можно
каким-то образом упорядочить (например, численно или по алфавиту). (Ср.
с упражнением @ref{Упражнение 2.66} из @ref{Глава 2}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.27}Упражнение 3.27:}
(@newterm{memoization}) (называемая также (@newterm{tabulation)}) --- прием,
который позволяет процедуре записывать в локальной таблице единожды
вычисленные значения. Такой прием может сильно повысить
производительность программы. Мемоизированная процедура поддерживает
таблицу, где сохраняются результаты предыдущих вызовов, а в качестве
ключей используются аргументы, относительно которых эти результаты были
получены. Когда от мемоизированной процедуры требуют вычислить значение,
сначала она проверят в таблице, нет ли там уже нужного значения, и если
да, то она просто возвращает это значение. Если нет, то она вычисляет
значение обычным способом и заносит его в таблицу. В качестве примера
мемоизации, вспомним экспоненциальный процесс вычисления чисел Фибоначчи
из @ref{1.2.2}:

@lisp
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
@end lisp

Мемоизированная версия той же самой процедуры выглядит так:

@lisp
(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))
@end lisp

@noindent
а процедура @code{memoize} определяется так:

@lisp
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
@end lisp

Нарисуйте диаграмму окружений, анализирующую вычисление
@code{(memo-fib 3)}. Объясните, почему @code{memo-fib} вычисляет
@math{n}-е число Фибоначчи за число шагов, пропорциональное @math{n}.
Стала бы схема работать, если бы мы определили @code{memo-fib} просто
как @code{(memoize fib)}?
@end quotation

@comment @subsection A Simulator for Digital Circuits
@subsection Имитация цифровых схем
@node	3.3.4, 3.3.5, 3.3.3, 3.3

Проектирование сложных цифровых систем, таких, как компьютеры, является
важной отраслью инженерной деятельности. Цифровые системы строятся путем
соединения простых элементов. Хотя поведение этих составляющих элементов
примитивно, сети, из них собранные, могут обладать весьма сложным
поведением. Компьютерная имитация проектируемых электронных схем служит
важным инструментом для инженеров-специалистов по цифровым системам. В
этом разделе мы спроектируем систему для имитационного моделирования
цифровых схем. Система эта будет служить примером программ особого вида,
называемых (@newterm{event-driven simulation}), в которых действия (<<события>>)
вызывают другие события, которые происходят спустя некоторое время и при
этом в свою очередь вызывают события, и так далее.

Наша вычислительная модель цифровой схемы будет состоять из объектов,
соответствующих элементарным компонентам, из которых строится схема.
Имеются (@newterm{wires}), несущие (@newterm{digital signals}). В каждый данный момент
цифровой сигнал может иметь только одно из двух возможных значений, 0
или 1. Кроме того, имеются различные виды (@newterm{function boxes}), которые
соединяют провода, несущие входные сигналы, с выходными проводами. Такие
элементы порождают выходные сигналы, вычисляя их на основе входных
сигналов. Выходной сигнал задерживается на время, зависящее от типа
функционального элемента. Например, (@newterm{inverter}) --- элементарный
функциональный элемент, который обращает свой входной сигнал. Если
входной сигнал инвертора становится 0, то на одну инверторную задержку
позже сигнал на выходе станет равен 1. Если входной сигнал станет 1, то
на инверторную задержку позже на выходе появится 0. Инвертор
символически изображен на @ref{Рисунок 3.24}. (@newterm{and-gate}), также
показанный на @ref{Рисунок 3.24}, имеет два входа и один выход.
Он обеспечивает на выходе сигнал, равный (@newterm{logical and}) от входов. Это
означает, что если оба входных сигнала становятся равными 1, то одну
И-задержку спустя И-элемент заставит свой выходной сигнал стать 1; в
противном случае на выходе будет 0.
(or-gate) представляет собой подобный же элементарный функциональный
элемент, который обеспечивает на выходе сигнал, равный (logical or)
своих входов. А именно, выходной сигнал станет равен 1, если хотя бы
один из входных сигналов окажется 1; в противном случае на выходе будет
0.

@float
@quotation
@anchor{Рисунок 3.24}
@ifinfo
@strong{Рисунок 3.24:} Primitive functions in the digital logic simulator.

@example
               __          ___
  |\        --|  \       --\  \
--| >o--      |   )--       )  >--
  |/        --|__/       --/__/

инвертор   И-элемент    ИЛИ-элемент
@end example
@end ifinfo
@iftex
@sp 0.4
@center @image{fig/chap3/Fig3.24b,74mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 3.24:} Primitive functions in the digital logic simulator. }@short
@sp 0.7
@end iftex
@end quotation
@end float

Соединяя элементарные функции, можно получать более сложные. Для этого
надо подсоединять выходы одних функциональных элементов ко входам
других. Например, схема (@newterm{half-adder}) на рис. @ref{Рисунок 3.25}
состоит из ИЛИ-элемента, двух И-элементов и инвертора. Полусумматор
получает два входа, A и B, и имеет два выхода, S и C. S становится 1,
когда ровно один из сигналов A и B равен 1, а C тогда, когда и A, и B
равны 1. Из схемы можно видеть, что по причине задержек выходные сигналы
могут генерироваться в разное время. Отсюда происходят многие сложности
в проектировании цифровых схем.

@float
@quotation
@anchor{Рисунок 3.25}
@ifinfo
@strong{Рисунок 3.25:} A half-adder circuit.

@example
    +--------------------------------------+
    |         ____                         |
A --------*---\   \ D               ___    |
    |     |    >   >---------------|   \   |
    |  +--|---/___/                |    )----- S
    |  |  |              |\  E  +--|___/   |
    |  |  |           +--| >o---+          |
    |  |  |    ___    |  |/                |
    |  |  +---|   \   |                    |
    |  |      |    )--*----------------------- C
B -----*------|___/                        |
    |                                      |
    +--------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.7
@center @image{fig/chap3/Fig3.25c,72mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.25:} A half-adder circuit.}
@sp 1.2
@end iftex
@end quotation
@end float

Теперь мы построим программу для имитации цифровых логических схем,
которые мы хотим изучать. Программа будет строить вычислительные
объекты, моделирующие провода, которые <<содержат>> сигналы.
Функциональные элементы будут моделироваться процедурами, которые
обеспечивают нужное отношение между сигналами.

Одним из базовых элементов нашей имитации будет процедура
@code{make-wire}, которая порождает провода. Например, мы можем создать
шесть проводов так:

@lisp
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
@end lisp

@noindent
Мы подсоединяем функциональный элемент к проводу во время вызова
процедуры, которая создает данный вид элемента. Аргументами порождающей
процедуры служат провода, подсоединяемые к элементу. Например, если мы
умеем создавать И-элементы, ИЛИ-элементы и инверторы, мы можем собрать
полусумматор, изображенный на рисунке @ref{Рисунок 3.25}:

@lisp
(or-gate a b d)
@i{ok}
(and-gate a b c)
@i{ok}
(inverter c e)
@i{ok}
(and-gate d e s)
@i{ok}
@end lisp

@noindent
Даже лучше того, можно присвоить этой операции имя, определив процедуру
@code{half-adder}, конструирующую схему, используя четыре внешних
провода, которые нужно подсоединить к полусумматору:

@lisp
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
@end lisp

@noindent
Преимущество этого определения в том, что теперь мы можем использовать
@code{half-adder} как строительный блок при создании более сложных схем.
Например, на рисунке @ref{Рисунок 3.26} изображен (@newterm{full-adder}),
состоящий из двух полусумматоров и ИЛИ-элемента.@footnote{Сумматор ---
основной элемент схем, используемых для сложения двоичных чисел. Здесь A
и B --- биты на соответствующих позициях двух складываемых чисел, а
@math{\rm C_{in}} --- бит переноса из позиции на одну правее. Схема
генерирует SUM, бит суммы для соответствующей позиции, и
@math{\rm C_{out}}, бит переноса для распространения налево.}
Сумматор можно сконструировать так:

@lisp
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
@end lisp

@float
@quotation
@anchor{Рисунок 3.26}
@ifinfo
@strong{Рисунок 3.26:} A full-adder circuit.

@example
    +----------------------------------+
    |              +-------+           |
A -----------------+ half- +-------------- SUM
    |  +-------+   | adder |   ____    |
B -----+ half- +---+       +---\   \   |
    |  | adder |   +-------+    >or >----- Cout
C -----+       +---------------/___/   |
    |  +-------+                       |
    +----------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.26a,74mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.26:} A full-adder circuit.}
@sp 1.2
@end iftex
@end quotation
@end float

@noindent
Определив @code{full-adder} как процедуру, мы можем ее использовать как
строительный блок для еще более сложных схем. (См., например,
упражнение @ref{Упражнение 3.30}.)

В сущности, наша имитация дает инструмент, с помощью которого строится
язык описания схем. Принимая общую точку зрения на языки, с которой мы
приступили к изучению Лиспа в @ref{1.1},
можно сказать, что элементарные функциональные элементы являются
примитивами языка, связывание их проводами представляет собой средство
комбинирования, а определение шаблонных схем в виде процедур служит
средством абстракции.

@comment @subsubheading Primitive function boxes
@subsubheading Элементарные функциональные элементы.

Элементарные функциональные элементы изображают <<силы>>, через
посредство которых изменение сигнала в одном проводе влечет изменение
сигнала в других проводах. Для построения функциональных элементов мы
будем пользоваться следующими операциями над проводами:

@itemize @bullet

@item @code{(get-signal @math{\langle}@var{провод}@math{\rangle})} возвращает текущее значение
сигнала в проводе.

@item @code{(set-signal!}@math{\;\;\langle\kern0.08em\hbox{\ttfamily\slshape провод}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape новое-значение}\kern0.08em\rangle}@code{)}
@noindentyy
заменяет значение сигнала в проводе на указанное.

@item @code{(add-action! @math{\langle}@var{провод}@math{\rangle} @math{\langle}@var{процедура без аргументов}@math{\rangle})}
@noindent
указывает, чтобы процедура-аргумент вызывалась каждый раз, когда
сигнальный провод изменяет значение. Такие процедуры служат передаточным
механизмом, с помощью которого изменение значения сигнала в одном
проводе передается другим проводам.

@end itemize

@noindent
В дополнение, мы будем пользоваться процедурой @code{after-delay}, которая
принимает значение задержки и процедуру. Она выполняет процедуру после истечения задержки.

При помощи этих процедур можно определить элементарные функции цифровой
логики. Чтобы соединить вход с выходом через инвертор, мы используем
@code{add-action!} и ассоциируем со входным проводом процедуру, которая
будет вызываться всякий раз, когда сигнал на входе элемента изменит
значение. Процедура вычисляет @code{logical-not} (логическое отрицание)
входного сигнала, а затем, переждав @code{inverter-delay}, устанавливает
выходной сигнал в новое значение:

@lisp
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input) 'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
@end lisp

@noindent
И-элемент устроен немного сложнее. Процедура-действие должна вызываться,
когда меняется любое из значений на входе. Она при этом через процедуру,
подобную @code{logical-not}, вычисляет @code{logical-and} (логическое И)
значений сигналов на входных проводах, и затем требует, чтобы изменение
значения выходного провода произошло спустя задержку длиной в
@code{and-gate-delay}.

@lisp
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay
       and-gate-delay
       (lambda () (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
@end lisp

@quotation
@strong{@anchor{Упражнение 3.28}Упражнение 3.28:}
Определите ИЛИ-элемент как элементарный функциональный
блок. Ваш конструктор @code{or-gate} должен быть подобен
@code{and-gate}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.29}Упражнение 3.29:}
Еще один способ создать ИЛИ-элемент --- это собрать его как
составной блок из И-элементов и инверторов. Определите процедуру
@code{or-gate}, которая это осуществляет. Как время задержки
ИЛИ-элемента выражается через @code{and-gate-delay} и
@code{inverter-delay}?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.30}Упражнение 3.30:}
На рисунке @ref{Упражнение 3.27} изображен (ripple-carry
adder), полученный выстраиванием в ряд @math{n} сумматоров. Это
простейшая форма параллельного сумматора для сложения двух
@math{n}-битных двоичных чисел. На входе мы имеем 
@math{A_1}, @math{A_2}, @math{A_3}, @dots{}, @math{A_n} и
@math{B_1}, @math{B_2}, @math{B_3}, @dots{}, @math{B_n} --- два двоичных
числа, подлежащих сложению (каждый из @math{A_k} и @math{B_n} имеет значение
либо 0, либо 1). Схема порождает
@math{S_1}, @math{S_2}, @math{S_3}, @dots{}, @math{S_n} --- первые @math{n} бит суммы, и @math{C} -- бит
переноса после суммы. Напишите процедуру @code{riple-carry-adder},
которая бы моделировала эту схему. Процедура должна в качестве
аргументов принимать три списка по @math{n} проводов в каждом
(@math{A_k}, @math{B_k} и @math{S_k}), а также дополнительный провод @math{C}.
Главный недостаток каскадных сумматоров в том, что приходится ждать, пока
сигнал распространится. Какова задержка, требуемая для получения полного
вывода @math{n}-битного каскадного сумматора, выраженная в зависимости от
задержек И-, ИЛИ-элементов и инверторов?
@end quotation

@float
@quotation
@anchor{Рисунок 3.27}
@ifinfo
@strong{Рисунок 3.27:} A ripple-carry adder for @math{n}-bit numbers.

@example
   :                                              :   :
   : A_1 B_1   C_1   A_2 B_2   C_2   A_3 B_3   C_3:   : A_n B_n C_n=0
   :  |   |   +---+   |   |   +---+   |   |   +-----  :  |   |   +-
   |  |   |   |   |   |   |   |   |   |   |   |   :   :  |   |   |
   : ++---+---++  |  ++---+---++  |  ++---+---++  :   : ++---+---++
   : |   FA    |  |  |   FA    |  |  |   FA    |  :   : |   FA    |
   : +--+---+--+  |  +--+---+--+  |  +--+---+--+  :   : +--+---+--+
   :    |   |     |     |   |     |     |   |     :   :    |   |
C ------+   |     +-----+   |     +-----+   |     :  ------+   |
   :        |       C_1     |       C_2     |     :   :C_(n-1) |
   :        |               |               |     :   :        |
           S_1             S_2             S_3                S_n
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.27a,96mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 3.27:} A ripple-carry adder for @math{n}-bit numbers.}
@sp 0.3
@end iftex
@end quotation
@end float

@comment @subsubheading Representing wires
@subsubheading Представление проводов

Провод в нашей имитации будет вычислительным объектом с двумя
внутренними переменными состояния: значение сигнала @code{signal-value}
(вначале равное 0) и набор процедур-действий @code{action-procedures},
подлежащих исполнению, когда сигнал изменяется. Мы реализуем провод в
стиле с передачей сообщений, как набор локальных процедур плюс процедура
диспетчеризации, которая выбирает требуемую внутреннюю операцию. Точно
так же мы строили объект-банковский счет в @ref{3.1.1}.

@lisp
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation: WIRE" m))))
    dispatch))
@end lisp

@noindent
Внутренняя процедура @code{set-my-signal!} проверяет, отличается ли
новое значение сигнала в проводе от старого. Если да, то она запускает
все процедуры-действия при помощи процедуры @code{call-each}, которая по
очереди вызывает элементы списка безаргументных процедур:

@lisp
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))
@end lisp

@noindent
Внутренняя процедура @code{accept-action-procedure!} добавляет
процедуру-аргумент к списку действий, а затем один раз запускает новую
процедуру. (См. упражнение @ref{Упражнение 3.31}.)

Располагая вышеописанной процедурой @code{dispatch}, мы можем написать
следующие процедуры для доступа к внутренним операциям над
проводами:@footnote{@anchor{Сноска 27} Эти процедуры --- всего лишь
синтаксический сахар, который позволяет нам работать с внутренними
процедурами объектов, используя обычный синтаксис процедурного вызова.
Поразительно, что мы так просто можем менять местами роли процедур и
данных. Например, когда мы пишем @code{(wire 'get-signal)}, мы
представляем себе провод @code{wire} как процедуру, вызываемую с
сообщением @code{get-signal} на входе. С другой стороны, запись
@code{(get-signal wire)} поощряет нас думать о @code{wire} как об
объекте данных, который поступает на вход процедуре @code{get-signal}.
Истина состоит в том, что в языке, где с процедурами можно работать как
с объектами, никакого фундаментального различия между <<процедурами>> и
<<данными>> не существует, и мы имеем право выбирать такой
синтаксический сахар, который позволит программировать в удобном для нас
стиле.}

@lisp
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
@end lisp

@noindent
Провода, которые содержат меняющиеся со временем сигналы и могут
подсоединяться к одному объекту за другим, --- типичный образец
изменяющихся объектов. Мы смоделировали их в виде процедур с внутренними
переменными состояния, которые изменяются присваиванием. При создании
нового провода создается новый набор переменных состояния (в выражении
@code{let} внутри @code{make-wire}), а также порождается и возвращается
новая процедура @code{dispatch}, которая захватывает окружение с новыми
переменными состояния.

Провода разделяются между различными устройствами, к ним
подсоединенными. Таким образом, изменение, произведенное при
взаимодействии с одним устройством, скажется на всех других устройствах,
связанных с этим проводом. Провод передает изменение своим соседям,
вызывая процедуры-действия, зарегистрированные в нем в момент
установления соединения.

@comment @subsubheading The agenda
@subsubheading План действий

Теперь для завершения модели нам остается только написать
@code{after-delay}. Здесь идея состоит в том, чтобы организовать
структуру данных под названием (@newterm{agenda}), где будет храниться
расписание того, что нам надо сделать. Для планов действий определены следующие
операции:

@itemize @bullet

@item
@code{(make-agenda)} возвращает новый пустой план действий.

@item
@code{(empty-agenda? @math{\langle}@var{план-действий}@math{\rangle})} истинно, если план
пуст.

@item
@code{(first-agenda-item @math{\langle}@var{план-действий}@math{\rangle})} возвращает первый
элемент плана.

@code{(remove-first-agenda-item! @math{\langle}@var{план-действий}@math{\rangle})}
модифицирует план, убирая из него первый элемент.

@item
@code{(add-to-agenda! @math{\langle}@var{время}@math{\rangle} @math{\langle}@var{действие}@math{\rangle} @math{\langle}@var{план-действий}@math{\rangle})}
модифицирует план, добавляя указанную процедуру-действие, которую нужно
запустить в указанное время.

@item
@code{(current-time @math{\langle}@var{план-действий}@math{\rangle})}
возвращает текущее время модели.

@end itemize

@noindent
Экземпляр плана, которым мы будем пользоваться, будет обозначаться
@code{the-agenda}. Процедура @code{after-delay} добавляет новый элемент
в план @code{the-agenda}:

@lisp
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
@end lisp

@noindent
Имитация управляется процедурой @code{propagate}, которая работает с
@code{the-agenda}, по очереди выполняя процедуры, содержащиеся в плане.
В общем случае, при работе модели в план добавляются новые элементы, а
@code{propagate} продолжает работу, пока план не становится пустым:

@lisp
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
@end lisp

@comment @subsubheading A sample simulation
@subsubheading Пример работы модели

Следующая процедура, которая навешивает на провод <<тестер>>, показывает
имитационную модель в действии. Тестер говорит проводу, что, каждый раз,
когда сигнал изменяет значение, нужно напечатать новое значение сигнала,
а также текущее время и имя провода:

@lisp
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name) (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
@end lisp

@noindent
Сначала мы инициализируем план действий и указываем задержки для
элементарных функциональных элементов:

@lisp
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
@end lisp

@noindent
Затем мы создаем четыре провода и к двум из них подсоединяем тестеры:

@lisp
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
@i{sum 0  New-value = 0}

(probe 'carry carry)
@i{carry 0  New-value = 0}
@end lisp

@noindent
Затем мы связываем провода, образуя схему полусумматора (как на рис.
@ref{Рисунок 3.25}), устанавливаем сигнал на входе @code{input-1} в 1,
и запускаем модель:

@lisp
(half-adder input-1 input-2 sum carry)
@i{ok}
@end lisp

@lisp
(set-signal! input-1 1)
@i{done}
@end lisp

@lisp
(propagate)
@i{sum 8  New-value = 1}
@i{done}
@end lisp

@noindent
Сигнал @code{sum} становится 1 в момент времени 8. Мы находимся в 8
единицах от начала работы модели. В этот момент мы можем установить
сигнал на входе @code{input-2} в 1 и дать изменению распространиться:

@lisp
(set-signal! input-2 1)
@i{done}
@end lisp

@lisp
(propagate)
@i{carry 11  New-value = 1}
@i{sum 16  New-value = 0}
@i{done}
@end lisp

@noindent
Сигнал @code{carry} становится равным 1 в момент 11, а @code{sum}
становится 0 в момент 16.

@quotation
@strong{@anchor{Упражнение 3.31}Упражнение 3.31:}
Внутренняя процедура @code{accept-action-procedure!},
определенная в @code{make-wire}, требует, чтобы в момент, когда
процедура-действие добавляется к проводу, она немедленно исполнялась.
Объясните, зачем требуется такая инициализация. В частности, проследите
работу процедуры @code{half-adder} из этого текста и скажите, как
отличалась бы реакция системы, если бы @code{accept-action-procedure!}
была определена как

@lisp
(define (accept-action-procedure! proc)
  (set! action-procedures
        (cons proc action-procedures)))
@end lisp
@end quotation

@comment @subsubheading Implementing the agenda
@subsubheading Реализация плана действий

Наконец, мы описываем детали структуры данных плана действий, которая
хранит процедуры, предназначенные для исполнения в будущем.

План состоит из (@newterm{time segments}). Каждый временной отрезок является
парой, состоящей из числа (значения времени) и очереди
(см. @ref{Упражнение 3.32}), которая содержит процедуры,
предназначенные к исполнению в этот временной отрезок.

@lisp
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
@end lisp

@noindent
Мы будем работать с очередями временных отрезков при помощи операций,
описанных в @ref{3.3.2}.

Сам по себе план действий является одномерной таблицей временных
отрезков. От таблиц, описанных в @ref{3.3.3}, он отличается тем, что
сегменты отсортированы в порядке возрастания времени. В дополнение к
этому мы храним (@newterm{current time}) (т. е. время последнего исполненного
действия) в голове плана. Свежесозданный план не содержит временных
отрезков, а его текущее время равно 0:@footnote{Подобно таблицам из
@ref{3.3.3}, план действий --- это список
с заголовком, но, поскольку в заголовке хранится время, не нужно
дополнительного заголовка-пустышки (вроде символа @code{table*}, которым
мы пользовались в таблицах).}

@lisp
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
@end lisp

@noindent
План пуст, если в нем нет ни одного временного отрезка:

@lisp
(define (empty-agenda? agenda)
  (null? (segments agenda)))
@end lisp

@noindent
Для того, чтобы добавить в план новое действие, прежде всего мы
проверяем, не пуст ли он. Если пуст, мы создаем для действия новый
отрезок и вставляем его в план. Иначе мы просматриваем план, глядя на
времена отрезков. Если мы находим отрезок с назначенным временем, мы
добавляем действие к соответствующей очереди. Если же мы обнаруживаем
время, большее, чем назначенное, мы вставляем новый отрезок перед
текущим. Если мы доходим до конца плана, мы вставляем новый отрезок в
конец.

@lisp
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
@end lisp

@noindent
Процедура, которая убирает из плана первый элемент, уничтожает элемент в
начале очереди первого отрезка времени. Если в результате отрезок
становится пустым, мы изымаем его из списка отрезков:@footnote{Обратите
внимание, что в этой процедуре выражение @code{if} не имеет
@math{\langle}@var{альтернативы}@math{\kern0.08em\rangle}. Такие <<односторонние
предложения @code{if}>> используются, когда требуется решить, нужно ли
какое-то действие, а не выбрать одно из двух выражений. Если предикат
ложен, а @math{\langle}@var{альтернатива}@math{\kern0.08em\rangle} отсутствует,
значение предложения @code{if} не определено.}

@lisp
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
@end lisp

@noindent
Первый элемент плана находится в начале очереди в первом временном
отрезке. Каждый раз, когда мы обращаемся к такому элементу, мы обновляем
текущее время.@footnote{Таким образом, текущее время всегда будет
совпадать с временем последнего обработанного действия. Благодаря тому,
что это время хранится в голове плана, оно всегда доступно, даже если
соответствующий отрезок времени был уничтожен.}

@lisp
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty: FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda
                           (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.32}Упражнение 3.32:}
Процедуры, предназначенные к выполнению в каждом временном
отрезке, хранятся в виде очереди. Таким образом, процедуры для каждого
отрезка вызываются в том же порядке, в котором они были добавлены к
плану (первый пришел, первый ушел). Объясните, почему требуется
использовать именно такой порядок. В частности, проследите поведение
И-элемента, входы которого меняются с 0 на 1 и с 1 на 0 одновременно и
скажите, как отличалось бы поведение, если бы мы хранили процедуры
отрезка в обыкновенном списке, добавляя и убирая их только с головы
(последний пришел, первый ушел).
@end quotation

@comment @subsection Propagation of Constraints
@subsection Распространение ограничений
@node	3.3.5,  , 3.3.4, 3.3

Традиционно компьютерные программы организованы как однонаправленные
вычисления, выполняющие вычисления над указанными аргументами и
получающие указанные значения. С другой стороны, часто системы
приходится моделировать в виде отношений между величинами. Например,
математическая модель механической структуры может включать информацию,
что деформация @math{d} металлического стержня связана уравнением
@math{dAE = FL} с приложенной к нему силой @math{F}, его длиной
@math{L}, поперечным сечением @math{A} и модулем упругости @math{E}.
Такое уравнение не является однонаправленным. Имея любые четыре
величины, мы можем вычислить пятую. Однако при переводе уравнения на
традиционный компьютерный язык нам придется выбрать величину, которая
вычисляется на основе остальных четырех, так что процедура для
вычисления площади @math{A} не может быть использована для вычисления
деформации @math{d}, хотя вычисление @math{A} и @math{d} основаны на
одном и том же уравнении.@footnote{Распространение ограничений появилось
в системе SKETCHPAD Айвена Сазерленда (Sutherland 1963), невероятно
опередившей свое время. Изящная система распространения ограничений,
основанная на языке Smalltalk, была разработана Аланом Борнингом
(Borning 1977) в исследовательском центре компании Xerox в Пало Альто.
Сассман, Столлман и Стил применили распространение ограничений к анализу
электрических цепей (Sussman and Stallman 1975; Sussman and Steele
1980). TK!Solver (Konopasek and Jayaraman 1984) представляет собой
богатую среду моделирования, основанную на ограничениях.}

В этом разделе мы набросаем эскиз языка, который позволит нам работать в
терминах самих отношений. Минимальными составляющими этого языка будут
служить (@newterm{primitive constraints}), которые говорят, что между величинами
существуют определенные связи. Например, @code{(adder a b c)} означает,
что величины @math{a}, @math{b} и @math{c} должны быть связаны
уравнением @math{a + b = c}, @code{(multiplier x y z)} выражает
ограничение @math{xy =
z}, а @code{(constant 3.14 x)} говорит, что значение @math{x} обязано
равняться 3.14.

Наш язык предоставляет средства комбинирования элементарных ограничений,
чтобы с их помощью выражать более сложные отношения. Сочетания образуют
(@newterm{constraint networks}), в которых ограничения связаны (@newterm{connectors}).
Соединитель --- это объект, который <<содержит>> значение, способное
участвовать в одном или нескольких ограничениях. К примеру, мы знаем,
что связь между температурами по Цельсию и по Фаренгейту выглядит как
@math{9 C = 5 (F - 32)} Такое ограничение можно изобразить в виде сети,
состоящей из элементарных ограничений --- сумматора, умножителей и
констант (рисунок @ref{Рисунок 3.28}). На этом рисунке слева мы видим
блок умножителя с тремя выводами, обозначенными @math{m1}, @math{m2} и
@math{p}. Вывод @math{m1} присоединен к соединителю @math{C}, который
будет хранить температуру по Цельсию. Вывод @math{m2} присоединен к
соединителю @math{w}, который, кроме того, связан с блоком-константой,
содержащим 9. Вывод @math{p}, про который блок-умножитель говорит, что
он должен быть произведением @math{m1} и @math{m2}, связан с выводом
@math{p} другого блока-умножителя, чей вывод @math{m2} связан с
константой 5, а @math{m1} присоединен к одному из слагаемых суммы.

@float
@anchor{Рисунок 3.28}
@ifinfo
@quotation
@strong{Рисунок 3.28:} The relation @math{9C = 5(F - 32)} expressed as a constraint network.

@example
       +---------+     +---------+   v   +---------+
C -----+ m1      |  u  |      m1 +-------+ a1      |
       |    *  p +-----+ p  *    |       |    *  s +---- F
    +--+ m2      |     |      m2 +--+ +--+ a2      |
    |  +---------+     +---------+  | |  +---------+
  w |                              x| |y
    |    +-----+        +-----+     | |     +-----+
    +----+  9  |        |  5  +-----+ +-----+  32 |
         +-----+        +-----+             +-----+
@end example
@end quotation
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.28,87mm,,,.pdf}
@sp 0.4
@center @caption{@strong{Рисунок 3.28:} The relation @math{9C = 5(F - 32)} expressed as a constraint network.}
@sp 0.7
@end iftex
@end float

Вычисления в такой сети происходят следующим образом: когда соединителю
дается значение (пользователем либо блоком-ограничением, с которым он
связан), соединитель пробуждает все связанные с ним ограничения (кроме
того, которое само его пробудило), и сообщает им, что у него появилось
значение. Каждый пробужденный блок-ограничение опрашивает свои выводы,
чтобы определить, достаточно ли у него информации, чтобы найти значение
для какого-нибудь еще соединителя. Если да, блок присваивает соединителю
значение, и тогда уже он пробуждает связанные с ним ограничения, и так
далее. Например, при преобразовании между градусами Цельсия и
Фаренгейта, значения @math{w}, @math{x} и @math{y} сразу устанавливаются
блоками-константами соответственно в 9, 5 и 32. Соединители пробуждают
умножители и сумматор, которые убеждаются, что у них не хватает
информации, чтобы продолжить. Если пользователь (или какая-то другая
часть сети) установит значение @math{C} в 25, пробудится левый
умножитель, и сделает @math{u} равным @math{25 \cdot 9 = 225}. Затем
@math{u} разбудит второй умножитель, который присвоит @math{v} значение
45, а @math{v} разбудит сумматор, и тот сделает значение @math{F} равным
77.

@comment @subsubheading Using the constraint system
@subsubheading Использование системы ограничений

Чтобы при помощи системы ограничений провести вышеописанное вычисление,
сначала мы порождаем два соединителя, @code{C} и @code{F}, вызовами
конструктора @code{make-connector}, и связываем @code{C} и @code{F} в
требуемую нам сеть:

@lisp
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
@i{ok}
@end lisp

@noindent
Процедура, создающая сеть, определяется так:

@lisp
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
@end lisp

@noindent
Эта процедура порождает внутренние соединители @code{u}, @code{v},
@code{w}, @code{x} и @code{y}, а затем связывает их, как показано на
рис. @ref{Рисунок 3.28}, при помощи элементарных ограничений
@code{adder}, @code{multiplier} и @code{constant}. Как и при
моделировании цифровых схем в @ref{3.3.4}, способность
выражать комбинации базовых элементов в виде процедур автоматически
сообщает нашему языку средство абстракции для составных объектов.

Чтобы наблюдать сеть в действии, мы подсоединим тестеры к соединителям
@code{C} и @code{F} при помощи процедуры @code{probe}, подобной той,
которая следила за сигналами в проводах в @ref{3.3.4}. Установка
тестера на соединителе ведет к тому, что каждый раз, когда он получает
значение, печатается сообщение:

@lisp
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
@end lisp

@noindent
Затем мы присваиваем значение 25 соединителю @code{C}. (Третий аргумент
процедуры @code{set-value!} сообщает @code{C}, что директива исходит от
пользователя.)

@lisp
(set-value! C 25 'user)
@i{Probe: Celsius temp = 25}
@i{Probe: Fahrenheit temp = 77}
@i{done}
@end lisp

@noindent
Тестер на @code{C} просыпается и печатает значение. Кроме того, @code{C}
распространяет значение по сети, как описано выше. В результате @code{F}
становится равным 77, и тестер на @code{F} об этом сообщает.

Теперь можно попробовать присвоить @code{F} новое значение, скажем, 212:

@lisp
(set-value! F 212 'user)
@i{Error! Contradiction (77 212)}
@end lisp

@noindent
Соединитель жалуется, что обнаружил противоречие: его значение равно 77,
а при этом кто-то пытается установить его в 212. Если мы и вправду хотим
снова воспользоваться сетью с новыми значениями, можно попросить
@code{C} забыть свое старое значение:

@lisp
(forget-value! C 'user)
@i{Probe: Celsius temp = ?}
@i{Probe: Fahrenheit temp = ?}
@i{done}
@end lisp

@noindent
@code{С} видит, что @code{user}, который изначально присвоил ему
значение, отменяет его, так что @code{C} соглашается потерять значение,
как показывает тестер, и информирует об этом остальную сеть. Эта
информация в конце концов добирается до @code{F}, и у @code{F} уже не
остается причин считать, что его значение равно 77. Так что @code{F}
тоже теряет значение, и тестер это отображает.

Теперь, когда у @code{F} больше нет значения, мы можем установить его в
212:

@lisp
(set-value! F 212 'user)
@i{Probe: Fahrenheit temp = 212}
@i{Probe: Celsius temp = 100}
@i{done}
@end lisp

@noindent
Это новое значение, распространяясь по сети, заставляет @code{C}
получить значение 100, и тестер на @code{C} это регистрирует. Заметим,
что одна и та же сеть используется и для того, чтобы на основе @code{F}
получить @code{C} и для того, чтобы на основе @code{C} получить
@code{F}. Эта ненаправленность вычислений является отличительной чертой
систем, основанных на ограничениях.

@comment @subsubheading Implementing the constraint system
@subsubheading Реализация системы ограничений

Система ограничений реализована на основе процедурных объектов с
внутренним состоянием, очень похоже на модель цифровых схем из
@ref{3.3.4}. Хотя базовые
объекты системы с ограничениями несколько более сложны, система в целом
проще за счет того, что незачем заботиться о планах действий и
логических задержках.

Базовые операции над соединителями таковы:

@itemize @bullet

@item
@code{(has-value? @math{\langle}@var{соединитель}@math{\rangle})}
сообщает, есть ли у соединителя значение.

@item
@code{(get-value @math{\langle}@var{соединитель}@math{\rangle})}
возвращает текущее значение соединителя.

@item
@code{(set-value! @math{\langle}@var{соединитель}@math{\rangle} 
@math{\langle}@var{новое-знач}@math{\rangle} 
@math{\langle}@var{информант}@math{\rangle})} сообщает соединителю, что
информант требует установить в нем новое значение.

@item
@code{(forget-value! @math{\langle}@var{соединитель}@math{\rangle} 
@math{\langle}@var{отказник}@math{\rangle})} сообщает соединителю, что
отказник просит его забыть значение.

@item
@code{(connect @math{\langle}@var{соединитель}@math{\rangle}
@math{\langle}@var{новое-ограничение}@math{\rangle})} говорит соединителю, что
он участвует в новом ограничении.

@end itemize

@noindent
Соединители общаются с ограничениями при помощи процедур
@code{inform-about-value}, которая говорит ограничению, что у
соединителя есть значение, и @code{inform-about-no-value}, которая
сообщает ограничению, что соединитель утратил значение.

@code{adder} порождает ограничение-сумматор между
соединителями-слагаемыми @code{a1} и @code{a2} и соединителем-суммой
@code{sum}. Сумматор реализован в виде процедуры с внутренним состоянием
(процедура @code{me}):

@lisp
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
@end lisp

@noindent
@code{adder} связывает новый сумматор с указанными соединителями и
возвращает его в качестве значения. Процедура @code{me}, которая
представляет сумматор, работает как диспетчер для внутренних процедур.
Для доступа к диспетчеру используются следующие <<синтаксические
интерфейсы>> (см. примечание @ref{Сноска 27} в
@ref{3.3.4}):

@lisp
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
@end lisp

@noindent
Внутренняя процедура сумматора @code{process-new-value} вызывается,
когда сумматору сообщают, что один из его соединителей получил значение.
Сумматор проверяет, имеют ли значения одновременно @code{a1} и
@code{a2}. Если да, то он говорит @code{sum}, чтобы тот установил
значение в сумму двух слагаемых. Аргумент @code{informant} процедуры
@code{set-value!} равен @code{me}, то есть самому объекту-сумматору.
Если неверно, что и @code{a1} и @code{a2} имеют значения, то сумматор
проверяет, имеют ли одновременно значения @code{a1} и @code{sum}. Если
да, то он устанавливает @code{a2} в их разность. Наконец, если значения
есть у @code{a2} и @code{sum}, это дает сумматору достаточно информации,
чтобы установить @code{a1}. Если сумматору сообщают, что один из
соединителей потерял значение, то он просит все свои соединители
избавиться от значений. (На самом деле будут отброшены только значения,
установленные самим сумматором.) Затем он зовет
@code{process-new-value}. Смысл этого последнего шага в том, что один
или более соединителей по-прежнему могут обладать значением (то есть, у
соединителя могло быть значение, не установленное сумматором), и эти
значения может быть необходимо распространить через сумматор.

Умножитель очень похож на сумматор. Он устанавливает свой вывод
@code{product} в 0, если хотя бы один множитель равен 0, даже в том
случае, когда второй множитель неизвестен.

@lisp
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product)
                          (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product)
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: MULTIPLIER"
                       request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
@end lisp

@noindent
Конструктор @code{constant} просто устанавливает значение указанного
соединителя. Сообщение @code{I-have-a-value} либо
@code{I-lost-my-value}, посланные блоку-константе, приводят к ошибке.

@lisp
(define (constant value connector)
  (define (me request)
    (error "Unknown request: CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
@end lisp

@noindent
Наконец, тестер печатает сообщение о присваивании или потере значения в
указанном соединителе:

@lisp
(define (probe name connector)
  (define (print-probe value)
    (newline) (display "Probe: ") (display name)
    (display " = ") (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value) (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: PROBE" request))))
  (connect connector me)
  me)
@end lisp

@comment @subsubheading Representing connectors
@subsubheading Представление соединителей

Соединитель представляется в виде процедурного объекта с внутренними
переменными состояния: @code{value}, значение соединителя;
@code{informant}, объект, который установил значение соединителя; и
@code{constraints}, множество ограничений, в которых участвует
соединитель.

@lisp
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "unknown operation: connector"
                         request))))
    me))
@end lisp

@noindent
Внутренняя процедура соединителя @code{set-my-value} зовется, когда
поступает требование установить значение соединителя. Если у соединителя
нет текущего значения, он его устанавливает и запоминает ограничение,
которое потребовало установки значения, в переменной
@code{informant}.@footnote{@code{Setter} может и не быть ограничением. В
примере с температурой мы использовали символ @code{user} в качестве
значения @code{setter}.} Затем соединитель оповещает все связанные с
ним ограничения, кроме того, которое потребовало установить значение.
Это проделывается с помощью следующего итератора, который применяет
указанную процедуру ко всем элементам списка, кроме одного.

@lisp
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
@end lisp

@noindent
Если от соединителя требуют забыть значение, он запускает внутреннюю
процедуру @code{forget-my-value}, которая первым делом убеждается, что
запрос исходит от того же самого объекта, который значение установил.
Если это так, соединитель оповещает связанные с ним ограничения о потере
значения.

Внутренняя процедура @code{connect} добавляет указанное ограничение к
списку ограничений, если его там еще нет. Затем, если у соединителя есть
значение, он сообщает об этом ограничению.

Процедура соединителя @code{me} служит диспетчером для остальных
внутренних процедур, а кроме того, представляет соединитель как объект.
Следующие процедуры предоставляют синтаксический интерфейс к диспетчеру:

@lisp
(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.33}Упражнение 3.33:}
С помощью элементарных ограничений сумматор, умножитель и
константа, определите процедуру @code{averager} (усреднитель), которая
принимает три соединителя @code{a}, @code{b} и @code{c}, и обеспечивает
условие, что значение @code{c} равно среднему арифметическому значений
@code{a} и @code{b}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.34}Упражнение 3.34:}
Хьюго Дум хочет построить квадратор, блок-ограничение с
двумя выводами, такое, что значение соединителя @code{b} на втором
выводе всегда будет равно квадрату значения соединителя @code{a} на
первом выводе. Он предлагает следующее простое устройство на основе
умножителя:

@lisp
(define (squarer a b)
  (multiplier a a b))
@end lisp

В такой идее есть существенная ошибка. Объясните ее.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.35}Упражнение 3.35:}
Бен Битобор объясняет Хьюго, что один из способов избежать
неприятностей в упражнении @ref{Упражнение 3.34} --- определить
квадратор как новое элементарное ограничение. Заполните недостающие
части в Беновой схеме процедуры, реализующей такое ограничение:

@lisp
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER"
                   (get-value b))
            @math{\langle}@var{alternative1}@math{\rangle})
        @math{\langle}@var{alternative2}@math{\rangle}))
  (define (process-forget-value) @math{\langle}@var{body1}@math{\rangle})
  (define (me request) @math{\langle}@var{body2}@math{\rangle})
  @math{\langle}@var{rest of definition}@math{\rangle}
  me)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.36}Упражнение 3.36:}
Допустим, что мы выполняем следующую последовательность
действий в глобальном окружении:

@lisp
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
@end lisp

В какой-то момент при вычислении @code{set-value!} будет выполнено
следующее выражение из внутренней процедуры соединителя:

@lisp
(for-each-except
  setter inform-about-value constraints)
@end lisp

Нарисуйте диаграмму, изображающую окружение, в котором выполняется
указанное выражение.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.37}Упражнение 3.37:}
Процедура @code{celsius-fahrenheit-converter} выглядит
громоздко по сравнению со стилем определения в формате выражения:

@lisp
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
@end lisp

Здесь @code{c+}, @code{c*} и т. п. --- <<ограничительные>> версии
арифметических операций. Например, @code{c+} берет в виде аргументов два
соединителя, и возвращает соединитель, который связан с ними
ограничением-сумматором:

@lisp
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
@end lisp

Определите аналогичные процедуры для @code{c-}, @code{c*}, @code{c/} и
@code{cv} (константа), так, чтобы можно было определять составные
ограничения, как в вышеприведенном примере.@footnote{Представление в виде
выражений удобно, потому что при этом отпадает необходимость давать
имена промежуточным выражениям в вычислении. Наша исходная формулировка
языка ограничений громоздка по той же причине, по которой многие языки
оказываются громоздкими при работе с составными данными. Например, если
нам нужно вычислить произведение @math{(a+b) \cdot (c+d)}, где переменные представляют вектора, мы можем работать в
<<императивном>> стиле, с процедурами, которые присваивают значения
указанным векторным аргументам, но сами не возвращают вектора как
значения:

@sp -0.8
@smallexample
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
@end smallexample
@sp -0.8

@noindent
С другой стороны, мы можем работать с выражениями, используя процедуры,
которые возвращают вектора как значения, и таким образом избежать
прямого упоминания @code{temp1} и @code{temp2}:

@sp -0.8
@smallexample
(define answer (v-prod (v-sum a b) (v-sum c d)))
@end smallexample
@sp -0.8

@noindent
Поскольку Лисп позволяет возвращать составные объекты как результаты
процедур, мы можем преобразовать свой императивный язык ограничений в
язык на основе выражений, как показано в этом упражнении. В языках, где
средства работы с составными объектами бедны, как в Алголе, Бейсике и
Паскале (если явно не использовать паскалевские переменные-указатели),
обычно при решении таких задач программист ограничен императивным
стилем. Поскольку формат выражений предпочтителен, можно спросить, есть
ли причина строить систему императивно, как мы поступили в этом разделе.
Одна из причин состоит в том, что язык ограничений, не ориентированный
на выражения, дает нам возможность работать не только с
объектами-соединителями, но и с объектами-ограничениями (например,
значением, порождаемым процедурой @code{adder}). Это будет полезно, если
мы захотим расширить систему новыми операциями, которые работают с
ограничениями напрямую, а не только косвенным образом через операции над
соединителями. Хотя реализовать работу с выражениями на основе
императивной реализации просто, сделать обратное значительно труднее.}
@end quotation

@comment @section Concurrency: Time Is of the Essence
@section Параллелизм: время имеет значение
@node	3.4, 3.5, 3.3, Chapter 3

Мы убедились в мощности вычислительных объектов с внутренним состоянием
в качестве инструмента моделирования. Однако, как было сказано в
@ref{3.1.3}, за эту
мощность приходится платить потерей референциальной прозрачности,
которая ведет в дебри вопросов об идентичности и изменении, и
необходимостью замены подстановочной модели вычислений на более сложную
модель с окружениями.

Главная проблема, стоящая за сложностями состояния, идентичности и
изменения, состоит в том, что, введя присваивание, мы вынуждены внести в
свои вычислительные модели понятие (@newterm{time}). До того, как появилось
присваивание, наши программы от времени не зависели --- в том смысле,
что всякое выражение, обладающее значением, всегда имело одно и то же
значение. Вспомним, однако, пример со снятием денег со счета и
просмотром получившегося баланса из начала
@ref{3.1.1}:

@lisp
(withdraw 25)
@i{75}
(withdraw 25)
@i{50}
@end lisp

@noindent
Здесь последовательное вычисление одного и того же выражения приводит к
различным результатам. Такое поведение возникает из-за того, что
выполнение предложений присваивания (в данном случае присваивания
переменной @code{balance}) отмечает (@newterm{moments in time}), когда значения
меняются. Результат вычисления выражения зависит не только от самого
выражения, но и от того, происходит ли вычисление до или после таких
моментов. Построение моделей в терминах вычислительных объектов с
внутренним состоянием заставляет нас рассматривать время как
существенное для программирования понятие.

Можно пойти еще дальше в структурировании наших вычислительных объектов,
чтобы точнее отразить наше восприятие физического мира. Объекты мира
изменяются не последовательно один за другим. Мы воспринимаем их как
действующие (@newterm{concurrently}) --- все вместе. Так что зачастую бывает
естественно моделировать системы как сообщества вычислительных
процессов, работающих параллельно. Точно так же, как можно сделать
программы модульными, организуя их в виде объектов с раздельным
внутренним состоянием, часто имеет смысл разделять вычислительные модели
на части, вычисляющиеся раздельно и одновременно. Даже если на самом
деле предполагается выполнять программы на последовательном компьютере,
практика написания программ так, как будто вычисление будет
параллельным, заставляет программиста избегать несущественных временны́х
ограничений, и таким образом повышает модульность программ.

Параллельное вычисление не только делает программы модульнее, оно к тому
же может дать выигрыш в скорости перед последовательным.
Последовательные компьютеры выполняют только одну операцию за раз, так
что время, необходимое для решения задачи, пропорционально общему
количеству выполняемых операций.@footnote{На самом деле большинство
процессоров выполняют несколько операций за раз, используя стратегию,
называемую (@newterm{pipelining}) Хотя этот метод значительно повышает степень
использования аппаратных ресурсов, он используется только для ускорения
выполнения последовательного потока вычислений, сохраняя поведение
последовательной программы.} Однако если возможно разбить задачу на
части, которые относительно независимы друг от друга и должны общаться
между собой редко, может оказаться возможным раздать эти куски отдельным
вычисляющим процессорам и получить выигрыш, пропорциональный числу
имеющихся процессоров.

К несчастью, проблемы, связанные с присваиванием, становятся только
тяжелее в присутствии параллелизма. Связано ли это с тем, что
параллельно работает мир, или компьютер, но явление одновременных
вычислений привносит дополнительную сложность в наше понимание времени.

@menu
* 3-4-1::            Природа времени в параллельных системах
* 3-4-2::            Механизмы управления параллелизмом
@end menu

@comment @subsection The Nature of Time in Concurrent Systems
@subsection Природа времени в параллельных системах
@node	3.4.1, 3.4.2, 3.4, 3.4

На первый взгляд, время --- вещь простая. Это порядок, накладываемый на
события.@footnote{Граффити на одной стене в Кембридже: <<Время --- это
устройство для того, чтобы случалось не все сразу>>.} Для всяких двух
событий @math{A} и @math{B}, либо @math{A} случается раньше @math{B},
либо @math{A} и @math{B} происходят одновременно, либо @math{A}
случается позже @math{B}. Например, возвращаясь к примеру с банковским
счетом, пусть Петр берет с общего счета 10 долларов, а Павел 25, притом,
что сначала на счету 100 долларов. На счету останется 65 долларов. В
зависимости от порядка двух событий, последовательность балансов на
счету будет либо @math{\$100 \to \$90 \to \$65}, либо
@math{\$100 \to \$75 \to \$65}. В компьютерной реализации банковской
системы эта изменяющаяся последовательность балансов может
моделироваться через последовательные присваивания переменной
@code{balance}.

Однако в некоторых ситуациях такой взгляд может вести к проблемам.
Допустим, что Петр и Павел, и еще другие люди помимо них, имеют доступ к
совместному банковскому счету через сеть банкоматов, разбросанных по
всему миру. Последовательность значений баланса будет критическим
образом зависеть от точной хронологии доступа и деталей коммуникации
между машинами.

Неопределенность порядка событий может приводить к серьезным проблемам в
проектировании компьютерных систем. Например, предположим, что действия
Петра и Павла реализованы как два отдельных процесса с общей переменной
@code{balance}, и что каждый процесс определяется процедурой из
@ref{3.1.1}:

@lisp
(define (withdraw amount)
  (if (>= balance amount)
      (begin
        (set! balance (- balance amount))
        balance)
      "Insufficient funds"))
@end lisp

@noindent
Если два процесса работают одновременно, то Петр может проверить баланс
и попытаться снять разрешенную сумму. Однако за промежуток времени между
моментами, когда Петр проверяет баланс, и когда он завершает снятие
денег, Павел может снять какую-то сумму и сделать результат Петровой
проверки несостоятельным.

И это еще не самое худшее. Рассмотрим выражение

@lisp
(set! balance (- balance amount))
@end lisp

@noindent
которое выполняется во время каждого снятия денег. Выполнение происходит
в три шага: (1) считывание значения переменной @code{balance}; (2)
вычисление нового значения баланса; (3) присвоение переменной
@code{balance} этого нового значения. Если процессы Петра и Павла
выполняют это предложение параллельно, то в двух процессах снятия денег
порядок чтения переменной @code{balance} и присваивания могут
чередоваться.

@float[tp]
@anchor{Рисунок 3.29}
@ifinfo
@strong{Рисунок 3.29:} Timing diagram showing how interleaving the order of events
in two banking withdrawals can lead to an incorrect final balance.

@example
 |           Peter              Bank              Paul
 |                              ____
 |                             /    \
 |             .--------------| $100 |-------------.
 |             |               \____/              |
 |             V                                   V
 |  .----------------------.            .----------------------.
 |  | Access balance: $100 |            | Access balance: $100 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   V
 |  .----------------------.            .----------------------.
 |  | new value: 100-10=90 |            | new value: 100-25=75 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   |
 |  .----------------------.                       |
 |  | set! balance to $90  |                       |
 |  `----------+-----------'    ____               |
 |             |               /    \              |
 |             `------------->| $ 90 |             V
 |                             \____/   .----------------------.
 |                                      | new value: 100-25=75 |
 |                              ____    `----------+-----------'
 |                             /    \              |
 |                            | $ 90 |<------------'
 V                             \____/
time
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.29b,109mm,,,.pdf}
@sp 0.8
@noindent
@caption{@strong{Рисунок 3.29:} Timing diagram showing how interleaving the order of events in two banking withdrawals can lead to an incorrect final balance.}
@sp 1.2
@end iftex
@end float

Временна́я диаграмма на рисунке @ref{Рисунок 3.29} показывает порядок
событий, при котором @code{balance} сначала равен 100. Петр берет 10,
Павел 25, и однако в итоге @code{balance} оказывается равен 75. Как
показано на диаграмме, причина аномалии состоит в том, что у Павла
присваивание переменной значения 75 основано на предположении, что
значение @code{balance}, которое надо уменьшить, равно 100. Однако это
предположение стало неверным, когда Петр сделал @code{balance} равным
90. Для банковской системы это катастрофическая ошибка, так как не
сохраняется общее количество денег в системе. До транзакций общая сумма
была 100 долларов. После же у Петра оказывается 10 долларов, у Павла 25,
и у банка 75.@footnote{Еще худшая ошибка могла бы случиться, если бы две
операции @code{set!} попытались одновременно изменить баланс. В
результате содержимое памяти могло бы стать случайной комбинацией
данных, записанных двумя процессами. В большинство компьютеров встроена
блокировка элементарных операций записи в память, которая предохраняет
от такого одновременного доступа. Однако даже такой, казалось бы,
простой метод защиты придает дополнительную сложность проектированию
многопроцессорных компьютеров, где требуются сложные протоколы (cache
coherence), чтобы у разных процессоров были непротиворечивые точки
зрения на содержимое памяти, при том, что данные могут дублироваться
(<<кэшироваться>>) в разных процессорах, чтобы увеличить скорость
доступа к памяти.}

Общее явление, иллюстрируемое здесь, состоит в том, что различные
процессы могут разделять одну и ту же переменную состояния. Сложность
возникает оттого, что с этой переменной в одно и то же время может
пытаться работать более одного процесса. В примере с банковским счетом
во время каждой транзакции клиент должен иметь возможность действовать
так, как будто остальных клиентов не существует. Когда клиент изменяет
баланс, исходя из его предыдущего значения, ему надо обеспечить гарантии
того, что прямо перед моментом изменения баланс все еще соответствует
его, клиента, предoставлениям.

@endpage
@comment @subsubheading Correct behavior of concurrent programs
@subsubheading Правильное поведение параллельных программ

Вышеприведенный пример демонстрирует типичную неочевидную ошибку,
которая может возникнуть в параллельной программе. Сложность здесь
восходит к присваиванию переменным, разделяемым между различными
процессами. Мы уже знаем, что при работе с @code{set!} требуется
осторожность, потому что результаты вычислений зависят от порядка, в
котором происходят присваивания.@footnote{Программа подсчета факториала
из @ref{3.1.3} демонстрирует это в рамках одного последовательного процесса.}
При наличии параллелизма нужно быть острожным вдвойне, поскольку не всегда
можно управлять порядком, в котором присваивания происходят в разных
процессах. Если несколько таких изменений могут происходить одновременно
(как в случае с двумя вкладчиками, имеющими доступ к общему счету), нам
требуется способ обеспечить правильную работу системы. Например, в
случае со снятием денег с общего счета, мы должны сделать так, чтобы
общее количество денег оставалось неизменным. Чтобы заставить
параллельные программы работать корректно, иногда требуется наложить
некоторые ограничения на одновременное исполнение.

Одно из возможных ограничений на параллелизм может состоять в том, что
никакие две операции, способные изменить разделяемые переменные
состояния, не могут исполняться одновременно. Это очень серьезное
ограничение. Для распределенной банковской системы это означало бы, что
проектировщик системы должен сделать так, что в каждый момент происходит
не более одной транзакции. Это требование чрезмерно консервативное и
ведет к неэффективности. На рисунке @ref{Рисунок 3.30} показан случай
с совместным счетом Петра и Павла, причем у Павла есть еще и собственный
счет. Диаграмма показывает две операции снятия денег с совместного счета
(одну проводит Петр, одну Павел), а также занесение Павлом денег на
личный счет.@footnote{По столбцам: содержимое кошелька Петра, общий счет
(в Банке 1), кошелек Павла и личный счет Павла (в Банке 2), до и после
каждого снятия (W) и занесения денег на счет (D). Петр берет 10 долларов
из Банка 1; Павел кладет 5 долларов в Банк 2, затем берет 25 долларов из
Банка 1.} Два снятия денег с одного счета не должны происходить
одновременно (поскольку оба работают с одним счетом), и Павел не может
одновременно снять деньги и занести их в банк (поскольку и та, и другая
операция касаются кошелька Павла). Однако не должно быть препятствий,
мешающих Павлу заносить деньги на личный счет в то время, как Петр берет
деньги с общего счета.

@float
@quotation
@anchor{Рисунок 3.30}
@ifinfo
@strong{Рисунок 3.30:} Concurrent deposits and withdrawals from a joint account
in Bank1 and a private account in Bank2.

@example
 |    Peter          Bank1          Paul           Bank2
 |    ____           ____           ____           ____
 |   /    \         /    \         /    \         /    \
 |  |  $7  |--. .--| $100 |       |  $5  |--. .--| $300 |
 |   \____/   V V   \____/         \____/   V V   \____/
 |           +---+                         +---+
 |           | W |                         | D |
 |    ____   ++-++   ____           ____   ++-++   ____
 |   /    \   | |   /    \         /    \   | |   /    \
 |  | $17  |<-' `->| $90  |--. .--|  $0  |<-' `->| $305 |
 |   \____/         \____/   V V   \____/         \____/
 |                          +---+
 |                          | W |
 |    ____           ____   ++-++   ____           ____
 |   /    \         /    \   | |   /    \         /    \
 |  | $17  |       | $65  |<-' `->| $25  |       | $305 |
 |   \____/         \____/         \____/         \____/
 V
time
@end example
@end ifinfo
@iftex
@sp 0.3
@center @image{fig/chap3/Fig3.30b,94mm,,,.pdf}
@sp 0.7
@caption{@strong{Рисунок 3.30:} Concurrent deposits and withdrawals from a joint @w{account} in Bank1 and a private account in Bank2.}
@sp 1.0
@end iftex
@end quotation
@end float

Менее драконовское ограничение на параллелизм могло бы состоять в том,
чтобы параллельная система выдавала такие же результаты, как если бы
процессы происходили последовательно. У этого ограничения две важных
стороны. Во-первых, от процессов на самом деле не требуется
последовательного исполнения, а только результаты, совпадающие с теми,
которые @emph{получались бы}, если бы они работали один за другим. В
примере на рис. @ref{Рисунок 3.30}, проектировщик банковской системы
спокойно может разрешить одновременное занесение денег Павлом и снятие
их Петром, поскольку общий результат будет таков, как будто бы они шли
последовательно. Во-вторых, у параллельной программы может быть более
одного <<правильного>> результата, потому что мы требуем только, чтобы
он совпадал с результатом при @emph{каком-нибудь} последовательном
порядке. Например, предположим, что общий счет Петра и Павла вначале
равен 100 долларам, Петр кладет на него 40 долларов, а Павел снимает
половину имеющихся там денег. При этом последовательное исполнение может
привести к значению на счету либо в 70, либо в 90 долларов
(см. @ref{Упражнение 3.38}).@footnote{@anchor{Сноска 39} Более
формально это утверждение можно выразить, сказав, что поведение
параллельных программ --- (nondeterministic). То есть, они описываются
не функциями с одним значением, а функциями, чьи результаты являются
множествами возможных значений. В @ref{4.3}
мы рассмотрим язык для выражения недетерминистских вычислений.}

Можно найти и еще более слабые требования для корректного выполнения
параллельных программ. Программа, имитирующая диффузию (например, поток
тепла в объекте), может состоять из большого числа процессов, каждый из
которых изображает маленький участок пространства, и которые параллельно
обновляют свои значения. Каждый процесс в цикле изменяет свое значение
на среднее между своим собственным значением и значениями соседей. Этот
алгоритм сходится к правильному ответу независимо от порядка, в котором
выполняются операции; нет никакой нужды в ограничениях на параллельное
использование разделяемых значений.

@quotation
@strong{@anchor{Упражнение 3.38}Упражнение 3.38:}
Пусть Петр, Павел и Мария имеют общий счет, на котором
вначале лежит 100 долларов. Петр кладет на счет 10 долларов,
одновременно с этим Павел берет 20, а Мария берет половину денег со
счета. При этом они выполняют следующие операции:

@lisp
Peter: (set! balance (+ balance 10))
Paul:  (set! balance (- balance 20))
Mary:  (set! balance (- balance (/ balance 2)))
@end lisp

@enumerate a.

@item
Перечислите возможные значения @code{balance} после завершения операций,
предполагая, что банковская система требует от транзакций исполняться
последовательно в каком-то порядке.

@item
Назовите какие-нибудь другие значения, которые могли бы получиться, если
бы система разрешала операциям чередоваться. Нарисуйте временные
диаграммы, подобные рис. @ref{Рисунок 3.29}, чтобы объяснить, как
возникают такие результаты.

@end enumerate
@end quotation

@comment @subsection Mechanisms for Controlling Concurrency
@subsection Механизмы управления параллелизмом
@node	3.4.2,  , 3.4.1, 3.4

Мы убедились, что сложность работы с параллельными процессами происходит
из необходимости учитывать порядок чередования событий в различных
процессах. Предположим, к примеру, что у нас есть два процесса, один с
упорядоченными событиями @math{(a, b, c)}, а другой с упорядоченными
событиями @math{(x, y, z)}. Если эти два процесса исполняются
параллельно, без каких-либо дополнительных ограничений на чередование
событий, то возможно 20 различных порядков событий, соблюдающих
упорядочение их внутри каждого из процессов:

@example
(a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)  (x,a,y,z,b,c)
(a,b,x,c,y,z)  (a,x,b,y,z,c)  (x,a,b,y,c,z)  (x,y,a,b,c,z)
(a,b,x,y,c,z)  (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
(a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)  (x,y,a,z,b,c)
(a,x,b,c,y,z)  (a,x,y,z,b,c)  (x,a,y,b,z,c)  (x,y,z,a,b,c)
@end example

@noindent
При разработке этой системы нам как программистам пришлось
бы рассматривать результаты каждого из этих 20 упорядочений и проверять,
что каждое из них допустимо. С ростом числа процессов и событий такой
подход быстро становится нереалистичным.

Более практичный подход к проектированию параллельных систем состоит в
том, чтобы придумать общие механизмы, которые бы ограничивали
чередование событий в параллельных процессах и тем самым давали нам
уверенность, что поведение программы верно. Для этой цели было
разработано большое количество механизмов. В этом разделе мы опишем один
из них --- (@newterm{serializer}).

@comment @subsubheading Serializing access to shared state
@subsubheading Сериализация доступа к разделяемой памяти

Идея сериализации заключается в следующем: процессы выполняются
параллельно, но при этом существуют определенные группы процедур,
которые не могут выполняться одновременно. Выражаясь точнее,
сериализация порождает выделенные множества процедур, такие, что в
каждом сериализованном множестве в любой момент может происходить
выполнение только одной процедуры из множества. Если какая-то процедура
из множества уже выполняется, то процесс, который пытается выполнить
любую процедуру из множества, будет приостановлен до тех пор, пока не
закончится текущее вычисление процедуры.

С помощью сериализации можно управлять доступом к разделяемым
переменным. Например, если мы хотим присвоить разделяемой переменной
значение, зависящее от ее текущего значения, мы помещаем доступ к
прежнему значению и присваивание нового в одну процедуру. Затем мы
помещаем все такие процедуры в один сериализатор и тем самым добиваемся
того, что никакая другая процедура, которая присваивает значения этой
переменной, не может выполняться одновременно с нашей. Это гарантирует
нам, что значение переменной не может измениться в промежутке между
доступом к ней и соответствующим ему присваиванием.

@comment @subsubheading Serializers in Scheme
@subsubheading Сериализаторы в Scheme

Чтобы сделать это описание более конкретным, предположим, что мы
расширили язык Scheme, добавив в него процедуру @code{parallel-execute}:

@lisp
(parallel-execute @math{\langle}@var{p}@math{_{\mono{1}}\rangle} @math{\langle}@var{p}@math{_{\mono{2}}\rangle} @dots{} @math{\langle}@var{p}@math{_{\monoit{k}}\rangle})
@end lisp

Каждый из @math{\langle p \rangle} должен быть
процедурой без аргументов. @code{parallel-execute} создает для каждого
@math{\langle p \rangle} отдельный процесс, который выполняет
@math{\langle p \rangle} (с пустым набором аргументов). Все эти процессы выполняются
параллельно.@footnote{@code{parallel-execute} не входит в стандартную
Scheme, но такая процедура может быть реализована в MIT Scheme. В нашей
реализации новые процессы выполняются параллельно еще и с исходным
Scheme-процессом. Кроме того, в нашей реализации значение, которое
возвращает @code{parallel-execute}, представляет собой специальный
управляющий объект, с помощью которого можно остановить все
новосозданные процессы.}

Чтобы продемонстрировать, как эта процедура используется, рассмотрим

@lisp
(define x 10)
(parallel-execute
 (lambda () (set! x (* x x)))
 (lambda () (set! x (+ x 1))))
@end lisp

@noindent
Здесь создаются два параллельных процесса --- @math{P_1}, который
присваивает @code{x} значение @code{x} умножить на @code{x}, и
@math{P_2}, который увеличивает @code{x} на единицу. После того, как
вычисление закончено, @code{x} может иметь одно из пяти значений, в
зависимости от чередования событий в @math{P_1} и @math{P_2}:

@lisp
101: @r{@math{P_1} делает @code{x} равным 100, затем @math{P_2} его
увеличивает.}

121: @r{@math{P_2} увеличивает @code{x}, делая его равным 11, затем
@math{P_1} присваивает ему значение @code{x} умножить на @code{x}.}

110: @r{@math{P_2} изменяет @code{x} с 10 на 11 в промежутке между двумя
обращениями к @code{x} из @math{P_1} во время вычисления @code{(* x x)}.}

11: @r{@math{P_2} читает @code{x}, затем @math{P_1} присваивает ему
значение 100, затем @math{P_1} пишет @code{x}}

100: @r{@math{P_1} читает @code{x} (дважды), затем @math{P_2} присваивает
ему значение 11, затем @math{P_1} записывает значение @code{x}.}
@end lisp

@noindent
Мы можем ограничить параллелизм, используя сериализованные процедуры,
которые создаются (@newterm{serializers}). Сериализаторы порождаются процедурой
@code{make-serializer}, реализация которой дана ниже. Сериализатор
принимает в качестве аргумента процедуру, и возвращает сериализованную
процедуру с таким же поведением. Все вызовы сериализатора порождают
сериализованные процедуры, принадлежащие одному множеству.

Таким образом, в отличие от предыдущего примера, выполнение

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute
 (s (lambda () (set! x (* x x))))
 (s (lambda () (set! x (+ x 1)))))
@end lisp

@noindent
может иметь только два результата, 101 и 121. Остальные возможности
отбрасываются, поскольку выполнение @math{P_1} и @math{P_2} не может
чередоваться.

Ниже приведена версия процедуры @code{make-account} из @ref{3.1.1},
в которой помещение денег на счет и снятие их со счета сериализованы:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
    dispatch))
@end lisp

@noindent
В такой реализации два процесса не могут параллельно помещать деньги на
счет или снимать их. Таким образом устраняется источник ошибки,
показанной на рис. @ref{Рисунок 3.29}, где Петр изменяет баланс на
счете в промежутке между моментами, когда Павел считывает значение
баланса, и когда он производит присваивание. С другой стороны, у каждого
счета свой собственный сериализатор, так что операции с различными
счетами могут происходить параллельно.

@quotation
@strong{@anchor{Упражнение 3.39}Упражнение 3.39:}
Какие из пяти возможных исходов параллельного выполнения
сохраняются, если мы сериализуем выполнение таким образом:

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.40}Упражнение 3.40:}
Укажите все возможные значения @code{x} при выполнении

@lisp
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
@end lisp

Какие из них сохраняются, если вместо этого мы выполняем сериализованные
процедуры:

@lisp
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.41}Упражнение 3.41:}
Бен Битобор считает, что лучше было бы реализовать
банковский счет таким образом (измененная строка отмечена комментарием):

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance
                     (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected
               (lambda () balance)))) @r{; serialized}
            (else
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
@end lisp

@noindent
поскольку несериализованный доступ к банковскому счету может привести к
неправильному поведению. Вы согласны? Существует ли сценарий, который
демонстрирует обоснованность беспокойства Бена?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.42}Упражнение 3.42:}
Бен Битобор говорит, что слишком расточительно в ответ на
каждое сообщение @code{withdraw} и @code{deposit} создавать по новой
сериализованной процедуре. Он говорит, что можно изменить
@code{make-account} так, чтобы все вызовы @code{protected} происходили
вне процедуры @code{dispatch}. Таким образом, счет будет возвращать одну
и ту же сериализованную процедуру (созданную тогда же, когда и сам счет)
каждый раз, когда у него просят процедуру снятия денег:

@lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else
               (error "Unknown request: MAKE-ACCOUNT"
                      m))))
      dispatch)))
@end lisp

Безопасно ли такое изменение? В частности, есть ли разница в том, в
каком порядке может происходить параллельное выполнение в этих двух
версиях @code{make-account}?
@end quotation

@comment @subsubheading Complexity of using multiple shared resources
@subsubheading Сложности при использовании множественных разделяемых ресурсов

Сериализаторы предоставляют нам мощную абстракцию, которая позволяет
изолировать сложности выполнения параллельных программ, так что мы
получаем возможность работать с ними аккуратно (и, будем надеяться, без
ошибок). Однако, хотя при работе только с одним разделяемым ресурсом
(например, с одним банковским счетом) использовать сериализаторы
относительно просто, при наличии множественных разделяемых ресурсов
параллельное программирование может быть предательски сложным.

Чтобы проиллюстрировать одну из ряда трудностей, которые могут
возникнуть, предположим, что нам требуется поменять местами балансы на
двух банковских счетах. Мы читаем каждый счет, чтобы узнать баланс,
вычисляем разницу между балансами, снимаем ее с одного счета и кладем на
другой. Это можно реализовать следующим образом:@footnote{Мы упростили
@code{exchange}, пользуясь тем, что наше сообщение @code{deposit} может
принимать отрицательные суммы. (Для банковской системы это серьезная
ошибка!)}

@lisp
(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
@end lisp

@noindent
Эта процедура работает правильно в том случае, когда только один процесс
пытается осуществить обмен. Допустим, однако, что Петр и Павел имеют
доступ к совместным счетам @math{a1}, @math{a2} и @math{a3}, и что Петр
меняет местами @math{a1} и @math{a2}, а Павел в то же время обменивает
@math{a1} и @math{a3}. Даже если снятие и занесение денег на отдельные
счета сериализованы (как в процедуре @code{make-account} из предыдущего
раздела), @code{exchange} может привести к неверным результатам.
Например, может оказаться, что Петр посчитает разницу между @math{a1} и
@math{a2}, но Павел изменит баланс на @math{a1} прежде, чем Петр
закончит обмен.@footnote{Если балансы на счетах вначале равны 10, 20 и 30
долларам, то после любого количества параллельных обменов балансы должны
по прежнему быть 10, 20 и 30, в каком-то порядке. Сериализации доступа к
отдельным счетам недостаточно, чтобы это гарантировать.
См. @ref{Упражнение 3.43}.} Чтобы добиться правильного
поведения, мы должны устроить так, чтобы процедура @code{exchange}
блокировала всякий параллельный доступ к счетам на все время обмена.

Один из способов этого достичь --- сериализовать всю процедуру
@code{exchange} сериализаторами обоих счетов. Ради этого мы откроем
доступ к сериализаторам счетов. Обратите внимание, что, раскрывая
сериализатор, мы намеренно ломаем модульное построение
объекта-банковского счета. Следующая версия процедуры
@code{make-account} идентична исходной версии из @ref{}, за исключением
того, что имеется сериализатор для защиты переменной баланса, и он
экспортируется через передачу сообщений:

@lisp
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
@end lisp

\enlargethispage{\baselineskip}

@noindent
С помощью этой версии мы можем выполнять сериализованное занесение и
снятие денег. Заметим, однако, что, в отличие от предыдущей версии
сериализованного счета, теперь каждый пользователь объектов-банковских
счетов должен явным образом управлять сериализацией, например,
так:@footnote{В @ref{Упражнение 3.45} рассматривается
вопрос, почему занесение и снятие денег теперь не сериализуются счетом
автоматически.}

@lisp
(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
@end lisp

@noindent
Экспорт сериализатора дает нам достаточно гибкости, чтобы реализовать
сериализованную программу обмена. Мы просто-напросто сериализуем
исходную процедуру @code{exchange} сериализаторами обоих счетов:

@lisp
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.43}Упражнение 3.43:}
Предположим, что значения баланса на трех счетах вначале
равны 10, 20 и 30 долларам, и что несколько процессов занимаются обменом
значений баланса. Покажите, что если эти процессы выполняются
последовательно, то после любого количества обменов значения баланса
по-прежнему будут равны 10, 20 и 30 долларам, в каком-то порядке.
Нарисуйте временную диаграмму вроде той, которая изображена на
рис. @ref{Рисунок 3.29}, и покажите, что указанное условие может
нарушаться, если работает первая версия процедуры обмена из этого
раздела. Покажите, с другой стороны, что даже с первой программой
@code{exchange} общая сумма балансов на счетах сохранится. Нарисуйте
временную диаграмму, показывающую, что если бы мы не сериализовали
транзакции по отдельным счетам, это условие тоже могло бы нарушаться.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.44}Упражнение 3.44:}
Рассмотрим задачу переноса денег с одного счета на другой.
Бен Битобор утверждает, что ее можно решить с помощью следующей
процедуры, даже в тех случаях, когда много людей одновременно перемещают
деньги между различными счетами, если использовать при этом какой-то
механизм, сериализующий операции занесения на счет и снятия со счета,
например, версию @code{make-account} из нашего текста.

@lisp
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
@end lisp

Хьюго Дум считает, что с этой версией возникнут проблемы и что нужно
использовать более сложный подход, вроде того, который требуется при
решении задачи обмена. Прав ли он? Если нет, то в чем состоит
существенная разница между задачей перевода денег и задачей обмена
счетов? (Нужно предположить, что значение баланса на @code{from-account}
по крайней мере равно @code{amount}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.45}Упражнение 3.45:}
Хьюго Дум полагает, что теперь, когда операции снятия денег
со счета и занесения их на счет перестали сериализовываться
автоматически, система банковских счетов стала неоправданно сложной и
работать с ней правильным образом чересчур трудно. Он предлагает сделать
так, чтобы @code{make-account-and-serializer} экспортировал сериализатор
(для использования в процедурах вроде @code{serialized-exchange}), и
вдобавок сам использовал его для сериализации простых операций со
счетом, как это делал @code{make-account}. Он предлагает переопределить
объект-счет так:

@smalllisp
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount)) balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
@end smalllisp

Then deposits are handled as with the original @code{make-account}:

@lisp
(define (deposit account amount)
  ((account 'deposit) amount))
@end lisp

Объясните, в чем Хьюго ошибается. В частности, рассмотрите, что
происходит при вызове @code{serialized-exchange}.
@end quotation

@comment @subsubheading Implementing serializers
@subsubheading Реализация сериализаторов

Мы реализуем сериализаторы на основе более примитивного механизма
синхронизации, называемого (@newterm{mutex}). Мьютекс --- это объект, который
поддерживает две операции: его можно (@newterm{acquire}), и его можно (@newterm{release}).
Когда мьютекс захвачен, никакая другая операция захвата того же самого
мьютекса произойти не может, пока его не освободят.@footnote{Название
<<мьютекс>> происходит от английского <<взаимное исключение>>. Общая
проблема построения механизма, который позволил бы параллельным
процессам безопасно разделять ресурсы, называется проблемой взаимного
исключения. Наши мьютексы являются простым вариантом механизма
(@newterm{semaphores}) (см. упражнение @ref{Упражнение 3.47}), которые впервые
появились в Системе Мультипрограммирования THE, разработанной в
Эйндховенском Техническом Университете и названной по первым буквам
голландского названия этого учебного заведения (Dijkstra 1968a).
Операции захвата и освобождения изначально назывались P и V, от
голландских глаголов @emph{passeren} (пройти) и @emph{vrijgeven}
(освободить), употребляемых по отношению к семафорам на железных
дорогах. Классическое описание Дейкстры (Dijkstra 1968b) было одним из
первых ясных изложений вопросов управления параллелизмом, и там было
показано, как решаются при помощи семафоров различные задачи.} В нашей
реализации каждый сериализатор содержит по мьютексу. Получая процедуру
@code{p}, сериализатор возвращает процедуру, которая захватывает
мьютекс, выполняет @code{p}, и затем освобождает мьютекс. Благодаря
этому, только одна из процедур, порожденных сериализатором, может
исполняться в каждый момент времени. Именно такого поведения мы и хотели
добиться от сериализации.

@lisp
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
@end lisp

@noindent
Мьютекс --- изменяемый объект (здесь мы используем одноэлементный
список, который будем называть (@newterm{cell)}), способный хранить значение
истина или ложь. Когда значение ложно, мьютекс можно захватывать. Когда
значение истинно, мьютекс недоступен, и процесс, который попытается его
захватить, вынужден будет ждать.

Конструктор мьютекса @code{make-mutex} для начала присваивает
содержимому ячейки значение ложь. Для захвата мьютекса мы проверяем
значение ячейки. Если мьютекс доступен, мы делаем значение истинным и
идем дальше. Если нет, мы входим в цикл ожидания, все время пытаясь
захватить мьютекс, пока он не окажется свободным.@footnote{В большинстве
систем разделения времени процессы, блокированные на мьютексе, не тратят
время в <<занятом ожидании>>, как это описано здесь. Вместо этого
система назначает на исполнение другой процесс, пока первый ждет, а
когда мьютекс освобождается, она будит заблокированный процесс.} Чтобы
освободить мьютекс, мы присваиваем значению ячейки ложь.

@lisp
(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) @r{; retry}
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell) (set-car! cell false))
@end lisp

@noindent
@code{test-and-set!} проверяет ячейку и возвращает результат проверки.
Помимо того, если значение было ложным, @code{test-and-set!}
устанавливает значение в истину, прежде чем вернуть ложь. Мы можем
описать это поведение так:

@lisp
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))
@end lisp

@noindent
Однако эта реализация @code{test-and-set!}, как она есть, не годится.
Здесь есть важная тонкость, и именно здесь управление параллелизмом
становится частью системы: операция @code{test-and-set!} должна
производиться (atomically). Это значит, что мы должны гарантировать, что
когда процесс протестировал ячейку и убедился, что ее значение ложь,
значение будет установлено в истину прежде, чем какой-либо еще процесс
успеет проверить ячейку. Если мы такую гарантию не обеспечим, мьютекс
может сломаться таким же образом, как банковский счет на @ref{Рисунок 3.29}.)

Реализация @code{test-and-set!} зависит от того, как наша система на
самом деле управляет параллельными процессами. Например, мы можем
выполнять параллельные процессы на последовательном процессоре при
помощи механизма разделения времени, который перебирает процессы по
очереди, дает каждому из них выполняться в течение небольшого промежутка
времени, а затем прерывает его и переходит к следующему процессу. В
таком случае @code{test-and-set!} может запрещать смену процесса в
момент между проверкой и присваиванием.@footnote{В MIT Scheme на
однопроцессорной системе можно реализовать @code{test-and-set!}
следующим образом:

@smalllisp
(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
@end smalllisp

@noindent
@code{without-interrupts} запрещает прерывания по таймеру, пока
выполняется его процедурный аргумент.} С другой стороны, в
многопроцессорных компьютерах бывают команды, которые обеспечивают
атомарные операции прямо на уровне аппаратуры.@footnote{Есть много
вариантов таких команд --- включая проверку-и-установку,
проверку-и-сброс, обмен, сравнение-и-обмен, загрузку с резервированием и
условную запись, --- и их форма должна точно соответствовать интерфейсу
между процессором и памятью в данной машине. Один из возникающих
вопросов состоит в том, что происходит, когда два процесса пытаются
получить один и тот же ресурс в точности одновременно при помощи такой
команды. Тут требуется какой-то механизм, принимающий решение, который
из процессов получает управление. Такой механизм называется (arbiter).
Обычно арбитры представляют собой аппаратные устройства. К сожалению,
можно доказать, что нельзя построить справедливого арбитра, работающего
в 100% случаев, если не позволять арбитру принимать решение
неопределенно долгое время. Сущность этого явления была открыта
французским философом XIV века Жаном Буриданом в комментарии к @i{De
caelo} Аристотеля. Буридан указал, что идеально разумная собака,
помещенная между двумя одинаково привлекательными кусками еды, должна
умереть от голода, поскольку она не сможет решить, к какому куску идти в
первую очередь.}

@quotation
@strong{@anchor{Упражнение 3.46}Упражнение 3.46:}
Допустим, что мы реализуем @code{test-and-set} в виде
обыкновенной процедуры, как показано в тексте, не пытаясь сделать ее
атомарной. Нарисуйте временную диаграмму, подобную диаграмме на
рис. @ref{Рисунок 3.29}, и покажите, как реализация мьютекса может
ошибиться и позволить двум процессам одновременно захватить мьютекс.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.47}Упражнение 3.47:}
Семафор (размера @math{n}) представляет собой обобщение
мьютекса. Подобно мьютексу, семафор поддерживает операции захвата и
освобождения, но захватить его одновременно могут до @math{n} процессов.
Прочие процессы, которые попытаются захватить семафор, должны будут
ждать освобождения. Дайте реализацию семафоров

@enumerate a.

@item
в терминах мьютексов.

@item
в терминах атомарных операций @code{test-and-set!}.

@end enumerate
@end quotation

@comment @subsubheading Deadlock
@subsubheading Тупик

Теперь, когда мы рассмотрели, как реализуются сериализаторы, мы
убеждаемся, что с обменом счетов по-прежнему связаны проблемы, даже с
вышеописанной процедурой @code{serialized-exchange}. Допустим, что Петр
хочет обменять @math{a1} и @math{a2}, а Павел в то же время пытается
обменять @math{a2} и @math{a1}. Допустим, что процесс Петра доходит до
некоторой точки внутри сериализованной процедуры, защищающей @math{a1},
и сразу вслед за этим процесс Павла входит в сериализованную процедуру,
защищающую @math{a2}. Теперь Петр не может двигаться дальше (ему надо
войти в сериализованную процедуру для @math{a2}), пока Павел не выйдет
из сериализованной процедуры для @math{a2}. Точно так же Павел не может
двигаться дальше, пока Петр не выйдет из сериализованной процедуры для
@math{a1}. Оба процесса замирают навеки в ожидании друг друга. Такая
ситуация называется (deadlock). В любой системе, которая предоставляет
доступ к множественным разделяемым ресурсам, существует опасность
тупика.

В этой ситуации можно избежать тупика, если присвоить каждому счету
уникальный идентификационный номер, и переписать
@code{serialized-exchange} так, чтобы процесс всегда пытался сначала
войти в процедуру, которая защищает счет с наименьшим номером. Хотя для
задачи обмена это решение работает хорошо, бывают и другие ситуации, в
которых требуются более развитые методы избежания тупиков, или где
тупика нельзя избежать в принципе.  (См. @ref{Упражнение 3.48} и
@ref{Упражнение 3.49}.)@footnote{Общий метод избежания тупиков путем
нумерации разделяемых ресурсов и захвата их по порядку придумал
Хейвендер (Havender 1968). В ситуациях, где тупика нельзя избежать,
нужны меры по (deadlock recovery), когда от процессов требуется
<<откатиться>> из тупикового состояния и повторить попытку. Механизмы
выхода из тупика широко используются в системах управления базами
данных. Эта тема детально рассматривается у Грея и Рейтера (Gray and
Reuter 1993).}

@quotation
@strong{@anchor{Упражнение 3.48}Упражнение 3.48:}
Подробно объясните, почему метод избежания тупиков,
описанный выше (т. е. счета нумеруются, и каждый процесс сначала
пытается захватить счет с меньшим номером), в самом деле позволяет
избежать тупика в задаче обмена балансов. Перепишите
@code{serialized-exchange} с использованием этой идеи. (Придется также
изменить @code{make-account}, так, чтобы каждый счет создавался вместе с
номером, и чтобы этот номер можно было считать, послав соответствующее
сообщение.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.49}Упражнение 3.49:}
Опишите сценарий, в котором вышеописанный механизм
избежания тупиков не работает. (Подсказка: в задаче обмена счетов каждый
процесс заранее знает, к каким счетам ему нужен будет доступ.
Рассмотрите ситуацию, в которой процессу нужно сначала получить доступ к
каким-то разделяемым ресурсам, прежде чем он сможет определить, какие
ресурсы ему потребуются дополнительно.)
@end quotation

@comment @subsubheading Concurrency, time, and communication
@subsubheading Параллелизм, время и взаимодействие

Мы видели, что для программирования параллельных систем, когда различные
процессы имеют доступ к разделяемому состоянию, необходимо управление
порядком событий, и мы видели, как можно добиться нужного порядка с
помощью надлежащего использования сериализаторов. Однако проблемы
параллелизма лежат глубже, поскольку, с фундаментальной точки зрения, не
всегда ясно, что имеется в виду под <<разделяемым состоянием>>.

Механизмы вроде @code{test-and-set!} требуют, чтобы процессы в
произвольные моменты времени имели доступ к глобальному разделяемому
флагу. На современных высокоскоростных процессорах это реализуется
сложно и неэффективно, поскольку, благодаря средствам оптимизации вроде
конвейеров и кэширования памяти, содержимое памяти не обязательно должно
в каждый момент находиться в непротиворечивом состоянии. Из-за этого в
современных многопроцессорных системах идея сериализаторов вытесняется
новыми подходами к управлению параллелизмом.@footnote{Один из подходов,
альтернативных сериализации, называется (@newterm{barrier synchronization}).
Программист позволяет параллельным процессам выполняться как угодно, но
устанавливает определенные точки синхронизации (<<барьеры>>), так что ни
один процесс не может продолжаться, пока все они не достигли барьера.
Современные процессоры обладают машинными командами, которые позволяют
программистам устанавливать точки синхронизации там, где требуется иметь
непротиворечивое состояние. Например, в Power PC
имеются две предназначенные для этого команды: SYNC и EIEIO (Enforced
In-Order Execution of Input-Output, Гарантированно Последовательное
Исполнение Ввода-Вывода).}

Кроме того, проблемы с разделяемым состоянием возникают в больших
распределенных системах. Например, рассмотрим распределенную банковскую
систему, в которой отдельные местные банки поддерживают собственные
значения баланса счетов и время от времени сравнивают их со значениями,
хранимыми в других местах. В такой системе значение <<баланс счета>> не
будет определенным ни в какой момент, кроме как сразу после
синхронизации. Если Петр вносит деньги на счет, который он делит с
Павлом, когда мы должны считать, что баланс изменился, --- когда
меняется баланс в местном банке или только после синхронизации? А если
Павел обращается к счету через другую ветвь системы, какие ограничения
нужно наложить на банковскую систему, чтобы ее поведение считалось
<<правильным>>? Единственное, что может иметь значение для определения
<<правильности>>, --- это поведение, которое Павел и Петр наблюдают по
отдельности, и состояние счета сразу после синхронизации. Вопросы о
<<настоящем>> значении баланса или порядке событий между синхронизациями
могут не иметь значения или даже смысла.@footnote{Такая точка зрения
может казаться странной, но при этом существуют системы, которые именно
так и работают. Изменения на счетах, связанных с кредитными картами,
например, обычно поддерживаются отдельно в каждой стране, а изменения в
различных странах согласовываются время от времени. Таким образом,
баланс на счете может быть различным в различных странах.}

Общее в этих проблемах то, что синхронизация различных процессов,
установление общего состояния и управление порядком событий требуют
взаимодействия процессов. В сущности, любое понятие времени при
управлении параллельными процессами должно быть прочно привязано к
взаимодействию процессов.@footnote{Для распределенных систем эта точка
зрения исследовалась Лэмпортом (Lamport 1978). Он показал, как при
помощи взаимодействия установить <<глобальные часы>>, через которые
можно управлять порядком событий в распределенных системах.} Любопытно,
что похожая связь между временем и обменом информацией возникает в
теории относительности, где скорость света (самого быстрого сигнала,
который можно использовать для синхронизации событий) служит
универсальной константой, связывающей пространство и время. Сложности, с
которыми мы сталкиваемся при работе с временем и состоянием в
вычислительных моделях, могут на самом деле отражать фундаментальную
сложность физического мира.

@comment @section Streams
@section Потоки
@node 3.5,  , 3.4, Chapter 3

Теперь у нас есть ясное понимание того, как присваивание может служить
инструментом моделирования, а также понятие о сложности проблем,
связанных с ним. Пора задать вопрос, нельзя ли организовать работу иначе
и избежать части этих проблем. В этом разделе мы исследуем
альтернативный подход к моделированию состояния, основанный на
структурах данных, называемых (@newterm{streams}). Как нам предстоит убедиться,
потоки могут смягчить некоторые трудности в моделировании состояния.

Давайте сделаем шаг назад и рассмотрим еще раз, откуда происходят эти
сложности. Пытаясь моделировать явления реального мира, мы приняли
несколько, казалось бы, разумных решений: мы моделировали объекты
внешнего мира, обладающие состоянием, при помощи вычислительных объектов
с внутренними переменными. Мы отождествили течение времени в мире с
течением времени в компьютере. Мы имитировали на компьютере изменение
состояния моделируемых объектов при помощи присваивания внутренним
переменным объектов-моделей.

Возможен ли другой подход? Можно ли избежать отождествления времени в
компьютере с временем в моделируемом мире? Должны ли мы заставить модель
изменяться во времени, чтобы смоделировать явления изменяющегося мира?
Давайте подумаем об этом в терминах математических функций. Можно
описать изменение во времени величины @math{x} с помощью функции
@math{x(t)}, где время выступает как аргумент. Если мы сосредотачиваем
внимание на @math{x} момент за моментом, мы думаем об изменяющейся
величине. Однако если мы обращаем внимание на всю хронологию значений,
мы не подчеркиваем изменение --- функция сама по себе не
изменяется.@footnote{Физики иногда принимают эту точку зрения, вводя
<<мировые линии>> частиц в рассуждениях о движении. Кроме того, мы уже
упоминали (в @ref{2.2.3}),
что это естественный ход мысли при рассужднениях о системах обработки
сигналов. Мы рассмотрим приложение потоков к обработке сигналов в
@ref{3.5.3}.}

Если время измеряется дискретными интервалами, мы можем смоделировать
функцию времени как последовательность (возможно, бесконечную). В этом
разделе мы увидим, как моделировать изменение в виде
последовательностей, которые представляют картины изменения во времени
систем, подвергаемых моделированию. С этой целью мы вводим новую
структуру данных, называемую (@newterm{stream}). С абстрактной точки зрения, поток
--- это просто последовательность. Однако, как мы увидим, прямое
представление потоков в виде списков (как в @ref{2.2.1}) не
полностью раскрывает мощь работы с потоками. В качестве альтернативы мы
введем метод (@newterm{delayed evaluation}), который позволит нам представлять
очень большие (даже бесконечные) последовательности в виде потоков.

Работа с потоками позволяет моделировать системы, обладающие состоянием,
совершенно не используя присваивание и изменяемые данные. Отсюда есть
важные следствия, как теоретические, так и практические, поскольку мы
приобретаем возможность строить модели, лишенные недостатков, связанных
с присваиванием. С другой стороны, парадигма потоков вызывает свои
собственные трудности, и вопрос, какой из методов моделирования ведет к
построению более модульных и легко поддерживаемых систем, остается
открытым.

@menu
* 3-5-1::            Потоки как задержанные списки
* 3-5-2::            Бесконечные потоки
* 3-5-3::            Использование парадигмы потоков
* 3-5-4::            Потоки и задержанное вычисление
* 3-5-5::            Модульность функциональных программ и модульность
                     объектов
@end menu

@comment @subsection Streams Are Delayed Lists
@subsection Потоки как задержанные списки
@node	3.5.1, 3.5.2, 3.5, 3.5

Как мы видели в @ref{2.2.3},
последовательности можно использовать как стандартные интерфейсы для
комбинирования программных модулей. Мы сформулировали мощные абстракции
для работы с последовательностями, такие как @code{map}, @code{filter} и
@code{accumulate}, с помощью которых можно описать широкий класс
действий одновременно коротко и изящно.

К сожалению, если представлять последовательности в виде списков, за это
изящество приходится расплачиваться чрезвычайной неэффективностью как с
точки зрения времени, так и с точки зрения объема памяти, который
требуется нашим вычислениям. Когда мы представляем операции над
последовательностями в виде трансформаций списков, программам приходится
на каждом шагу строить и копировать структуры данных (которые могут быть
громадными).

Чтобы понять, почему это так, сравним две программы для вычисления суммы
всех простых чисел на интервале. Первая программа написана в стандартном
итеративном стиле:@footnote{Мы предполагаем, что у нас имеется предикат
@code{prime?} (например, из @ref{1.2.6}), который проверяет, является ли
число простым.}

@lisp
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count)
             (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
@end lisp

@noindent
Вторая программа производит то же самое вычисление с помощью операций
над последовательностями из @ref{2.2.3}:

@lisp
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime?
                      (enumerate-interval a b))))
@end lisp

@noindent
Во время вычисления первая программа должна хранить только накапливаемую
сумму. Напротив, фильтр во второй программе не может начать тестировать,
пока @code{enumerate-interval} не создала полного списка чисел на
интервале. Фильтр порождает еще один список, который, в свою очередь,
передается @code{accumulate}, прежде, чем он сожмется в сумму. Первой
программе не требуется такого количества промежуточной памяти, --- мы
можем считать, что она просто проходит интервал снизу вверх, добавляя к
сумме каждое простое число, которое ей встретится.

Неэффективность использования списков становится болезненно очевидной,
если мы воспользуемся парадигмой последовательностей для вычисления
второго простого числа в интервале от 1000 до 1 000 000 при помощи
следующего выражения:

@lisp
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
@end lisp

@noindent
Это выражение находит второе простое число, однако на это затрачивается
возмутительное количество вычислительных ресурсов. Мы строим список из
почти миллиона целых чисел, фильтруем этот список, проверяя каждый его
элемент на простоту, а затем почти весь результат игнорируем. При более
традиционном программистском подходе мы бы чередовали перечисление и
фильтрацию, и остановились бы по достижении второго простого числа.

Потоки представляют собой прием, который дает возможность работать с
последовательностями и при этом ничего не терять на представлении
последовательностей в виде списков. Потоки сочетают лучшее из обоих
подходов: мы можем изящно формулировать программы в терминах операций с
последовательностями и при этом сохранять эффективность пошагового
вычисления. Основная идея состоит в том, чтобы строить список только
частично и передавать частично построенный список программе,
потребляющей поток. Если потребитель запросит доступ к той части потока,
которая еще не сконструирована, поток автоматически достроит ровно такую
часть себя самого, какая нужна, и сохранит таким образом иллюзию, что он
существует целиком. Другими словами, хотя программы будут писаться так,
как будто обрабатываются полные последовательности, мы так спроектируем
реализацию потоков, что построение потока будет автоматически и
незаметно для пользователя чередоваться с его использованием.

На первый взгляд, потоки --- это просто списки, у которых процедуры
работы с ними переименованы. Имеется конструктор, @code{cons-stream}, и
два селектора, @code{stream-car} и @code{stream-cdr}, причем выполняются
уравнения

@lisp
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
@end lisp

@noindent
Имеется специальный объект, @code{the-empty-stream}, который не может
быть результатом никакой операции @code{cons-stream}, и который можно
распознать процедурой @code{stream-null?}.@footnote{В реализации MIT
@code{the-empty-stream} совпадает с пустым списком @code{'()}, а
процедура @code{stream-null?} совпадает с @code{null?}.} Таким образом,
можно создавать и использовать потоки, точно так же, как списки, для
представления составных данных, организованных в виде последовательности.
В частности, можно построить потоковые аналоги операций со списками из
@ref{Глава 2},
таких, как @code{list-ref}, @code{map} и @code{for-each}:@footnote{Здесь
у Вас должно возникнуть беспокойство. То, что мы определяем столь
сходные процедуры для потоков и списков, показывает, что мы упускаем
некую глубинную абстракцию. К сожалению, чтобы использовать эту
абстракцию, нам нужно более точное управление процессом вычисления, чем
у нас сейчас есть. Мы подробнее обсудим этот вопрос в конце @ref{3.4.5}.
В @ref{4.2} мы разработаем среду, в которой списки и потоки объединяются.}

@lisp
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
@end lisp

@noindent
С помощью @code{stream-for-each} потоки можно печатать:

@lisp
(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))
@end lisp

@noindent
Чтобы заставить реализацию потоков автоматически и незаметно чередовать
построение потока с его использованием, мы сделаем так, чтобы @code{cdr}
потока вычислялся тогда, когда к нему обращается процедура
@code{stream-cdr}, а не тогда, когда поток создается процедурой
@code{cons-stream}. Такое проектное решение заставляет вспомнить
обсуждение рациональных чисел в @ref{2.1.2}, где мы
увидели, что можно приводить рациональные числа к наименьшему
знаменателю либо во время создания числа, либо во время обращения к
нему. Две реализации рациональных чисел предоставляют одну и ту же
абстракцию, однако наш выбор влияет на эффективность работы. Существует
подобная связь и между потоками и обычными списками. В качестве
абстракции данных потоки не отличаются от списков. Разница состоит в
том, когда вычисляются их элементы. В обычных списках и @code{car}, и
@code{cdr} вычисляются во время построения. У потоков @code{cdr}
вычисляется при обращении.

Наша реализация потоков основана на особой форме под названием
@code{delay}. Выполнение не вычисляет
@code{(delay @math{\langle}@var{выражение}@math{\rangle})},
а вместо этого возвращает так называемый (@newterm{delayed object}).
Мы можем считать, что это <<обещание>>
вычислить @code{выражение} когда-нибудь в будущем. В качестве пары к
@code{delay} имеется процедура @code{force}, которая берет задержанный
объект в качестве аргумента и вычисляет его --- фактически, заставляя
@code{delay} выполнить обещание. Ниже мы увидим, как можно реализовать
@code{delay} и @code{force}, но сначала давайте посмотрим, как с их
помощью строить потоки.

@code{cons-stream} --- это особая форма, такая, что

@lisp
(cons-stream @math{\langle}@var{a}@math{\rangle} @math{\langle}@var{b}@math{\rangle})
@end lisp

@noindent
эквивалентно

@lisp
(cons @math{\langle}@var{a}@math{\rangle} (delay @math{\langle}@var{b}@math{\rangle}))
@end lisp

@noindent
Это означает, что мы строим потоки при помощи пар. Однако вместо того,
чтобы поместить значение остатка потока в @code{cdr} пары, мы кладем
туда обещание вычислить остаток, если нас об этом попросят. Теперь можно
определить @code{stream-car} и @code{stream-cdr} как процедуры:

@lisp
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
@end lisp

@noindent
@code{stream-car} возвращает @code{car} пары. @code{stream-cdr} берет
@code{cdr} пары и вычисляет хранящееся там задержанное выражение, чтобы
получить остаток потока.@footnote{В отличие от @code{stream-car} и
@code{stream-cdr}, которые можно определить в виде процедур,
@code{cons-stream} обязан быть особой формой. Если бы он был процедурой,
то, согласно нашей модели вычислений, выполнение
@code{(cons-stream @math{\langle} a @math{\rangle} @math{\langle} b @math{\rangle})} автоматически
приводило бы к вычислению @emph{@math{\langle}b@math{\rangle}}, а именно
этого мы и не хотим. По этой же причине @code{delay} должен быть особой
формой, хотя @code{force} может оставаться обычной процедурой.}

@comment @subsubheading The stream implementation in action
@subsubheading Реализация потоков в действии

Чтобы посмотреть, как ведет себя эта реализация, давайте проанализируем
<<возмутительное>> вычисление с простыми числами, переформулированное
через потоки:

@lisp
(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval
                  10000 1000000))))
@end lisp

@noindent
Мы увидим, что теперь вычисления происходят эффективно.

Вначале зовется процедура @code{stream-enumerate-interval} с аргументами
1,000 и 1,000,000. @code{Stream-enumerate-interval} --- это потоковый
аналог процедуры @code{enumerate-interval} (@ref{2.2.3}):

@lisp
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
@end lisp

@noindent
и, таким образом, результат, возвращаемый
@code{stream-enumerate-interval}, сформированный @code{cons-stream}
внутри нее, равен@footnote{Показанные здесь числа на самом деле не
появляются в возвращаемом выражении. Возвращается исходное выражение
вместе с окружением, в котором переменным присвоены соответствующие
значения. Например, там, где напечатано число 10001, стоит
@code{(+ low 1)}, и переменная @code{low} связана со значением 10,000.}

@lisp
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
@end lisp

@noindent
А именно, @code{stream-enumerate-interval} возвращает поток,
представленный в виде пары, @code{car} которой равен 10,000, а @code{cdr}
является обещанием вычислить остаток интервала, когда попросят. Теперь
этот поток отфильтровывается на предмет поиска простых чисел с помощью
потокового аналога процедуры @code{filter} (@ref{2.2.3}):

@lisp
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter
                       pred
                       (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
@end lisp

@noindent
@code{stream-filter} проверяет @code{stream-car} потока (то есть
@code{car} пары, то есть 10000). Поскольку это не простое число,
@code{stream-filter} смотрит на @code{stream-cdr} своего входного
потока. Вызов @code{stream-cdr} приводит к вычислению задержанного
вызова @code{stream-enumerate-interval}, возвращающего

@lisp
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
@end lisp

@noindent
Теперь @code{stream-filter} смотрит на @code{stream-car} этого потока,
10,001, видит, что и это не простое число, снова зовет @code{stream-cdr}
и так далее, пока @code{stream-enumerate-interval} не выдаст простое
число 10007. Тогда @code{stream-filter}, в соответствии со своим
определением, вернет

@lisp
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
@end lisp

@noindent
что в данном случае равняется

@lisp
(cons 10007
      (delay (stream-filter
              prime?
              (cons 10008
                    (delay (stream-enumerate-interval
                            10009
                            1000000))))))
@end lisp

@noindent
Теперь этот результат передается в @code{stream-cdr} из нашего исходного
выражения. При этом вызывается задержанный @code{stream-filter},
который, в свою очередь, вынуждает задержанные вызовы
@code{stream-enumerate-interval}, пока не доберется до следующего
простого числа, а именно 10,009. Наконец, результат, передаваемый в
@code{stream-car} нашего исходного выражения, равен

@lisp
(cons 10009
      (delay (stream-filter
              prime?
              (cons 10010
                    (delay (stream-enumerate-interval
                            10011
                            1000000))))))
@end lisp

@noindent
@code{stream-car} возвращает 10,009, и вычисление закончено. На простоту
было проверено ровно столько чисел, сколько было необходимо, чтобы найти
второе простое число на интервале, и сам интервал был перебран только до
того места, которое было нужно фильтру простых чисел.

В общем, мы можем считать задержанные вычисления программированием,
<<управляемым потребностями>>, в котором каждый шаг вычислений в
потоковом процессе активизируется лишь настолько, насколько это нужно
для следующего шага. Таким образом, нам удалось отделить реальный
порядок событий при вычислении от внешней структуры процедур. Мы пишем
процедуры так, как будто потоки существуют <<все целиком>>, а на самом
деле вычисление происходит пошагово, как и при программировании в
традиционном стиле.

@comment @subsubheading Implementing @code{delay} and @code{force}
@subsubheading Реализация @code{delay} и @code{force}

@code{delay} и @code{force} могут казаться таинственными операциями, но
на самом деле их реализация весьма проста. @code{delay} должно упаковать
выражение так, чтобы потом его можно было выполнить по требованию, и мы
добиваемся этого, просто рассматривая выражение как тело процедуры.
Можно сделать @code{delay} особой формой, такой, чтобы

@lisp
(delay @math{\langle}@var{выражение}@math{\rangle})
@end lisp

@noindent
было синтаксическим сахаром для

@lisp
(lambda () @math{\langle}@var{выражение}@math{\rangle})
@end lisp

@noindent
@code{force} просто вызывает (безаргументную) процедуру, порожденную
@code{delay}, так что она может быть реализована как процедура

@lisp
(define (force delayed-object) (delayed-object))
@end lisp

@noindent
При такой реализации и @code{force} работают согласно описанию, однако к
ней можно добавить важную оптимизацию. Во многих приложениях мы
вынуждаем один и тот же задержанный объект по многу раз. В рекурсивных
программах с использованием потоков это может привести к существенной
неэффективности (см. упражнение @ref{Упражнение 3.57}). Решение
состоит в том, чтобы строить задержанные объекты так, чтобы при первом
вынуждении они сохраняли вычисленное значение. Последующие обращения
будут просто возвращать сохраненное значение без повторения вычислений.
Другими словами, мы реализуем @code{delay} как особого рода
мемоизированную процедуру, подобную описанным в
упражнении @ref{Упражнение 3.27}. Один из способов этого добиться ---
использовать следующую процедуру, которая принимает процедуру (без
аргументов) и возвращает ее мемоизированную версию. При первом вызове
мемоизированная процедура сохраняет результат. При последующих вызовах
она просто его возвращает.

@lisp
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
@end lisp

@noindent
Теперь можно определить @code{delay} таким образом, что
@code{(delay @math{\langle}@var{выражение}@math{\rangle})} равносильно

@lisp
(memo-proc (lambda () @math{\langle}@var{exp}@math{\rangle}))
@end lisp

@noindent
а определение @code{force} не меняется.@footnote{Есть много возможных
реализаций потоков помимо описанной в этом разделе. Задержанное
вычисление, ключевой элемент, который делает потоки практически
полезными, было частью метода передачи параметров @emph{по имени} (by
name) в языке Алгол-60. Использование этого механизма для реализации
потоков впервые было описано Ландином (Landin 1965). Задержанное
вычисление для потоков ввели в Лисп Фридман и Уайз (Friedman and Wise
1976). В их реализации @code{cons} всегда задерживает вычисление своих
аргументов, так что списки автоматически ведут себя как потоки.
Мемоизирующая оптимизация известна также как (@newterm{call-by-need}).
В сообществе программистов на Алголе задержанные объекты из нашей первой
реализации назывались бы (@newterm{call-by-name thunks}), а
оптимизированный вариант (@newterm{call-by-need thunks}).}

@quotation
@strong{@anchor{Упражнение 3.50}Упражнение 3.50:}
Закончите следующее определение, которое обобщает процедуру
@code{stream-map}, чтобы она позволяла использовать процедуры от
нескольких аргументов, подобно @code{map} из @ref{2.2.1}, сноска @ref{Сноска 2.12}.

@lisp
(define (stream-map proc . argstreams)
  (if (@math{\langle}??@math{\rangle} (car argstreams))
      the-empty-stream
      (@math{\langle}??@math{\rangle}
       (apply proc (map @math{\langle}??@math{\rangle} argstreams))
       (apply stream-map
              (cons proc (map @math{\langle}??@math{\rangle} argstreams))))))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.51}Упражнение 3.51:}
Чтобы внимательнее изучить задержанные вычисления, мы
воспользуемся следующей процедурой, которая печатает свой аргумент, а
затем возвращает его:

@lisp
(define (show x)
  (display-line x)
  x)
@end lisp

Что печатает интерпретатор в ответ на каждое выражение из следующей
последовательности?@footnote{Упражнения типа @ref{Упражнение 3.51} и
@ref{Упражнение 3.52} помогают понять, как работает @code{delay}. С
другой стороны, смешение задержанного вычисления с печатью --- или, хуже
того, с присваиванием, --- ужасно запутывает, и преподаватели, читающие
курсы по языкам программирования, часто пытают студентов
экзаменационными вопросами вроде упражнений из этого раздела. Незачем и
говорить, что писать программы, зависящие от таких тонкостей, ---
показатель чрезвычайно плохого стиля. Отчасти мощность потокового
программирования в том и заключается, что можно игнорировать порядок, в
котором на самом деле происходят события в программах. К сожалению,
ровно этого мы и не можем себе позволить в присутствии присваивания,
заставляющего нас думать о времени и изменении.}

@lisp
(define x
  (stream-map show
              (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.52}Упражнение 3.52:}
Рассмотрим последовательность выражений

@lisp
(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
(stream-ref y 7)
(display-stream z)
@end lisp

Каково значение @code{sum} после вычисления каждого из этих выражений?
Что печатается при вычислении выражений @code{stream-ref} и
@code{display-stream}? Изменился бы этот результат, если бы мы
реализовали @code{(delay @math{\langle}@var{выражение}@math{\rangle})}
просто как @code{(lambda () @math{\langle}@var{выражение}@math{\rangle})},
не применяя оптимизацию через @code{memo-proc}? Объясните свой ответ.
@end quotation

@comment @subsection Infinite Streams
@subsection Бесконечные потоки
@node	3.5.2, 3.5.3, 3.5.1, 3.5

Мы видели, как можно поддерживать иллюзию работы с потоками как с
цельными объектами, хотя на самом деле мы вычисляем только ту часть
потока, к которой нам требуется доступ. Этот метод можно использовать,
чтобы эффективно представлять последовательности в виде потоков, даже
если эти последовательности весьма длинны. Еще удивительнее то, что при
помощи потоков можно представлять последовательности бесконечной длины.
Рассмотрим, например, следующее определение потока положительных целых
чисел:

@lisp
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
@end lisp

@noindent
Такая запись имеет смысл, потому что описывает @code{integers} как пару,
у которой @code{car} равен 1, а @code{cdr} является обещанием породить
целые числа, начиная с 2. Такой поток бесконечен, но в любой данный
момент мы можем работать только с конечной его частью. Таким образом,
наши программы никогда не узнают, что целиком бесконечного потока не
существует.

При помощи @code{integers} можно определять другие бесконечные потоки,
например, поток чисел, не делящихся на 7:

@lisp
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
@end lisp

@noindent
Теперь мы можем искать числа, не делящиеся на 7, просто обращаясь к
элементам этого потока:

@lisp
(stream-ref no-sevens 100)
@i{117}
@end lisp

@noindent
По аналогии с @code{integers}, можно определить бесконечный поток чисел
Фибоначчи:

@lisp
(define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
(define fibs (fibgen 0 1))
@end lisp

@noindent
@code{fibs} представляет собой пару, @code{car} которой равен 0, а
@code{cdr} является обещанием вычислить @code{(fibgen 1 1)}. Когда мы
выполняем это задержанное @code{(fibgen 1 1)}, оно порождает пару, где
@code{car} равен 1, а в @code{cdr} лежит обещание вычислить
@code{(fibgen 1 2)}, и так далее.

Чтобы продемонстрировать пример более интересного потока, можно обобщить
@code{no-sevens} и построить бесконечный поток простых чисел, используя
метод, известный как (@newterm{sieve of Eratosthenes}).@footnote{Эратосфен,
греческий философ третьего века до н. э. из Александрии, знаменит тем,
что он дал первую верную оценку длины окружности Земли, которую он
вычислил, наблюдая тени, отбрасываемые в полдень летнего солнцестояния.
Метод решета Эратосфена, несмотря на свою древность, лежал в основе
специальных аппаратных устройств-<<решет>>, которые до недавних пор были
самыми мощными устройствами для поиска простых чисел. Однако начиная с
70-х годов такие устройства были вытеснены развитием вероятностных
методик, обсуждаемых в @ref{1.2.6}.}
Сначала мы строим поток чисел, начиная с 2, первого простого числа. Для
того, чтобы найти остальные простые числа, мы фильтруем кратные двойки
из потока остальных чисел. Получается поток, который начинается с 3,
следующего простого числа. Теперь из остатка потока мы фильтруем числа,
кратные 3. Получается поток, начинающийся с 5, следующего простого, и
так далее. Другими словами, мы строим простые числа с помощью
просеивающего процесса, описываемого так: чтобы просеять поток @math{S},
нужно сформировать поток, в котором первый элемент совпадает с первым
элементом @math{S}, а остаток получается фильтрацией множителей первого
элемента из оставшейся части @math{S} и просеивания того, что получится.
Такой процесс нетрудно описать в терминах операций над потоками:

@lisp
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))
@end lisp

@noindent
Теперь, чтобы найти определенное простое число, надо только попросить:

@lisp
(stream-ref primes 50)
@i{233}
@end lisp

@noindent
Интересно представить себе систему обработки сигналов, соответствующую
@code{sieve}, показанную на <<хендерсоновской диаграмме>> на
@ref{Рисунок 3.31}.@footnote{Мы назвали этот способ
изображения потоков в честь Питера Хендерсона, который первым показал
нам диаграммы такого вида как способ рассуждений об обработке потоков.
Сплошные линии представляют потоки передаваемых сигналов. Прерывистая
линия от @code{car} к @code{cons} и @code{filter} указывает, что здесь
передается не поток, а единичное значение.} Входной поток попадает в
<<рас@code{cons}ер>>, который отделяет первый элемент потока от его
хвоста. При помощи первого элемента строится фильтр на делимость, и
через него пропускается остаток входного потока, а выход запускается в
еще один элемент @code{sieve}. Затем исходный первый элемент сочетается
при помощи @code{cons} с выходом внутреннего @code{sieve}, и получается
выходной поток. Таким образом, не только входной поток бесконечен, но и
обработчик сигналов также бесконечен, поскольку одно решето содержит в
себе другое.

@float
@c @quotation
@anchor{Рисунок 3.31}
@ifinfo
@strong{Рисунок 3.31:} The prime sieve viewed as a signal-processing system.

@example
  +---------------------------------------------------------------+
  | sieve                                                         |
  |                                                               |
  |        __/|                                        |\__       |
  |     __/car|........................................|   \__    |
  |   _/      |           :                            |      \_  |
----><_       |           V                            |  cons _>---->
  |    \__    |    +------------+    +------------+    |    __/   |
  |       \cdr|--->| filter:    |    | sieve      |--->| __/      |
  |          \|    |            |--->|            |    |/         |
  |                | not        |    |            |               |
  |                | divisible? |    |            |               |
  |                +------------+    +------------+               |
  +---------------------------------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.31,111mm,,,.pdf}
@sp 0.7
@center @caption{@strong{Рисунок 3.31:} The prime sieve viewed as a signal-processing system.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@comment @subsubheading Defining streams implicitly
@subsubheading Неявное определение потоков

Потоки @code{integers} и @code{fibs} были определены при помощи
<<порождающих>> процедур, которые явным образом вычисляют элементы
потока один за другим. Однако можно определять потоки неявно, пользуясь
задержанным вычислением. Например, следующее выражение определяет
@code{ones} как бесконечный поток, состоящий из одних единиц:

@lisp
(define ones (cons-stream 1 ones))
@end lisp

@noindent
Это выражение работает примерно так же, как рекурсивная процедура:
@code{ones} является парой, чей @code{car} есть 1, а @code{cdr}
представляет собой обещание вычислить @code{ones}. Обращение к
@code{cdr} дает нам снова 1 и обещание вычислить @code{ones}, и так далее.

Можно делать и более интересные вещи с помощью операций вроде
@code{add-streams}, которая порождает поэлементную сумму двух данных
потоков:@footnote{Здесь используется обобщенная версия @code{stream-map}
из упражнения @ref{Упражнение 3.50}.}

@lisp
(define (add-streams s1 s2) (stream-map + s1 s2))
@end lisp

@noindent
Теперь можно определить поток целых чисел следующим образом:

@lisp
(define integers
  (cons-stream 1 (add-streams ones integers)))
@end lisp

@noindent
Здесь @code{integers} определяются как поток, в котором первый элемент
1, а остаток равен сумме @code{ones} и @code{integers}. Таким образом,
второй элемент @code{integers} равен 1 плюс первый элемент
@code{integers}, то есть 2; третий элемент равен 1 плюс второй элемент
@code{integers}, то есть 3, и так далее. Это определение работает
потому, что в любой момент сгенерировано достаточно элементов потока
@code{integers}, чтобы мы могли обратиться к ним в определении и
породить следующий элемент.

В том же стиле можно определить числа Фибоначчи:

@lisp
(define fibs
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
@end lisp

@noindent
Это определение говорит, что @code{fibs} есть поток, начинающийся с 0 и
1, такой, что остаток потока порождается сложением @code{fibs} с собой
самим, сдвинутым на одну позицию:

@lisp
      1  1  2  3  5  8   13  21  @dots{}  =  @code{(stream-cdr fibs)}
      0  1  1  2  3  5   8   13  @dots{}  =  @code{fibs}
0  1  1  2  3  5  8  13  21  34  @dots{}  =  @code{fibs}
@end lisp

@noindent
Еще одна полезная процедура для подобных определений потоков ---
@code{scale-stream}. Она умножает каждый элемент потока на данную
константу:

@lisp
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream))
@end lisp

@noindent
Например,

@lisp
(define double (cons-stream 1 (scale-stream double 2)))
@end lisp

@noindent
порождает поток степеней двойки: 1, 2, 4, 8, 16, 32 @dots{}

Можно дать альтернативное определение потока простых чисел, начав с
потока целых чисел, и фильтруя его через проверку на простоту. Вначале
нам потребуется первое простое число, 2:

@lisp
(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
@end lisp

@noindent
Это определение не столь тривиально, как кажется, поскольку мы будем
проверять число @math{n} на простоту, проверяя, делится ли @math{n} на
простые числа (а не на все целые), меньшие или равные @math{\sqrt{n}}:

@lisp
(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
@end lisp

@noindent
Это рекурсивное определение, поскольку @code{primes} определяются
посредством предиката @code{prime?}, а он сам использует поток
@code{primes}. Работает эта процедура потому, что в любой момент имеется
достаточно элементов потока @code{primes} для проверки на простоту
следующего требуемого числа. А именно, при проверке @code{n} либо
оказывается не простым (а в таком случае имеется уже сгенерированное
простое число, на которое оно делится), либо оно простое (а в таком
случае, имеется уже сгенерированное простое число --- то есть, простое
число меньше @math{n}, --- большее @math{\sqrt{n}}.@footnote{Это тонкая
деталь, которая основана на том, что @math{p_{n+1} \le p_{n}^2} (Здесь
@math{p_k} обозначает @math{k}-е простое число.) Такие оценки достаточно
трудно доказать. Античное доказательство Евклида показывает, что имеется
бесконечное количество простых чисел, и что
@math{p_{n+1} \le p_1 p_2 \cdots p_n + 1}. Никакого существенно лучшего
результата не было найдено до 1851 года, когда русский математик
П. Л. Чебышев доказал, что для всех @math{n}, @math{p_{n+1} \le 2p_n}.
Предположение, что это так, было высказано в 1845 году и известно как
(Bertrand's hypothesis). Доказательство можно найти в разделе 22.3 в
книге Hardy and Wright 1960.}

@quotation
@strong{@anchor{Упражнение 3.53}Упражнение 3.53:}
Не запуская программу, опишите элементы потока, порождаемого

@lisp
(define s (cons-stream 1 (add-streams s s)))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.54}Упражнение 3.54:}
Определите процедуру @code{mul-streams}, аналогичную
@code{add-streams}, которая порождает поэлементное произведение двух
входных потоков. С помощью нее и потока @code{integers} закончите
следующее определение потока, @math{n}-й элемент которого (начиная с 0)
равен факториалу @math{n+1}:

@lisp
(define factorials
  (cons-stream 1 (mul-streams @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp
@c @noindent
@c @code{(define factorials (cons-stream 1 (mul-streams}@math{\kern0.7ex\langle}@code{?}@math{\rangle}@math{\kern0.7ex\langle}@code{?}@math{\rangle}@code{)))}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.55}Упражнение 3.55:}
Определите процедуру @code{partial-sums}, которая в
качестве аргумента берет поток @math{S}, а возвращает поток, элементы
которого равны @math{S_0, S_0 + S_1, S_0 + S_1 + S_2, \ldots}. Например,
@code{(partial-sums integers)} должно давать поток 1, 3, 6, 10, 15 @dots{}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.56}Упражнение 3.56:}
Существует знаменитая задача, впервые сформулированная
Р. Хэммингом: породить в возрастающем порядке и без повторений все
положительные целые числа, у которых нет других простых делителей, кроме
2, 3 и 5. Очевидное решение состоит в том, чтобы перебирать все
натуральные числа по очереди и проверять, есть ли у них простые
множители помимо 2, 3 и 5. Однако эта процедура весьма неэффективна,
поскольку чем больше числа, тем меньшая их доля соответствует условию.
Применим альтернативный подход: назовем искомый поток чисел @code{S} и
обратим внимание на следующие факты:

@itemize @bullet

@item
@code{S} начинается с 1.

@item
Элементы @code{(scale-stream S 2)} также принадлежат @code{S}

@item
То же верно и для @code{(scale-stream S 3)} и @code{(scale-stream S 5)}.

@item
Других элементов @code{S} нет.

@end itemize

Теперь требуется только соединить элементы из этих источников. Для этого
мы определяем процедуру @code{merge}, которая сливает два упорядоченных
потока в один упорядоченный поток, убирая при этом повторения:

@lisp
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream
                   s2car
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))
@end lisp

Тогда требуемый поток можно получить с помощью @code{merge} таким
образом:

@lisp
(define S (cons-stream 1 (merge @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp

Заполните пропуски в местах, обозначенных знаком @math{\langle}??@math{\kern0.08em\rangle}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.57}Упражнение 3.57:}
Сколько сложений происходит при вычислении @math{n}-го
числа Фибоначчи, в случае, когда мы используем определение @math{fibs}
через процедуру @code{add-streams}? Покажите, что число сложений выросло
бы экспоненциально, если бы мы реализовали
@code{(delay @math{\langle}@var{выражение}@math{\rangle})} просто как
@code{(lambda () @math{\langle}@var{выражение}@math{\rangle})}, без
оптимизации через процедуру @code{memo-proc} из @ref{3.5.1}.@footnote{Это
упражнение показывает, как близко связан вызов по необходимости с обычной
мемоизацией, описанной в @ref{Упражнение 3.27}. В этом
упражнении мы при помощи присваивания явным образом создавали локальную
таблицу. Наша оптимизация с вызовом по необходимости, в сущности,
автоматически создает такую же таблицу, сохраняя значения в уже
размороженных частях потока.}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.58}Упражнение 3.58:}
Дайте интерпретацию потоку, порождаемому следующей процедурой:

@lisp
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
@end lisp

(Элементарная процедура @code{quotient} возвращает целую часть частного
двух целых чисел.) Каковы последовательные элементы потока, порожденного
выражением @code{(expand 1 7 10)}? Что дает вычисление @code{(expand 3 8 10)}?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.59}Упражнение 3.59:} В @ref{2.5.3} мы
увидели, как реализовать систему арифметики многочленов, используя
представление многочленов в виде списка термов. Подобным же образом
можно работать со (@newterm{power series}), например
@ifinfo

@example
               x^2     x^3       x^4
e^x = 1 + x + ----- + ----- + --------- + ...
                2     3 * 2   4 * 3 * 2

             x^2       x^4
cos x = 1 - ----- + --------- - ...
              2     4 * 3 * 2

             x^3         x^5
sin x = x - ----- + ------------- - ...
            3 * 2   5 * 4 * 3 * 2
@end example

@end ifinfo
@tex
$$
e^x = 1 + x + \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} + \dots,
$$
@end tex
@tex
$$
\cos x = 1 - \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} - \dots,
$$
@end tex
@tex
$$
\sin x = x - \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^5}{5 \cdot 4 \cdot 3 \cdot 2} - \dots
$$
@end tex
@noindent
представленными в виде бесконечных потоков. Будем
представлять последовательность
@math{a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots} как поток, элементами
которого являются коэффициенты @math{a_0, a_1, a_2, a_3 \ldots}

@enumerate a.

@item
Интеграл последовательности
@math{a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots} есть последовательность
@ifinfo

@example
             1             1             1
c + a_0 x + --- a_1 x^2 + --- a_2 x^3 + --- a_3 x^4 + ...
             2             3             4
@end example

@end ifinfo
@tex
$$ c + a_0 x + {1\over2} a_1 x^2 + {1\over3} a_2 x^3 + {1\over4} a_3 x^4 + \dots, $$
@end tex
@noindent
где @math{c} --- произвольная константа. Определите процедуру
@code{integrate-series}, которая на входе принимает поток
@math{a_0, a_1, a_2,\ldots}, представляющую степенной ряд, и возвращает
поток @math{a_0}, @math{{1\over2}a_1}, @math{{1\over3}a_2}, @dots{}
коэффициентов при неконстантных членах интеграла последовательности.
(Поскольку в результате отсутствует постоянный член, он не представляет
собой степенной ряд; при использовании @code{integrate-series} мы через
@code{cons} будем присоединять к началу соответствующую константу.)

@item
Функция @math{x \mapsto e^x} равна своей собственной производной. Отсюда
следует, что @math{e^x} и интеграл @math{e^x} суть одна и та же
последовательность, с точностью до постоянного члена, который равен
@math{e^0 = 1}. Соответственно, можно породить последовательность для
@math{e^x} через

@lisp
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
@end lisp

Покажите, как породить последовательности для синуса и косинуса,
опираясь на то, что производная синуса равна косинусу, а производная
косинуса равна минус синусу:

@lisp
(define cosine-series (cons-stream 1 @math{\langle}??@math{\rangle}))
(define sine-series (cons-stream 0 @math{\langle}??@math{\rangle}))
@end lisp
@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 3.60}Упражнение 3.60:}
Если степенной ряд представляется в виде потока своих
коэффициентов, как в упражнении @ref{Упражнение 3.59}, то сумма
последовательностей реализуется посредством @code{add-streams}.
Завершите определение следующей процедуры для перемножения
последовательностей:

@lisp
(define (mul-series s1 s2)
  (cons-stream @math{\langle}??@math{\rangle} (add-streams @math{\langle}??@math{\rangle} @math{\langle}??@math{\rangle})))
@end lisp

Можете проверить свою процедуру, убедившись, что
@math{\sin^2 x + \cos^2 x = 1} с помощью последовательностей из
@ref{Упражнение 3.59}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.61}Упражнение 3.61:} Пусть @math{S} будет
степенным рядом (упражнение @ref{Упражнение 3.59}) с постоянным членом 1.
Предположим, что мы хотим найти степенной ряд @math{1/S}, то есть такой ряд
@math{X}, что @math{S \cdot X = 1}. Запишем @math{S = 1 + S_R}, где
@math{S_R} --- часть @math{S} после постоянного члена. Тогда мы можем
решить уравнение для @math{X} так:
@ifinfo

@example
        S * X = 1
(1 + S_R) * X = 1
  X + S_R * X = 1
            X = 1 - S_R * X
@end example

@end ifinfo
@tex
$$
\begin{array}{r@{{}={}}l}
            S \cdot X 	& 1, \\
    (1 + S_R) \cdot X 	& 1, \\
      X + S_R \cdot X 	& 1, \\
                    X 	& 1 - S_R \cdot X.
\end{array}
$$
@end tex
Другими словами, @math{X} есть степенной ряд с постоянным
членом 1, чьи члены с более высокими степенями определяются как минус
произведение @math{S_R} и @math{X}. Воспользовавшись этим, напишите
процедуру @code{invert-unit-series}, которая вычисляет @math{1/S} для
степенного ряда @math{S} с постоянным членом 1. Вам потребуется
@code{mul-series} из упражнения @ref{Упражнение 3.60}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.62}Упражнение 3.62:}
При помощи результатов упражнений @ref{Упражнение 3.60} и
@ref{Упражнение 3.61} определите процедуру @code{div-series}, которая
делит один степенной ряд на другой. @code{Div-series} должна работать
для любых двух рядов, при условии, что ряд в знаменателе начинается с
ненулевого постоянного члена. (Если в знаменателе постоянный член равен
нулю, @code{div-series} должна сообщать об ошибке.) Покажите, как при
помощи @code{div-series} и результата упражнения @ref{Упражнение 3.59}
получить степенной ряд для тангенса.
@end quotation

@endpage
@comment @subsection Exploiting the Stream Paradigm
@subsection Использование парадигмы потоков
@node	3.5.3, 3.5.4, 3.5.2, 3.5

Потоки с задержкой вычисления могут служить мощным инструментом
моделирования. Они дают многие из преимуществ, обычно предоставляемых
внутренним состоянием и присваиванием. Более того, они избегают
некоторых из теоретических неудобств, связанных с введением присваивания
в язык программирования.

Потоковый метод может изменять взгляд на вещи, так как он позволяет
строить системы с другими границами модулей, не такими, как в системах,
основанных на присваивании переменным состояния. Например, можно
сосредоточивать внимание на всей временной последовательности (или
сигнале), а не на значении переменных состояния в отдельные моменты.
Оказывается удобно сочетать и сравнивать параметры состояния в различные
моменты времени.

@comment @subsubheading Formulating iterations as stream processes
@subsubheading Итерация как потоковый процесс

В @ref{1.21}
мы ввели понятие итеративного процесса, по мере исполнения изменяющего
переменные состояния. Теперь мы узнали, что можно представлять состояние
в виде <<вневременного>> потока значений, а не набора обновляемых
переменных. Давайте примем этот взгляд и заново рассмотрим процедуру
поиска квадратного корня из @ref{1.1.7}.
Напомним, что идея процедуры состояла в том, чтобы порождать
последовательность все лучших и лучших приближений к квадратному корню
@math{x}, снова и снова применяя процедуру улучшения гипотезы:

@lisp
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
@end lisp

@noindent
В исходной процедуре @code{sqrt} эти гипотезы были последовательными
значениями переменной состояния. Вместо этого можно породить бесконечный
поток гипотез, в голове которого стоит начальная гипотеза
1:@footnote{Внутреннюю переменную @code{guesses} нельзя связать с помощью
@code{let}, поскольку значение @code{guesses} зависит от нее самой. В
упражнении @ref{Упражнение 3.63} рассматривается вопрос, зачем здесь
нужна внутренняя переменная.}

@lisp
(define (sqrt-stream x)
  (define guesses
    (cons-stream
     1.0
     (stream-map (lambda (guess) (sqrt-improve guess x))
                 guesses)))
  guesses)

(display-stream (sqrt-stream 2))
@i{1.}
@i{1.5}
@i{1.4166666666666665}
@i{1.4142156862745097}
@i{1.4142135623746899}
@dots{}
@end lisp

@noindent
Можно порождать все больше элементов потока, получая все лучшие
приближения. Если нужно, можно написать процедуру, которая бы порождала
гипотезы до тех пор, пока ответ не окажется достаточно хорош.
(См. @ref{Упражнение 3.64}.)

Еще один итеративный процесс, который можно рассматривать подобным
образом --- аппроксимация числа @math{\pi}, основанная на
знакочередующемся ряде, упомянутом в @ref{Section 1.3.1}:
@ifinfo

@example
[pi]        1     1     1
---- = 1 - --- + --- - --- + ...
  4         3     5     7
@end example

@end ifinfo
@tex
$$ {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots. $$
@end tex
Сначала мы порождаем поток элементов ряда (числа, обратные нечетным
натуральным, с чередующимся знаком). Затем мы берем поток сумм все
большего количества элементов (при помощи процедуры @code{partial-sums}
из упражнения @ref{Упражнение 3.55}) и домножаем результат на 4:

@lisp
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

(display-stream pi-stream)
@i{4.}
@i{2.666666666666667}
@i{3.466666666666667}
@i{2.8952380952380956}
@i{3.3396825396825403}
@i{2.9760461760461765}
@i{3.2837384837384844}
@i{3.017071817071818}
@dots{}
@end lisp

@noindent
Получается поток все более точных приближений к @math{\pi}, но сходятся
эти приближения довольно медленно. Восемь членов последовательности
поместили @math{\pi} между 3.284 и 3.017.

Пока что подход с потоком состояний не слишком отличается от потока с
переменными состояния. Однако потоки дают нам возможность проделывать
некоторые интересные трюки. Например, поток можно преобразовать с
помощью (@newterm{sequence accelerator}), преобразующего последовательность
приближений в новую последовательность, которая сходится к тому же
значению, что и исходная, но быстрее.

Один такой ускоритель, открытый швейцарским математиком восемнадцатого
века Леонардом Эйлером, хорошо работает с последовательностями частичных
сумм знакочередующихся рядов (рядов, знаки элементов которых
чередуются). По методу Эйлера, если @math{S_n} есть @math{n}-й член
исходного ряда, то ускоренная последовательность имеет элементы
@ifinfo

@example
             (S_(n+1) - S_n)^2
S_(n+1) - ------------------------
          S_(n-1) - 2S_n + S_(n+1)
@end example

@end ifinfo
@tex
$$ S_{n+1} - {(S_{n+1} - S_n)^2 \over S_{n-1} - 2S_n + S_{n+1}}\,. $$
@end tex
Таким образом, если исходная
последовательность представлена как поток значений, преобразованная
последовательность дается процедурой

@lisp
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))     @r{; @math{S_{n-1}}}
        (s1 (stream-ref s 1))     @r{; @math{S_n}}
        (s2 (stream-ref s 2)))    @r{; @math{S_{n+1}}}
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
@end lisp

@noindent
Можно продемонстрировать ускорение Эйлера на нашей последовательности
приближений к @math{\pi}:

@lisp
(display-stream (euler-transform pi-stream))
@i{3.166666666666667}
@i{3.1333333333333337}
@i{3.1452380952380956}
@i{3.13968253968254}
@i{3.1427128427128435}
@i{3.1408813408813416}
@i{3.142071817071818}
@i{3.1412548236077655}
@dots{}
@end lisp

@noindent
Более того, можно ускорить ускоренную последовательность, рекурсивно
ускорить результат, и так далее. То есть, можно создать поток потоков
(структуру, которую мы будем называть (@newterm{tableau)}), в котором
каждый поток есть результат преобразования предыдущего:

@lisp
(define (make-tableau transform s)
  (cons-stream s (make-tableau transform (transform s))))
@end lisp

@noindent
Табло имеет вид
@ifinfo

@example
s_00   s_01   s_02   s_03   s_04   ...
       s_10   s_11   s_12   s_13   ...
              s_20   s_21   s_22   ...
                            ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ s_{00} $ 	&  $ s_{01} $ 	&  $ s_{02} $ 	&  $ s_{03} $ 	&  $ s_{04} $ 	&  $ \dots $ \cr
		&  $ s_{10} $ 	&  $ s_{11} $ 	&  $ s_{12} $ 	&  $ s_{13} $ 	&  $ \dots $ \cr
		& 		&  $ s_{20} $ 	&  $ s_{21} $ 	&  $ s_{22} $ 	&  $ \dots $ \cr
		& 		& 		&  $ \dots $ 	& 		&  \cr }
} $$
@end tex
Наконец, можно построить последовательность, членами
которой будут первые элементы каждой строки табло:

@lisp
(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))
@end lisp

@noindent
Можно показать, как работает такое <<сверхускорение>> на
последовательности приближений к @math{\pi}:

@lisp
(display-stream
 (accelerated-sequence euler-transform pi-stream))
@i{4.}
@i{3.166666666666667}
@i{3.142105263157895}
@i{3.141599357319005}
@i{3.1415927140337785}
@i{3.1415926539752927}
@i{3.1415926535911765}
@i{3.141592653589778}
@dots{}
@end lisp

@noindent
Результат впечатляет. Восемь членов последовательности дают нам верное
значение @math{\pi} с точностью до 14 десятичных знаков. Если бы у нас
была только исходная последовательность приближений к @math{\pi}, то
пришлось бы вычислить порядка @math{10^{13}} ее элементов (то есть
довести последовательность до такого места, где ее элементы становятся
меньше @math{10^{-13}}), чтобы добиться такой точности!

Все эти методы ускорения можно было бы реализовать и без помощи потоков.
Однако формулировка в терминах потоков обладает особым удобством и
изяществом, поскольку мы имеем доступ ко всей последовательности
состояний в виде структуры данных, с которой можно работать при помощи
единого набора операций.

@quotation
@strong{@anchor{Упражнение 3.63}Упражнение 3.63:}
Хьюго Дум спрашивает, почему нельзя было написать
@code{sqrt-stream} более простым способом, без внутренней переменной
@code{guesses}:

@lisp
(define (sqrt-stream x)
  (cons-stream 1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    (sqrt-stream x))))
@end lisp

Лиза П. Хакер отвечает, что эта версия процедуры значительно менее
эффективна, поскольку производит избыточные вычисления. Объясните Лизин
ответ. Сохранилось бы отличие в эффективности, если бы реализация
@code{delay} использовала только
@code{(lambda () @math{\langle}@var{выражение}@math{\rangle})}, без
оптимизации через @code{memo-proc} (см. @ref{3.5.1})?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.64}Упражнение 3.64:}
Напишите процедуру , которая в качестве аргумента принимает
поток и число (погрешность). Она должна просматривать поток, пока не
найдется два элемента подряд, различающихся меньше, чем на погрешность,
и возвращать второй из этих элементов. При помощи этой процедуры можно
будет вычислять квадратные корни с заданной точностью так:

@lisp
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
@end lisp
@end quotation

@quotation
@strong{@anchor{Упражнение 3.65}Упражнение 3.65:}
С помощью ряда
@ifinfo

@example
            1     1     1
ln 2 = 1 - --- + --- - --- + ...
            2     3     4
@end example

@end ifinfo
@tex
$$ \ln 2 = 1 - {1\over2} + {1\over3} - {1\over4} + \dots $$
@end tex
@noindent
породите три последовательности приближений к натуральному логарифму 2,
так же, как мы выше сделали это для @math{\pi}. Как быстро сходятся эти
последовательности?
@end quotation

@comment @subsubheading Infinite streams of pairs
@subsubheading Бесконечные потоки пар

В @ref{2.2.3} мы видели, как парадигма работы с последовательностями
рассматривает вложенные циклы традиционной парадигмы в виде процессов,
определенных на последовательности пар. Если мы обобщим этот метод на
бесконечные потоки, то сможем писать программы, которые трудно воспроизвести
с помощью обычных циклов, поскольку <<цикл>> охватывает бесконечное множество.

Например, пусть нам хочется обобщить процедуру @code{sum-of-primes} из
@ref{2.2.3} так, чтобы получился поток из @emph{всех} пар натуральных чисел
@math{(i,j)}, таких, что @math{i \le j} и @math{i+j} простое. Если
@code{int-pairs} есть последовательность всех пар натуральных чисел
@math{(i,j)}, где @math{i \leq j}, то необходимый нам поток
таков:@footnote{Как и в @ref{2.2.3}, мы представляем пару натуральных
чисел в виде списка, а не лисповской пары.}

@lisp
(stream-filter
 (lambda (pair) (prime? (+ (car pair) (cadr pair))))
 int-pairs)
@end lisp

@noindent
Задача, следовательно, состоит в том, чтобы породить поток @code{int-pairs}.
В более общем случае допустим, что у нас есть два потока @math{S = (S_i)}
и @math{T = (T_j)}, и представим себе бесконечную матрицу
@ifinfo

@example
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
(S_1, T_0)  (S_1, T_1)  (S_1, T_2)  ...
(S_2, T_0)  (S_2, T_1)  (S_2, T_2)  ...
   ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

    $ (S_0, T_0) $ & $ (S_0, T_1) $ & $ (S_0, T_2) $ & $ \dots $ \cr
    $ (S_1, T_0) $ & $ (S_1, T_1) $ & $ (S_1, T_2) $ & $ \dots $ \cr
    $ (S_2, T_0) $ & $ (S_2, T_1) $ & $ (S_2, T_2) $ & $ \dots $ \cr
    $ \dots $ & & & \cr }
} $$
@end tex
Нам хочется породить поток, который содержит все пары из
этой матрицы, лежащие на диагонали или выше, а именно пары
@ifinfo

@example
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
            (S_1, T_1)  (S_1, T_2)  ...
                        (S_2, T_2)  ...
                                    ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
        & $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
        & 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
        & 			& 			& $ \dots $ \cr }
} $$
@end tex
@noindent
(Если мы возьмем и @math{S}, и @math{T} равными потоку
натуральных чисел, то получим как раз необходимый нам поток
@code{int-pairs}.)

Назовем общий поток пар @code{(pairs S T)}, и будем считать, что он
состоит из трех частей: пары @math{(S_0, T_0)}, остатка пар в первом
ряду, и всех остальных пар:@footnote{В упражнении @ref{Упражнение 3.68}
объясняется, почему мы выбрали именно такую декомпозицию.}
@ifinfo

@example
(S_0, T_0) | (S_0, T_1)  (S_0, T_2)  ...
-----------+-----------------------------
           | (S_1, T_1)  (S_1, T_2)  ...
           |             (S_2, T_2)  ...
           |                         ...
@end example

@end ifinfo
@tex
$$ \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & \vrule
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil &
    \hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
\noalign{\hrule}
        & $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
        & 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
        & 			& 			& $ \dots $ \cr }
} $$
@end tex
Заметим, что третья часть этой декомпозиции (пары, не
лежащие в первом ряду) суть пары, получаемые (рекурсивно) из
@code{(stream-cdr S)} и @code{(stream-cdr T)}. Заметим также, что вторая
часть (остаток первого ряда) есть

@lisp
(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
@end lisp

@noindent
Таким образом, мы можем сформировать наш поток пар так:

@lisp
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (@math{\langle}@var{combine-in-some-way}@math{\rangle}
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t)))))
@end lisp

@noindent
Чтобы закончить определение процедуры, нужно выбрать какой-нибудь способ
смешать два внутренних потока. В голову приходит воспользоваться
потоковым аналогом процедуры @code{append} из @ref{2.2.1}:

@lisp
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
@end lisp

@noindent
Однако эта идея не срабатывает с бесконечными потоками, поскольку,
прежде чем перейти ко второму потоку, нужно пройти весь первый поток до
конца. В частности, если мы попробуем породить все пары натуральных
чисел при помощи

@lisp
(pairs integers integers)
@end lisp

@noindent
то получившийся поток сначала попытается перечислить все пары, где
первый элемент равен 1, а следовательно, никогда не породит ни одной
пары с другим значением первого члена.

Для работы с бесконечными потоками требуется придумать способ смешения,
который гарантировал бы, что каждый элемент будет достигнут, если
программе дать достаточно времени. Изящный способ добиться этого состоит
в том, чтобы воспользоваться следующей процедурой
@code{interleave}:@footnote{Точная формулировка требования, которому
должен удовлетворять порядок слияния, выглядит так: должна существовать
функция от двух аргументов @math{f}, такая, что пара, соответствующая
@math{i}-му элементу первого потока и @math{j}-му элементу второго,
появится в качестве элемента выходного потока под номером @math{f(i,j)}.
Трюк с чередованием через @code{interleave} нам показал Дэвид Тёрнер,
который использовал его в языке KRC (Turner 1981).}

@lisp
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
@end lisp

@noindent
Поскольку @code{interleave} чередует элементы из двух потоков, всякий
элемент второго потока рано или поздно попадет в смешанный поток, даже
если первый поток бесконечен.

Таким образом, мы можем породить требуемый поток пар так:

@lisp
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
@end lisp

@quotation
@strong{@anchor{Упражнение 3.66}Упражнение 3.66:}
Рассмотрим поток @code{(pairs integers integers)} Можете ли
Вы что-то сказать о порядке, в котором пары попадают в поток? Например,
сколько приблизительно пар предшествуют паре (1, 100)? Паре (99, 100)?
(100, 100)? (Если Вы способны предоставить точные математические
утверждения, --- прекрасно. Однако если Вы увязаете в деталях,
достаточно качественных оценок.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.67}Упражнение 3.67:}
Измените процедуру так, чтобы
@code{(pairs integers integers)} порождало поток из @emph{всех} пар
натуральных чисел @math{(i,j)}, без дополнительного условия
@math{i \leq j}. Подсказка: потребуется примешать еще один поток.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.68}Упражнение 3.68:}
Хьюго Дум считает, что построение потока пар из трех
частей --- процедура слишком сложная. Он предлагает вместо того, чтобы
отделять пару @math{(S_0, T_0)}, работать с первой строкой целиком:

@lisp
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
@end lisp

Будет ли такой код работать? Посмотрите, что произойдет, если мы
попытаемся вычислить @code{(pairs integers integers)}, используя
определение Хьюго.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.69}Упражнение 3.69:}
Напишите процедуру @code{triples}, которая берет три
бесконечных потока @math{S}, @math{T} и @math{U}, и порождает поток
троек @math{(S_i, T_j, U_k)}, таких, что @math{i \leq j \leq k}. С
помощью @code{triples} породите поток всех Пифагоровых троек натуральных
чисел, т. е. таких троек @math{(i,j,k)}, что @math{i \leq
j} и @math{i^2 + j^2 = k^2}
@end quotation

@quotation
@strong{@anchor{Упражнение 3.70}Упражнение 3.70:}
Интересно было бы уметь порождать потоки в каком-либо
полезном порядке, а не в порядке, задаваемом к случаю придуманным
процессом чередования. Можно воспользоваться методом, подобным процедуре
@code{merge} из упражнения @ref{Упражнение 3.56}, если мы определим
способ сказать, что одна пара целых чисел <<меньше>> другой. Один из
способов состоит в том, чтобы определить <<функцию взвешивания>>
@math{W(i,j)} и постановить, что @math{(i_1, j_1)} меньше, чем
@math{(i_2, j_2)}, если @math{W(i_1, j_1) < W(i_2, j_2)}. Напишите процедуру
@code{merge-weighted}, которая во всем подобна @code{merge}, но только в
качестве дополнительного аргумента принимает процедуру @code{weight},
которая вычисляет вес пары, и используется для определения порядка, в
котором элементы должны появляться в получающемся смешанном
потоке.@footnote{Мы будем требовать от функции взвешивания, чтобы вес
пары возрастал при движении вправо по строке или вниз по столбцу в
матрице пар.} При помощи @code{merge-weighted} напишите процедуру
@code{weighted-pairs}, обобщающую @code{pairs}. Она должна принимать два
потока и процедуру, вычисляющую функцию взвешивания, и порождать поток
пар, упорядоченных по весу. Породите, используя эту процедуру:

@enumerate a.

@item
Поток всех пар натуральных чисел @math{(i,j)} где @math{i \leq j},
упорядоченных по сумме @math{i+j}.

@item
поток всех пар натуральных чисел @math{(i,j)}, где @math{i \leq j}, ни
@math{i}, ни @math{j} не делится ни на 2, ни на 3, ни на 5, и пары
упорядочены по значению суммы @math{2i + 3j + 5ij}.

@end enumerate
@end quotation

@quotation
@strong{@anchor{Упражнение 3.71}Упражнение 3.71:}
Числа, которые можно выразить в виде суммы двух кубов
более, чем одним способом, иногда называют (@newterm{Ramanujan numbers}), в
честь математика Шринивасы Рамануджана.@footnote{Цитата из некролога на смерть
Рамануджана, написанного Г. Х. Харди (Hardy 1921): <<Кажется, это
мистер Литлвуд заметил, что <<каждое натуральное число было ему
другом>>. Я помню, как однажды навестил его, когда он лежал больной в
Путни. Я приехал в такси номер 1729, сказал, что число показалось мне
скучным, и выразил надежду, что это не было несчастливым знаком. <<Нет,
--- ответил он, --- это очень интересное число; это наименьшее число,
которое можно двумя различными способами выразить как сумму двух
кубов>>. Трюк с использованием взвешенных пар для порождения чисел
Рамануджана нам показал Чарльз Лейзерсон.} Упорядоченные потоки пар
предлагают изящное решение для задачи порождения таких чисел. Чтобы
найти число, которое можно двумя разными способами записать в виде суммы
двух кубов, требуется только породить поток пар натуральных чисел
@math{(i,j)}, взвешенных согласно сумме @math{i^3 + j^3}
(см. упражнение @ref{Упражнение 3.70}), и искать в этом потоке две
пары подряд с одинаковым весом. Напишите процедуру для порождения чисел
Рамануджана. Первое такое число 1729. Каковы следующие пять?
@end quotation

@quotation
@strong{@anchor{Упражнение 3.72}Упражнение 3.72:} Используя метод, подобный
описанному в упражнении @ref{Упражнение 3.71}, породите поток всех чисел,
которые можно записать как сумму двух квадратов тремя различными способами (и
покажите, каковы эти способы).
@end quotation

@comment @subsubheading Streams as signals
@subsubheading Потоки как сигналы

Мы начали обсуждение потоков с того, что описали их как вычислительные
аналоги <<сигналов>> в системах обработки сигналов. На самом деле с
помощью потоков такие системы можно моделировать самым непосредственным
образом, представляя значения сигнала в последовательные моменты времени
как последовательные элементы потока. Например, можно реализовать
(@newterm{integrator}), или (@newterm{summer}), который, для входного потока
@math{x = (x_i)}, начального значения @math{C} и малого приращения
времени @math{dt}, собирает сумму
@ifinfo

@example
           i
          ---
S_i = C + >   x_j dt
          ---
          j=1
@end example

@end ifinfo
@tex
$$ S_i = C + \sum_{j=1}^i x_{\kern-0.07em j} \kern0.1em dt $$
@end tex
@noindent
и возвращает поток значений @math{S = (S_i)}. Следующая процедура
@code{integral} напоминает <<неявное>> определение потока целых (@ref{3.5.2}):

@lisp
(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
@end lisp

@noindent
На рисунке @ref{Рисунок 3.32} показана система преобразования
сигналов, соответствующая процедуре @code{integral}. Входной поток
делится на отрезки @math{dt} и пропускается через сумматор, а вывод
сумматора опять направляется на его вход. Ссылка на самого себя в
определении @code{int} отражена на диаграмме в виде цикла обратной
связи, соединяющего выход сумматора с одним из его входов.

@float
@c @quotation
@anchor{Рисунок 3.32}
@ifinfo
@strong{Рисунок 3.32:} The @code{integral} procedure viewed as a signal-processing system.

@example
                             initial-value
                                  |
       +-----------+              |   |\__
input  |           |      |\__    +-->|   \_  integral
------>| scale: dt +----->|   \_      |cons_>--*------->
       |           |      | add_>---->| __/    |
       +-----------+  +-->| __/       |/       |
                      |   |/                   |
                      |                        |
                      +------------------------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.32,102mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 3.32:} The @code{integral} procedure viewed as a signal-processing system.}
@sp 0.8
@end iftex
@c @end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.73}Упражнение 3.73:}
Можно моделировать электрические цепи с помощью потоков,
представляющих значения тока или напряжения в определенные моменты
времени. Допустим, например, что у нас имеется (RC circuit), состоящая
из резистора с сопротивлением @math{R} и конденсатора емкостью @math{C},
соединенных последовательно. Значение напряжения @math{v} в зависимости
от заданного тока @math{i} определяется формулой, показанной на
рис. @ref{Рисунок 3.33}. Структура формулы показана на прилагаемой
диаграмме потока сигналов.

@float
@anchor{Рисунок 3.33}
@ifinfo
@strong{Рисунок 3.33:} An RC circuit and the associated signal-flow diagram.

@example
  +        v        -

 ->----'\/\/\,---| |---
  i       R         C


                  / t
               1  |
 v  =  v   +  --- |  i dt  +  R i
        0      C  |
                  / 0

         +--------------+
     +-->|   scale: R   |---------------------+   |\_
     |   +--------------+                     |   |  \_
     |                                        +-->|    \   v
  i  |   +--------------+     +------------+      | add >--->
 ----+-->|  scale: 1/C  |---->|  integral  |----->|   _/
         +--------------+     +------------+      | _/
                                    |             |/
                   v
                    0
@end example
@end ifinfo
@iftex
@sp 0.1
@center @image{fig/chap3/Fig3.33,94mm,,,.pdf}
@sp 0.6
@center @caption{@strong{Рисунок 3.33:} An RC circuit and the associated signal-flow diagram. }@short
@sp 0.9
@end iftex
@end float

Напишите процедуру @code{RC}, моделирующую эту цепь. На входе @code{RC}
должна получать значения @math{R}, @math{C} и @math{dt}, и выдавать
процедуру, которая принимает на входе поток значений тока @math{i} и
начальное значение напряжения @math{v_0}, а на выходе выдает поток
значений напряжения @math{v}. Например, у Вас должна быть возможность
смоделировать при помощи @code{RC} RC-цепь с @math{R = 5} ом,
@math{C = 1} фараде, и временным шагом в 0,5 секунды, вычислив
@code{(define RC1 (RC 5 1 0.5))}. Здесь @code{RC1} определяется как
процедура, которая принимает на входе поток, представляющий временную
последовательность токов, и исходное напряжение на конденсаторе, а на
выходе дает временной поток напряжений.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.74}Упражнение 3.74:}
Лиза П. Хакер разрабатывает систему для обработки
сигналов, приходящих от физических сенсоров. Один из важных
инструментов, который она хочет построить, --- это сигнал, описывающий
(@newterm{zero crossings}). Выходной сигнал должен равняться +1, когда сигнал на
входе меняется с отрицательного на положительный, -1, когда сигнал
меняется с положительного на отрицательный, и 0 в остальных случаях.
(Допустим, что знак нулевого входа положителен). Например, типичный
входной сигнал и связанный с ним сигнал перехода через ноль могут
выглядеть так:

@lisp
@dots{} 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 @dots{}
@dots{} 0 0  0  0  0   -1   0  0  0   0   1  0 0 @dots{}
@end lisp

В Лизиной системе сигнал от сенсора представляется как поток
@code{sense-data}, а @code{zero-crossings} представляет соответствующий
поток пересечений нуля. Для начала Лиза пишет процедуру
@code{sign-change-detector}, которая берет два значения в качестве
аргументов и, сравнив их знаки, выдает 0, 1 или -1. Затем она строит
поток переходов через ноль следующим образом:

@lisp
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream)
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
@end lisp

Мимо проходит Лизина начальница Ева Лу Атор и замечает, что программа
приблизительно равносильна следующей, написанной с использованием
обобщенной версии @code{stream-map} из упражнения @ref{Упражнение 3.50}:

@lisp
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              @math{\langle}@var{выражение}@math{\rangle}))
@end lisp

Завершите программу, вставив необходимое
@math{\langle}@var{выражение}@math{\rangle}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.75}Упражнение 3.75:}
К сожалению, Лизин детектор перехода через ноль из
упражнения @ref{Упражнение 3.74} оказывается недостаточным, потому что
зашумленный сигнал от сенсоров приводит к ложным срабатываниям.
Инженер-электронщик Дайко Поправич предлагает Лизе сгладить сигнал,
чтобы отфильтровать шум, прежде, чем отлавливать пересечение нуля. Лиза
принимает его совет и решает извлечь переходы через ноль из сигнала,
полученного взятием среднего арифметического каждого значения входных
данных с предыдущим значением. Она объясняет задачу своему помощнику
Хьюго Думу, и тот пытается реализовать идею, поправив Лизин текст
следующим образом:

@lisp
(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream)
                    last-value)
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings
      (stream-cdr input-stream) avpt))))
@end lisp

Этот код неверно реализует замысел Лизы. Найдите ошибку, внесенную
Хьюго, и исправьте ее, не меняя структуру программы. (Подсказка:
придется увеличить число аргументов @code{make-zero-crossings}.)
@end quotation

@quotation
@strong{@anchor{Упражнение 3.76}Упражнение 3.76:}
Ева Лу Атор недовольна подходом Хьюго из
упражнения @ref{Упражнение 3.75}. Написанная им программа не модульна,
поскольку смешивает операции сглаживания и отлова пересечений ноля.
Например, тест на пересечение не должен изменяться, если Лизе удастся
найти другой способ улучшить качество входного сигнала. Помогите Хьюго и
напишите процедуру @code{smooth}, которая берет на входе поток, а на
выходе выдает поток, элементы которого получены усреднением каждых двух
последовательных элементов входного потока. Затем используйте
@code{smooth} как компоненту и реализуйте детектор перехода через ноль в
более модульном стиле.
@end quotation

@comment @subsection Streams and Delayed Evaluation
@subsection Потоки и задержанное вычисление
@node	3.5.4, 3.5.5, 3.5.3, 3.5

Процедура @code{integral} в конце предыдущего раздела показывает, как с
помощью потоков можно моделировать системы обработки сигналов, которые
содержат циклы обратной связи. Цикл обратной связи для сумматора,
показанный на рис. @ref{Рисунок 3.32}, моделируется тем, что
внутренний поток @code{int} в процедуре @code{integral} определяется с
использованием себя самого:

@lisp
(define int
  (cons-stream
   initial-value
   (add-streams (scale-stream integrand dt)
                int)))
@end lisp

@noindent
Способность интерпретатора работать с таким косвенным определением
зависит от @code{delay}, встроенного в @code{cons-stream}. Без этой
задержки интерпретатор не мог бы построить @code{int}, не вычислив оба
аргумента @code{cons-stream}, а для этого нужно, чтобы @code{int} уже
был определен. В общем случае, @code{delay} играет ключевую роль, когда
мы моделируем системы обработки сигналов с обратной связью при помощи
потоков. В отсутствие задержки нам приходилось бы формулировать модели
так, чтобы вход всякого обрабатывающего блока полностью вычислялся,
прежде чем блок выдает что-либо на выходе. Такое условие исключает циклы.

@float
@quotation
@anchor{Рисунок 3.34}
@ifinfo
@strong{Рисунок 3.34:} An ``analog computer circuit'' that solves the equation @math{dy\! / dt = f(y)}.

@example
                            y_0
                             |
                             V
    +----------+  dy   +----------+     y
+-->|  map: f  +------>| integral +--*----->
|   +----------+       +----------+  |
|                                    |
+------------------------------------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.34,67mm,,,.pdf}
@sp 0.5
@caption{@strong{Рисунок 3.34:} An ``analog computer circuit'' that solves the equation @math{dy / dt = f(y)}.}
@sp 0.9
@end iftex
@end quotation
@end float

К сожалению, потоковые модели систем с циклами могут требовать
применения задержек помимо той, которая <<спрятана>> в
@code{cons-stream}. Например, на рисунке @ref{Рисунок 3.34} показана
система обработки сигналов, решающая дифференциальное уравнение
@math{dy/dt = f(y)}, где @math{f} --- заданная функция. На рисунке
показан отображающий блок, который применяет @math{f} ко входному
сигналу, связанный в цикл обратной связи с интегратором. Это очень
похоже на работу аналоговых схем, действительно используемых для решения
такого рода уравнений.

Если нам дано начальное значение @math{y_0}, мы могли бы попытаться
смоделировать эту систему с помощью процедуры

@lisp
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

@noindent
Эта процедура не работает, потому что вызов @code{integral} в первой
строке @code{solve} требует, чтобы был определен входной поток
@code{dy}, а это происходит только во второй строке процедуры
@code{solve}.

С другой стороны, замысл, заключенный в этом определении, вполне здрав,
поскольку мы можем, в принципе, начать порождать поток @code{y} и не
зная @code{dy}. Действительно, @code{integral} и многие другие операции
над потоками обладают свойствами, подобными @code{cons-stream}, а
именно, мы можем породить часть ответа, даже если нам дана только
частичная информация об аргументах. В случае @code{integral}, первый
элемент выходного потока есть указанное начальное значение
@code{initial-value}. Таким образом, можно породить первый элемент
выходного потока и не вычисляя интегрируемую величину @code{dy}. А раз
мы знаем первый элемент @code{y}, то @code{stream-map} во второй строке
@code{solve} может начать работать и породить первый элемент @code{dy},
а с его помощью мы получим второй элемент @code{y}, и так далее.

Чтобы воспользоваться этой идеей, переопределим @code{integral} так,
чтобы он ожидал интегрируемый поток в виде (@newterm{delayed argument}).
@code{Integral} будет размораживать вычисление входного потока через
@code{force} только тогда, когда ему нужно породить элементы входного
потока помимо первого:

@lisp
(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (let ((integrand (force delayed-integrand)))
       (add-streams (scale-stream integrand dt) int))))
  int)
@end lisp

@endpage
@noindent
Теперь можно реализовать процедуру @code{solve}, задержав вычисление
@code{dy} внутри определения @code{y}:@footnote{Не гарантируется, что эта
процедура будет работать во всех реализациях Scheme, но для любой
реализации должен найтись простой способ заставить подобную процедуру
работать. Проблемы связаны с тонкими различиями в том, как реализации
Scheme обрабатывают внутренние определения.  (См. @ref{4.1.6}.)}

@lisp
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
@end lisp

@noindent
Теперь при любом вызове @code{integral} необходимо задерживать
интегрируемый аргумент. Можно показать, что процедура @code{solve}
работает, аппроксимируя @math{e \approx 2.718} вычислением в точке
@math{y = 1} решения дифференциального уравнения @math{dy/dt = y} с
начальным условием @math{y(0) = 1}:

@lisp
(stream-ref (solve (lambda (y) y)
                   1
                   0.001)
            1000)
@i{2.716924}
@end lisp

@quotation
@strong{@anchor{Упражнение 3.77}Упражнение 3.77:}
Вышеприведенная процедура @code{integral} была аналогична <<непрямому>>
определению бесконечного потока натуральных чисел из @ref{3.5.2}. В виде
альтернативы можно дать определение @code{integral}, более похожее на
@code{integers-starting-from} (также в @ref{3.5.2}):

@smalllisp
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
@end smalllisp

В системах с циклами эта реализациея порождает такие же проблемы, как и
наша исходная версия @code{integral}. Модифицируйте процедуру так, чтобы
она ожидала @code{integrand} как задержанный аргумент, а следовательно,
могла быть использована в процедуре @code{solve}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.35}
@ifinfo
@strong{Рисунок 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.

@example
               dy_0                y_0
                |                   |
                V                   V
   ddy     +----------+    dy  +----------+    y
+--------->| integral +-----*--+ integral +--*--->
|          +----------+     |  +----------+  |
|                           |                |
|            +----------+   |                |
|     __/|<--+ scale: a |<--+                |
|   _/   |   +----------+                    |
+--<_add |                                   |
     \__ |   +----------+                    |
        \|<--+ scale: b |<-------------------+
             +----------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.35a,91mm,,,.pdf}
@sp 0.3
@caption{@strong{Рисунок 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.}
@sp 0.8
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.78}Упражнение 3.78:}
Рассмотрим задачу проектирования системы обработки сигналов
для решения гомогенных линейных дифференциальных уравнений второго
порядка
@ifinfo

@example
d^2 y        d y
-----  -  a -----  -  by  =  0
d t^2        d t
@end example

@end ifinfo
@tex
$$ {d^2\!y \over dt^2} - a {dy \over dt} - by = 0. $$
@end tex
Выходной поток, моделирующий @math{y}, порождается сетью, содержащей цикл. Этот
цикл возникает потому, что значение @math{d^2\!y / dt^2} зависит от
значений @math{y} и @math{dy/dt}, а они оба получаются интегрированием
@math{d^2\!y / dt^2}. Диаграмма, которую нам хотелось бы закодировать,
показана на рис. @ref{Рисунок 3.35}. Напишите процедуру
@code{solve-2nd}, которая в качестве аргументов берет константы
@math{a}, @math{b} и @math{dt} и начальные значения @math{y_0} и
@math{dy_0} для @math{y} и @math{dy}, и порождает поток последовательных
значений @math{y}.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.79}Упражнение 3.79:}
Обобщите процедуру @code{solve-2nd} из
упражнения @ref{Упражнение 3.78} так, чтобы с ее помощью можно было
решать дифференциальные уравнения второго порядка общего вида
@math{d^2\!y / dt^2 = f(dy / dt, y)}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.36}
@ifinfo
@strong{Рисунок 3.36:} A series RLC circuit.

@example
              + v_R -
        i_R
     +--->----'\/\/\,--------+
     |                       |  i_L
    \|/          R          \|/
  +  |  i_C                  |_   +
    -+-                       _)
v_C -+- C                     _)  v_L
     |                        _)
  -  |                       |    -
     +-----------------------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.36,60mm,,,.pdf}
@sp 0.5
@center @caption{@strong{Рисунок 3.36:} A series RLC circuit.}
@sp 0.9
@end iftex
@end quotation
@end float

@quotation
@strong{@anchor{Упражнение 3.80}Упражнение 3.80:}
(@newterm{series RLC circuit}) состоит из резистора, конденсатора и
катушки индуктивности, соединенных последовательно, как показано на
рис. @ref{Рисунок 3.36}. Если сопротивление, индуктивность и емкость
равны, соответственно, @math{R}, @math{L} и @math{C}, то отношения между
напряжением @math{v} и током @math{i} на трех элементах описываются
уравнениями
@ifinfo

@example
v_R = i_R R

         d i_L
v_L = L -------
          d t

         d v_C
i_C = C -------
          d t
@end example

@end ifinfo
@tex
$$ 	v_R 	= 	i_R R, \qquad\quad
	v_L 	= 	L {di_L \over dt}\,, \qquad\quad
	i_C 	= 	C {dv_C \over dt}\,, $$
@end tex
а цепь диктует соотношения
@ifinfo

@example
i_R = i_L = -i_C

v_C = v_L + v_R
@end example

@end ifinfo
@tex
$$ 	i_R 	= 	i_L = -i_C\,, \qquad\quad
	v_C 	= 	v_L +  v_R\,.  $$
@end tex
Сочетание этих условий
показывает, что состояние цепи (характеризуемое через @math{v_C},
напряжение на конденсаторе, и @math{i_L}, ток через катушку) описывается
парой дифференциальных уравнений
@ifinfo

@example
d v_C        i_L
-----  =  -  ---
 d t          C

d i_L      1           R
-----  =  --- v_C  -  --- i_L
 d t       L           L
@end example

@end ifinfo
@tex
$$  {dv_C \over dt}  =  -{i_L \over C}\,, \qquad\quad
    {di_L \over dt}  =   {1   \over L} v_C - {R \over L} i_L\,. $$
@end tex
Диаграмма потока сигналов, представляющая эту систему дифференциальных
уравнений, показана на рисунке @ref{Рисунок 3.37}.
@end quotation

@float
@quotation
@anchor{Рисунок 3.37}
@ifinfo
@strong{Рисунок 3.37:} A signal-flow diagram for the solution to a series RLC circuit.

@example
                 +-------------+
+----------------+  scale: l/L |<--+
|                +-------------+   |
|                                  |
|                +-------------+   |  v_C
|       dv_C +-->|   integral  +---*------>
|            |   +-------------+
|            |        ^
|            |        | v_(C_0)
|            |
|            |   +-------------+
|            +---+ scale: -l/C |<--+
|                +-------------+   |
|  |\__                            |
+->|   \_  di_L  +-------------+   |  i_L
   | add_>------>|   integral  +---*------>
+->| __/         +-------------+   |
|  |/                 ^            |
|                     | i_(L_0)    |
|                                  |
|                +-------------+   |
+----------------+ scale: -R/L |<--+
                 +-------------+
@end example
@end ifinfo
@iftex
@sp 0.0
@center @image{fig/chap3/Fig3.37a,68mm,,,.pdf}
@sp 0.8
@caption{@strong{Рисунок 3.37:} A signal-flow diagram for the solution to a series RLC circuit.}
@sp 0.8
@end iftex
@end quotation
@end float

@quotation
Напишите процедуру @code{RLC}, которая в качестве аргументов берет
параметры цепи @math{R}, @math{L} и @math{C} и точность по времени
@math{dt}. Подобно процедуре @code{RC} из
упражнения @ref{Упражнение 3.73}, @code{RLC} должна порождать
процедуру, которая берет начальные значения переменных состояния
@math{v_{C_0}} и @math{i_{L_0}} и порождает (через @code{cons}) пару
потоков состояния @math{v_C} и @math{i_L}. С помощью @code{RLC} породите
пару потоков, которая моделирует поведение RLC-цепи c @math{R = 1} ом,
@math{C = 0.2} фарад, @math{L = 1} генри, @math{dt = 0.1} секунды, и
начальными значениями @math{i_{L_0} = 0} ампер и @math{v_{C_0} = 10} вольт.
@end quotation

@comment @subsubheading Normal-order evaluation
@subsubheading Нормальный порядок вычислений

Примеры из этого раздела показывают, как явное использование
@code{delay} и @code{force} сообщает программированию большую гибкость,
однако те же самые примеры показывают, как наши программы от этого могут
стать сложнее и запутаннее. Например, новая процедура @code{integral}
позволяет моделировать системы с циклами, но теперь нам приходится
помнить, что звать ее надо с задержанным аргументом, и все процедуры,
которые пользуются @code{integral}, должны это знать. В результате мы
создали два класса процедур: обычные и те, которым требуются задержанные
аргументы. В общем случае создание новых классов процедур требует от нас
еще и создания новых классов процедур высших порядков.@footnote{Здесь мы
получаем в Лиспе слабое отражение тех сложностей, которые возникают при
работе с процедурами высших порядков в обыкновенных сильно
типизированных языках вроде Паскаля. В таких языках программисту нужно
указывать типы данных для аргументов и результата каждой процедуры:
число, логическое значение, последовательность и т. д. Следовательно,
мы не можем выразить такую абстракцию, как <<применить данную процедуру
@code{proc} ко всем элементам последовательности>> в виде единой
процедуры высшего порядка вроде @code{stream-map}. Вместо этого нам
потребуется отдельная процедура для каждой комбинации типов аргументов и
результата, которые можно указать для @code{proc}. Практическая
поддержка понятия <<тип данных>> при наличии процедур высших порядков
приводит ко многим интересным проблемам. Один из способов работы с ними
иллюстрирует язык ML (Gordon, Milner, and Wadsworth 1979), в котором
<<полиморфные типы данных>> включают шаблоны для преобразований между
типами данных высшего уровня. Более того, для большинства процедур в ML
типы данных явно не определяются программистом. Вместо этого в ML
встроен механизм (type inference), который при помощи контекстной
информации вычисляет типы данных для вновь определяемых процедур.}

Один из способов избежать необходимости вводить два класса процедур
состоит в том, чтобы заставить все процедуры принимать задержанные
аргументы. Можно принять модель вычислений, в которой все аргументы
процедур автоматически задерживаются, и вынуждение происходит только
тогда, когда их значения реально нужны (например, для выполнения
элементарной операции). Таким образом наш язык станет использовать
нормальный порядок вычислений, который мы впервые описали, когда
разговор шел о подстановочной модели вычислений в @ref{1.1.5}.
Переход к нормальному порядку вычислений предоставляет нам изящный и
единообразный способ упростить использование задержанных вычислений, и
если бы нас интересовала только обработка потоков, было бы естественно
принять эту стратегию. В @ref{4.2},
после того, как мы изучим устройство вычислителя, мы увидим, как можно
преобразовать язык именно таким способом. К сожалению, добавив задержки
в вызовы процедур, мы совершенно лишили себя возможности строить
программы, работа которых зависит от порядка событий, то есть программы,
использующие присваивание, изменяющие свои данные или производящие
ввод-вывод. Одно-единственное использование @code{delay} в форме
@code{cons-stream} уже может привести к неразберихе, как показано в
упражнениях @ref{Упражнение 3.51} и @ref{Упражнение 3.52}. Насколько
известно, в языках программирования изменение состояния и задержанные
вычисления плохо совместимы, и поиск возможностей использовать
одновременно и то, и другое является активной областью исследований.

@comment @subsection Modularity of Functional Programs@* and Modularity of Objects
@subsection Модульность функциональных программ и модульность объектов
@node	3.5.5,  , 3.5.4, 3.5

Как мы видели в @ref{3.1.2}, одно из
основных преимуществ от введения присваивания состоит в том, что мы
можем повысить модульность своих систем при помощи инкапсуляции, или
<<сокрытия>>, частей большой системы во внутренних переменных. Потоковые
модели могут предоставить нам такой же уровень модульности без
использования присваивания. В качестве примера мы можем заново
реализовать аппроксимацию @math{\pi} методом Монте-Карло, которую мы
рассматривали в @ref{3.1.2}, с точки зрения обработки потоков.

Главная задача при обеспечении модульности состояла в том, что нам
хотелось спрятать внутреннее состояние генератора случайных чисел от
программ, которые пользуются случайными числами. Мы начали с процедуры
@code{rand-update}, последовательные значения которой служили для нас
источником случайных чисел, и уже с ее помощью построили генератор
случайных чисел:

@lisp
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
@end lisp

@noindent
При формулировке посредством потоков генератора случайных чисел как
такового не существует, имеется только поток случайных чисел, полученных
вызовами @code{rand-update}:

@lisp
(define random-numbers
  (cons-stream
   random-init
   (stream-map rand-update random-numbers)))
@end lisp

@noindent
С его помощью мы порождаем поток результатов испытаний Чезаро,
проведенных на последовательных парах потока случайных чисел (@code{random-numbers}):

@lisp
(define cesaro-stream
  (map-successive-pairs
   (lambda (r1 r2) (= (gcd r1 r2) 1))
   random-numbers))
(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
@end lisp

@noindent
Поток @code{cesaro-stream} подается на вход процедуре
@code{monte-carlo}, которая порождает поток оценок вероятности. Затем
этот результат преобразуется, и получается поток оценок значения
@math{\pi}. В этой версии программы не требуется параметра,
указывающего, сколько испытаний требуется проводить. Более точные оценки
@math{\pi} (полученные при большем количестве испытаний) можно получить,
дальше заглянув в поток @code{pi}:

@lisp
(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))
(define pi
  (stream-map
   (lambda (p) (sqrt (/ 6 p)))
   (monte-carlo cesaro-stream 0 0)))
@end lisp

@noindent
Такой подход достаточно модулен, поскольку мы по-прежнему имеем
возможность сформулировать общую процедуру @code{monte-carlo},
работающую с произвольными испытаниями. Однако здесь нет ни
присваивания, ни внутреннего состояния.

@quotation
@strong{@anchor{Упражнение 3.81}Упражнение 3.81:}
В упражнении @ref{Упражнение 3.6} обсуждалась возможность
обобщить генератор случайных чисел и позволить пользователю сбрасывать
последовательность случайных чисел, так, чтобы можно было порождать
воспроизводимые <<случайные>> последовательности. Постройте потоковый
вариант такой же процедуры-генератора, которая работает со входным
потоком запросов вида @code{generate} --- породить новое число, либо
@code{reset} --- сбросить последовательность в нужную точку, и которая
порождает требуемый поток случайных чисел. Не используйте в своем
решении присваивание.
@end quotation

@quotation
@strong{@anchor{Упражнение 3.82}Упражнение 3.82:} Переделайте на основе потоков
упражнение @ref{Упражнение 3.5} на интегрирование методом Монте-Карло.
Потоковая версия процедуры @code{estimate-integral} не требует
аргумента, который говорит, сколько проводить испытаний. Вместо этого
она порождает поток оценок, основанных на все большем количестве испытаний.
@end quotation

@comment @subsubheading A functional-programming view of time
@subsubheading Взгляд на время в функциональном программировании

Вернемся теперь к вопросам об объектах и изменении, поднятым в начале
этой главы, и рассмотрим их в новом свете. Мы ввели присваивание и
изменяемые объекты, чтобы иметь механизм для модульного построения
программ, которые моделируют обладающие состоянием системы. Мы порождали
вычислительные объекты с внутренними переменными состояния и изменяли
эти объекты при помощи присваивания. Мы моделировали временно́е поведение
объектов мира через временное поведение соответствующих вычислительных
объектов.

Теперь мы видим, что потоки дают альтернативный способ моделирования
объектов, обладающих внутренним состоянием. Можно моделировать
изменяющуюся величину, например, внутреннее состояние какого-либо
объекта, через поток, который представляет динамику изменений состояния.
В сущности, с помощью потоков мы представляем время явно, так что время
в моделируемом мире оказывается отделено от последовательности событий,
происходящих во время вычисления. Действительно, благодаря наличию
@code{delay} между имитируемым временем модели и последовательностью
событий при вычислении может быть весьма мало общего.

Чтобы сопоставить эти два подхода к моделированию, рассмотрим еще раз
<<обработчик снятия денег>>, следящий за значением баланса на банковском
счету. В @ref{3.1.3} мы реализовали упрощенную версию такой программы обработки:

@lisp
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
@end lisp

@noindent
Вызовы @code{make-simplified-withdraw} порождают вычислительные объекты,
и каждый из них содержит внутреннюю переменную @code{balance}, которая
уменьшается при каждом обращении к объекту. Этот объект принимает в
качестве аргумента количество денег @code{amount}, а возвращает новый
баланс. Можно представить себе, как пользователь банковского счета
печатает последовательность входных данных для такого объекта и
рассматривает на экране дисплея последовательность возвращаемых данных.

С другой стороны, можно смоделировать обработчик снятия денег и в виде
процедуры, которая принимает на входе баланс и поток снимаемых сумм, а
порождает поток последовательных балансов на счету:

@lisp
(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
@end lisp

@noindent
@code{stream-withdraw} реализует хорошо определенную математическую
функцию, выход которой полностью определяется входом. Однако
предположим, что вход @code{amount-stream} есть поток последовательных
значений, вводимых пользователем, и что получающийся поток балансов
выводится на печать. В таком случае, с точки зрения пользователя,
который печатает значения и смотрит на результаты, потоковый процесс
обладает тем же поведением, что и объект, созданный при помощи
@code{make-simplified-withdraw}. Однако в потоковой версии нет ни
присваивания, ни внутренней переменной состояния, и, следовательно, она
не вызывает никаких теоретических сложностей из описанных в
@ref{3.1.3}. И все-таки система обладает состоянием!

Это достижение достойно внимания. Несмотря на то, что
@code{stream-withdraw} реализует хорошо определенную математическую
функцию, поведение которой не меняется, у пользователя создается
впечатление, что он взаимодействует с системой, обладающей изменяющимся
состоянием. Один из способов разрешить парадокс заключается в том, чтобы
понять, что именно существование пользователя во времени навязывает
системе состояние. Если бы пользователь мог принять более отстраненную
точку зрения и думать в терминах потоков и балансов, а не отдельных
актов взаимодействия, система выглядела бы как объект без
состояния.@footnote{Подобным образом в физике, когда мы наблюдаем за
движением частицы, мы говорим, что позиция (состояние) частицы
изменяется. Однако с точки зрения мировой линии частицы в
пространстве-времени никакого изменения нет.}

С точки зрения одной части сложного процесса кажется, что другие его
части меняются со временем. Они содержат скрытое изменчивое внутреннее
состояние. Если мы хотим писать программы, моделирующие такой тип
естественной декомпозиции нашего мира (как мы видим его со своей точки
зрения, будучи частицами этого мира) при помощи структур в нашем
компьютере, мы строим вычислительные объекты, не являющиеся
функциональными, --- они обязаны меняться со временем. Мы моделируем
состояние при помощи внутренних переменных, и изменение состояния мы
моделируем через присваивание этим переменным. Пойдя по этому пути, мы
делаем время выполнения вычислительной модели временем мира, частью
которого мы являемся, и так в нашем компьютере возникают <<объекты>>.

Моделирование при помощи объектов --- мощная и интуитивно понятная
техника, во многом потому, что она соответствует восприятию
взаимодействия с миром, частью которого мы являемся. Однако, как мы
неоднократно видели в этой главе, в таких моделях возникают неудобные
вопросы управления порядком событий и синхронизации множественных
процессов. Возможность избежать этих проблем стимулировала развитие
(@newterm{functional programming languages}), в которых нет понятий присваивания и
изменяемых данных. В таком языке все процедуры реализуют точно
определенные математические функции, поведение которых не меняется.
Функциональный подход весьма привлекателен при работе с параллельными
системами.@footnote{Джон Бэкус, изобретатель Фортрана, привлек внимание к
функциональному программированию, когда в 1978 году получил премию
Тьюринга Американской Ассоциации по Вычислительным Машинам (ACM). В
своей инаугурационной речи (Backus 1978) он горячо отстаивал
функциональный подход. Хороший обзор функционального программирования
дается в книгах Henderson 1980 и Darlington, Henderson, and
Turner 1982.}

С другой стороны, при более внимательном взгляде мы обнаружим, что и
функциональные модели не избавляют от проблем, связанных со временем.
Одна из самых болезненных возникает, когда нам нужно проектировать
интерактивные системы, особенно такие, которые моделируют взаимодействие
между независимыми сущностями. К примеру, рассмотрим еще раз реализацию
банковской системы, которая позволяет иметь совместные счета. В
традиционной системе с присваиванием и объектами информация о том, что у
Петра и Павла есть общий счет, моделировалась бы тем, что и Петр, и
Павел посылали бы заказы на транзакции одному и тому же
объекту-банковскому счету, как мы видели в @ref{3.1.3}. С точки
зрения потоков, где <<объекты>> сами по себе не существуют, банковский
счет, как мы уже указывали, может моделироваться в виде процесса,
работающего с потоком заказов на транзакции и порождающего поток
реакций. Соответственно, информация о том, что Петр и Павел совместно
владеют счетом, может моделироваться путем смешения потока заказов Петра
на транзакции с потоком Павла и направления слитого потока в
процесс-поток банковского счета, как показано на
рисунке @ref{Рисунок 3.38}.

@float
@quotation
@anchor{Рисунок 3.38}
@ifinfo
@strong{Рисунок 3.38:} A joint bank account, modeled by merging two streams of transaction requests.

@example
Peter's requests   +---------+     +---------+
------------------>|         |     |         |
Paul's requests    |  merge  |---->| bank    |---->
------------------>|         |     | account |
                   +---------+     +---------+
@end example
@end ifinfo
@iftex
@sp 0.2
@center @image{fig/chap3/Fig3.38,88mm,,,.pdf}
@sp 0.6
@caption{@strong{Рисунок 3.38:} A joint bank account, modeled by merging two streams of transaction requests.}
@sp 1.2
@end iftex
@end quotation
@end float

Проблему в этой формулировке вызывает понятие (@newterm{merge}). Неверным решением
будет просто брать по очереди один заказ от Петра и один от Павла.
Допустим, что Павел очень редко обращается к счету. Не следует
заставлять Петра ждать, пока Павел обратится к счету, прежде чем он
сможет осуществить вторую транзакцию. Как бы ни было реализовано
слияние, оно должно чередовать потоки транзакций так, чтобы
соответствовать <<реальному времени>> с точки зрения Петра и Павла, в
том смысле, что если Петр и Павел встретятся, то они могут согласиться,
что определенные транзакции произошли до встречи, а определенные
после.@footnote{Заметим, что для любых двух потоков в принципе существует
более одного возможного способа чередования. Так что с технической точки
зрения <<слияние>> не функция, а отношение --- ответ не является
детерминистской функцией аргументов. Мы уже упоминали (в примечании
@ref{Сноска 3.39}), что недетерминизм имеет существенное значение при
работе с параллельными процессами. Отношение слияния показывает тот же
самый недетерминизм с функциональной точки зрения. В @ref{4.3}
мы рассмотрим еще одну точку зрения на недетерминизм.} Это в точности то
же самое ограничение, с которым нам приходилось сталкиваться в @ref{3.4.1},
где у нас возникла необходимость ввести явную синхронизацию, чтобы добиться
<<правильного>> порядка событий при параллельной обработке объектов,
обладающих состоянием. Таким образом, при попытке поддержать
функциональный стиль необходимость сливать потоки ввода от различных
агентов опять привносит те самые проблемы, от которых функциональный
стиль должен был нас избавить.

В начале этой главы мы поставили цель научиться строить вычислительные
модели, чья структура соответствует нашему восприятию реального мира,
который мы моделируем. Мы можем моделировать мир либо как собрание
ограниченных во времени взаимодействующих объектов, обладающих
состоянием, либо же как единую, вневременную, лишенную состояния
сущность. Каждая из этих точек зрения имеет свои преимущества, но ни
одна из них не удовлетворяет нас полностью. Время великого объединения
пока не настало.@footnote{Объектная модель строит приближенное описание
мира, разделяя его на отдельные фрагменты. Функциональная модель не
проводит границ модулей по границам объектов. Объектная модель полезна
тогда, когда раздельное состояние <<объектов>> намного больше, чем
состояние, общее для всех или некоторых из них. Примером области, где
объектный взгляд не работает, является квантовая механика, где попытки
думать об объектах как отдельных частицах ведут к парадоксам и
недоразумениям. Объединение объектного взгляда с функциональным может
иметь отношение не столько к программированию, сколько к фундаментальным
вопросам эпистемологии.}
